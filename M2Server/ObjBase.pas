unit ObjBase;

interface

uses
  Windows, Classes, SysUtils, Forms, StrUtils, Math, StallSystem, MD5,
  Grobal2, Envir, MudUtil, MaketSystem, HashList, CnHashTable, VMProtectSDK, UCHECK;

type

  TVisibleMapItem = record
    MapItem: pTMapItem;
    sName: string[35];
    nVisibleFlag: Integer;
    nX, nY: Integer;
    wLooks: Word;
  end;
  pTVisibleMapItem = ^TVisibleMapItem;
  
  TBaseObject = class
    ProcessMsgCriticalSection: TRTLCriticalSection; //0428

    m_fHeroMon: Boolean;
    m_sUserID: string[10];
    m_sMapName: string[16];
    m_sCharName: string[14];
    m_sFCharName: string[14];
    m_nCurrX: Integer;
    m_nCurrY: Integer;
    m_btDirection: Byte;
    m_btGender: Byte;
    m_btHair: Byte;
    m_btHairEx: Byte;
    m_btJob: Byte;
    m_nGold: Integer;
    m_Abil: TAbility;
    m_nCharStatus: Integer;
    m_wApprStatus: Word;
    m_sHomeMap: string[16];
    m_nHomeX: Integer;
    m_nHomeY: Integer;
    m_boOnHorse: Boolean;
    m_btHorseType: Byte;
    m_btDressEffType: Byte;
    m_nPkPoint: Integer;
    m_btClPkPoint: Byte;
    m_nIncHealth: Integer;
    m_nIncSpell: Integer;
    m_nIncHealing: Integer;
    m_nFightZoneDieCount: Integer;
    m_btNewHuman: Byte;
    m_MagicArr: TMagicArr;
    m_nCharStatusEx: Integer;
    m_dwFightExp: LongWord;
    m_dwFightIPExp: LongWord;
    m_WAbil: TAbility;
    m_AddAbil: TAddAbility;
    m_nViewRangeX: Integer;
    m_nViewRangeY: Integer;

    m_wStatusTimeArr: TStatusTime;
    m_dwStatusArrTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord;

    m_wStatusTimeArrEx: TStatusTimeEx;
    m_dwStatusArrTickEx: TStatusArrTickEx;

    m_wStatusArrValue: array[0..6] of Word;
    m_dwStatusArrTimeOutTick: array[0..6] of LongWord;

    m_wStatusArrValue2: array[0..6] of Word;
    m_dwStatusArrTimeOutTick2: array[0..6] of LongWord;

    m_DefenceRate: Word;
    m_MagDefenceRate: Word;
    m_wPowerRate: array[0..6] of Word;
    m_wPowerRateTick: array[0..6] of LongWord;
    m_wAppr: Word;
    m_btRaceServer: Byte;
    m_btRaceImg: Byte;
    m_btHitPoint: Byte;
    m_nHitPlus: ShortInt;
    m_nHitDouble: ShortInt;
    m_nHitDoubleEx: ShortInt;
    m_nHitDouble_101: ShortInt;
    m_boRecallSuite: Boolean;
    m_boRaceImg: Boolean;
    m_nHealthRecover: ShortInt;
    m_nSpellRecover: ShortInt;
    m_btAntiPoison: Byte;
    m_btAntiStone: Byte;
    m_nPoisonRecover: ShortInt;
    m_nAntiMagic: ShortInt;
    m_nLuck: Integer;
    m_nPerHealth: Integer;
    m_nPerHealing: Integer;
    m_nPerSpell: Integer;
    m_dwIncHealthSpellTick: LongWord;
    m_dwIncHealthTick: LongWord;
    m_dwIncSpellTick: LongWord;
    m_dwCheckHPMPTick: LongWord;
    m_dwDragonHeartTick: LongWord;
    m_dwSquSkillPowerUpTick: LongWord;

    m_dwHintMsgTick: LongWord;
    m_btGreenPoisoningPoint: Byte;
    m_nGoldMax: Integer;
    m_btSpeedPoint: Byte;
    m_btPermission: Byte;
    m_nHitSpeed: ShortInt;
    m_btLifeAttrib: Byte;
    m_btCoolEye: Byte;
    m_boHearWhisper: Boolean;
    m_boBanShout: Boolean;
    m_boBanGuildChat: Boolean;
    m_boAllowDeal: Boolean;
    m_dwShoutMsgTick: LongWord;
    m_Master: TBaseObject;
    m_Robber: TBaseObject;
    m_dwMasterRoyaltyTick: LongWord;
    m_dwCloneDispearTick: LongWord;
    m_dwMasterTick: LongWord;
    m_nKillMonCount: Integer;
    m_btSlaveExpLevel: Byte;
    m_btSlaveMakeLevel: Byte;
    m_SlaveList: TList;
    m_boSlaveRelax: Boolean;
    m_boHeroSearchTag: Boolean;
    m_btHeroRelax: Byte;
    m_btAttatckMode: Byte;
    m_btNameColor: Byte;
    m_nLight: Integer;
    m_boGuildWarArea: Boolean;
    m_Castle: TObject;
    m_boStruck: Boolean;
    m_boDoubleStruck: Boolean;
    m_boDoubleStruck2: Boolean;
    m_boDoubleStruck3: Boolean;
    m_dw2B4Tick: LongWord;
    m_boSuperMan: Boolean;
    m_boHoldPlace: Boolean;
    m_boSafeWalk: Boolean;
    m_boAnimal: Boolean;
    m_boExplore: Boolean;
    m_boNoItem: Boolean;
    m_boFixedHideMode: Boolean;
    m_boStickMode: Boolean;
    m_boCowKingMon: Boolean;
    m_boNoAttackMode: Boolean;
    m_boSkeleton: Boolean;
    m_boGetRandomItems: Boolean;
    m_nMeatQuality: Integer;
    m_nBodyLeathery: Integer;
    m_nPerBodyLeathery: Integer;
    m_boHolySeize: Boolean;
    m_dwHolySeizeTick: LongWord;
    m_dwHolySeizeInterval: LongWord;
    m_boCrazyMode: Boolean;
    m_dwCrazyModeTick: LongWord;
    m_dwCrazyModeInterval: LongWord;
    m_boShowHP: Boolean;
    m_dwShowHPTick: LongWord;
    m_dwShowHPInterval: LongWord;
    m_boPlayerDupMode: Boolean;
    m_dwDupObjTick: LongWord;
    m_PEnvir: TEnvirnoment;
    m_boGhost: Boolean;
    m_dwGhostTick: LongWord;
    m_boDeath: Boolean;
    m_boCanReAlive: Boolean;
    m_boInvisible: Boolean;
    m_dwReAliveTick: LongWord;
    m_pMonGen: pTMonGenInfo;

    m_dwDeathTick: LongWord;
    m_btMonsterWeapon: Byte;
    m_dwStruckTick: LongWord;
    m_boWantRefMsg: Boolean;
    m_boErrorOnInit: Boolean;
    m_boHealthCrc: Boolean;
    m_MyGuild: TObject;
    m_nGuildRankNo: Integer;
    m_sGuildRankName: string;
    m_sScriptLable: string;
    m_btAttackSkillCount: Byte;
    m_btAttackSkillPointCount: Byte;
    m_boMission: Boolean;
    m_nMissionX: Integer;
    m_nMissionY: Integer;
    m_boHideMode: Boolean;
    m_boTDBeffect: Boolean;
    m_boStoneMode: Boolean;
    m_boCoolEye: Boolean;
    m_boUserUnLockDurg: Boolean;
    m_boTransparent: Boolean;
    m_boAdminMode: Boolean;
    m_boSuperMode: Boolean;
    m_dwSuperManTick: LongWord;
    m_dwAdminTick: LongWord;
    m_boObMode: Boolean;
    m_boTeleport: Boolean;

    m_boParalysis: Boolean;
    m_boParalysis2: Boolean;
    m_boMParalysis: Boolean;

    m_dwUnParalysisTick: LongWord;
    m_dwUnParalysisTick2: LongWord;

    m_boUnParalysis: Boolean;
    m_boRevival: Boolean;
    m_boUnRevival: Boolean;
    m_dwRevivalTick: LongWord;
    m_boFlameRing: Boolean;
    m_boRecoveryRing: Boolean;
    m_boAngryRing: Boolean;
    m_boMagicShield: Boolean;
    m_boMagicShield2: Boolean;
    m_boUnMagicShield: Boolean;
    m_boMuscleRing: Boolean;
    m_boFastTrain: Boolean;
    m_boProbeNecklace: Boolean;
    m_boGuildMove: Boolean;
    m_boSupermanItem: Boolean;
    m_bopirit: Boolean;
    m_boDragonFireSkill: Boolean;
    m_boAttackedMag62: Boolean;
    m_boNoDropItem: Boolean;
    m_boNoDropUseItem: Boolean;
    m_boNoDropItemEx: Boolean;
    m_boNoDropUseItemEx: Boolean;
    m_boExpItem: Boolean;
    m_boPowerItem: Boolean;
    m_boAcItem: Boolean;
    m_boMacItem: Boolean;
    m_rExpItem: real;
    m_rPowerItem: real;
    m_rAcItem: real;
    m_rMacItem: real;
    m_boUnAllParalysis: Boolean;
    m_dwPKDieLostExp: LongWord;
    m_nPKDieLostLevel: Integer;
    m_btMagShieldLevel: Byte;
    m_nMagShieldHP: Integer;
    m_dwUnionHitShieldTick: LongWord;
    m_boAbilSeeHealGauge: Boolean;
    m_boAbilMagBubbleDefence: Boolean;
    m_btMagBubbleDefenceLevel: Byte;
    //m_boAbilScPowerUpDefence: Boolean;
    m_dwSearchTime: LongWord;
    m_dwSearchTick: LongWord;
    m_dwRunTick: LongWord;
    m_nRunTime: Integer;
    m_nHealthTick: Integer;
    m_nSpellTick: Integer;
    m_TargetCret: TBaseObject;
    m_LockTarget: TBaseObject;
    m_dwTargetFocusTick: LongWord;
    m_PoisonHiter: TBaseObject;
    m_PoisonHiterTick: LongWord;
    m_LastHiter: TBaseObject;
    m_LastHiterTick: LongWord;
    m_ExpHitter: TBaseObject;
    m_ExpHitterTick: LongWord;
    m_dwTeleportTick: LongWord;
    m_dwProbeTick: LongWord;
    m_dwMapMoveTick: LongWord;
    m_boPKFlag: Boolean;
    m_dwPKTick: LongWord;
    m_nMoXieSuite: Integer;
    m_nHongMoSuite: Integer;
    m_dbHongMoSuite: Double;
    m_dwPoisoningTick: LongWord;
    m_dwDecPkPointTick: LongWord;
    m_DecLightItemDrugTick: LongWord;
    m_dwVerifyTick: LongWord;
    m_dwGroupAttribTick: LongWord;
    m_dwCheckRoyaltyTick: LongWord;
    m_dwDecHungerPointTick: LongWord;
    m_dwHPMPTick: LongWord;
    m_MsgList: TList;
    m_VisibleHumanList: TList;
    //m_VisibleItems: TList;
    //m_VisibleEvents: TList;
    m_SendRefMsgTick: LongWord;
    m_boInFreePKArea: Boolean;
    m_dwHitTick: LongWord;
    m_dwWalkTick: LongWord;
    m_dwSearchEnemyTick: LongWord;
    m_boNameColorChanged: Boolean;
    m_boIsVisibleActive: Boolean;
    m_nProcessRunCount: ShortInt;
    m_VisibleActors: TList;
    m_ItemList: TList;
    m_DealItemList: TList;
    m_nDealGolds: Integer;
    m_boDealOK: Boolean;
    m_MagicList: TList;
    m_UseItems: THumanUseItems;
    m_SayMsgList: TList;
    m_StorageItemList: TList;
    m_nWalkSpeed: Integer;
    m_nWalkStep: Integer;
    m_nWalkCount: Integer;
    m_dwWalkWait: LongWord;
    m_dwWalkWaitTick: LongWord;
    m_boWalkWaitLocked: Boolean;
    m_nNextHitTime: Integer;
    m_boPowerHit: Boolean;
    m_boUseThrusting: Boolean;
    m_boUseHalfMoon: Boolean;
    m_boFireHitSkill: Boolean;
    m_boPursueHitSkill: Boolean;
    m_boSmiteSkill: Boolean;
    m_boRushhitSkill: Boolean;
    m_boSmiteLongSkill: Boolean;
    m_boSmiteLongSkill2: Boolean;
    m_boSmiteLongSkill3: Boolean;
    m_boSmiteWideSkill: Boolean;
    m_boSmiteWideSkill2: Boolean;

    m_boCrsHitkill: Boolean;
    m_boSquareHit: Boolean;
    m_boTwinHitSkill: Boolean;
    m_btSquareHit: Byte;
    m_dwLatestFireHitTick: LongWord;
    m_dwLatestTwinHitTick: LongWord;
    m_dwLatestPursueHitTick: LongWord;
    m_dwLatestRushHitTick: LongWord;
    m_dwLatestSmiteTick: LongWord;
    m_dwLatestSmiteLongTick: LongWord;
    m_dwLatestSmiteLongTick2: LongWord;
    m_dwLatestSmiteLongTick3: LongWord;
    m_dwLatestSmiteDamageTick: LongWord;

    m_boMedusaEyeHint: Boolean;
    m_dwLatestMedusaEyeTick: LongWord;

    m_dwLatestSkill68Tick: LongWord;
    m_dwLatestSkill77Tick: LongWord;

    m_dwLatestSmiteWideTick: LongWord;
    m_dwLatestSmiteWideTick2: LongWord;

    m_dwLatestHeroLongHitTick: LongWord;
    m_dwDoMotaeboTick: LongWord;
    //m_boDenyRefStatus: Boolean;
    m_boAddToMaped: Boolean;
    m_boDelFormMaped: Boolean;
    m_boAutoChangeColor: Boolean;
    m_dwAutoChangeColorTick: LongWord;
    m_dwAutoChangeColorTime: Integer;
    m_nAutoChangeIdx: Integer;
    m_boFixColor: Boolean;
    m_nFixColorIdx: Integer;
    m_nFixStatus: Integer;
    m_boFastParalysis: Boolean;
    m_btMedusaEyeAttack: Byte;
    m_boStrike: Boolean;
    m_sStatuName: string;
    m_dwClearCopyTtemTick: LongWord;
    m_dwCheckItemsNeed: LongWord;
    m_dwDoRecallSlaveTick: LongWord;
    m_dwCloneSelfTick: LongWord;
    //m_btChatColor: byte;
    //m_btChatFont: byte;
    //m_btMsgFColor: byte;
    //m_btMsgBColor: byte;
    //m_wMsgSecond: Word;
    m_nCurMagId: Integer;
    m_dwMagNailTick: LongWord;
    m_boLongAttack: Boolean;
    m_boLockLongAttack: Boolean;
    m_nDropUseItemRate: Integer;
{$IF VER_ClientType_45}
    m_wClientType: Word;
{$IFEND VER_ClientType_45}
    m_nClientVerNO: Word;
    m_boLoadHeroRcd: Boolean;
    m_boLoadRcdFail: Boolean;
    m_boNewHero: Boolean;
    m_sHeroName: string[14];
    m_sTempHeroName: string[14];
    m_sHeroMasterName: string[14];
    m_dwHeroSaveRcdTick: LongWord;
    m_boHeroSaveRcd: Boolean;
    m_dwRecallHeroTick: LongWord;
    m_btHeroMakeSlave: Byte;
    m_nAutoAddHPMPMode: Integer;
    m_boDrangonHeart: Boolean;
    m_nJointAttackEnergy: Integer;
    m_boJointAttackReady: Boolean;
    m_boVigourAddAble: Boolean;
    m_nVigour: Integer;
    m_dwQueryBagItemsTick: LongWord;
    m_sStoragePwd: string[7];
    m_btCreditPoint: Byte;
    m_btReLevel: Byte;
    m_sMasterName: string[14];
    m_boMaster: Boolean;
    m_sDearName: string[14];
    m_nGameGold: Integer;
    m_nGamePoint: Integer;
    //m_sMarkerMap: string[16];
    //m_wMarkerX: Word;
    //m_wMarkerY: Word;
    m_nKillMonExpRate: Integer;
    m_dwKillMonExpRateTime: LongWord;
    m_boPasswordLocked: Boolean;
    m_boLockLogon: Boolean;
    m_nPayMentPoint: Integer;
    m_btAttribute: Byte;
    m_nAddHPMPRate: Integer;
    m_nAddPowerRate: Integer;
    m_nCursePowerRate: Integer;
    m_nCursePowerRateTime: LongWord;
    m_nGameDiamond: Word;
    m_nGameGird: Word;
    m_btPostSell: Byte;
    m_boShowMasterName: Boolean;
    m_boChgRecallHero: Boolean;
    m_dwBaseGetMsgTick: LongWord;
    m_dBodyLuck: Double;
    m_dHeroLoyalty: Double;
    m_nBodyLuckLevel: Integer;
    m_btUseAmulet: Byte;
    m_boUseAmulet: Boolean;
    m_nNonFrzWalkSpeed: Integer;
    m_nNonFrzNextHitTime: Integer;
    m_nMaxDamageHealth: Integer;

    m_nInPowerPoint: Integer;
    m_nInPowerLevel: Integer;
    m_AddDamage: Byte;
    m_DecDamage: Byte;
    m_IPRecoverRate: Word;

    m_dwInPowerExp: LongWord;
    m_wInPowerRateEx: Word;
    m_nCurEnvirIdx: Integer;
    m_nCastleEnvirListIdx: Integer;
    m_dwDoubleScTick: LongWord;

    m_CurSafeZoneList: TList;

    m_btHitPowerAddOn: Byte;
    m_wDoublePower: Word;
    m_wVampire: Word;
    m_btSuckRate: Byte;
    m_btDoubleDamage: Byte;

    m_wVampire2: Word;
    m_boHaveMag: Boolean;

    m_wHPAddLevel: Byte;
    m_wMPAddLevel: Byte;
    m_wJobAbil: Word;

    m_btSPLuck: Byte;
    m_btSPEnergy: Byte;
    m_dwSPEnergyAddTick: LongWord;

    m_btSkill77: Byte;

    m_btSpSkill1: Byte;
    m_btSpSkill2: Byte;
    m_btSpSkill3: Byte;
    m_btSpSkill4: Byte;

    m_btSpSkill5: Byte;
    m_btSpSkill6: Byte;
    m_btSpSkill7: Byte;
    m_btSpSkill8: Byte;

    m_btIgnoreTagDefence: Byte;
    m_btDamageAddOn: Byte;
    m_btDamageRebound: Byte;
    m_btACDamageReduction: Byte;
    m_btMCDamageReduction: Byte;
    m_btGetExpExRate: Byte;

    m_spMonAbil: TMonSpAbil;
    m_btWeaponSkill: Byte;
    m_btWeaponEffect: Byte;
    m_nPushedCount: Integer;
    m_nBodyState: Integer;

    m_nLastMapSecret: Integer;

    m_btReduceSpellTime: Byte;
    m_btDragonRageSkillLevel: Byte;
    m_dwDragonRageSkillTick: LongWord;

    m_boShowFashion: Boolean;
    m_dwShowFashionTick: LongWord;

    m_btInitTitle: Byte;
    m_btActiveTitle: Byte;
    m_Titles: THumTitles;
    m_dwCheckTitleTick: LongWord;
    m_UnreachableItemList: TList;
    m_UnreachableTick: Integer;
  private
    function GetLevelExp(nLevel: Integer): LongWord;
    function InSafeArea: Boolean;
    function AddToMap(): Boolean;
    procedure UseLamp();
    procedure CheckPKStatus();
    //procedure UpdateVisibleItem(wX, wY: Integer; MapItem: pTMapItem);
    //procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
    procedure GetAccessory(item: TUserItem; var AddAbility: TAddAbility);
    procedure GetAccessory2(StdItem: pTStdItem; var AddAbility: TAddAbility);
    function RecalcBagWeight(): Integer;
    procedure RecalcHitSpeed();
    procedure AddItemSkill(nIndex: Integer);
    procedure DelItemSkill(nIndex: Integer);
    procedure AddItemSkillEx(mid, lv: Integer);
    procedure DelItemSkillEx(mid: Integer);
    procedure DecPKPoint(nPoint: Integer);
    procedure HearMsg(sMsg: string);
    //procedure DamageSpell(nSpellPoint: Integer);
    procedure DoDamageWeapon(nWeaponDamage: Integer);
    function GetFeatureEx(): Word;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    function  FindItemInUnreseachable(VisibleMapItem: pTVisibleMapItem): Boolean;
    procedure AddUnreachableItem(VisibleMapItem: pTVisibleMapItem);
    procedure ClearUnreachableItemList();

    procedure ReadAllBook;
    procedure ClearStatusTime();
    function IsMoveAble: Boolean;
    procedure RandomSpaceMoveInRange(mtype, inrange, OutRange: Integer);

    function Walk(nIdent: Integer): Boolean;
    procedure SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string; nMagID: Word = 0);
    procedure SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word = 0);
    procedure SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord; nMagID: Word = 0);
    procedure SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word = 0);
    procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word = 0);
    procedure SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);

    procedure OnEnvirnomentChanged();

    procedure SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; fc: Integer = 0; bc: Integer = 0; sec: Integer = 0);
    procedure MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
    procedure UpdateVisibleGay(BaseObject: TBaseObject); //virtual;
    function IsVisibleHuman(): Boolean;
    procedure RecalcLevelAbilitys;
    function PKLevel(): Integer;
    function InSafeZone(): Boolean; overload;
    function DisableSyaMsgInSafeZone(): Boolean; overload;
    function InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean; overload;
    procedure OpenHolySeizeMode(dwInterval: LongWord);
    procedure BreakHolySeizeMode;
    procedure OpenCrazyMode(nTime: Integer);
    procedure BreakCrazyMode();
    procedure HealthSpellChanged();
    procedure DMSkillFix();

    function DirectAttack(BaseObject: TBaseObject; nSecPwr, nMid: Integer): Boolean;
    function SwordLongAttack(nSecPwr: Integer): Boolean; //´ÌÉ±
    function SwordLongAttackA(nSecPwr: Integer): Boolean;
    function SwordLongAttackX(nSecPwr, step, id: Integer): Boolean;
    function SwordLongAttackY(nSecPwr, step, id: Integer): Boolean;
    //function SwordLongAttack_3(nSecPwr: Integer): Boolean;
    function SUQAttack(nSecPwr: Integer): Boolean;
    function GetSUQAttack(): Boolean;
    function SwordLongAttack61(nSecPwr: Integer): Boolean;
    function SwordWideAttack(nSecPwr: Integer): Boolean; //°ëÔÂ¹¥»÷
    function SwordWideAttack2(nSecPwr: Integer): Boolean;
    function CrsWideAttack(nSecPwr: Integer): Boolean;
    function SmiteWideAttack(nSecPwr: Integer): Boolean;
    function SmiteWideAttack2(nSecPwr: Integer): Boolean;

    procedure TrainCurrentSkill(t, wHitMode: Integer);
    function _Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
    function GetHitStruckDamage(Attacker: TBaseObject; nDamage: Integer): Integer;
    function GetMagStruckDamage(Attacker: TBaseObject; nDamage: Integer): Integer;
    function GetDirectAttackStruckDamage(Attacker: TBaseObject; nDamage: Integer; IgnoreDefence: Boolean): Integer;
    function GetIPStruckDamage(Attacker: TBaseObject; nDamage: Integer; nMagIdx: Integer): Integer;
    procedure HasLevelUp(biplvl: Boolean = False);
    procedure HeroHasLevelUp(biplvl: Boolean = False);
    procedure GoldChanged();
    procedure GameGoldChanged();
    function GetGuildRelation(cert1: TBaseObject; cert2: TBaseObject): Integer;
    function IsGoodKilling(Cert: TBaseObject): Boolean;
    procedure IncPkPoint(nPoint: Integer);
    procedure AddBodyLuck(dLuck: Double);
    procedure MakeWeaponUnlock();
    procedure ScatterGolds(GoldOfCreat: TBaseObject);
    function DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean;
    function DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
    function HeroDropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
    function GetPowerDamage(Attacker: TBaseObject; Pwr: Integer): Integer;
    procedure DamageHealth(nDamage: Integer; bcalc: Boolean = True);
    function GetAttackPower(nBasePower, nPower: Integer): Integer; {virtual;}
    function CharPushed(nDir, nPushCount: Integer; dm: Boolean = False; step: Integer = 0): Integer;
    function ChrDupPushed(nDir, nPushCount: Integer): Integer;
    function GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean;
    function GetBackDir(nDir: Integer): Integer;
    function GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY: Integer; nRage: Integer; rList: TList): Boolean;
    function MagPassThroughMagic(sX, sY, tX, tY, nDir, magpwr, id: Integer; UnDeadAttack: Boolean): Integer;
    function MagPassThroughMagic60(sX, sY, tX, tY, nDir, magpwr: Integer; UnDeadAttack: Boolean): Integer;
    procedure KickException;
    procedure DamageBubbleDefence(nInt: Integer);
    procedure BreakOpenHealth;
    function GetCharStatus(): Integer;
    procedure MakeOpenHealth;
    procedure IncHealthSpell(nHP, nMP: Integer);
    procedure IncHealthSpellEx(nHP, nMP: Integer);
    procedure ItemDamageRevivalRing;
    function CalcGetExp(nLevel: Integer; nExp: LongWord): Integer;
    procedure GainSlaveExp(nLevel: Integer);
    procedure MapRandomMove(sMapName: string; nInt: Integer);
    procedure TurnTo(nDir: Integer);
    procedure FeatureChanged();
    function GetFeatureToLong(Buffer: PByte): Integer;
    function GetPoseCreate(): TBaseObject;
    function GetPoseCreateA(): TBaseObject;
    function GetPoseCreateB(): TBaseObject;

    function GetFeature(BaseObject: TBaseObject; Buffer: pByte): Integer;
    procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean);
    //procedure StruckDamage(nDamage: Integer); virtual;
    procedure StruckDamage(Attacker: TBaseObject; nDamage: Integer; nMagIdx: Integer); virtual;
    function sub_4C4CD4(sItemName: string; var nCount: Integer): pTUserItem;
    procedure StatusChanged(const sEx: string = '');
    function GetApprStatus(): Word;
    procedure StatusExChanged();
    function GeTBaseObjectInfo(): string;
    procedure TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
    function MagicMaxTrainLevel(UserMagic: pTUserMagic): Integer;
    function CheckMagicLevelup(UserMagic: pTUserMagic; bHighLv: Boolean = False): Boolean;
    function MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean; virtual;
    procedure CheckSkillShowHP(Magic: pTUserMagic);
    function MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
    function MagPossessedUp(nState, nLevel, nSec: Integer): Boolean;
    function MagShieldDefenceUp(nLevel: Integer): Boolean;
    function MagDontMove(nSec: Integer): Boolean;
    function MagTransparent(nSec: Integer): Boolean;
    procedure ApplyMeatQuality();
    function ButchMonBagItems(BaseObject: TBaseObject; boHint: Boolean = False): Boolean;
    function ButchMonUseItems(BaseObject: TBaseObject; boHint: Boolean = False): Boolean;
    function AddItemToBag(UserItem: pTUserItem): Boolean;
    function AddItemToStorage(UserItem: pTUserItem): Boolean;

    function DelBagItem(nIndex: Integer; renew: Boolean = False; log: string = ''): Boolean; overload;
    function DelBagItem(nItemIndex: Integer; sItemName: string): Boolean; overload;
    function GetBagStdItemCount(StdMode, Shape, maxcnt: Integer): Integer;
    function GetBagStdItemNameCount(Name: string; maxcnt: Integer): Integer;
    function DelBagStdItemCount(StdMode, Shape, maxcnt: Integer; log: string = ''): Integer;
    function DelBagStdItemNameCount(Name: string; maxcnt: Integer; log: string = ''): Integer;
    function DeleteBagItem(UserItem: pTUserItem): Boolean;

    procedure WeightChanged();
    function IsTrainingSkill(nIndex: Integer; btClass: Byte): Boolean;

    {procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: Integer): Integer;
    procedure SetQuestUnitOpenStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitOpenStatus(nFlag: Integer): Integer;
    procedure SetQuestUnitStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitStatus(nFlag: Integer): Integer;}

    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    function GetLongAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    function GetLongAttackDirX(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    function GetLongAttackDir_Dis(BaseObject: TBaseObject; var btDir: Byte; dis: Integer = 3): Boolean;
    function TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    function TargetInSwordLongAttackRange(): Boolean;
    function TargetInSwordLongAttackRangeX(): Boolean;
    function TargetInSwordWideAttackRange(): Boolean;
    function CheckMagPassThrough(sX, sY, tX, tY, nDir: Integer): Integer;
    procedure MonsterRecalcAbilitys();
    procedure RefNameColor;
    procedure SetPKFlag(BaseObject: TBaseObject);
    procedure SetLastHiter(BaseObject: TBaseObject);
    procedure SetLastPoisonHiter(BaseObject: TBaseObject);
    //function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean;
    function MakeSinSuSlave(): Boolean;
    function DefenceUp(nSec, mlevel: Integer): Boolean;
    function AttPowerUp(nPower, nTime: Integer): Boolean;
    function AttPowerDown(nPower, nTime: Integer): Boolean;
    function MagDefenceUp(nSec, mlevel: Integer): Boolean;
    function MagPoison7(nSec, mlevel: Integer): Boolean;

    procedure RefShowName;
    function MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord; NameColor: Integer = 255; BodyColorIndex: Integer = -1; const boFalg: Boolean = True): TBaseObject;
    function MakeSlaveEx(sMonName: string; nX, nY, nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord; NameColor: Integer = 255; BodyColorIndex: Integer = -1; const boFalg: Boolean = True): TBaseObject;
    procedure ClearAllSlaves;
    procedure KillAllSlaves;
    function MakePosion(Attacker: TBaseObject; nMid, nType, nTime, nPoint: Integer): Boolean;
    procedure MagCurse(sec, pwrrate: Integer);
    function GetFrontPosition(var nX: Integer; var nY: Integer): Boolean; virtual;
    procedure DamageSpell(nSpellPoint: Integer);
    function GetBackPosition(var nX: Integer; var nY: Integer): Boolean;
    function GetBackPosition2(var nX, nY: Integer): Boolean;
    function GetBackPositionEx(var nX, nY: Integer; bRandom: Boolean = True): Boolean;
    function WalkTo(btDir: Byte; boFlag: Boolean): Boolean; virtual;
    procedure SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);
    //procedure SpaceMoveEX(sMAP: string; nX, nY: Integer; nInt, GTNumber: Integer); //gt spacemoves
    function GetRecallXY(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean;
    function CheckItems(sItemName: string): pTUserItem;
    function MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState, mlevel: Byte): Integer;
    function MagMakeCurseArea(xx, yy, range, sec, Pwr, SkillLevel: Integer; BoMag: Boolean): Integer;
    function CanWalkRage(): Integer;
    function IsGuildMaster(): Boolean;
    procedure LoadSayMsg();
    procedure DisappearA(bt: Byte = 0);
    function GetShowName(): string; virtual;
    procedure DropUseItems(BaseObject: TBaseObject); virtual;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); virtual;
    procedure HeroScatterBagItems(ItemOfCreat: TBaseObject); virtual;
    function AutoTakeOnItem(btWhere: Byte; sItemName: string; const boBagItem: Boolean = True): Boolean;
    function HeroDoSpell(UserMagic: pTUserMagic; TagObject: TBaseObject; var boTrainOk: Boolean): Boolean;

    function GetMessage(Msg: pTProcessMessage): Boolean; virtual;
    procedure Initialize(); virtual;
    procedure Disappear(); virtual;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; virtual;
    procedure SearchViewRange(); virtual; //dynamic;
    procedure SearchViewRange_Death(); virtual;
    procedure Run(); virtual;
    procedure ProcessSayMsg(sMsg: string); virtual;
    procedure MakeGhost; virtual;
    procedure Die(); virtual;
    function KillFunc: Boolean;
    function LevelUPFunc: Boolean;
    function TakeOnFunc(byWhere: Byte): Boolean;
    function TakeOffFunc(byWhere: Byte): Boolean;
    procedure ReAlive(); virtual;
//    procedure ReAliveEx(pMonGen: pTMonGenInfo);
    function ReAliveEx(pMonGen: pTMonGenInfo): Boolean;

    procedure RecalcAbilitys(boAction: Boolean = False); virtual;
    function IsProtectTarget(BaseObject: TBaseObject): Boolean; virtual;
    function IsAttackTarget(BaseObject: TBaseObject; MagFire: Boolean = False): Boolean; virtual;
    function IsProperTarget(BaseObject: TBaseObject; MagFire: Boolean = False): Boolean; virtual;
    function IsProperFriend(BaseObject: TBaseObject): Boolean; virtual;
    procedure SetTargetCreat(BaseObject: TBaseObject); virtual;
    procedure DelTargetCreat(); virtual;

    procedure AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer); virtual;
    function GetNamecolor: Byte;
    procedure ClearBagItem();
    procedure ClearStorageItem();
    procedure AddSkillByName(sSkillName: string; Level: Integer = 0);
    function IsHero: Boolean;
    function HeroCanSaveRcd: Boolean;
    function GetTagXYRangeCount(nType, nRange: Integer; const btCheck: Byte = 0): Integer;
    function GetSelfRangeCount(nRange: Integer = 1): Integer;
    procedure ReSetGroupAttrib();
    function GetMaxBagItem: Integer;
    function GetMainPlayer(BaseObject: TBaseObject): TBaseObject;
    function IPLevelInRange(): Boolean;
    function GetTitleIndex(): Byte;
  end;

  TAnimalObject = class(TBaseObject)
    m_nNotProcessCount: Integer;
    m_nTargetX: Integer;
    m_nTargetY: Integer;
    m_nTargetX2: Integer;
    m_nTargetY2: Integer;
    m_boRunAwayMode: Boolean;
    m_dwRunAwayStart: LongWord;
    m_dwRunAwayTime: LongWord;
  private
  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure SearchTarget();
    procedure SearchTargetA();
    procedure SearchTargetHero();
    procedure HeroSearchTarget; virtual;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure Run(); override;
    procedure DelTargetCreat(); override;
    procedure SetTargetXY(nX, nY: Integer); virtual;
    function RuntoTargetXY(btDir: Byte; boFlag: Boolean): Boolean; virtual;
    procedure GotoTargetXY(); virtual;
    procedure Wondering(); virtual;
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer); virtual;
    procedure Struck(hiter: TBaseObject); virtual;
    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer; nMagPower: Integer; boFlag: Boolean; nRange: Integer = 0);
    function SetUseNormAttack(): Boolean;
    function MonPickItem(): Boolean;
    //function HumPickItem(): Boolean;
  end;

  TVisibleBaseObject = packed record
    BaseObject: TBaseObject;
    nVisibleFlag: Byte;
  end;
  pTVisibleBaseObject = ^TVisibleBaseObject;

  TPlayObject = class(TAnimalObject)
    m_xHWID: MD5.MD5Digest;

    m_DetectItem: TUserItem;
    m_dwDetectItemTick: LongWord;

    m_boGetHeros: Boolean;
    m_boSendHeros: Boolean;
    m_Heros: THerosInfo;
    m_boCanBind: Boolean;
    m_boCanUnBind: Boolean;
    m_dwIdCRC: Cardinal;
    m_BonusAbil: TNakedAbility;
    m_nBonusPoint: Integer;
    m_nHungerStatus: Integer;
    m_boAllowGuildReCall: Boolean;
    m_wGroupRcallTime: Word;
    m_boAllowGroupReCall: Boolean;
    m_dwGroupRcallTick: LongWord;

    m_boAllowGroup: Boolean;
    m_boAllowGuild: Boolean;

    m_QuestUnitOpen: TQuestUnit;
    m_QuestUnit: TQuestUnit;
    m_QuestFlag: TQuestFlag;

{$IF DEATHWALKING = 1}
    m_boLAT: Boolean;
    m_boNorAttack: Boolean;
    m_boDupMode: Boolean;
    m_boRunReady: Boolean;
    m_btMagPassTh: Byte;
    m_dwThinkTick: LongWord;
    m_dwMag41Tick: LongWord;
    m_dwSpellTick: LongWord;

    m_dwJointHitTick: LongWord;
    m_dwStartWalkTick: LongWord;
    m_nLongAttackCount: Integer;
    m_dwSpaceMoveTick: LongWord;
    m_nLatestAmuounsulIdx1: Integer;
    m_nLatestAmuounsulIdx2: Integer;
    m_nLatestFireChamIdx: Integer;
    m_sTargetCret: TBaseObject;
    m_nLastSSkillID: Integer;
{$IFEND DEATHWALKING}
    //////////////
    m_Escort: TBaseObject;

    m_dwClickNPCTick: LongWord;
    m_nTagDropPlus: Integer;
    m_nPreventDrop: Integer;

    m_dwHeroSetTargetTick: LongWord;
    m_LastNimbusCount: Integer;
    m_dwRefNimbusStateTick: LongWord;
    m_DefMsg: TDefaultMessage;
    m_nSayMsgCount: Integer;
    m_dwSayMsgTick: LongWord;
    m_boDisableSayMsg: Boolean;
    m_dwDisableSayMsgTick: LongWord;
    m_dwCheckDupObjTick: LongWord;
    m_dwLogonTimcCostTick: LongWord;
    m_dwExecScriptTick: LongWord;
    m_dwSafeZoneCheckTick: LongWord;
    m_boInSafeArea: Boolean;
    m_boInSafeZone: Boolean;
    m_boSendInSafeZone: Boolean;
    m_sIPaddr: string;
    m_sIPLocal: string;
    m_nSocket: Integer;
    m_nGSocketIdx: Integer;
    m_nGateIdx: Integer;
    m_nSoftVersionDate: Integer;
    m_dLogonTime: TDateTime;
    m_dwLogonTick: LongWord;
    m_boReadyRun: Boolean;
    m_nSessionID: Integer;
    m_nPayMent: Integer;
    m_nPayMode: Integer;
    m_dwLoadTick: LongWord;
    m_nServerIndex: Integer;
    m_boEmergencyClose: Boolean;
    m_boSoftClose: Boolean;
    m_boKickFlag: Boolean;
    m_boReconnection: Boolean;
    m_boOffLineFlag: Boolean;
    m_boOffLinePlay: Boolean;
    m_boOffLineLogin: Boolean;
    m_boSetOffLine: Boolean;
    m_sOffLineLeaveword: string;
    m_dwKickOffLineTick: LongWord;
    m_boRcdSaved: Boolean;
    m_nNewHeroOK: Integer;

    m_boSwitchData: Boolean;
    m_boSwitchDataOK: Boolean;
    m_boSwitchDataNeedDelay: Boolean;
    m_nWriteChgDataErrCount: Integer;
    m_sSwitchMapName: string;
    m_nSwitchMapX: Integer;
    m_nSwitchMapY: Integer;
    m_dwChgDataWritedTick: LongWord;
    m_sSwitchDataTempFile: string;

    m_dwHitIntervalTime: LongWord;
    m_dwMagicHitIntervalTime: LongWord;
    m_dwRunIntervalTime: LongWord;
    m_dwWalkIntervalTime: LongWord;
    m_dwTurnIntervalTime: LongWord;
    m_dwActionIntervalTime: LongWord;
    m_dwRunLongHitIntervalTime: LongWord;
    m_dwRunHitIntervalTime: LongWord;
    m_dwWalkHitIntervalTime: LongWord;
    m_dwRunMagicIntervalTime: LongWord;

    m_dwMagicAttackTick: LongWord;
    m_dwMagicAttackInterval: LongWord;
    m_dwAttackTick: LongWord;
    m_dwMoveTick: LongWord;
    m_dwAttackCount: LongWord;
    m_dwAttackCountA: LongWord;
    m_dwMagicAttackCount: LongWord;
    m_dwMoveCount: LongWord;
    m_nOverSpeedCount: Integer;
    m_boDieInFight3Zone: Boolean;
    m_sGotoNpcLabel: string;
    m_DelayCallList: TList;
    //m_nDelayCall: Integer;
    //m_dwDelayCallTick: LongWord;
    //m_boDelayCall: Boolean;
    //m_DelayCallNPC: Integer;
    //m_sDelayCallLabel: string;

    m_aScriptTimers: TScriptTimers;
    m_Script: pTScript;
    m_NPC: TBaseObject;
    m_LastNPC: TBaseObject;
    m_nVal: array[0..9] of Integer;
    m_nMval: array[0..99] of Integer;
    m_DyVal: array[0..99] of Integer;
    m_nSval: array[0..99] of string;
    m_sPlayDiceLabel: string;
    m_boTimeRecall: Boolean;
    m_dwTimeRecallTick: LongWord;
    m_sMoveMap: string;
    m_nMoveX: Integer;
    m_nMoveY: Integer;
    m_dwSaveRcdTick: LongWord;
    m_nBright: Integer;
    m_Time: Single;
    m_boNewHuman: Boolean;
    m_boSendNotice: Boolean;
    m_boSendImageFileCustom: Boolean;
    m_boSendSafeZoneEffectCustom: Boolean;
    m_boSendNpcCustom: Boolean;
    m_dwWaitLoginNoticeOKTick: LongWord;
    m_boLoginNoticeOK: Boolean;
    m_boTryPlayMode: Boolean;
    m_boExpire: Boolean;
    m_dwShowLineNoticeTick: LongWord;
    m_nShowLineNoticeIdx: Integer;
{$IF VER_ClientType_45}
    m_nSoftVersionDateEx: Integer;
{$IFEND VER_ClientType_45}
    m_CanJmpScriptLableList: TStringList;
    m_nScriptGotoCount: Integer;
    m_sScriptCurrLable: string;
    m_sScriptGoBackLable: string;
    m_dwTurnTick: LongWord;
    m_wOldIdent: Word;
    m_btOldDir: Byte;

    m_boFirstAction: Boolean;
    m_dwActionTick: LongWord;
    m_DearHuman: TPlayObject;
    m_boCanDearRecall: Boolean;
    m_boCanMasterRecall: Boolean;
    m_dwDearRecallTick: LongWord;
    m_dwMasterRecallTick: LongWord;
    m_MasterHuman: TPlayObject;
    m_MasterList: TList;
    m_btMarryCount: Byte;
    m_btReColorIdx: Byte;
    m_dwReColorTick: LongWord;
    m_nKillMonExpMultiple: Integer;
    m_dwGetMsgTick: LongWord;
    m_boNameChangeColor: Boolean;

    m_sItemCodeFileName: string;
    m_boSetItemCode: Boolean;
    m_bItemCode: Byte;
    m_boSetStoragePwd: Boolean;
    m_boReConfigPwd: Boolean;
    m_boCheckOldPwd: Boolean;
    m_boUnLockPwd: Boolean;
    m_boUnLockStoragePwd: Boolean;
    m_btPwdFailCount: Byte;
    m_boLockLogoned: Boolean;
    m_boRemoteMsg: Boolean;
    m_sTempPwd: string[7];
    m_PoseBaseObject: TBaseObject;
    m_boStartMarry: Boolean;
    m_boStartMaster: Boolean;
    m_boStartUnMarry: Boolean;
    m_boStartUnMaster: Boolean;
    m_boFilterSendMsg: Boolean;
    m_nPowerRate: Integer;
    m_dwPowerRateTime: LongWord;
    m_dwRateTick: LongWord;

    m_boCanUseItem: Boolean;
    m_boCanDeal: Boolean;
    m_boCanRecallHero: Boolean;
    m_boCanDrop: Boolean;
    m_boCanGetBackItem: Boolean;
    m_boCanWalk: Boolean;
    m_boCanRun: Boolean;
    m_boCanHit: Boolean;
    m_boCanSpell: Boolean;
    m_boCanSendMsg: Boolean;

    m_nMemberType: Integer;
    m_nMemberLevel: Integer;
    m_boSendMsgFlag: Boolean;
    m_boChangeItemNameFlag: Boolean;
    m_boDecGameGold: Boolean;
    m_dwDecGameGoldTime: LongWord;
    m_dwDecGameGoldTick: LongWord;
    m_nDecGameGold: Integer;
    m_boIncGameGold: Boolean;
    m_dwIncGameGoldTime: LongWord;
    m_dwIncGameGoldTick: LongWord;
    m_nIncGameGold: Integer;
    m_dwIncGamePointTick: LongWord;
    m_dwDecGamePointTick: LongWord;
    m_dwPayMentPointTick: LongWord;
    m_dwDecHPTick: LongWord;
    m_dwIncHPTick: LongWord;
    m_dwCollectExpTick: LongWord;
    m_GetWhisperHuman: TPlayObject;
    m_dwHighInfoTick: LongWord;
    m_dwClearObjTick: LongWord;
    m_sRankLevelName: string;
    m_boFilterAction: Boolean;
    m_nClientFlag: Integer;
    m_dwAutoClearEctypeTick: Integer;
    m_dwAutoGetExpTick: LongWord;
    m_nAutoGetExpTime: Integer;
    m_nAutoGetExpPoint: Integer;
    m_AutoGetExpEnvir: TEnvirnoment;
    m_boAutoGetExpInSafeZone: Boolean;
    m_DynamicVarList: TList;
{$IF VER_ClientType_45}
    m_dwClientTick: LongWord;
{$IFEND VER_ClientType_45}
    m_boClientVerOK: Boolean;
    m_boTestSpeedMode: Boolean;
    //m_PowerBlock: pTPowerBlock;
    m_dwSendWhisperTick: LongWord;
    nRunCount: Integer;
    dwRunTimeCount: LongWord;
    m_dwDelayTime: LongWord;
    m_sRandomNo: string;
    m_sPneumaName: string[14];
    m_dwDoFlyTick: LongWord;
    m_dwMagicIceRainTick: LongWord;
    m_dwMagicDeadEyeTick: LongWord;
    m_nCanRun: Integer;
    m_dwCanRunTime: LongWord;
    m_sOffLineLabel: string;
    m_dwGetSaleListTick: LongWord;
    m_dwBuyShopItemTick: LongWord;
    m_btGetShopItem: array[0..5] of Byte;
    m_HeroObject: TBaseObject;
    m_HeroRcd: pTHumDataInfo;
    m_MakerMapInfo: TMakerMapInfo;
    m_dwSaveHumanDataTick: LongWord;
    m_aBoxItems: TBoxItems;
    m_nBoxIndex: Integer;
    m_boCanGetRareBoxItem: Boolean;
    m_dwLatestDropTime: LongWord;
    m_GroupOwner: TPlayObject;
    m_GroupMembers: TStringList;
    m_ChgSlaveList: TList;
    m_boDealing: Boolean;
    m_DealLastTick: LongWord;
    m_DealCreat: TPlayObject;
    m_DealGoldLastTick: LongWord;
    m_DealGoldCreat: TPlayObject;
    m_dwEatItemTick: LongWord;
    m_dwGatherExp: LongWord;
    m_dwGatherIPExp: LongWord;
    m_dwGatherExpTick: LongWord;
    m_dwGatherIPExpTick: LongWord;

    m_dwGatherNimbus: LongWord;
    m_dwGatherNimbusTick: LongWord;
    m_dwGatherNimbusTick2: LongWord;

    m_boTakeDlgItem: Boolean;
    m_nDlgItemIndex: Integer;
    m_nPerInPower: Integer;

    m_dwIncInPowerTick: LongWord;
    m_boHeroSidestep: Boolean;
    m_boHeroTargetFilter: Boolean;
    m_nHeroSidestepHP: Integer;
    m_sCmdParams: array[0..7] of string;
    m_dwCheckSafeArea: LongWord;

    m_BlockWhisperList: TStringList;
    m_MissionList: TStringList;
    m_VisibleEvents: TList;
    m_VisibleItems: TList;

    m_boQueryRankOK: Boolean;
    m_nLvRankType: Integer;
    m_nLvRankResult: Integer;
    m_sSendRankData: string;
{$IF SERIESSKILL}
    m_SeriesSkillArr: TSeriesSkillArr;
    m_SeriesSkillArr2: TSeriesSkillInfos;
    m_VenationInfos: TVenationInfos;
    m_btReadySeriesSkill: Byte;
    m_dwReadySeriesSkillTick: LongWord;
    m_dwCanNextMoveTick: LongWord;
    m_btSeriesSkillSetpCur: Byte;
    m_btSeriesSkillSetpMax: Byte;
{$IFEND SERIESSKILL}
    m_btValNPCType: Byte;
    m_btValType: Byte;
    m_btValLabel: Byte;

    m_btCollectExpLv: Byte;
    m_dwCollectExp: LongWord;
    m_dwCollectIPExp: LongWord;

    m_StallMgr: TStallMgr;

    m_dwQueryLevelRankTick: LongWord;

    m_sMarkerMap: string[16];
    m_wMarkerX: Word;
    m_wMarkerY: Word;

    m_status: Integer;
    m_CurItemName: string;  
    m_CurItemIdx: Word;   
  private
    m_dwReportEscortPosTick: LongWord;
    m_UserMarket: TMarketItemManager;
    m_MarketNpc: TBaseObject;
    m_boFlagUserMarket: Boolean;
    m_boFlagReadyToSellCheck: Boolean;

    procedure SendTestUrl();
    procedure SendQueryVersion();
    procedure UpdateViewRange();
    procedure UpdateVisibleItem(wX, wY: Integer; MapItem: pTMapItem);
    procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);

    procedure ServerGetMarketList(MarketNpc: TBaseObject; page_: Integer; Body: string);
    procedure ServerGetMarketSell(MarketNpc: TBaseObject; Count_: Integer; MakeIndex_: Integer; Body: string);
    procedure ServerGetMarketBuy(MarketNpc: TBaseObject; SellIndex_: Integer);
    procedure ServerGetMarketCancel(MarketNpc: TBaseObject; SellIndex_: Integer);
    procedure ServerGetMarketGetPay(MarketNpc: TBaseObject; SellIndex_: Integer);
    procedure ServerGetMarketClose;

    function ClientDropGold(nGold: Integer): Boolean;
    procedure ClientQueryUserState(PlayObject: TPlayObject; nX, nY: Integer);
    procedure ClientQueryUserSet(ProcessMsg: pTProcessMessage);
    function ClientDropItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
    function ClientDismantleItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
    function ClientHeroDropItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
    procedure ClientOpenDoor(nX, nY: Integer);
    procedure ClientUseItems(nItemIdx: Integer; sItemName: string);
    procedure ClientHeroUseItems(nItemIdx, nType: Integer; sItemName: string);
    function InNotAllowUseItems(ItemIdx: Integer): Boolean;
    function GetUnBindItems(sItemName: string; nCount: Integer): Boolean;

    function CretInNearXYEx(nX, nY: Integer): Boolean;
    procedure SendStallItems(RecvObject: TPlayObject);
    procedure CancelDoStall;
    procedure ClientStallOnOpening(MsgBuff: string; nCount: Integer);
    procedure ClientUpdateStallItem(Msg: string; AddItemStall: Boolean);
    function IsOnSaleItem(MakeIndex: Integer): Boolean;

    procedure ClientBindItem(Npc, MakeIndex: Integer; ItemName: string; IsUnBind: Boolean);
    procedure ClientQueryChangeHero(HeroName: string);

    procedure ClientHeroSetTarget(nTarget, nTagX, nTagY: Integer);
    function ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean;
    procedure ClientChangeMagicKey(nSkillIdx, nKey: Integer);
    procedure ClientHeroChangeMagicKey(nSkillIdx, nKey: Integer);
    procedure ClientClickNPC(Npc: Integer);
    procedure ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);

    procedure ClientMerchantQueryExchgBook(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg: string);
    function  ClientUserSellItem(nParam1, nMakeIndex, sellcnt: Integer; sMsg: string): Boolean;

    procedure ClientSellItemList(IntMerchant: Integer; sMsg: String);
    procedure ClientUserExchgItem(nParam1, nMakeIndex, sellcnt: Integer; sMsg: string);

    procedure ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
    procedure ClientGetSellOff(nParam1, nMakeIndex: Integer; sMsg: string);
    function ClientGetBuyOff(Npc: TBaseObject; var sMsg: string): Integer;
    procedure ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
    procedure ClientGropuClose();
    procedure ClientCreateGroup(sHumName: string);
    procedure ClientAddGroupMember(sHumName: string);
    procedure ClientDelGroupMember(sHumName: string);
    procedure ClientDealTry(sHumName: string);
    procedure ClientAddDealItem(nItemIdx, Count: Integer; sItemName: string);
    procedure ClientDelDealItem(nItemIdx: Integer; sItemName: string);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold: Integer);
    procedure ClientDealEnd();
    procedure ClientStorageItem(Npc: TObject; nItemIdx, Count: Integer; sMsg: string; bIsStorageView:Boolean = False);
    procedure ClientTakeBackStorageItem(Npc: TObject; nItemIdx, TakeBackCnt: Integer; sMsg: string; bIsStorageView: Boolean = False);
    procedure ClientGetMinMap();
    procedure ClientMakeDrugItem(Npc: TObject; nItemName: string);
    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();

    procedure ClientGuildAddMember(sHumName: string);
    procedure ClientGuildDelMember(sHumName: string);
    procedure ClientGuildUpdateNotice(sNotict: string);
    procedure ClientGuildUpdateRankInfo(sRankInfo: string);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName: string);
    procedure ClientAdjustBonus(nPoint: Integer; sMsg: string);
    procedure ClientPostSell(nNPC, nCount: Integer; sMsg: string);
    procedure ClientCancelPostSell(nNPC: Integer);
    procedure ClientAffirmPostDeal(nNPC: Integer);
    procedure ClientCancelPostDeal(nNPC: Integer);
    procedure ClientRefineItem(sBody: string);
    procedure ClientTrainSkill(idx, mid: Integer);
    function ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    // Ë½ÓÐº¯ÊýÎ´µ÷ÓÃ
    function ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord; var IswarrSkill: Boolean): Boolean;
    function CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean;
    function GetUserItemWeitht(nWhere: Integer): Integer;
    function UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
    procedure SendDelDealItem(UserItem: pTUserItem);
    procedure SendAddDealItem(UserItem: pTUserItem; remain: Integer);
    procedure OpenDealDlg(BaseObject: TPlayObject);
    function EatItems(StdItem: pTStdItem): Boolean;
    function EatUseItems(nShape: Integer): Boolean;
    function ReadBook(StdItem: pTStdItem): Boolean;
    procedure MoveToHome();

    function RepairWeapon(): Boolean;
    function SuperRepairWeapon(): Boolean;
    function WinLottery(): Boolean;
    procedure ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
    function WeaptonMakeLuck(): Boolean;
    function PileStones(nX, nY: Integer): Boolean;
    function PileEarth(nX, nY, Shape, EventId: Integer): Boolean;

    function GetNearNumbusPoints(): Integer;
    function RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
    procedure ThrustingOnOff(boSwitch: Boolean);
    procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure SkillCrsOnOff(boSwitch: Boolean);
    procedure SkillSquOnOff(boSwitch: Boolean);

    procedure MakeMine();
     procedure DigItem(Shape: Integer);   
    function GetRangeHumanCount(): Integer;
    procedure GetHomePoint();
    procedure LogonTimcCost;
    procedure SendNotice();
    procedure SendImageFileListCustom();
    procedure SendSafeZoneEffectCustom();
    procedure SendNpcCustom;
    procedure SendMissions();
    procedure SendLogon();
    procedure SendServerConfig();
    // procedure SendServerStatus();         
    procedure ClientQueryUserName(Target: TBaseObject; x, y: Integer);
    procedure SendUseitems();
    procedure SendUseMagic();

    procedure SendSaveItemList(nBaseObject: Integer);
    procedure sendStorageItemList(nBaseObject: Integer);
    procedure SendAdjustBonus();
    procedure SendChangeGuildName();
    procedure SendMapDescription();
    procedure SendGoldInfo(boSendName: Boolean);
    procedure ShowMapInfo(sMAP, sX, sY: string);
    function CancelGroup(): Boolean;
    function CheckItemsNeed(StdItem: pTStdItem): Boolean;
    function CheckItemBindUse(UserItem: pTUserItem): Boolean;
    function CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
    procedure RecalcAdjusBonus;
    procedure CheckMarry();
    procedure CheckMaster();
    procedure RefMyStatus;
    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    function CheckDenyLogon: Boolean;
    procedure ProcessSpiritSuite;
    function HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
    procedure ClientMerchantItemDlgSelect(nParam1, nParam2, nParam3: Integer);
    procedure ProcessQueryValue(Npc: Integer; sData: string);

    function ReportEscortPos(): Boolean;
    procedure ClientMoveDetectItem(nItemIdx, putOn: Integer);
    procedure ClientDetectButchItem(nItemIdx: Integer);
    procedure ClientTreasureIdentify(nItemIdx, nBookIdx, nType: Integer);
    procedure ClientExchangeItem(nItemIdx, nBookIdx: Integer);

    procedure ClientSecretProperty(nItemIdx, nBookIdx, mlevel: Integer);
    procedure DoPositionMoveAttack(nLastX, nLastY, nLevel, nMagIdx, nPower: Integer);

    procedure ClientChangeConfig(nHero, nIdx: Integer);

  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: string); virtual;
    procedure SendSocketAll(DefMsg: pTDefaultMessage; sMsg: string);
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
    procedure SearchViewRange(); override;
    procedure SearchViewRange_Death(); override;

    procedure ClientChangeTitle(nHero, nIdx: Byte);

    procedure SendMyTitles(boReCount: Boolean);
    procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: Integer): Integer;
    procedure SetQuestUnitOpenStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitOpenStatus(nFlag: Integer): Integer;
    procedure SetQuestUnitStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitStatus(nFlag: Integer): Integer;

{$IF DEATHWALKING = 1}
    procedure Run2();
    function Think(): Boolean; virtual;
    //function Sidestep(): Boolean; virtual;
    function ProperTarget(): Boolean;
    procedure TrainingSkill(Magic: pTUserMagic); virtual;
    function AttackTarget(): Boolean; virtual;
    function RuntoTargetXY(btDir: Byte; boFlag: Boolean): Boolean; override;
    function __Wiza__HeroAttackTarget(): Boolean; virtual;
    function __Warr__HeroAttackTarget(): Boolean; virtual;
    function __Taos__HeroAttackTarget(): Boolean; virtual;

    function ProcUniteAttack(): Boolean;
{$IFEND DEATHWALKING}

    procedure MoveToHomeRandom;
    function GetCharColor(BaseObject: TBaseObject): Byte;
    function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean;
    procedure InternalPowerPointChanged(ref: Boolean = False);
    procedure ClientGuildMemberList();
    procedure ClientQueryBagItems();
    procedure PKDie(PlayObject: TPlayObject);
    procedure GameTimeChanged();

    function AllowFireHitSkill(): Boolean;
    function AllowSquHitSkill(): Boolean;
    function AllowTwinHitSkill(): Boolean;
    function AllowPursueHitSkill(): Boolean;
{$IF SERIESSKILL}
    function AllowRushHitSkill(): Boolean;
    function AllowSmiteSkill(): Boolean;
    function AllowSmiteLongSkill(): Boolean;
    function AllowSmiteWideSkill(): Boolean;
    function AllowSmiteWideSkill2(): Boolean;
{$IFEND SERIESSKILL}
    function AllowSmiteLongSkill2(): Boolean;
    function AllowSmiteLongSkill3(): Boolean;
    function AllowSuperSkill3(): Boolean;
    function AllowSkill_MedusaEye(): Boolean;
    function AllowSuperSkill68(): Boolean;
    function AllowSuperSkill77(): Boolean;

    procedure ServerSendItemCountChanged(mindex, icount, increase: Integer; itmname: string);
    procedure ServerSendItemCountChangedFail(mindex, icount: Integer);
    procedure ServerGetSumCountItem(DestMakeIndex, SrcMakeIndex: Integer; itmnames: string);
    procedure AddDealCounterItem(uitem: TUserItem; remain: Integer);
    procedure DelDealCounterItem(uitem: TUserItem);
    function UserCounterItemAdd(StdMode, Looks, Cnt: Integer; iName: string; bEnforce: Boolean; ExceptMakeIndex: Integer = -1): Boolean;
    function UserCounterDealItemAdd(StdMode, Looks, Cnt: Integer; iName: string): Integer;
    function DeletePItemAndSend(pcheckitem: pTUserItem): Boolean;
    procedure RunSendImageFileCustom();
    procedure RunSendSafeZoneEffectCustom();
    procedure RunSendNpcCustom();
    procedure RunNotice();
    procedure SendDelItemList(ItemList: TStringList; wParam: Word);
    procedure GetOldAbil(var OAbility: TOAbility);
    procedure ClientQueryHeroBagItems;
    procedure SendHeroUseitems();
    procedure SendHeroLoyalty();
    procedure SendHeroUseMagic();
    procedure SendHeroUseMagicDelay();
    //function GetAttackPower(nBasePower, nPower: Integer): Integer; override;

    function GetMissionStep(sid: string): Integer;
    function DeleteMission(sid: string): Integer;
    function UpdateMission(sid: string; nstep: Integer): Integer;

    function GetMyStatus(): Integer;
    function IncGold(tGold: Integer): Boolean;
    function IsEnoughBag(): Boolean;
    function IsAddWeightAvailable(nWeight: Integer): Boolean;
    procedure SendAddItem(UserItem: pTUserItem; nHint: Integer = 1);
    procedure SendDelItems(UserItem: pTUserItem);
    procedure Whisper(whostr, SayStr: string);
    procedure WhisperRe(SayStr: string; MsgType: Byte);
    function IsBlockWhisper(sName: string): Boolean;
    function QuestCheckItem(sItemName: string; var nCount: Integer; var nParam: Integer; var nDura: Integer): pTUserItem;
    function QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
    procedure GainExp(dwExp: LongWord; nMonLevel: Integer; bipexp: Boolean = False);
    procedure GetExp(dwExp: LongWord; bGainExp: Boolean; bipexp: Boolean; bGatherExp: Boolean = True);
    procedure HeroGetExp(dwExp: LongWord);
    procedure HeroGetIPExp(dwExp: LongWord);
    procedure WinExp(dwExp: LongWord; bipexp: Boolean);
    function DecGold(nGold: Integer): Boolean;
    procedure Run(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure RecalcAbilitys(boAction: Boolean = False); override;
    procedure MakeSaveRcd(var HumanRcd: THumDataInfo);
    procedure DealCancel();
    procedure DealCancelA();
    function GetShowName(): string; override;
    procedure GetBackDealItems();
    procedure Disappear(); override;
    procedure GoldChange(sChrName: string; nGold: Integer);
    procedure ProcessUserLineMsg(sData: string);
    procedure ProcessSayMsg(sData: string); override;
    //procedure ClearStatusTime();
    procedure UserLogon(); //virtual;
    procedure UserResumeLogon();
    procedure RefRankInfo(nRankNo: Integer; sRankName: string);
    procedure RefUserState;
    procedure SendGroupMembers();
    procedure JoinGroup(PlayObject: TPlayObject);
    function GetPlayObjectInfo(): string;
    function GetHitMsgCount(): Integer;
    function GetSpellMsgCount(): Integer;
    function GetWalkMsgCount(): Integer;
    function GetRunMsgCount(): Integer;
    function GetTurnMsgCount(): Integer;
    function GetSiteDownMsgCount(): Integer;
    function GetDigUpMsgCount(): Integer;
    procedure GetScriptLabel(sMsg: string);
    function LableIsCanJmp(sLabel: string): Boolean;
    function CheckAmulet(nCount, nType: Integer; var idx: Integer): Boolean;
    procedure UseAmulet(nCount, nType: Integer; var idx: Integer);
    function GetMyInfo(): string;
    procedure MakeGhost; override;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); override;
    procedure ScatterBagItemsWithoutFail(ItemOfCreat: TBaseObject);
    procedure DropUseItems(BaseObject: TBaseObject); override;
    procedure DropUseItemsWithoutFail(BaseObject: TBaseObject);
    procedure Die(); override;
    procedure RecallHuman(sHumName: string);
    procedure SendAddMagic(UserMagic: pTUserMagic);
    procedure SendDelMagic(UserMagic: pTUserMagic);
    procedure SendConvertMagic(t1, t2, id1, id2: Integer; UserMagic: pTUserMagic);
    procedure SendDelHeroMagic(UserMagic: pTUserMagic);
    procedure ReQuestGuildWar(sGuildName: string);
    procedure SendUpdateItem(UserItem: pTUserItem);
    procedure SendUpdateDetectItem(UserItem: TUserItem);
    procedure GetBagUseItems(var btDc: Byte; var btSc: Byte; var btMc: Byte; var btDura: Byte);
    //procedure ReadAllBook;
    function GetSpellPoint(UserMagic: pTUserMagic): Integer;
    function DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
{$IF SERIESSKILL}function DoMotaeboEx(nDir: Byte; nMagicLevel: Integer): Boolean;
{$IFEND SERIESSKILL}
    function IsGroupMember(Target: TBaseObject): Boolean;
    procedure DelMember(BaseObject: TPlayObject);
    procedure SendGroupText(sMsg: string; Color: Integer = 0; fc: Integer = 0; bc: Integer = 0; sec: Integer = 0);
    procedure LeaveGroup();

    procedure CmdEndGuild();
    procedure CmdAddToCastleWarList(param1, param2: string);
    procedure CmdMemberFunction(sCmd, sParam: string);
    procedure CmdMemberFunctionEx(sCmd, sParam: string);
    procedure CmdSearchDear(sCmd, sParam: string);
    procedure CmdSearchMaster(sCmd, sParam: string);
    procedure CmdDearRecall(sCmd, sParam: string);
    procedure CmdMasterRecall(sCmd, sParam: string);
    procedure CmdSbkDoorControl(sCmd, sParam: string);
    procedure CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdLockLogin(Cmd: pTGameCmd);
    procedure CmdUnLockLogin(Cmd: pTGameCmd);
    procedure CmdRemoteMsg(Cmd: pTGameCmd);
    procedure CmdViewDiary(sCmd: string; nFlag: Integer);
    procedure CmdUserMoveXY(sCmd, sX, sY: string);
    procedure CmdSearchHuman(sCmd, sHumanName: string);
    procedure CmdGroupRecall(sCmd: string);
    procedure CmdAllowGroupReCall(sCmd, sParam: string);
    procedure CmdChangeLongAttack();
    procedure CmdChangeHeroMakeSlave();

    procedure CmdGuildRecall(sCmd, sParam: string);
    procedure CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
    procedure CmdChangeSalveStatus();
    procedure CmdChangeHeroStatus;
    procedure CmdTakeOnHorse(sCmd, sParam: string);
    procedure CmdTakeOffHorse(sCmd, sParam: string);
    procedure CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMapMove(Cmd: pTGameCmd; sMapName: string);
    procedure CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
    procedure CmdSignMove(Cmd: pTGameCmd);
    procedure CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReLoadAdmin(sCmd: string);
    procedure CmdReloadNpc(sParam: string);
    procedure CmdReloadManage(Cmd: pTGameCmd; sParam: string);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human: TPlayObject; nExp: Integer);
    procedure CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);
    procedure CmdInitSabuk(Cmd: pTGameCmd);
    procedure CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdGuildWar(sCmd, sGuildName: string);
    procedure CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean);
    procedure CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
    procedure CmdOPTraining(sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdOPDeleteSkill(sHumanName, sSkillName: string);
    procedure CmdReloadGuildAll();
    procedure CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);
    procedure CmdAdjuestIPLevel(sHumanName: string; nLevel: Integer);
    procedure CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
    procedure CmdBackStep(sCmd: string; nType, nCount: Integer);
    procedure CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer);
    procedure CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
    procedure CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
    procedure CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
    procedure CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
    procedure CmdTakeUserItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
    procedure CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdTraining(sSkillName: string; nLevel: Integer);
    procedure CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
    procedure CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
    procedure CmdMission(Cmd: pTGameCmd; sX, sY: string);
    procedure CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount: string);
    procedure CmdMobLevel(Cmd: pTGameCmd; Param: string);
    procedure CmdMobCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdDisableFilter(sCmd, sParam1: string);
    procedure CmdChangeUserFull(sCmd, sUserCount: string);
    procedure CmdChangeZenFastStep(sCmd, sFastStep: string);
    procedure CmdReconnection(sCmd, sIPaddr, sPort: string);
    procedure CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdStartContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdEndContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdKill(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount, nDura: Integer);
    procedure CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
    procedure CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdFireBurn(nInt, nTime, nN: Integer);
    procedure CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
    procedure CmdTestStatus(sCmd: string; nType, nTime: Integer);
    procedure CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
    procedure CmdGamePoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdCreditPoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint: Integer);
    procedure CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel: Integer);
    procedure CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit: Integer);
    procedure CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor, nType: Integer);
    procedure CmdRecallHero(Cmd: pTGameCmd; sMonName, sExtraName: string; boUseItem: Boolean);
    procedure CmdLuckPoint(sCmd: string; nPermission: Integer; sHumanName, sCtr, sPoint: string);
    procedure CmdLotteryTicket(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadGuild(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadLineNotice(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdReloadAbuse(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3, sParam4: string);
    procedure CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3: string);
    procedure CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
    procedure CmdTing(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
    procedure CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
    procedure CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
    procedure CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
    procedure CmdShutupList(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold: string);
    procedure CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowHumanFlag(sCmd: string; nPermission: Integer; sHumanName, sFlag: string);
    procedure CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    procedure CmdShowHumanUnit(sCmd: string; nPermission: Integer; sHumanName, sUnit: string);
    procedure CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
    procedure CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
    procedure CmdChangeDearName(Cmd: pTGameCmd; sHumanName: string; sDearName: string);
    procedure CmdChangeMasterName(Cmd: pTGameCmd; sHumanName: string; sMasterName, sIsMaster: string);
    procedure CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
    procedure CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
    procedure CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);
    procedure CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
    procedure CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
    procedure CmdSpirtStart(sCmd: string; sParam1: string);
    procedure CmdSpirtStop(sCmd: string; sParam1: string);
    procedure CmdSetMapMode(sCmd: string; sMapName, sMapMode, sParam1, sParam2: string);
    procedure CmdShowMapMode(sCmd: string; sMapName: string);
    procedure CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
    procedure CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdDisableSendMsgList(Cmd: pTGameCmd);
    procedure CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
    procedure CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType, sTime, sPoint: string);
    procedure CmdTestSpeedMode(Cmd: pTGameCmd);
    procedure CmdSetEvaItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
    procedure CmdHWID(sCmd, sParam1: string; nInt: Integer);

    function CloneSelf(btLevel: Byte): TBaseObject;
    function ProcessUserCmd(sCmd: string): Boolean;
    function DieFunc: Boolean;
    procedure DeleteBagEctype();
    procedure DeleteStorageEctype();
    procedure CheckDelBagCopyed();
    procedure CheckDelStoCopyed();
    procedure CheckItemExpires();
    function ClientPickUpItem(nItemX, nItemY: Integer): Boolean;
    function HeroPickUpItem(x, y: Integer; MapItem: pTMapItem): Boolean;
    function DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer; BaseObject: TBaseObject; var boTrainOk: Boolean): Boolean;
    function ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
    procedure ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
    function ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
    function ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
    procedure ClientPlayerAddItemToHero(nItemIdx: Integer; sItemName: string);
    procedure ClientHeroAddItemToPlayer(nItemIdx: Integer; sItemName: string);
    procedure ClientRecallHero();
    procedure QueryHeroHeroState();
    procedure ClientHeroJointAttack();
    procedure ScriptOpenBox(sMsg: string);
    procedure ClientOpenBox(sMsg: string);
    procedure ClientQueryLevelRank(nType, nPage: Integer);
    procedure ClientSelectBoxFlash();
    procedure ClientGetBoxItem();
{$IF SERIESSKILL}
    procedure ClientSetSeriesSkill(Index, MagID: Integer);
    procedure ClientSetSeriesSkill2(Index, MagID: Integer);
    procedure ClientBreakPonit(v, p, h: Integer);
    procedure ClientTrainVenation(v: Integer);
    procedure ClientBuildAcus(buff: string);
{$IFEND SERIESSKILL}
    procedure ClientWantReleaseCollectExp();
    procedure BaseObjectMove(sMAP, sX, sY: string);
    function OffLineFunc(): Boolean;
    function CheckMapEvent(nAction: Integer; ItemName: string): Boolean;
    function SetAttrGroupMemberInNear(GroupMember: TPlayObject; nType: Integer): Boolean;
    procedure SetBankPassword(sPassWord: string);
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer; range: Integer = 1): Boolean;
    procedure GetSaleItemList(MsgObject: TBaseObject; nIndex: Integer);
    procedure BuyShopItem(MsgObject: TBaseObject; sMsg: string);
    procedure LoadHumanCustomData();
    procedure SaveHumanCustomData();
    procedure GetSaleItemListEx(ProcessMessage: pTProcessMessage);
    procedure BuySaleItemListEx(ProcessMessage: pTProcessMessage);
    procedure PresendItem(ProcessMessage: pTProcessMessage);
    function GetHeroObjectA(): TBaseObject;
    function DoMag60(UserMagic: pTUserMagic; nDir: Integer; TargeTBaseObject: TBaseObject): Boolean;

    procedure RequireLoadRefresh;
    procedure RequireLoadUserMarket(MarketName: string; ItemType: Integer; UserMode: Integer; OtherName: string; ItemName_: string);
    procedure RequireSellUserMarket(MakeIndex_: Integer; SellCount_: Integer; SellPrice_: Integer);
    procedure RequireBuyUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);
    procedure RequireCancelUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);
    procedure RequireGetPayUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);

    function IsExistBagItem(MakeIndex_: Integer): pTUserItem;
    function IsFullBagCount: Boolean;
    function IsEnableUseMarket: Boolean;
    function DeleteFromBagItem(MakeIndex_: Integer; SellCount_: Integer): Boolean;
    function AddToBagItem(UserItem_: TUserItem): Boolean;
    function GetMarketName: string;
    procedure SendUserMarketSellReady(MarketNpc: TBaseObject);
    procedure SendUserMarketCloseMsg;

    procedure GetMarketData(pInfo: PTSearchSellItem);
    procedure SendUserMarketList(NextPage: Integer);
    procedure SellUserMarket(pSellItem: PTMarketLoad);
    procedure ReadyToSellUserMarket(pReadyItem: PTMarketLoad);
    procedure BuyUserMarket(pBuyItem: PTMarketLoad);
    procedure CancelUserMarket(pCancelItem: PTMarketLoad);
    procedure GetPayUserMarket(pGetpayItem: PTMarketLoad);
{$IF SERIESSKILL}
    procedure SerieSkillReady();
    function GetSeriesSkillDamage(mid: Word; Pwr: Integer): Integer;
{$IFEND SERIESSKILL}
    procedure CollectExp(dwExp, dwIPExp: LongWord);
    procedure CollectLevelUp(open: Boolean; delay: Integer = 600);
    procedure HeroAutoJointAttack();
    procedure MakeItem(sItemName: string; nCount, nDura: Integer);

    procedure SendChangeBagItemDura(makeIndex: Integer; newDura: Word; waitItemToBag: Boolean);

  end;

procedure ClearEctypeManus();

var
  gdeny: Boolean;

implementation

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, ItmUnit, Event, SqlEngn,
  ObjMon, LocalDB, Castle, EncryptUnit, svMain, RunSock, RunDB, Magic, ObjectHero, UsrEngn,
  ObjMon2, ObjMon3, ObjMon5, backdoor;

var
  dwStartTick: DWORD;
  dwLastCheck: DWORD;
//  gdeny             :Boolean;

function CheckTestValide: Boolean;
var
  cur: DWORD;
begin

  Result := False;

  cur := GetTickCount;


  if (cur - dwStartTick) > 1000 * 1 * 60 * 40 then
  begin
    if (cur - dwLastCheck) > 1000 * 1 * 10 then
    begin
      if (UserEngine.GetUserCount > 20) then
      begin
        Result := True;
      end;
    end;

  end;

end;

{ TBaseObject }

constructor TBaseObject.Create;
begin
  InitializeCriticalSection(ProcessMsgCriticalSection); //???
  m_fHeroMon := False;
  m_btIgnoreTagDefence := 0;
  m_btDamageAddOn := 0;
  m_btDamageRebound := 0;
  m_btACDamageReduction := 0;
  m_btMCDamageReduction := 0;
  m_btGetExpExRate := 0;

  m_boParalysis := False;
  m_boUnParalysis := False;
  m_boUnAllParalysis := False;
  m_boUnRevival := False;
  m_boUnMagicShield := False;

  FillChar(m_spMonAbil, SizeOf(m_spMonAbil), 0);

  m_boGhost := False;
  m_dwGhostTick := 0;
  m_boDeath := False;
  m_boCanReAlive := False;
  m_boInvisible := False;
  m_dwReAliveTick := 0;
  m_pMonGen := nil;

  m_dwDeathTick := 0;
  m_SendRefMsgTick := GetTickCount();
  m_btDirection := 4;
  m_btRaceServer := RC_ANIMAL;
  m_btRaceImg := 0;
  m_btHair := 0;
  m_btJob := 0;
  m_nGold := 0;
  m_wAppr := 0;
  m_boHoldPlace := True;
  m_nViewRangeX := 5;
  m_nViewRangeY := m_nViewRangeX;
  m_sHomeMap := '0';
  m_btPermission := 0;
  m_nLight := 0;
  m_boHeroSearchTag := False;
  m_btNameColor := 255;
  m_nHitPlus := 0;
  m_nHitDouble := 0;
  m_nHitDoubleEx := 0;
  m_nHitDouble_101 := 0;
  m_dBodyLuck := 0;
  m_dHeroLoyalty := 0;
  m_nMaxDamageHealth := 0;
  m_nNonFrzWalkSpeed := 0;
  m_nNonFrzNextHitTime := 0;
  m_nInPowerPoint := 0;
  m_nInPowerLevel := 0;
  m_IPRecoverRate := 1;
  m_wVampire := 0;
  m_wVampire2 := 0;

  m_btSuckRate := 0;
  m_btDoubleDamage := 0;
  m_wInPowerRateEx := 0;
  m_AddDamage := 0;
  m_DecDamage := 0;
  m_nCurEnvirIdx := -1;
  m_nCastleEnvirListIdx := -1;
  m_dwDoubleScTick := 0;
  m_CurSafeZoneList := TList.Create();
  m_btHitPowerAddOn := 0;
  m_wDoublePower := 0;
  m_dwInPowerExp := 0;

  //m_wGroupRcallTime := 0;
  //m_dwGroupRcallTick := GetTickCount();
  m_boRecallSuite := False;
  m_boRaceImg := False;
  //m_boTestGa := False;
  //m_boGsa := False;
  m_boSafeWalk := False;
  m_boAbilSeeHealGauge := False;
  m_boPowerHit := False;
  m_boUseThrusting := False;
  m_boUseHalfMoon := False;
  m_boFireHitSkill := False;
  m_boPursueHitSkill := False;
  m_boSmiteSkill := False;
  m_boRushhitSkill := False;
  m_boSmiteLongSkill := False;
  m_boSmiteLongSkill2 := False;
  m_boSmiteLongSkill3 := False;
  m_boSmiteWideSkill := False;
  m_boSmiteWideSkill2 := False;

  m_boCrsHitkill := False;
  m_boSquareHit := False;
  m_boTwinHitSkill := False;
  m_btSquareHit := 0;
  m_btHitPoint := 5;
  m_btSpeedPoint := 15;
  m_nHitSpeed := 0;
  m_btLifeAttrib := 0;
  m_btAntiPoison := 0;
  m_btAntiStone := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 0;
  m_nLuck := 0;
  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;
  m_nPerHealth := g_Config.nCordialAddHPMPMax; //5
  m_nPerHealing := g_Config.nHealingRate; //5
  m_nPerSpell := g_Config.nCordialAddHPMPMax;
  m_dwLatestSmiteLongTick3 := GetTickCount();
  m_dwIncHealthSpellTick := GetTickCount();
  m_dwIncHealthTick := GetTickCount();
  m_dwIncSpellTick := GetTickCount();
  m_dwCheckHPMPTick := GetTickCount();

  m_boMedusaEyeHint := False;
  m_dwLatestMedusaEyeTick := GetTickCount();
  m_dwLatestSkill68Tick := GetTickCount();
  m_dwLatestSkill77Tick := GetTickCount();
  m_btGreenPoisoningPoint := 0;
  m_nFightZoneDieCount := 0;
  m_nGoldMax := g_Config.nHumanMaxGold;
  m_nCharStatus := 0;
  m_nCharStatusEx := 0;
  m_wApprStatus := 0;
  m_UnreachableTick := 0;
  //m_wGroupRcallTime := 0;
  //m_boAllowGroupReCall := False;
  //FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);

  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
  FillChar(m_wStatusTimeArrEx, SizeOf(m_wStatusTimeArrEx), #0);

  FillChar(m_dwStatusArrTickEx, SizeOf(m_dwStatusArrTickEx), #0);

  FillChar(m_wStatusArrValue, SizeOf(m_wStatusArrValue), #0);
  FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);
  FillChar(m_wStatusArrValue2, SizeOf(m_wStatusArrValue2), #0);
  FillChar(m_dwStatusArrTimeOutTick2, SizeOf(m_dwStatusArrTimeOutTick2), #0);
  m_DefenceRate := 0;
  m_MagDefenceRate := 0;

  m_btClPkPoint := 0;
  m_btAttatckMode := 0;
  m_boInFreePKArea := False;
  m_boGuildWarArea := False;
  m_boStruck := False;
  m_boDoubleStruck := False;
  m_boDoubleStruck2 := False;
  m_boDoubleStruck3 := False;
  m_boSuperMan := False;
  m_boSkeleton := False;
  m_boGetRandomItems := False;
  m_boCowKingMon := False;
  m_boHolySeize := False;
  m_boCrazyMode := False;
  m_boShowHP := False;
  m_boPlayerDupMode := False;
  m_boAnimal := False;
  m_boExplore := False;
  m_boNoItem := False;
  m_nBodyLeathery := 50;
  m_nPerBodyLeathery := m_nBodyLeathery;
  m_boFixedHideMode := False;
  m_boStickMode := False;
  m_boNoAttackMode := False;
  m_boPKFlag := False;
  m_nMoXieSuite := 0;
  m_nHongMoSuite := 0;
  m_dbHongMoSuite := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  m_MsgList := TList.Create;
  m_VisibleHumanList := TList.Create;

  m_VisibleActors := TList.Create;

  //m_VisibleItems := TList.Create;
  //m_VisibleEvents := TList.Create;
  m_ItemList := TList.Create;
  m_DealItemList := TList.Create;
  m_boIsVisibleActive := False;
  m_nProcessRunCount := 0;
  m_nDealGolds := 0;
  m_MagicList := TList.Create;
  m_StorageItemList := TList.Create;
  FillChar(m_UseItems, SizeOf(m_UseItems), #0);
  m_boHaveMag := False;
  m_wHPAddLevel := 0;
  m_wMPAddLevel := 0;
  m_wJobAbil := 0;
  m_btSPLuck := 0;
  m_btSkill77 := 0;
  m_btSpSkill1 := 0;
  m_btSpSkill2 := 0;
  m_btSpSkill3 := 0;
  m_btSpSkill4 := 0;
  m_btSpSkill5 := 0;
  m_btSpSkill6 := 0;
  m_btSpSkill7 := 0;
  m_btSpSkill8 := 0;
  m_btSPEnergy := 0;
  m_dwSPEnergyAddTick := GetTickCount();
  FillChar(m_MagicArr, SizeOf(TMagicArr), #0);
  m_Castle := nil;
  m_Master := nil;
  m_Robber := nil;
  m_nKillMonCount := 0;
  m_btSlaveExpLevel := 0;
  m_dwCloneDispearTick := 0;
  m_boHearWhisper := True;
  m_boBanShout := True;
  m_boBanGuildChat := True;
  m_boAllowDeal := True;

  m_SlaveList := TList.Create;
  FillChar(m_WAbil, SizeOf(TAbility), #0);
  //FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit), #0);
  //FillChar(m_QuestUnit, SizeOf(TQuestUnit), #0);
  m_Abil.Level := 1;
  m_Abil.AC := 0;
  m_Abil.MAC := 0;
  m_Abil.DC := MakeLong(1, 4);
  m_Abil.MC := MakeLong(1, 2);
  m_Abil.SC := MakeLong(1, 2);
  m_Abil.HP := 15;
  m_Abil.MP := 15;
  m_Abil.MaxHP := 15;
  m_Abil.MaxMP := 15;
  m_Abil.Exp := 0;
  m_Abil.MaxExp := 50;
  m_Abil.Weight := 0;
  m_Abil.MaxWeight := 100;
  m_boWantRefMsg := False;
  m_MyGuild := nil;
  m_nGuildRankNo := 0;
  m_sGuildRankName := '';
  m_sScriptLable := '';
  m_boMission := False;
  m_boHideMode := False;
  m_boTDBeffect := False;
  m_boStoneMode := False;
  m_boCoolEye := False;
  m_boUserUnLockDurg := False;
  m_boTransparent := False;
  m_boAdminMode := False;
  m_boSuperMode := False;
  m_boObMode := False;
  m_dwRunTick := GetTickCount + LongWord(Random(1500));
  m_nRunTime := 250;
  m_dwSearchTime := Random(2000) + 2000;
  m_dwSearchTick := GetTickCount;
  m_dwDecPkPointTick := GetTickCount;
  m_DecLightItemDrugTick := GetTickCount();
  m_dwPoisoningTick := GetTickCount;
  m_dwVerifyTick := GetTickCount();
  m_dwGroupAttribTick := GetTickCount();
  m_dwCheckRoyaltyTick := GetTickCount();
  m_dwDecHungerPointTick := GetTickCount();
  m_dwHPMPTick := GetTickCount();
  m_dwShoutMsgTick := 0;
  m_dwTeleportTick := 0;
  m_dwProbeTick := 0;
  m_dwMapMoveTick := GetTickCount();
  m_dwMasterTick := 0;
  m_nWalkSpeed := 1400;
  m_nNextHitTime := 2000;
  m_nWalkCount := 0;
  m_dwWalkWaitTick := GetTickCount();
  m_boWalkWaitLocked := False;
  m_nHealthTick := 0;
  m_nSpellTick := 0;
  m_TargetCret := nil;
  m_LockTarget := nil;
  m_PoisonHiter := nil;
  m_LastHiter := nil;
  m_ExpHitter := nil;
  m_SayMsgList := nil;
  //m_boDenyRefStatus := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;
  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_btMagShieldLevel := 0;
  m_nMagShieldHP := 0;
  m_boAddToMaped := True;
  m_boAutoChangeColor := False;
  m_dwAutoChangeColorTick := GetTickCount();
  m_dwAutoChangeColorTime := 0;
  m_nAutoChangeIdx := 0;
  m_boAttackedMag62 := False;
  m_boFixColor := False;
  m_boLongAttack := False;
  m_boLockLongAttack := False;
  m_boNoDropItemEx := False;
  m_boNoDropUseItemEx := False;
  m_nDropUseItemRate := 500;
  m_nFixColorIdx := 0;
  m_nFixStatus := -1;
  m_boFastParalysis := False;
  m_btMedusaEyeAttack := 0;
  m_boStrike := False;
  m_dwClearCopyTtemTick := GetTickCount();
  m_dwCheckItemsNeed := GetTickCount();
  m_sHeroName := '';
  m_sTempHeroName := '';
  m_sHeroMasterName := '';
{$IF VER_ClientType_45}
  m_wClientType := 0;
{$IFEND VER_ClientType_45}
  m_nClientVerNO := 0;
  m_boLoadHeroRcd := False;
  m_boLoadRcdFail := False;
  m_boNewHero := False;
  m_dwHeroSaveRcdTick := GetTickCount();
  m_boHeroSaveRcd := False;
  m_nAutoAddHPMPMode := 0;
  m_boDrangonHeart := False;
  m_nJointAttackEnergy := 0;
  m_nVigour := 0;
  m_boJointAttackReady := False;
  m_boVigourAddAble := True;
  m_sStoragePwd := '';
  m_btCreditPoint := 0;
  m_btReLevel := 0;
  m_sMasterName := '';
  m_boMaster := False;
  m_sDearName := '';
  m_nGameGold := 0;
  m_nGamePoint := 0;
  //m_sMarkerMap := '';
  //m_wMarkerX := 0;
  //m_wMarkerY := 0;
  m_btHeroRelax := 0;
  m_nKillMonExpRate := 100;
  m_boPasswordLocked := False;
  m_nPayMentPoint := 0;
  m_boLockLogon := True;
  m_btAttribute := 0;
  m_nAddHPMPRate := 100;
  m_nAddPowerRate := 100;
  m_nCursePowerRate := 100;
  m_nCursePowerRateTime := 0;
  m_btHairEx := 0;
  m_btWeaponSkill := 0;
  m_btWeaponEffect := 0;
  m_nPushedCount := 0;
  m_nBodyState := 0;
  m_nLastMapSecret := -1;
  m_btReduceSpellTime := 0;
  m_dwDragonRageSkillTick := GetTickCount();
  m_btPostSell := 0;
  m_nGameDiamond := 0;
  m_nGameGird := 0;
  m_boShowMasterName := True;
  m_boChgRecallHero := False;
  m_btUseAmulet := 1;
  m_boUseAmulet := False;
  m_dwLatestSmiteWideTick2 := GetTickCount();
  m_boShowFashion := True;
  m_btActiveTitle := 0;
  m_btInitTitle := 0;
  FillChar(m_Titles, SizeOf(THumTitles), 0);
  m_UnreachableItemList := TList.Create
end;

destructor TBaseObject.Destroy;
var
  i: Integer;
  SendMessage: pTSendMessage;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Destroy %s(%s/%d/%d) Code: %d';
begin
  nCheckCode := 0;
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      nCheckCode := 1;
      SendMessage := m_MsgList.Items[i];
      nCheckCode := 2;
      if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <> 0) then
      begin
        nCheckCode := 3;
        if TStringList(SendMessage.nParam1) <> nil then
        begin
          TStringList(SendMessage.nParam1).Free;
          TStringList(SendMessage.nParam1) := nil;
        end;
      end;
      nCheckCode := 4;
      if (SendMessage.wIdent = RM_MAKESLAVE) and (SendMessage.nParam1 <> 0) then
      begin
        Dispose(pTSlaveInfo(SendMessage.nParam1));
        pTSlaveInfo(SendMessage.nParam1) := nil;
      end;
      nCheckCode := 5;
      if (SendMessage.buff <> nil) then
      begin
        FreeMem(SendMessage.buff);
        SendMessage.buff := nil;
      end;
      Dispose(SendMessage);
      SendMessage := nil;
    end;
    nCheckCode := 6;
    m_MsgList.Free;

    nCheckCode := 7;
    m_VisibleHumanList.Free;

    nCheckCode := 8;
    for i := 0 to m_VisibleActors.Count - 1 do
      Dispose(pTVisibleBaseObject(m_VisibleActors[i]));
    m_VisibleActors.Free;

    {nCheckCode := 10;
    for i := 0 to m_VisibleItems.Count - 1 do
      Dispose(pTVisibleMapItem(m_VisibleItems[i]));
    nCheckCode := 11;
    m_VisibleItems.Free;}

    {nCheckCode := 12;
    for i := 0 to m_VisibleEvents.Count - 1 do
      Dispose(pTVisibleEvent(m_VisibleEvents[i]));
    m_VisibleEvents.Free;}

    nCheckCode := 13;
    for i := 0 to m_ItemList.Count - 1 do
      Dispose(pTUserItem(m_ItemList.Items[i]));
    m_ItemList.Free;

    nCheckCode := 14;
    for i := 0 to m_DealItemList.Count - 1 do
      Dispose(pTUserItem(m_DealItemList.Items[i]));
    m_DealItemList.Free;

    nCheckCode := 15;
    for i := 0 to m_MagicList.Count - 1 do
      Dispose(pTUserMagic(m_MagicList.Items[i]));
    m_MagicList.Free;

    nCheckCode := 16;
    for i := 0 to m_StorageItemList.Count - 1 do
      Dispose(pTUserItem(m_StorageItemList.Items[i]));
    m_StorageItemList.Free;

    nCheckCode := 17;
    m_SlaveList.Free;

    m_CurSafeZoneList.Free;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;

  DeleteCriticalSection(ProcessMsgCriticalSection);
  m_UnreachableItemList.Free;
  inherited;
end;

procedure TBaseObject.ChangePKStatus(boWarFlag: Boolean); //004B84C8
begin
  if m_boInFreePKArea <> boWarFlag then
  begin
    m_boInFreePKArea := boWarFlag;
    m_boNameColorChanged := True;
  end;
end;

function TBaseObject.GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY: Integer): Boolean;
var
  i, ii, III: Integer;
  nItemCount, n24, n28, n2C: Integer;
begin
  n24 := 999;
  Result := False;
  n28 := 0;
  n2C := 0;
  for i := 1 to nRange do
  begin
    for ii := -i to i do
    begin
      for III := -i to i do
      begin
        nDX := nOrgX + III;
        nDY := nOrgY + ii;
        if m_PEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then
        begin
          if m_PEnvir.m_boChFlag then
          begin
            Result := True;
            Break;
          end;
        end
        else if m_PEnvir.m_boChFlag and (n24 > nItemCount) then
        begin
          n24 := nItemCount;
          n28 := nDX;
          n2C := nDY;
        end;
      end;
      if Result then
        Break;
    end;
    if Result then
      Break;
  end;
  if not Result then
  begin
    if n24 < 8 then
    begin
      nDX := n28;
      nDY := n2C;
    end
    else
    begin
      nDX := nOrgX;
      nDY := nOrgY;
    end;
  end;
end;

function TBaseObject.DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
var
  dx, dy, idura: Integer;
  MapItem, pr: pTMapItem;
  StdItem: pTStdItem;
  countstr, logcap: string;
  sUserItemName: string;
  CSObject: TBaseObject;
begin
  Result := False;
  countstr := '';
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then
  begin
    if StdItem.StdMode = 40 then
    begin
      idura := UserItem.Dura;
      idura := idura - 2000;
      if idura < 0 then
        idura := 0;
      UserItem.Dura := idura;
    end;
    New(MapItem);
    MapItem.IsGold := False;
    MapItem.boHeroPickup := StdItem.SvrSet.boHeroPickup;
    MapItem.UserItem := UserItem^;

    if (StdItem.Overlap >= 1) and (UserItem.Dura > 1) then
    begin
      countstr := Format('(%d)', [UserItem.Dura]);
      MapItem.Name := Format('%s\(%d)', [StdItem.Name, UserItem.Dura])
    end
    else
    begin
      MapItem.Name := StdItem.Name;
    end;

    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
    begin
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        MapItem.Name := sUserItemName;
    end;
    MapItem.Looks := StdItem.Looks;
    if StdItem.StdMode = 45 then
      MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
    MapItem.AniCount := StdItem.AniCount;
    MapItem.Reserved := 0;
    MapItem.Count := 1;
    MapItem.OfBaseObject := ItemOfCreat;
    MapItem.dwCanPickUpTick := GetTickCount();
    MapItem.DropBaseObject := DropCreat;
    if (ItemOfCreat <> nil) and (m_btRaceServer = RC_MISSION) then
    begin
      CSObject := GetMainPlayer(ItemOfCreat);
      CSObject.GetDropPosition(CSObject.m_nCurrX, CSObject.m_nCurrY, 2, dx, dy)
    end
    else
      GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
    pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
    if pr = MapItem then
    begin
      SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), dx, dy, MapItem.Name);
      if boDieDrop then
      begin
        logcap := '15' ;
        if (m_btRaceServer <> RC_PLAYOBJECT) and (m_btRaceServer <> RC_HERO) then  //@MonDropItemµÄÊ±»ú
        begin
          if InLimitItemList('', UserItem.wIndex, t_MonDropItem) then
          begin
            if g_FunctionNPC <> nil then
            begin
              g_FunctionNPC.m_OprCount := 0;
              TPlayObject(ItemOfCreat).m_CurItemName := StdItem.Name;
              TPlayObject(ItemOfCreat).m_CurItemIdx := UserItem.wIndex;
              g_FunctionNPC.GotoLable(TPlayObject(ItemOfCreat), '@MonDropItem', False);
              TPlayObject(ItemOfCreat).m_CurItemName := '';
              TPlayObject(ItemOfCreat).m_CurItemIdx := 0;
            end;
          end;
        end;
      end
      else
      begin
        logcap := '7';
        if m_btRaceServer = RC_PLAYOBJECT then
          TPlayObject(Self).m_dwLatestDropTime := GetTickCount;
      end;
      if not IsCheapStuff(StdItem.StdMode) then
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI(logcap + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0' + countstr);
      Result := True;
    end
    else
      Dispose(MapItem);
  end;
end;

function TBaseObject.HeroDropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
var
  dx, dy, idura: Integer;
  MapItem, pr: pTMapItem;
  StdItem: pTStdItem;
  logcap, countstr: string;
  sUserItemName: string;
begin
  Result := False;
  countstr := '';
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then
  begin
    if StdItem.StdMode = 40 then
    begin
      idura := UserItem.Dura;
      idura := idura - 2000;
      if idura < 0 then
        idura := 0;
      UserItem.Dura := idura;
    end;

    New(MapItem);
    MapItem.IsGold := False;
    MapItem.boHeroPickup := StdItem.SvrSet.boHeroPickup;
    MapItem.UserItem := UserItem^;

    if (StdItem.Overlap >= 1) and (UserItem.Dura > 1) then
    begin
      countstr := Format('(%d)', [UserItem.Dura]);
      MapItem.Name := Format('%s(%d)', [StdItem.Name, UserItem.Dura]);
    end
    else
      MapItem.Name := StdItem.Name;

    {if PCardinal(@MapItem.UserItem.btValue[22])^ > 0 then begin
      MapItem.Name := MapItem.Name + '\(ÒÑ°ó¶¨)';
    end else begin
      case StdItem.SvrSet.nBind of
        1: if g_Config.boBindPickUp then MapItem.Name := MapItem.Name + '\(Ê°È¡ºó°ó¶¨)';
        2: if g_Config.boBindTakeOn then MapItem.Name := MapItem.Name + '\(×°±¸ºó°ó¶¨)';
        3: if g_Config.boBindPickUp and g_Config.boBindTakeOn then MapItem.Name := MapItem.Name + '\(Ê°È¡»ò×°±¸°ó¶¨)';
      end;
    end;}

    //È¡×Ô¶¨ÒåÎïÆ·Ãû³Æ
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
    begin
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        MapItem.Name := sUserItemName;
    end;

    MapItem.Looks := StdItem.Looks;
    if StdItem.StdMode = 45 then
      MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
    MapItem.AniCount := StdItem.AniCount;
    MapItem.Reserved := 0;
    MapItem.Count := 1;
    MapItem.OfBaseObject := ItemOfCreat;
    MapItem.dwCanPickUpTick := GetTickCount();
    MapItem.DropBaseObject := DropCreat;
    GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
    pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
    if pr = MapItem then
    begin
      DropCreat.SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), dx, dy, MapItem.Name);
      if boDieDrop then
        logcap := '15'
      else
        logcap := '7';
      if not IsCheapStuff(StdItem.StdMode) then
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI(logcap + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + '0' + countstr);
      Result := True;
    end
    else
      Dispose(MapItem);
  end;
end;

procedure TBaseObject.GoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then
    SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
end;

procedure TBaseObject.GameGoldChanged();
begin
  if m_btRaceServer = RC_PLAYOBJECT then
    SendUpdateMsg(Self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
end;

function TPlayObject.ClientPickUpItem(nItemX, nItemY: Integer): Boolean;

  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    Result := False;
    if (BaseObject = nil) or (Self = BaseObject) then
    begin
      Result := True;
      Exit;
    end;
    if IsHero and (BaseObject = m_Master) then
      Result := True;
  end;

  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    i: Integer;
    GroupMember: TBaseObject;
  begin
    Result := False;
    if m_GroupOwner = nil then
      Exit;
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = BaseObject then
      begin
        Result := True;
        Break;
      end;
      if (BaseObject <> nil) and (GroupMember = BaseObject.m_Master) then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

var
  UserItem: pTUserItem;
  MapItem: pTMapItem;
  StdItem: pTStdItem;
  countstr: string;
begin
  Result := False;
  if m_boDealing or m_StallMgr.OnSale then
    Exit;
  countstr := '0';
  MapItem := m_PEnvir.GetItem(nItemX, nItemY);
  if MapItem = nil then
    Exit;
  if Integer(GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime then
    MapItem.OfBaseObject := nil;
  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then
  begin
    SysMsg(g_sCanotPickUpItem, c_Red, t_Hint);
    Exit;
  end;

  if MapItem.IsGold {CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0} then
  begin
    if m_PEnvir.DeleteFromMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
    begin
      if IncGold(MapItem.Count) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
          CheckMapEvent(2, MapItem.Name);
        if IsHero then
          TPlayObject(m_Master).SendMsg(TPlayObject(m_Master), RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '')
        else
          SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '');
        if g_boGameLogGold then
          AddGameDataLogAPI('4' + #9 + m_sMapName + #9 + IntToStr(nItemX) + #9 + IntToStr(nItemY) + #9 +
            m_sCharName + #9 + sSTRING_GOLDNAME + #9 + IntToStr(MapItem.Count) + #9 + '1' + #9 + '0');
        GoldChanged();
        Dispose(MapItem);
        Result := True;
      end
      else
        m_PEnvir.AddToMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem));
    end;
    Exit;
  end;

  StdItem := UserEngine.GetStdItem(MapItem.UserItem.wIndex);
  if StdItem <> nil then
  begin
    if (PCardinal(@MapItem.UserItem.btValue[22])^ > 0) and (PCardinal(@MapItem.UserItem.btValue[22])^ <> m_dwIdCRC) then
    begin
      if g_Config.boBindNoPickUp then
      begin
        SendDefMessage(SM_PICKUP_FAIL, -1, 0, 0, 0, '');
        Exit;
      end;
    end;


    if StdItem.Overlap >= 1 then
    begin
      countstr := '(' + IntToStr(MapItem.UserItem.Dura) + ')';
      if m_PEnvir.DeleteFromMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
      begin
        if UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, MapItem.UserItem.Dura, StdItem.Name, False) then
        begin
          if IsHero then
            TPlayObject(m_Master).SendMsg(TPlayObject(m_Master), RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '')
          else
            SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '');
          WeightChanged;

          if InLimitItemList('', MapItem.UserItem.wIndex, t_PickItem) then
          begin
            if g_FunctionNPC <> nil then
            begin
              m_CurItemName := StdItem.Name;
              m_CurItemIdx := MapItem.UserItem.wIndex;
              g_FunctionNPC.m_OprCount := 0;
              g_FunctionNPC.GotoLable(TPlayObject(Self), '@PickItem', False); //@PickItemµÄÊ±»ú ´¦ÀíOVERLAP=1
              m_CurItemName := '';
              m_CurItemIdx := 0;
            end;
          end;


          Dispose(MapItem);
          Exit;
        end
        else
        begin
          m_PEnvir.AddToMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
    end;
    if IsEnoughBag then
    begin
      if m_PEnvir.DeleteFromMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
      begin
        New(UserItem);
        UserItem^ := MapItem.UserItem;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex, UserItem.Dura)) then
        begin
          if m_btRaceServer = RC_PLAYOBJECT then
            CheckMapEvent(2, MapItem.Name);
          if IsHero then
            TPlayObject(m_Master).SendMsg(TPlayObject(m_Master), RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '')
          else
            SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), nItemX, nItemY, '');

          //Ê°È¡ºó°ó¶¨
          if g_Config.boBindPickUp and (PCardinal(@UserItem.btValue[22])^ = 0) then
          begin
            if StdItem.SvrSet.nBind and $1 <> 0 then
              PCardinal(@UserItem.btValue[22])^ := m_dwIdCRC;
          end;

          AddItemToBag(UserItem);


          if InLimitItemList('', MapItem.UserItem.wIndex, t_PickItem) then
          begin
            self.m_CurItemName := StdItem.Name;
            self.m_CurItemIdx := MapItem.UserItem.wIndex;
            if g_FunctionNPC <> nil then
            begin
              g_FunctionNPC.m_OprCount := 0;
              g_FunctionNPC.GotoLable(TPlayObject(Self), '@PickItem', False); //@PickItemµÄÊ±»ú ÐÂÔö±³°üÎïÆ·
            end;
          end;

          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('4' + #9 + m_sMapName + #9 + IntToStr(nItemX) + #9 + IntToStr(nItemY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + countstr);
          Dispose(MapItem);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            TPlayObject(Self).SendAddItem(UserItem);
          Result := True;
        end
        else
        begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(nItemX, nItemY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
    end;
  end;
end;

function TPlayObject.HeroPickUpItem(x, y: Integer; MapItem: pTMapItem): Boolean;
var
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  countstr: string;
begin
  Result := False;
  if m_boDealing then
    Exit;
  countstr := '';
  MapItem := m_PEnvir.GetMapItem(x, y, MapItem);
  if MapItem = nil then
    Exit;
  if MapItem.IsGold then
  begin
    if m_PEnvir.DeleteFromMap(x, y, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
    begin
      if IncGold(MapItem.Count) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
          CheckMapEvent(2, MapItem.Name);
        SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), x, y, '');
        if g_boGameLogGold then
          AddGameDataLogAPI('4' + #9 + m_sMapName + #9 + IntToStr(x) + #9 + IntToStr(y) + #9 + m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 + IntToStr(MapItem.Count) + #9 + '1' + #9 + '0');
        GoldChanged();
        Dispose(MapItem);
        Result := True;
      end
      else
        m_PEnvir.AddToMap(x, y, OS_ITEMOBJECT, TObject(MapItem));
    end;
    Exit;
  end;

  StdItem := UserEngine.GetStdItem(MapItem.UserItem.wIndex);
  if StdItem <> nil then
  begin
    if StdItem.Overlap >= 1 then
    begin
      countstr := '(' + IntToStr(MapItem.UserItem.Dura) + ')';
      if m_PEnvir.DeleteFromMap(x, y, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
      begin
        if UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, MapItem.UserItem.Dura, StdItem.Name, False) then
        begin
          if IsHero then
            TPlayObject(m_Master).SendMsg(TPlayObject(m_Master), RM_ITEMHIDE, 0, Integer(MapItem), x, y, '')
          else
            SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), x, y, '');
          WeightChanged;

          if InLimitItemList('', MapItem.UserItem.wIndex, t_PickItem) then
          begin
            if g_FunctionNPC <> nil then
            begin
              TPlayObject(m_Master).m_CurItemName := StdItem.Name;
              TPlayObject(m_Master).m_CurItemIdx := MapItem.UserItem.wIndex;
              g_FunctionNPC.m_OprCount := 0;
              g_FunctionNPC.GotoLable(TPlayObject(m_Master), '@H.PickItem', False); //´¥·¢@H.PickItemµÄÊ±»ú ´¦ÀíOVERLAP=1
              TPlayObject(m_Master).m_CurItemName := '';
              TPlayObject(m_Master).m_CurItemIdx := 0;
            end;
          end;

          Dispose(MapItem);
          Exit;
        end
        else
        begin
          m_PEnvir.AddToMap(x, y, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
    end;
    if IsEnoughBag then
    begin
      if m_PEnvir.DeleteFromMap(x, y, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
      begin
        New(UserItem);
        UserItem^ := MapItem.UserItem;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex, UserItem.Dura)) then
        begin
          if m_btRaceServer = RC_PLAYOBJECT then
            CheckMapEvent(2, MapItem.Name);
          if IsHero then
            TPlayObject(m_Master).SendMsg(TPlayObject(m_Master), RM_ITEMHIDE, 0, Integer(MapItem), x, y, '')
          else
            SendMsg(Self, RM_ITEMHIDE, 0, Integer(MapItem), x, y, '');
          AddItemToBag(UserItem);


          if InLimitItemList('', MapItem.UserItem.wIndex, t_PickItem) then
          begin
            TPlayObject(m_Master).m_CurItemName := StdItem.Name;
            TPlayObject(m_Master).m_CurItemIdx := MapItem.UserItem.wIndex;
            if g_FunctionNPC <> nil then
            begin
              g_FunctionNPC.m_OprCount := 0;
              g_FunctionNPC.GotoLable(TPlayObject(m_Master), '@H.PickItem', False); //´¥·¢@H.PickItemµÄÊ±»ú ´¦ÀíÐÂÔöÓ¢ÐÛ±³°ü
            end;
          end;          

          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('4' + #9 + m_sMapName + #9 + IntToStr(x) + #9 + IntToStr(y) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + '0' + countstr);
          Dispose(MapItem);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            TPlayObject(Self).SendAddItem(UserItem);
          Result := True;
        end
        else
        begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(x, y, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.RunSendImageFileCustom();
begin
  if not m_boSendImageFileCustom then
  begin
    SendImageFileListCustom(); //´«ËÍNOTICEÖ®ºó£¬½ô½Ó×Å·¢ËÍ×Ô¶¨Òå×ÊÔ´ÎÄ¼þÁÐ±í 2019/12/5
    m_boSendImageFileCustom := True;
  end;
end;

procedure TPlayObject.RunSendSafeZoneEffectCustom();
begin
  if not m_boSendSafeZoneEffectCustom then
  begin
    SendSafeZoneEffectCustom(); //´«ËÍNOTICEÖ®ºó£¬½ô½Ó×Å·¢ËÍ×Ô¶¨Òå°²È«Çø¹âÈ¦ÌØÐ§ 2019/12/5
    m_boSendSafeZoneEffectCustom := True;
  end;
end;

procedure TPLayObject.RunSendNpcCustom();
begin
  if not m_boSendNpcCustom then
  begin
    SendNpcCustom();
    m_boSendNpcCustom := True;
  end;
end;
procedure TPlayObject.RunNotice();
var
  Msg: TProcessMessage;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::RunNotice';
begin
  if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
  begin
    if m_boKickFlag then
      SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
    MakeGhost();
  end
  else
  begin
    try
      if not m_boSendNotice then
      begin
        SendNotice();
        m_boSendNotice := True;
        m_dwWaitLoginNoticeOKTick := GetTickCount();
      end
      else
      begin
        if GetTickCount - m_dwWaitLoginNoticeOKTick > 60 * 1000 then
          m_boEmergencyClose := True;
        while GetMessage(@Msg) do
        begin
          if Msg.wIdent = CM_LOGINNOTICEOK then
          begin
            m_boLoginNoticeOK := True;
{$IF VER_ClientType_45}
            //MainOutMessageAPI('m_wClientType: ' + IntToStr(Msg.wParam));
            m_wClientType := Msg.wParam;
            m_dwClientTick := Msg.nParam1;
{$IFEND VER_ClientType_45}
            if Msg.nParam3 = 28 then
              m_nClientVerNO := Msg.nParam3
            else
              m_nClientVerNO := Msg.nParam2;
            if m_btHair > 1 then
              m_btHair := 1;
{$IF VER_ClientType_45}
            //if g_Config.boOnlyHeroClientLogon then
            if not (m_wClientType in [45, 46]) then
            begin
              m_boEmergencyClose := True;
              Exit;
            end;
{$IFEND VER_ClientType_45}
            m_dwRunTick := 0;
            m_dwSearchTick := 0;
          end;
        end;
      end;
    except
      MainOutMessageAPI(sExceptionMsg);
    end;
  end;
end;

procedure TPlayObject.WinExp(dwExp: LongWord; bipexp: Boolean);
var
  i, nLevelInt: Integer;
begin
  dwExp := LongWord(g_Config.dwKillMonExpMultiple * dwExp);
  dwExp := LongWord(m_nKillMonExpMultiple * dwExp);
  dwExp := LongWord(Round((m_nKillMonExpRate / 100) * dwExp));
  if m_PEnvir.m_MapFlag.boEXPRATE then
    dwExp := LongWord(Round((m_PEnvir.m_MapFlag.nEXPRATE / 100) * dwExp));
  if m_boExpItem then
    dwExp := LongWord(Round(m_rExpItem * dwExp));
  if g_boLimitLevelExp then
    for i := Low(g_Config.LimitLevelExp) to High(g_Config.LimitLevelExp) do
    begin
      if g_Config.LimitLevelExp[i].nHumLevel <= 0 then
        Break;
      if m_Abil.Level = g_Config.LimitLevelExp[i].nHumLevel then
      begin
        dwExp := LongWord(Round((g_Config.LimitLevelExp[i].nEXPRATE / 100) * dwExp));
        Break;
      end;
    end;
  nLevelInt := m_Abil.Level - g_Config.nLimitLevel + 1;
  if g_Config.boHighLevelLimitExp and (nLevelInt > 0) then
    dwExp := LongWord(Round((_MAX(1, (g_Config.nKillMonExpDiv - nLevelInt)) / _MAX(1, g_Config.nKillMonExpDiv)) * dwExp));

  GetExp(dwExp, False, bipexp);

  if (m_PEnvir = nil) or
    //(m_PEnvir.m_MapFlag.PCollectExp = nil) or
  ((m_btCollectExpLv = 4) and (m_dwCollectExp >= m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv]) and (m_dwCollectIPExp >= m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv])) then
    Exit;
  if bipexp then
  begin
    if IPLevelInRange() then
    begin
      if (m_PEnvir <> nil) and ((m_PEnvir.m_MapFlag.PCollectExp.nCollectExp > 0) or (m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp > 0)) then
      begin
        if m_btCollectExpLv = 0 then
          m_btCollectExpLv := 1;
        CollectExp(0, Round(dwExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate));
      end;
    end;
  end
  else
  begin
    if (m_PEnvir <> nil) and ((m_PEnvir.m_MapFlag.PCollectExp.nCollectExp > 0) or (m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp > 0)) then
    begin
      if m_btCollectExpLv = 0 then
        m_btCollectExpLv := 1;
      CollectExp(Round(dwExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate), 0);
    end;
  end;
end;

procedure TPlayObject.GetExp(dwExp: LongWord; bGainExp: Boolean; bipexp: Boolean; bGatherExp: Boolean);
var
  HeroObject: TBaseObject;
  dwInt, dwHeroExp: LongWord;
begin
  dwHeroExp := 0;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    HeroObject := GetHeroObjectA;
    if (HeroObject <> nil) and not HeroObject.m_boDeath then
    begin
      if not HeroObject.m_boDeath and
        (((m_PEnvir <> nil) and (m_PEnvir = HeroObject.m_PEnvir) and (abs(m_nCurrX - HeroObject.m_nCurrX) <= 12) and (abs(m_nCurrX - HeroObject.m_nCurrX) <= 12))) then
      begin
        if bipexp then
        begin //hero internal power exp
          if HeroObject.IPLevelInRange() then
          begin
            Inc(HeroObject.m_dwInPowerExp, dwExp);
            if not m_boOffLineFlag then
              SendMsg(Self, RM_HEROWINIPEXP, 0, dwExp, 0, 0, '');
            if HeroObject.m_dwInPowerExp >= g_dwIPNeedInfo[HeroObject.m_nInPowerLevel].dwHExp then
            begin
              Dec(HeroObject.m_dwInPowerExp, g_dwIPNeedInfo[HeroObject.m_nInPowerLevel].dwHExp);
              if HeroObject.m_nInPowerLevel < MAX_IPLEVEL then
              begin
                Inc(HeroObject.m_nInPowerLevel);
                if g_FunctionNPC <> nil then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@HeroIPLevelUp', False);
                end;
              end;
              HeroHasLevelUp(True);
              HeroObject.IncHealthSpell(High(Word), High(Word));
              HeroObject.m_nInPowerPoint := g_dwIPNeedInfo[HeroObject.m_nInPowerLevel].nPower;
              TPlayObject(HeroObject).InternalPowerPointChanged(True);
            end;
          end;
        end
        else
        begin //hero exp
          if bGainExp then
          begin //
            dwHeroExp := Round(dwExp * (g_Config.nHeroGetExpRate / 100));
            //dwExp := dwExp - dwHeroExp;
          end
          else
          begin
            if g_Config.boGetFullRateExp then
            begin
              dwHeroExp := dwExp;
            end
            else
            begin
              dwHeroExp := Round(dwExp * (g_Config.nHeroGainExpRate / 100)); //dwExp div g_Config.nHeroGainExpRate;
              if dwExp >= dwHeroExp then
                dwExp := dwExp - dwHeroExp
              else
                dwExp := dwHeroExp - dwExp;
            end;
          end;
          Inc(HeroObject.m_Abil.Exp, dwHeroExp);
          if not m_boOffLineFlag then
            SendMsg(Self, RM_HEROWINEXP, 0, dwHeroExp, 0, 0, '');
          if HeroObject.m_Abil.Exp >= HeroObject.m_Abil.MaxExp then
          begin
            Dec(HeroObject.m_Abil.Exp, HeroObject.m_Abil.MaxExp);
            if HeroObject.m_Abil.Level < MAXUPLEVEL then
            begin
              Inc(HeroObject.m_Abil.Level);
              HeroObject.LevelUPFunc();
            end;
            HeroHasLevelUp();
            HeroObject.AddBodyLuck(100);
            HeroObject.IncHealthSpell(High(Word), High(Word));
          end;
          HeroObject.AddBodyLuck(dwHeroExp * 0.00001);
        end;
      end;
    end;

    if bipexp then
    begin
      if IPLevelInRange() then
      begin
        Inc(m_dwInPowerExp, dwExp);
        if not m_boOffLineFlag then
          SendMsg(Self, RM_WINIPEXP, 0, dwExp, 0, 0, '');
        if m_dwInPowerExp >= g_dwIPNeedInfo[m_nInPowerLevel].dwPExp then
        begin
          Dec(m_dwInPowerExp, g_dwIPNeedInfo[m_nInPowerLevel].dwPExp);
          if m_nInPowerLevel < MAX_IPLEVEL then
          begin
            Inc(m_nInPowerLevel);
            if g_FunctionNPC <> nil then
            begin
              g_FunctionNPC.m_OprCount := 0;
              g_FunctionNPC.GotoLable(Self, '@IPLevelUp', False);
            end;
          end;
          HasLevelUp(True);
          IncHealthSpell(High(Word), High(Word));
          m_nInPowerPoint := g_dwIPNeedInfo[m_nInPowerLevel].nPower;
          TPlayObject(Self).InternalPowerPointChanged(True);

        end;
      end;
    end
    else
    begin
      Inc(m_Abil.Exp, dwExp);
      if not m_boOffLineFlag then
        SendMsg(Self, RM_WINEXP, 0, dwExp, 0, 0, '');
      if m_Abil.Exp >= m_Abil.MaxExp then
      begin
        Dec(m_Abil.Exp, m_Abil.MaxExp);
        if m_Abil.Level < MAXUPLEVEL then
        begin
          Inc(m_Abil.Level);
          LevelUPFunc();
        end;
        HasLevelUp();
        AddBodyLuck(100);
        IncHealthSpell(High(Word), High(Word));
      end;
      AddBodyLuck(dwExp * 0.002);
    end;

    //

    if bGatherExp then
    begin
      if bipexp then
      begin
        if m_dwGatherIPExp + Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100) > High(LongWord) then
          dwInt := High(LongWord) - m_dwGatherIPExp
        else
          dwInt := Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100);
        Inc(m_dwGatherIPExp, dwInt);
        if HeroObject <> nil then
        begin
          if TPlayObject(HeroObject).m_dwGatherIPExp + Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100) > High(LongWord) then
            dwInt := High(LongWord) - TPlayObject(HeroObject).m_dwGatherIPExp
          else
            dwInt := Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100);
          Inc(TPlayObject(HeroObject).m_dwGatherIPExp, dwInt);
        end;
      end
      else
      begin
        if m_dwGatherExp + Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100) > High(LongWord) then
          dwInt := High(LongWord) - m_dwGatherExp
        else
          dwInt := Round(LongWord(dwExp * g_Config.nGatherExpRate) / 100);
        Inc(m_dwGatherExp, dwInt);
        if dwHeroExp > 0 then
        begin
          if TPlayObject(HeroObject).m_dwGatherExp + Round(LongWord(dwHeroExp * g_Config.nGatherExpRate) / 100) > High(LongWord) then
            dwInt := High(LongWord) - TPlayObject(HeroObject).m_dwGatherExp
          else
            dwInt := Round(LongWord(dwHeroExp * g_Config.nGatherExpRate) / 100);
          Inc(TPlayObject(HeroObject).m_dwGatherExp, dwInt);
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.HeroGetExp(dwExp: LongWord);
begin
  if not IsHero then
    Exit;
  Inc(m_Abil.Exp, dwExp);
  m_Master.SendMsg(m_Master, RM_HEROWINEXP, 0, dwExp, 0, 0, '');
  if m_Abil.Exp >= m_Abil.MaxExp then
  begin
    Dec(m_Abil.Exp, m_Abil.MaxExp);
    if m_Abil.Level < MAXUPLEVEL then
    begin
      Inc(m_Abil.Level);
      LevelUPFunc();
    end;
    HasLevelUp();
    AddBodyLuck(100);
    IncHealthSpell(High(Word), High(Word));
  end;
  AddBodyLuck(dwExp * 0.00001);
end;

procedure TPlayObject.HeroGetIPExp(dwExp: LongWord);
begin
  if not IsHero then
    Exit;
  if IPLevelInRange() then
  begin
    Inc(m_dwInPowerExp, dwExp);
    m_Master.SendMsg(m_Master, RM_HEROWINIPEXP, 0, dwExp, 0, 0, '');
    if m_dwInPowerExp >= g_dwIPNeedInfo[m_nInPowerLevel].dwHExp then
    begin
      Dec(m_dwInPowerExp, g_dwIPNeedInfo[m_nInPowerLevel].dwHExp);
      if m_nInPowerLevel < MAX_IPLEVEL then
        Inc(m_nInPowerLevel);
      HasLevelUp();
      IncHealthSpell(High(Word), High(Word));
    end;
  end;
end;

procedure TBaseObject.RecalcLevelAbilitys();
var
  nLevel, r, n: Integer;
begin
  nLevel := m_Abil.Level;
  case m_btJob of
    2:
      begin
        m_Abil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 14 + Round(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));
        m_Abil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 13 + Round(((nLevel / g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)));
        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 4) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 50) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 42) * nLevel));
        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX1(n - 1, 0), _MAX1(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX1(n - 1, 0), _MAX1(1, n));
        m_Abil.AC := 0;
        n := Round(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
      end;
    1:
      begin
        m_Abil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 14 + Round(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)));
        m_Abil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 13 + Round((nLevel / 5 + 2) * 2.2 * nLevel));
        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 5) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 100) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 90) * nLevel));
        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX1(n - 1, 0), _MAX1(1, n));
        m_Abil.MC := MakeLong(_MAX1(n - 1, 0), _MAX1(1, n));
        m_Abil.SC := 0;
        m_Abil.AC := 0;
        m_Abil.MAC := 0;
      end;
    0:
      begin
        m_Abil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 14 + Round(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));
        m_Abil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, 11 + Round(nLevel * 3.5));
        m_Abil.MaxWeight := _MIN(High(Word), 50 + Round((nLevel / 3) * nLevel));
        m_Abil.MaxWearWeight := _MIN(High(Word), 15 + Round((nLevel / 20) * nLevel));
        m_Abil.MaxHandWeight := _MIN(High(Word), 12 + Round((nLevel / 13) * nLevel));
        m_Abil.DC := MakeLong(_MAX1((nLevel div 5) - 1, 1), _MAX1(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;
  end;

  if IsHero or ((m_btRaceServer = RC_HERO) and (m_dwCloneDispearTick > 0)) then
  begin
    r := g_Config.nHeroMaxHealthRate;
    case m_btJob of
      0: r := g_Config.nHeroMaxHealthRate;
      1: r := g_Config.nHeroMaxHealthRate1;
      2: r := g_Config.nHeroMaxHealthRate2;
    end;
    if g_Config.boHeroMaxHealthType then
    begin
      m_Abil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round(UInt64(m_Abil.MaxHP) / 100 * r));
      m_Abil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round(UInt64(m_Abil.MaxMP) / 100 * r));
    end
    else
    begin
      m_Abil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((UInt64(m_Abil.MaxHP) * 2 + 5) * r / 100));
      m_Abil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((UInt64(m_Abil.MaxMP) * 2 + 5) * r / 100));
    end;
  end;
  if m_Abil.HP > m_Abil.MaxHP then
    m_Abil.HP := m_Abil.MaxHP;
  if m_Abil.MP > m_Abil.MaxMP then
    m_Abil.MP := m_Abil.MaxMP;
end;

procedure TBaseObject.HeroHasLevelUp(biplvl: Boolean);
var
  HeroObject: TBaseObject;
begin
  HeroObject := TPlayObject(Self).GetHeroObjectA;
  if HeroObject <> nil then
  begin
    if not biplvl then
    begin
      HeroObject.m_Abil.MaxExp := HeroObject.GetLevelExp(HeroObject.m_Abil.Level);
      HeroObject.RecalcLevelAbilitys();
      HeroObject.RecalcAbilitys();
    end;
    SendMsg(Self, RM_HEROLEVELUP, 0, HeroObject.m_Abil.Exp, 0, 0, '');
    HeroObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 14, 0, 0, '');
  end;
end;

procedure TBaseObject.HasLevelUp(biplvl: Boolean);
begin
  if IsHero then
    m_Master.HeroHasLevelUp(biplvl)
  else
  begin
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
    RecalcLevelAbilitys();
    RecalcAbilitys();
    
  
    if  m_WAbil.HP > m_WAbil.MaxHP then
       m_WAbil.HP := m_WAbil.MaxHP;
    if  m_WAbil.MP > m_WAbil.MaxMP then
       m_WAbil.MP := m_WAbil.MaxMP;

    SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
    SendRefMsg(RM_STRUCKEFFECTEX, 0, 14, 0, 0, '');
  end;
end;

function TPlayObject.IncGold(tGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold + tGold <= g_Config.nHumanMaxGold then
  begin
    Inc(m_nGold, tGold);
    Result := True;
  end;
end;

function TBaseObject.WalkTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  dwTick: LongWord;
  nC, nOX, nOY, nNX, nNY, n20, n24: Integer;
  boTagOK: Boolean;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::WalkTo Code:%d';
begin
  Result := False;
  if not (btDir in [0..7]) then
    Exit;
  nC := 0;
  if m_boHolySeize or (m_PEnvir = nil) then
    Exit;
  try
    nOX := m_nCurrX;
    nOY := m_nCurrY;
    m_btDirection := btDir;
    nNX := 0;
    nNY := 0;
    case btDir of
      DR_UP:
        begin
          nNX := m_nCurrX;
          nNY := m_nCurrY - 1;
        end;
      DR_UPRIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY - 1;
        end;
      DR_RIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY;
        end;
      DR_DOWNRIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY + 1;
        end;
      DR_DOWN:
        begin
          nNX := m_nCurrX;
          nNY := m_nCurrY + 1;
        end;
      DR_DOWNLEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY + 1;
        end;
      DR_LEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY;
        end;
      DR_UPLEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY - 1;
        end;
    end;
    nC := 1;
    if (nNX >= 0) and ((m_PEnvir.m_MapHeader.wWidth - 1) >= nNX) and (nNY >= 0) and ((m_PEnvir.m_MapHeader.wHeight - 1) >= nNY) then
    begin
      boTagOK := True;
      nC := 2;
      if m_boSafeWalk and not m_PEnvir.CanSafeWalk(nNX, nNY) then
        boTagOK := False;
      nC := 3;
      if m_Master <> nil then
      begin
        m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX, m_Master.m_nCurrY, m_Master.m_btDirection, 1, n20, n24);
        if (nNX = n20) and (nNY = n24) then
          boTagOK := False;
      end;
      nC := 4;
      if boTagOK {and m_PEnvir.CanWalk(nNX, nNY, False)} then
      begin
        //if m_btRaceServer = RC_MISSION then boFlag := True;
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nNX, nNY, boFlag) > 0 then
        begin
          m_nCurrX := nNX;
          m_nCurrY := nNY;
        end;
      end;
    end;
    nC := 5;
    if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then
    begin
      nC := 6;
      if Walk(RM_WALK) then
      begin
        nC := 7;
        if m_boTransparent and m_boHideMode then
          m_wStatusTimeArr[STATE_TRANSPARENT] := 1;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          TPlayObject(Self).CheckMapEvent(4, '');
          TPlayObject(Self).ReportEscortPos();
        end;
        if (m_btRaceServer = RC_HERO) or ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) then
        begin
          dwTick := GetTickCount;
          if (IsHero or ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay)) and (TPlayObject(Self).m_btReadySeriesSkill = 2) then
            m_dwHitTick := dwTick
          else if g_Config.boHeroHitCmp then
          begin
            n24 := (dwTick - m_dwHitTick - m_nNextHitTime);
            if (n24 <= 0) then
            begin
              case m_btJob of //m_nNextHitTime
                0: m_dwHitTick := dwTick + n24 + g_Config.nWarrCmpInvTime + 40;
                1: m_dwHitTick := dwTick + n24 + g_Config.nWizaCmpInvTime + 40;
                2: m_dwHitTick := dwTick + n24 + g_Config.nTaosCmpInvTime + 40;
              end;
            end;
          end;

        end;
        if (m_btRaceServer = RC_PLAYOBJECT) and not TPlayObject(Self).m_boOffLinePlay then
          TPlayObject(Self).UpdateViewRange();
        Result := True;
      end
      else
      begin
        nC := 8;
        if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) = 1 then
        begin //0628  Î¨Ò»ÐÔ
          m_nCurrX := nOX;
          m_nCurrY := nOY;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [nC]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;
end;

function TAnimalObject.RuntoTargetXY(btDir: Byte; boFlag: Boolean): Boolean;
var
  dwTick: DWORD;
  n24, nOldX, nOldY: Integer;
  boInSafeZone: Boolean;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::RuntoTargetXY';
begin
  Result := False;
  if not (btDir in [0..7]) then
    Exit;
  if (m_nCurrX = m_nTargetX) and (m_nCurrY = m_nTargetY) then
  begin
    //if m_boLockLongAttack then
    //  m_boLockLongAttack := False;
    Exit;
  end;

  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY - 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY - 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, False) > 0) then
          begin
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY - 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY - 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, False) > 0) then
          begin
            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, False) > 0) then
          begin
            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY + 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY + 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, False) > 0) then
          begin
            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY + 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY + 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, False) > 0) then
          begin
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY + 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY + 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, False) > 0) then
          begin
            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 1) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, False) > 0) then
          begin
            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY - 1, False {, Self}) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY - 2, False {, Self}) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, False) > 0) then
          begin
            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if (m_nCurrX <> nOldX) or (m_nCurrY <> nOldY) then
    begin
      if Walk(RM_RUN) then
      begin
        if m_boTransparent and m_boHideMode then
          m_wStatusTimeArr[STATE_TRANSPARENT] := 1;

        if g_Config.boHeroHitCmp and ((m_btRaceServer = RC_HERO) or ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay)) then
        begin
          dwTick := GetTickCount;
          n24 := (dwTick - m_dwHitTick - m_nNextHitTime);
          if n24 <= 0 then
          begin
            case m_btJob of //m_nNextHitTime
              0: m_dwHitTick := dwTick + n24 + g_Config.nWarrCmpInvTime;
              1: m_dwHitTick := dwTick + n24 + g_Config.nWizaCmpInvTime;
              2: m_dwHitTick := dwTick + n24 + g_Config.nTaosCmpInvTime;
            end;
          end;
        end;

        Result := True;
        if g_Config.boHeroRecalcWalkTick and (m_TargetCret <> nil) and m_TargetCret.IsHero and IsProperTarget(m_TargetCret) then
          //m_TargetCret.m_dwWalkTick := 0;
          m_TargetCret.m_dwWalkTick := GetTickCount - m_nWalkSpeed div 2;
      end
      else
      begin
        //½â¾ö·½·¨ 1
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nOldX, nOldY, True {Move Back}) > 0 then
        begin
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
        end
        else
        begin
          MainOutMessageAPI('[Error] TAnimalObject.RuntoTargetXY MovingOBject :' + m_PEnvir.m_sMapFileName + ':' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
        end;

      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

function GetLevelBagSize(Level: Integer): Integer;
begin
  case Level of
    00..10: Result := 10;
    11..20: Result := 20;
    21..30: Result := 30;
    31..40: Result := 35;
    41..50: Result := 40;
  else
    Result := 40;
  end;
end;

function TBaseObject.GetMaxBagItem: Integer;
begin
  Result := MAXBAGITEM;
  if IsHero then
    Result := GetLevelBagSize(m_Abil.Level);
end;

function TPlayObject.IsEnoughBag: Boolean;
var
  pUserItem: pTUserItem;
  I: Integer;
begin
  // Result := False;
  // if m_ItemList.Count < GetMaxBagItem then
  Result := m_ItemList.Count < GetMaxBagItem;
end;

function TPlayObject.IsAddWeightAvailable(nWeight: Integer): Boolean; //004C4A78
begin
  Result := False;
  if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
    Result := True;
end;

procedure TPlayObject.SendAddItem(UserItem: pTUserItem; nHint: Integer);
var
  pStdItem: pTStdItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
begin
{$IF VER_ClientType_45}
  if (m_wClientType = 46) then
  begin
{$IFEND VER_ClientType_45}
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then
      Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.s.Name := sUserItemName;
    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;

    ClientItem.s.ItemType := UserItem.btValue[14];
    GetSendClientItem(UserItem, Self, ClientItem);

    if IsHero then
    begin
      TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROADDITEM, Integer(m_Master), 0, 0, nHint);
      TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end
    else if (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, nHint);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
{$IF VER_ClientType_45}
  end
  else if (m_wClientType = 45) or ((m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0)) then
  begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then
      Exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      OClientItem.s.Name := sUserItemName;
    OClientItem.MakeIndex := UserItem.MakeIndex;
    OClientItem.Dura := UserItem.Dura;
    OClientItem.DuraMax := UserItem.DuraMax;

    if IsHero then
    begin
      TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROADDITEM, Integer(m_Master), nHint, 0, nHint);
      TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end
    else if (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, nHint);
      SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end;
  end;
{$IFEND VER_ClientType_45}
end;

function TPlayObject.IsGroupMember(Target: TBaseObject): Boolean; //004C3908
var
  i: Integer;
begin
  Result := False;
  if m_GroupOwner = nil then
    Exit;
  for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
  begin
    if m_GroupOwner.m_GroupMembers.Objects[i] = Target then
    begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TPlayObject.Whisper(whostr, SayStr: string);
var
  PlayObject: TPlayObject;
  svidx: Integer;
resourcestring
  sNowCanNotSendMsg = 'ÄãÕý´¦ÓÚ±£»¤Ä£Ê½£¬ÎÞ·¨·¢ËÍÐÅÏ¢£¬Èç¹ûÄãÏë½øÈë·Ç±£»¤Ä£Ê½£¬ÇëÊäÈëÖ¸Áî:@%s';
  sOffLineWhisper = 'ÄúºÃÎÒÕýÔÚ¹Ò»úÅÝµãÖÐ£¬ÇëÉÔºòÔÙÁªÏµ£¡';
begin
  PlayObject := UserEngine.GetPlayObject(whostr);
  if PlayObject <> nil then
  begin
    if not PlayObject.m_boReadyRun then
    begin
      SysMsg(whostr + g_sCanotSendmsg, c_Red, t_Hint);
      Exit;
    end;
    if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName) then
    begin
      SysMsg(whostr + g_sUserDenyWhisperMsg, c_Red, t_Hint);
      Exit;
    end;
    if not m_boOffLineFlag and PlayObject.m_boOffLineFlag then
    begin
      //if g_Config.nForceOffLineMsg >= 8 then begin
      //  PlayObject.Whisper(m_sCharName, g_Config.sServerName + '[' + g_Config.sServerIPaddr + ']ÌáÊ¾Äú£¬' + GetResourceString(t_sAdvertisement));
      //  Exit;
      //end;
      if PlayObject.m_sOffLineLeaveword <> '' then
        PlayObject.Whisper(m_sCharName, PlayObject.m_sOffLineLeaveword);
      //else
        //PlayObject.Whisper(m_sCharName, sOffLineWhisper);
      //  PlayObject.Whisper(m_sCharName, sOffLineWhisper {g_Config.sServerName + '[' + g_Config.sServerIPaddr + ']ÌáÊ¾Äú£¬' +  GetResourceString(t_sAdvertisement)});
      Exit;
    end;
    //if m_boLockLogon then begin
    //  SysMsg(format(sNowCanNotSendMsg, [g_GameCommand.UNLOCKLOGON.sCmd]), c_Red, t_Hint);
    //  exit;
    //end;
    if m_btPermission > 0 then
    begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, Format('%s [%d¼¶]=>%s', [m_sCharName, m_Abil.Level, SayStr]));
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + SayStr);
      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + SayStr);
    end
    else
    begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, Format('%s [%d¼¶]=>%s', [m_sCharName, m_Abil.Level, SayStr]));
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + SayStr);
      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0, g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + SayStr);
    end;
  end
  else
  begin
    if UserEngine.FindOtherServerUser(whostr, svidx) then
      UserEngine.SendInterMsg(ISM_WHISPER, svidx, whostr + '/' + m_sCharName + '=> ' + SayStr)
    else
      SysMsg(whostr + g_sUserNotOnLine {'  Ã»ÓÐÔÚÏß'}, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.WhisperRe(SayStr: string; MsgType: Byte);
var
  sendwho: string;
begin
  GetValidStr3(SayStr, sendwho, ['[', ' ', '=', '>']);
  if m_boHearWhisper and (not IsBlockWhisper(sendwho)) then
  begin
    case MsgType of
      0: SendMsg(Self, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, SayStr);
      1: SendMsg(Self, RM_WHISPER, 0, g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, SayStr);
      2: SendMsg(Self, RM_WHISPER, 0, g_Config.btPurpleMsgFColor, g_Config.btPurpleMsgBColor, 0, SayStr);
    end;
  end;
end;

function TPlayObject.IsBlockWhisper(sName: string): Boolean;
var
  i: Integer;
begin
  //Result := m_BlockWhisperList.IndexOf(sName) > -1;
  Result := False;
  for i := 0 to m_BlockWhisperList.Count - 1 do
  begin
    if CompareText(sName, m_BlockWhisperList.Strings[i]) = 0 then
    begin
      Result := True;
      Break;
    end;
  end;
end;

function TBaseObject.PKLevel(): Integer;
begin
  Result := m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged;
var
  CharDesc: TCharDesc;
begin
  if m_WAbil.HP > 0 then
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
    if IsHero then
    begin
      //m_Master.SendUpdateMsg(m_Master, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
{$IF HIGHHP}
      TPlayObject(Self).m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
        Integer(Self),
        m_WAbil.HP,
        m_WAbil.MP,
        m_WAbil.MaxHP);
      if (m_PEnvir.m_MapFlag.nSecret > 0) then
      begin
        CharDesc.FeatureLen := Round(m_WAbil.HP / m_WAbil.MaxHP * 100);
        CharDesc.Status := m_WAbil.MP;
        CharDesc.StatusEx := 100;
      end
      else
      begin
        CharDesc.FeatureLen := m_WAbil.HP;
        CharDesc.Status := m_WAbil.MP;
        CharDesc.StatusEx := m_WAbil.MaxHP;
      end;
      TPlayObject(m_Master).SendSocket(@TPlayObject(Self).m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
{$ELSE}
      TPlayObject(Self).m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
        Integer(Self),
        m_WAbil.HP,
        m_WAbil.MP,
        m_WAbil.MaxHP);
      TPlayObject(m_Master).SendSocket(@TPlayObject(Self).m_DefMsg, '');
{$IFEND}
    end;
    if m_boShowHP {or IsHero} then
      SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.InternalPowerPointChanged(ref: Boolean);
begin
  if m_nInPowerLevel > 0 then
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
      SendUpdateMsg(Self, RM_INTERNALPOWER, 0, 0, 0, 0, '')
    else if IsHero then
    begin
      TPlayObject(Self).m_DefMsg := MakeDefaultMsg(SM_INTERNALPOWER,
        Integer(Self), m_nInPowerPoint, 0, 0);
      TPlayObject(m_Master).SendSocket(@TPlayObject(Self).m_DefMsg, '');
    end;
    if ref then
      SendRefMsg(RM_INTERNALPOWER, 0, 0, 0, 0, '');
  end;
end;

function TBaseObject.CalcGetExp(nLevel: Integer; nExp: LongWord): Integer;
begin
  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then
    Result := nExp
  else
    Result := nExp - Round((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
  if Result <= 0 then
    Result := 1;
end;

procedure TBaseObject.RefNameColor();
begin
  SendRefMsg(RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
end;

procedure TBaseObject.GainSlaveExp(nLevel: Integer);

  function GetUpKillCount(): Integer;
  var
    tCount: Integer;
  begin
    if m_btSlaveExpLevel < 15 then
      tCount := g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel]
    else
      tCount := 0;
    Result := ((m_Abil.Level * g_Config.nMonUpLvRate) - m_Abil.Level) + g_Config.nMonUpLvNeedKillBase + tCount;
  end;

begin
  if IsHero then
    Exit;
  Inc(m_nKillMonCount, nLevel);
  if GetUpKillCount() < m_nKillMonCount then
  begin
    Dec(m_nKillMonCount, GetUpKillCount);
    if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then
    begin
      Inc(m_btSlaveExpLevel);
      if m_btRaceServer = RC_HERO then
        RecalcLevelAbilitys();
      RecalcAbilitys();
      RefNameColor();
    end;
  end;
end;

function TBaseObject.DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat: TBaseObject): Boolean; //004C5794
var
  MapItem, MapItemA: pTMapItem;
  nX, nY: Integer;
  s20: string;
  CSObject: TBaseObject;
begin
  Result := False;
  New(MapItem);
  FillChar(MapItem^, SizeOf(TMapItem), #0);
  MapItem.boHeroPickup := g_boHeroPickupGold;
  MapItem.IsGold := True;
  MapItem.Name := sSTRING_GOLDNAME;
  MapItem.Count := nGold;
  MapItem.Looks := GetGoldShape(nGold);
  MapItem.OfBaseObject := GoldOfCreat;
  MapItem.dwCanPickUpTick := GetTickCount();
  MapItem.DropBaseObject := DropGoldCreat;

  if (GoldOfCreat <> nil) and (m_btRaceServer = RC_MISSION) then
  begin
    CSObject := GetMainPlayer(GoldOfCreat);
    CSObject.GetDropPosition(CSObject.m_nCurrX, CSObject.m_nCurrY, 2, nX, nY);
  end
  else
    GetDropPosition(m_nCurrX, m_nCurrY, 3, nX, nY);

  MapItemA := m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));

  if MapItemA <> nil then
  begin
    Result := True;

    if MapItemA <> MapItem then
    begin
      Dispose(MapItem);
      MapItem := MapItemA;
    end;

    SendRefMsg(RM_ITEMSHOW, MapItem.Looks, Integer(MapItem), nX, nY, MapItem.Name);

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if boFalg then
        s20 := '15'
      else
      begin
        s20 := '7';
        if m_btRaceServer = RC_PLAYOBJECT then
          TPlayObject(Self).m_dwLatestDropTime := GetTickCount;
      end;
      if g_boGameLogGold then
        AddGameDataLogAPI(s20 + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nGold) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
    end;
  end
  else
    Dispose(MapItem);
end;

function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer; //hashed
begin
  Result := 0;
  m_boGuildWarArea := False;
  if (cert1.m_MyGuild = nil) or (cert2.m_MyGuild = nil) then
    Exit;
  if TGuild(cert1.m_MyGuild).m_GuildWarList.Count <= 0 then
    Exit;
  if cert1.InSafeArea or (cert2.InSafeArea) then
    Exit;
  m_boGuildWarArea := True;

  if cert1.m_MyGuild = cert2.m_MyGuild then
    Result := 1
  else if TGuild(cert1.m_MyGuild).IsWarGuild(TGuild(cert2.m_MyGuild)) and TGuild(cert2.m_MyGuild).IsWarGuild(TGuild(cert1.m_MyGuild)) then
    Result := 2
  else if TGuild(cert1.m_MyGuild).IsAllyGuild(TGuild(cert2.m_MyGuild)) and TGuild(cert2.m_MyGuild).IsAllyGuild(TGuild(cert1.m_MyGuild)) then
    Result := 3;
end;

procedure TBaseObject.IncPkPoint(nPoint: Integer);
var
  nOldPKLevel: Integer;
begin
  nOldPKLevel := PKLevel;
  Inc(m_nPkPoint, nPoint);
  if PKLevel <> nOldPKLevel then
  begin
    if PKLevel <= 2 then
      RefNameColor;
  end;
end;

procedure TBaseObject.AddBodyLuck(dLuck: Double);
var
  n: Integer;
  UserMagic: pTUserMagic;
resourcestring
  sMsg = 'ÖÒ³Ï¶ÈÉý»ª,Ó¢ÐÛÁì»áÁË4¼¶';
begin
  if ((dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT)) or ((dLuck < 0) and (m_dBodyLuck > -dLuck {-(5 * BODYLUCKUNIT)})) then
    m_dBodyLuck := m_dBodyLuck + dLuck;

  if m_dBodyLuck > 5 * BODYLUCKUNIT then
    m_dBodyLuck := 5 * BODYLUCKUNIT
  else if m_dBodyLuck < 0 {-10 * BODYLUCKUNIT} then
    m_dBodyLuck := 0; //-10 * BODYLUCKUNIT;

  if abs(m_dBodyLuck - m_dHeroLoyalty) > 10 then
  begin //0.01%
    m_dHeroLoyalty := m_dBodyLuck;
    if IsHero then
      TPlayObject(m_Master).SendHeroLoyalty();
  end;

  n := Trunc(m_dBodyLuck / BODYLUCKUNIT);
  if n > 5 then
    n := 5
  else if n < 0 {-10} then
    n := 0; //-10;
  m_nBodyLuckLevel := n;

  if m_dBodyLuck >= 5 * BODYLUCKUNIT then
  begin
    if IsHero then
    begin
      case m_btJob of
        0: UserMagic := m_MagicArr[0][26];
        1: UserMagic := m_MagicArr[0][45];
        2: UserMagic := m_MagicArr[0][13];
      else
        UserMagic := nil;
      end;
      if (UserMagic <> nil) and (UserMagic.btLevel < 4) then
      begin
        UserMagic.btLevel := 4;
        SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, 0, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
        SysMsg(sMsg + UserMagic.MagicInfo.sMagicName, c_Green, t_Hint);
      end;
    end;
  end;
end;

procedure TBaseObject.MakeWeaponUnlock;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    Exit;

  if m_UseItems[U_WEAPON].btValue[3] > 0 then
  begin
    Dec(m_UseItems[U_WEAPON].btValue[3]);
    SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
  end
  else
  begin
    if m_UseItems[U_WEAPON].btValue[4] < 10 then
    begin
      Inc(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
    end;
  end;
  if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
  begin
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.DamageHealth(nDamage: Integer; bcalc: Boolean);
var
  nMadam, nSpdam: Integer;
  CSObject: TBaseObject;
resourcestring
  sUnionShield = 'ÄãµÄ»¤ÌåÉñ¶Ü±»»÷ÆÆÁË';
begin
  if m_nMaxDamageHealth > 0 then
  begin
    if nDamage > m_nMaxDamageHealth then
      nDamage := m_nMaxDamageHealth;
  end;

  if bcalc and (nDamage > 0) then
  begin
    if (m_nMagShieldHP > 0) then
    begin
      nMadam := Round(nDamage * 0.68);
      if (m_nMagShieldHP - nMadam) > 0 then
      begin
        m_nMagShieldHP := m_nMagShieldHP - nMadam;
        if g_Config.boShowShieldEffect and (nMadam > 20) then
          SendRefMsg(RM_STRUCKEFFECTEX, 0, 11, 0, 0, '');
      end
      else
      begin
        m_nMagShieldHP := 0;
        m_dwUnionHitShieldTick := GetTickCount;
        SendRefMsg(RM_STRUCKEFFECTEX, 0, 13, 0, 0, '');
        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
          SysMsg(sUnionShield, c_Red, t_Hint);
      end;
      nDamage := Round(nDamage * 0.92 - ((m_btMagShieldLevel + 2) / 6 + (m_Abil.Level / 10)));
      if nDamage <= 0 then
        nDamage := 1;
    end;
  end;

  if ((m_LastHiter = nil) or not m_LastHiter.m_boUnMagicShield) and (nDamage > 0) and (m_WAbil.MP > 0) then
  begin
    if not m_boDoubleStruck3 and (m_MagicArr[0][118] <> nil) and (m_wStatusTimeArrEx[STATE_14] = 0) and (nDamage >= Round(m_WAbil.MaxHP / 10)) then
    begin
      m_boDoubleStruck3 := True;
    end;

    if not m_boStrike and (m_btRaceServer = RC_HERO) then
      m_boStrike := True;

    if m_boMagicShield then
    begin
      nSpdam := Round(nDamage * 1.5);
      if Integer(m_WAbil.MP) >= nSpdam then
      begin
        m_WAbil.MP := m_WAbil.MP - nSpdam;
        // nSpdam := 0;
        nDamage := 0;
      end
      else
      begin
        nSpdam := nSpdam - m_WAbil.MP;
        m_WAbil.MP := 0;
        nDamage := Round(nSpdam / 1.5);
      end;
      //nDamage := Round(nSpdam / 1.5);
      HealthSpellChanged();
    end
    else if m_boMagicShield2 then
    begin
      nSpdam := Round(nDamage * 0.7);
      if Integer(m_WAbil.MP) >= nSpdam then
      begin
        m_WAbil.MP := m_WAbil.MP - nSpdam;
        // nSpdam := 0;
      end
      else
      begin
        // nSpdam := nSpdam - m_WAbil.MP;
        m_WAbil.MP := 0;
      end;
      //nDamage := Round(nSpdam / 0.75);

      nSpdam := Round(nDamage * 0.6);
      if Integer(m_WAbil.HP) > nSpdam then
      begin
        m_WAbil.HP := m_WAbil.HP - nSpdam;
      end
      else
      begin
        m_WAbil.HP := 0;
      end;
      nDamage := 0;

      HealthSpellChanged();
    end;
  end;

  if nDamage = 0 then
    Exit;

  if nDamage > 0 then
  begin
    if not m_boDoubleStruck3 and (m_MagicArr[0][118] <> nil) and (m_wStatusTimeArrEx[STATE_14] = 0) and (nDamage >= Round(m_WAbil.MaxHP / 10)) then
    begin
      m_boDoubleStruck3 := True;
    end;

    if m_WAbil.HP > nDamage then
      m_WAbil.HP := m_WAbil.HP - nDamage
    else
      m_WAbil.HP := 0;

    if m_boDragonFireSkill then
    begin
      if (m_WAbil.MP - nDamage) > 0 then
        m_WAbil.MP := m_WAbil.MP - nDamage
      else
        m_WAbil.MP := 0;
      m_boDragonFireSkill := False;
    end;

    if not m_boStrike and (m_btRaceServer = RC_HERO) then
      m_boStrike := True;

    if (m_btRaceServer = RC_Escort) and (m_Master <> nil) and (m_WAbil.HP > 0) then
    begin
      if GetTickCount - TEscortMon(Self).m_dwUnderFireHintTick > 10 * 1000 then
      begin
        TEscortMon(Self).m_dwUnderFireHintTick := GetTickCount;

        if (g_MapEventNPC <> nil) and
          ((m_PEnvir <> m_Master.m_PEnvir) or
          ((abs(m_nCurrX - m_Master.m_nCurrX) > 30) or (abs(m_nCurrY - m_Master.m_nCurrY) > 30))) then
        begin

          if m_ExpHitter <> nil then
          begin
            CSObject := GetMainPlayer(m_ExpHitter);
            if (CSObject.m_btRaceServer = RC_PLAYOBJECT) and (CSObject <> m_Master) then
            begin
              g_MapEventNPC.m_OprCount := 0;
              g_MapEventNPC.GotoLable(TPlayObject(m_Master), '@EscortUnderFire', False);
            end;
          end
          else if m_LastHiter <> nil then
          begin
            CSObject := GetMainPlayer(m_LastHiter);
            if (CSObject.m_btRaceServer = RC_PLAYOBJECT) and (CSObject <> m_Master) then
            begin
              g_MapEventNPC.m_OprCount := 0;
              g_MapEventNPC.GotoLable(TPlayObject(m_Master), '@EscortUnderFire', False);
            end;
          end;
        end;
      end;
    end;

    //
  end
  else if m_WAbil.HP <> 0 then
  begin
    if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then
      m_WAbil.HP := m_WAbil.HP - nDamage
    else
      m_WAbil.HP := m_WAbil.MaxHP;
  end;
end;

function TBaseObject.GetBackDir(nDir: Integer): Integer;
begin
  Result := 0;
  case nDir of
    DR_UP: Result := DR_DOWN;
    DR_DOWN: Result := DR_UP;
    DR_LEFT: Result := DR_RIGHT;
    DR_RIGHT: Result := DR_LEFT;
    DR_UPLEFT: Result := DR_DOWNRIGHT;
    DR_UPRIGHT: Result := DR_DOWNLEFT;
    DR_DOWNLEFT: Result := DR_UPRIGHT;
    DR_DOWNRIGHT: Result := DR_UPLEFT;
  end;
end;

function TBaseObject.CharPushed(nDir, nPushCount: Integer; dm: Boolean; step: Integer): Integer; //004C2F90
var
  i, nX, nY, olddir, nBackDir: Integer;
begin
  Result := 0;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if TPlayObject(Self).m_StallMgr.OnSale then
      Exit;
  end;

  olddir := m_btDirection;
  if not (nDir in [0..7]) then
    Exit;
  m_btDirection := nDir;
  nBackDir := GetBackDir(nDir);
  for i := 0 to nPushCount - 1 do
  begin
    GetFrontPosition(nX, nY);
    if m_PEnvir.CanWalk(nX, nY, False) then
    begin
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
      begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');

        if (m_btRaceServer = RC_HERO) then
          m_dwWalkTick := m_dwWalkTick + m_nWalkSpeed
        else if m_btRaceServer >= RC_ANIMAL then
          m_dwWalkTick := m_dwWalkTick + 800;

        if (m_btRaceServer = RC_PLAYOBJECT) and dm then
        begin
          if (g_Config.PushedPauseTime > 0) and (m_wStatusTimeArr[POISON_PURPLE] = 0) then
          begin
            m_wStatusTimeArr[POISON_PURPLE] := g_Config.PushedPauseTime;
            m_dwStatusArrTick[POISON_PURPLE] := GetTickCount();
          end;
        end;

        Inc(Result);
      end
      else
        Break;
    end
    else
      Break;
  end;
  m_btDirection := nBackDir;
  if Result = 0 then
    m_btDirection := olddir;

end;

function TBaseObject.ChrDupPushed(nDir, nPushCount: Integer): Integer;
var
  i, nX, nY, olddir, nBackDir: Integer;
begin
  Result := 0;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if TPlayObject(Self).m_StallMgr.OnSale then
      Exit;
  end;
  olddir := m_btDirection;
  if not (nDir in [0..7]) then
    Exit;
  m_btDirection := nDir;
  nBackDir := GetBackDir(nDir);
  for i := 0 to nPushCount - 1 do
  begin
    GetFrontPosition(nX, nY);
    if not InSafeZone(m_PEnvir, nX, nY) then
      Exit;
    if m_PEnvir.CanWalk(nX, nY, False) then
    begin
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
      begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
        Inc(Result);
        if (m_btRaceServer = RC_HERO) then
          m_dwWalkTick := m_dwWalkTick + m_nWalkSpeed
        else if m_btRaceServer >= RC_ANIMAL then
          m_dwWalkTick := m_dwWalkTick + 800;
      end
      else
        Break;
    end
    else
      Break;
  end;
  m_btDirection := nBackDir;
  if Result = 0 then
    m_btDirection := olddir;
end;

function TBaseObject.MagPassThroughMagic(sX, sY, tX, tY, nDir, magpwr, id: Integer; UnDeadAttack: Boolean): Integer;
var
  i, tCount, acpwr: Integer;
  BaseObject: TBaseObject;
begin
  tCount := 0;
  for i := 0 to 12 do
  begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sX, sY, True));
    if BaseObject <> nil then
    begin
      if IsProperTarget(BaseObject, True) then
      begin
        if Random(10) >= BaseObject.m_nAntiMagic then
        begin
          if UnDeadAttack then
            acpwr := Round(magpwr * 1.5)
          else
            acpwr := magpwr;
          BaseObject.SendDelayMsg(Self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 600, id);
          Inc(tCount);
        end;
      end;
    end;
    if not ((abs(sX - tX) <= 0) and (abs(sY - tY) <= 0)) then
    begin
      nDir := GetNextDirection(sX, sY, tX, tY);
      if not m_PEnvir.GetNextPosition(sX, sY, nDir, 1, sX, sY) then
        Break;
    end
    else
      Break;
  end;
  Result := tCount;
end;

function TBaseObject.MagPassThroughMagic60(sX, sY, tX, tY, nDir, magpwr: Integer; UnDeadAttack: Boolean): Integer;
var
  i, acpwr, tCount: Integer;
  BaseObject: TBaseObject;
begin
  tCount := 0;
  for i := 0 to 12 do
  begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sX, sY, True));
    if BaseObject <> nil then
    begin
      if IsProperTarget(BaseObject, True) then
      begin
        if (Random(BaseObject.m_btSpeedPoint) < m_btHitPoint) then
        begin
          acpwr := Round(magpwr * 3.1 * (g_Config.nSkillWWPowerRate + m_wInPowerRateEx) / 100);
          BaseObject.SendDelayMsg(Self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 50, 60);
          BaseObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 1, 0, 0, '');
          Inc(tCount);
        end;
      end;
    end;
    if not ((abs(sX - tX) <= 0) and (abs(sY - tY) <= 0)) then
    begin
      nDir := GetNextDirection(sX, sY, tX, tY);
      if not m_PEnvir.GetNextPosition(sX, sY, nDir, 1, sX, sY) then
        Break;
    end
    else
      Break;
  end;
  Result := tCount;
end;

procedure TPlayObject.SendSocket(DefMsg: pTDefaultMessage; sMsg: string);
var
  MsgHdr: TMsgHeader;
  nSendBytes: Integer;
  tBuff: PChar;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::SendSocket';
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) then
    Exit;

  if m_nSocket = -1 then
    Exit;

  if m_boOffLineFlag and (DefMsg <> nil) and (DefMsg.Ident <> SM_OUTOFCONNECTION) then
    Exit;
  tBuff := nil;
  try
    MsgHdr.dwCode := RUNGATECODE;
    MsgHdr.nSocket := m_nSocket;
    MsgHdr.wGSocketIdx := m_nGSocketIdx;
    MsgHdr.wIdent := GM_DATA;
    if DefMsg <> nil then
    begin
      if sMsg <> '' then
      begin
        MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
        Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
        //tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer) + Length(sMsg)] := #0; //0605
      end
      else
      begin
        MsgHdr.nLength := SizeOf(TDefaultMessage);
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
      end;
    end
    else if sMsg <> '' then
    begin
      MsgHdr.nLength := -(Length(sMsg) + 1);
      nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
      GetMem(tBuff, nSendBytes + SizeOf(Integer));
      Move(nSendBytes, tBuff^, SizeOf(Integer));
      Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
      Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
      //tBuff[SizeOf(TMsgHeader) + SizeOf(Integer) + Length(sMsg)] := #0;
    end;
    if not RunSocket.AddGateBuffer(m_nGateIdx, tBuff) then
      FreeMem(tBuff);
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.SendSocketAll(DefMsg: pTDefaultMessage; sMsg: string);
var
  MsgHdr: TMsgHeader;
  nBufLen, nSendBytes: Integer;
  tBuff: PChar;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::SendSocket';
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) then
    Exit;

  if m_nSocket = -1 then
    Exit;

  if m_boOffLineFlag and (DefMsg <> nil) and (DefMsg.Ident <> SM_OUTOFCONNECTION) then
    Exit;

  nBufLen := 0;
  tBuff := nil;
  try
    MsgHdr.dwCode := RUNGATECODE;
    MsgHdr.nSocket := m_nSocket;
    MsgHdr.wGSocketIdx := m_nGSocketIdx;
    MsgHdr.wIdent := GM_DATA;
    if DefMsg <> nil then
    begin
      if sMsg <> '' then
      begin
        MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        nBufLen := nSendBytes + SizeOf(Integer);
        GetMem(tBuff, nBufLen);
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
        Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) {+ 1});
        tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer) + Length(sMsg)] := #0; //0605
      end
      else
      begin
        MsgHdr.nLength := SizeOf(TDefaultMessage);
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        nBufLen := nSendBytes + SizeOf(Integer);
        GetMem(tBuff, nBufLen);
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], SizeOf(TDefaultMessage));
      end;
    end
    else if sMsg <> '' then
    begin
      MsgHdr.nLength := -(Length(sMsg) + 1);
      nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
      nBufLen := nSendBytes + SizeOf(Integer);
      GetMem(tBuff, nBufLen);
      Move(nSendBytes, tBuff^, SizeOf(Integer));
      Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
      Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) {+ 1});
      tBuff[SizeOf(TMsgHeader) + SizeOf(Integer) + Length(sMsg)] := #0;
    end;
    if nBufLen > 0 then
    begin
      RunSocket.AddGateBufferAll(tBuff, nBufLen);
    end;
    FreeMem(tBuff);
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string); //004CAD6C
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  //if m_boOffLineFlag and (wIdent <> SM_OUTOFCONNECTION) then Exit; //080118
  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
  if sMsg <> '' then
    SendSocket(@m_DefMsg, EncodeString(sMsg))
  else
    SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientQueryUserName(Target: TBaseObject; x, y: Integer);
var
  uname: string;
  TagColor: Integer;
  Def: TDefaultMessage;
begin
  if CretInNearXY(Target, x, y) then
  begin
    TagColor := GetCharColor(Target);
    if g_Config.boHumanAttribute and (m_btAttribute in [1..5]) then
      Def := MakeDefaultMsg(SM_USERNAME, Integer(Target), TagColor, m_btAttribute, 0)
    else
      Def := MakeDefaultMsg(SM_USERNAME, Integer(Target), TagColor, 0, 0);
    uname := Target.GetShowName;
    SendSocket(@Def, EncodeString(uname));
  end
  else
    SendDefMessage(SM_GHOST, Integer(Target), x, y, 0, '');
end;

function TBaseObject.GetShowName: string;
begin
  if m_PEnvir.m_MapFlag.nSecret and $08 <> 0 then
  begin
    if m_Master <> nil then
    begin
      if IsHero then
      begin
        Result := m_PEnvir.m_MapFlag.nSecretShowName;
      end
      else
      begin
        Result := Format('%s\(%s)', [m_sFCharName, m_PEnvir.m_MapFlag.nSecretShowName]);
      end;
      Exit;
    end;
  end;

  if IsHero then
  begin
    Result := m_sCharName
  end
  else
    Result := m_sFCharName;

  if (m_Master <> nil) and not m_Master.m_boObMode and (m_btRaceServer <> RC_Escort) then
  begin
    if m_btRaceServer = RC_HERO then
    begin
      if m_dwCloneDispearTick > 0 then
        //Result := Result + '(' + m_Master.m_sCharName + 'µÄÔªÉñ)'
      else if g_Config.boPShowMasterName and not IsHero then
        Result := Result + '\(' + m_Master.m_sCharName + g_Config.sHeroSlaveName + ')';
    end
    else if m_boShowMasterName then
    begin
      if m_sFCharName <> '' then
        Result := Result + '(' + m_Master.m_sFCharName + ')'
      else
        Result := Result + '(' + m_Master.m_sCharName + ')';
    end;
  end;
  if m_boShowMasterName and (m_btRaceServer = RC_Escort) and (TEscortMon(Self).m_sMName <> '') then
    Result := Result + '[' + TEscortMon(Self).m_sMName + ']';
end;

procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer);
begin
  inherited AttackDir(TargeTBaseObject, 0, nDir);
end;

constructor TAnimalObject.Create;
begin
  inherited;
  m_nNotProcessCount := 0;
  m_nTargetX := -1;
  m_btRaceServer := RC_ANIMAL;
  m_dwHitTick := GetTickCount - LongWord(Random(3000));
  m_dwWalkTick := GetTickCount - LongWord(Random(3000));
  m_dwSearchEnemyTick := GetTickCount();
  m_boRunAwayMode := False;
  m_dwRunAwayStart := GetTickCount();
  m_dwRunAwayTime := 0;
end;

destructor TAnimalObject.Destroy;
begin
  inherited;
end;

procedure TAnimalObject.GotoTargetXY;
var
  i: Integer;
  nDir: Integer;
  nOldX: Integer;
  nOldY: Integer;
label
  lHero;
begin
  if m_boStickMode then
    Exit;

  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then
  begin
    nDir := DR_DOWN;
    if m_nTargetX > m_nCurrX then
    begin
      nDir := DR_RIGHT;
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWNRIGHT
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UPRIGHT;
    end
    else if m_nTargetX < m_nCurrX then
    begin
      nDir := DR_LEFT;
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWNLEFT
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UPLEFT;
    end
    else
    begin
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWN
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UP;
    end;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(nDir, False);

    for i := DR_UP to DR_UPLEFT do
    begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then
      begin
        if Random(3) <> 0 then
          Inc(nDir)
        else if nDir > 0 then
          Dec(nDir)
        else
          nDir := DR_UPLEFT;
        if (nDir > DR_UPLEFT) then
          nDir := DR_UP;
        if WalkTo(nDir, False) then
        begin
          goto lHero;
        end;
      end
      else
      begin //1025
        lHero:
        if g_Config.boHeroRecalcWalkTick and (m_TargetCret <> nil) and m_TargetCret.IsHero and IsProperTarget(m_TargetCret) then
          m_TargetCret.m_dwWalkTick := GetTickCount - m_nWalkSpeed div 2; //m_TargetCret.m_dwWalkTick := 0;

        Break;
      end;
    end;

  end;
end;

{procedure TAnimalObject.GotoTargetXYEx;
var
  i, nDir, nOldX, nOldY     : Integer;
begin
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    nDir := DR_DOWN;
    if m_nTargetX > m_nCurrX then begin
      nDir := DR_RIGHT;
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWNRIGHT
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UPRIGHT;
    end else if m_nTargetX < m_nCurrX then begin
      nDir := DR_LEFT;
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWNLEFT
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UPLEFT;
    end else begin
      if m_nTargetY > m_nCurrY then
        nDir := DR_DOWN
      else if m_nTargetY < m_nCurrY then
        nDir := DR_UP;
    end;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(nDir, False);
    for i := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if Random(3) <> 0 then
          Inc(nDir)
        else if nDir > 0 then
          Dec(nDir)
        else
          nDir := DR_UPLEFT;
        if (nDir > DR_UPLEFT) then
          nDir := DR_UP;
        WalkTo(nDir, False);
      end;
    end;
  end;
end;}

{function TAnimalObject.GetTargetXYNear(var nTX, nTY: Integer): Boolean;
var
  i, nDir, nX, nY, nOldX, nOldY: Integer;
  nDis                      : Integer;
begin
  nTX := -1;
  nTY := -1;
  Result := False;
  if m_PEnvir = nil then Exit;
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    for i := 0 to 7 do begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, i, 2, nX, nY) then begin
        nDis := abs(nX - m_nTargetX) + abs(nY - m_nTargetY);
        if m_PEnvir.IsValidCell(nX, nY) and ((abs(nX - m_nTargetX) + abs(nY - m_nTargetY)) < nDis) then begin
          nTX := nX;
          nTY := nY;
          Break;
        end;
      end;
    end;
  end;
end;}

function TAnimalObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
begin
  // Result := False;
  if ProcessMsg.wIdent = RM_STRUCK then
  begin
    if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3) <> nil) then
    begin
      SetLastHiter(TBaseObject(ProcessMsg.nParam3));
      Struck(TBaseObject(ProcessMsg.nParam3));
      BreakHolySeizeMode();
      if (m_Master <> nil) and (TBaseObject(ProcessMsg.nParam3) <> m_Master) and
        ((TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or (TBaseObject(ProcessMsg.nParam3).m_Master <> nil)) then
      begin
        if (m_Master.m_Master = nil) or (TBaseObject(ProcessMsg.nParam3) <> m_Master.m_Master) then
        begin
          if (TBaseObject(ProcessMsg.nParam3).m_Master <> nil) and not TBaseObject(ProcessMsg.nParam3).IsHero then
            m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3).m_Master);
          m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
        end;
      end;
      if g_Config.boMonSayMsg then
        MonsterSayMsg(TBaseObject(ProcessMsg.nParam3), s_UnderFire);
    end;
    Result := True;
  end
  else
    Result := inherited Operate(ProcessMsg);
end;

procedure TAnimalObject.Run();
begin
  inherited Run();
end;

procedure TAnimalObject.Struck(hiter: TBaseObject);
var
  btDir: Byte;
begin
  m_dwStruckTick := GetTickCount;
  if hiter <> nil then
  begin
    if (m_TargetCret = nil) or GetAttackDir(m_TargetCret, btDir) or (Random(6) = 0) then
    begin
      if IsProperTarget(hiter) then
        SetTargetCreat(hiter);
    end;
  end;
  if m_boAnimal then
  begin
    m_nMeatQuality := m_nMeatQuality - Random(300);
    if m_nMeatQuality < 0 then
      m_nMeatQuality := 0;
  end;
  m_dwHitTick := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
end;

procedure TBaseObject.RecalcAbilitys(boAction: Boolean = False);
var
  s: string[255];
  i, ii, nOldLight, nInPowerRate: Integer;
  Abil: TAbility;
  StdItem: pTStdItem;
  boOldHideMode: Boolean;
  boSpirit1: Boolean;
  boSpirit2: Boolean;
  boSpirit3: Boolean;
  boSpirit4: Boolean;
  boMoXieSuite1: Boolean;
  boMoXieSuite2: Boolean;
  boMoXieSuite3: Boolean;
  boRecallSuite1: Boolean;
  boRecallSuite2: Boolean;
  boRecallSuite3: Boolean;
  boRecallSuite4: Boolean;
  boHongMoSuite1: Boolean;
  boHongMoSuite2: Boolean;
  boHongMoSuite3: Boolean;
  aSuiteIdx: TSuiteIndex;
  naSuitSubRate: TSuitSubRate;
  PSuiteItems: pTSuiteItems;
  IPI, Vam, Vam2, slegend: array[0..High(THumanUseItems)] of Byte;
  lac, hac, lmac, hmac: Word;

  recallmoblv: Byte;
  boFlameRing: Boolean;
  boRecoveryRing: Boolean;
  btSpSkillLv: Byte;
  mhp, mmp: DWORD;
  boIsPlayer, boHuman: Boolean;
  tbtWeaponSkill: Byte;
  nHPAdd, nMPAdd: Integer;

  btDragonRageSkill: Byte;
begin
  btDragonRageSkill := 0;
  m_btDragonRageSkillLevel := 0;

  nHPAdd := 0;
  nMPAdd := 0;
  boHuman := m_btRaceServer in [RC_PLAYOBJECT, RC_HERO];
  boIsPlayer := (m_btRaceServer = RC_PLAYOBJECT) or IsHero;
  m_wVampire := 0;
  m_wVampire2 := 0;
  m_btSuckRate := 0;
  recallmoblv := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);

  m_btIgnoreTagDefence := 0;
  m_btDamageAddOn := 0;
  m_btDamageRebound := 0;
  m_btACDamageReduction := 0;
  m_btMCDamageReduction := 0;
  m_btGetExpExRate := 0;

  m_btReduceSpellTime := 0;

  if boIsPlayer then
  begin
    if (m_nInPowerLevel > 0) then
      nInPowerRate := 1 + m_nInPowerLevel div 8
    else
      nInPowerRate := 0;
  end;
  FillChar(IPI, SizeOf(IPI), #0);
  FillChar(Vam, SizeOf(Vam), #0);
  FillChar(Vam2, SizeOf(Vam2), #0);
  FillChar(slegend, SizeOf(slegend), #0);

  Abil := m_WAbil;
  m_WAbil := m_Abil;
  m_WAbil.HP := Abil.HP;
  m_WAbil.MP := Abil.MP;

  mhp := m_WAbil.MaxHP;
  mmp := m_WAbil.MaxMP;

  m_WAbil.WearWeight := 0;
  m_WAbil.HandWeight := 0;
  m_btAntiPoison := 0;
  m_btAntiStone := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 1;
  m_nLuck := 0;
  m_nHitSpeed := 0;
  m_boExpItem := False;
  m_rExpItem := 0;
  m_boPowerItem := False;
  m_rPowerItem := 0;
  m_boAcItem := False;
  m_rAcItem := 0;
  m_boMacItem := False;
  m_rMacItem := 0;

  boOldHideMode := m_boHideMode;
  m_boHideMode := False;
  m_boTeleport := False;
  m_boParalysis := False;
  m_boParalysis2 := False;
  m_boMParalysis := False;

  m_boRevival := False;
  m_boUnRevival := False;

  boFlameRing := False;
  boRecoveryRing := False;

  m_boAngryRing := False;
  m_boMagicShield := False;
  m_boMagicShield2 := False;
  m_boUnMagicShield := False;
  m_boMuscleRing := False;
  m_boFastTrain := False;
  m_boProbeNecklace := False;
  m_boSupermanItem := False;
  m_boGuildMove := False;
  m_boUnParalysis := False;
  m_dwUnParalysisTick := 0;
  m_boUnAllParalysis := False;
  m_boExpItem := False;
  m_boPowerItem := False;
  m_boNoDropItem := False;
  m_boNoDropUseItem := False;
  m_bopirit := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;

  m_nMoXieSuite := 0;
  boMoXieSuite1 := False;
  boMoXieSuite2 := False;
  boMoXieSuite3 := False;
  m_dbHongMoSuite := 0;
  m_nHongMoSuite := 0;
  boHongMoSuite1 := False;
  boHongMoSuite2 := False;
  boHongMoSuite3 := False;

  boSpirit1 := False;
  boSpirit2 := False;
  boSpirit3 := False;
  boSpirit4 := False;

  m_boRecallSuite := False;
  boRecallSuite1 := False;
  boRecallSuite2 := False;
  boRecallSuite3 := False;
  boRecallSuite4 := False;

  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_nAutoAddHPMPMode := 0;
  m_boDrangonHeart := False;
  m_btHairEx := 0;

  tbtWeaponSkill := 0;
  m_btWeaponSkill := 0;
  m_btWeaponEffect := 0;

  m_btHitPowerAddOn := 0;
  m_wDoublePower := 0;
  m_wHPAddLevel := 0;
  m_wMPAddLevel := 0;
  m_wJobAbil := 0;

  m_btSkill77 := 0;

  m_btSpSkill1 := 0; //Î¨ÎÒ¶À×ð
  m_btSpSkill2 := 0; //ÕÙ»½¾ÞÄ§
  m_btSpSkill3 := 0; //ÉñÁú¸½Ìå
  m_btSpSkill4 := 0; //ÒÐÌìÅüµØ
  m_btSpSkill5 := 0;
  m_btSpSkill6 := 0;
  m_btSpSkill7 := 0;
  m_btSpSkill8 := 0;

  if boHuman then
  begin
    FillChar(aSuiteIdx, SizeOf(TSuiteIndex), #0);
    FillChar(naSuitSubRate, SizeOf(TSuitSubRate), #0);
  end;
  if boIsPlayer then
  begin
    TPlayObject(Self).m_nTagDropPlus := 0;
    TPlayObject(Self).m_nPreventDrop := 0;
  end;
  if (boHuman) then
  begin
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if (m_UseItems[i].wIndex <= 0) or (m_UseItems[i].Dura <= 0) then
        Continue;

      StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if StdItem = nil then
        Continue;

      if (i = U_WEAPON) and (StdItem.StdMode in [5, 6]) then
      begin
        if (StdItem.reserve[3] > 0) then
          m_btWeaponEffect := StdItem.reserve[3];
      end;

      if (StdItem.reserve[7] > 0) then
        Inc(nHPAdd, StdItem.reserve[7] * 100);

      if (StdItem.reserve[8] > 0) then
        Inc(nMPAdd, StdItem.reserve[8] * 100);

      if StdItem.UniqueItem > 0 then
        IPI[i] := StdItem.UniqueItem;

      if (i <> U_WEAPON) then
      begin
        if (StdItem.Reserved > 0) then
        begin
          if (StdItem.Shape = 190) then
            Vam[i] := StdItem.Reserved;
          if (StdItem.Shape = 191) then
            Vam2[i] := StdItem.Reserved;
        end;
        if (StdItem.Shape = 193) then
          slegend[i] := 1;
      end
      else
      begin
        if StdItem.AniCount = 193 then
          slegend[i] := 1;
      end;

      if i <= High(THumanUseItems) - 3 - 1 then
      begin
        if StdItem.SvrSet.btRefSuiteCount > 0 then
          for ii := 0 to StdItem.SvrSet.btRefSuiteCount - 1 do
            if i = StdItem.SvrSet.aSuiteWhere[ii] then
              Inc(aSuiteIdx[StdItem.SvrSet.aSuiteIndex[ii]]);
      end;

      GetAccessory(m_UseItems[i], m_AddAbil);

      if boIsPlayer then
      begin
        if m_UseItems[i].btValue[14] > 0 then
          Inc(TPlayObject(Self).m_nPreventDrop, m_UseItems[i].btValue[14]);
      end;

      if (i = U_BOOTS) and (StdItem.StdMode = 28) and (StdItem.AniCount > 0) then
      begin
        m_WAbil.MaxWeight := _MIN(High(Word), m_WAbil.MaxWeight + StdItem.AniCount);
        m_WAbil.MaxWearWeight := _MIN(High(Word), m_WAbil.MaxWearWeight + StdItem.AniCount);
        m_WAbil.MaxHandWeight := _MIN(High(Word), m_WAbil.MaxHandWeight + StdItem.AniCount);
      end;

      if (i = U_HELMETEX) and (StdItem.StdMode = 16) then
      begin
        m_btHairEx := StdItem.AniCount;
      end;

      if i in [U_WEAPON, U_RIGHTHAND, U_DRESS, U_FASHION] then
      begin
        //if m_UseItems[i].Dura > 0 then begin
        if i in [U_DRESS, U_FASHION] then
          Inc(m_WAbil.WearWeight, StdItem.Weight)
        else
          Inc(m_WAbil.HandWeight, StdItem.Weight);

        if StdItem.AniCount = 120 then
          m_boFastTrain := True
        else if StdItem.AniCount = 121 then
          m_boProbeNecklace := True
        else if StdItem.AniCount = 145 then
          m_boGuildMove := True
        else if StdItem.AniCount = 111 then
        begin
          m_wStatusTimeArr[STATE_TRANSPARENT] := g_MaxStatusTime;
          m_boHideMode := True;
        end
        else if StdItem.AniCount = 112 then
          m_boTeleport := True
        else if StdItem.AniCount = 113 then
          m_boParalysis := True
        else if StdItem.AniCount = 114 then
          m_boRevival := True
        else if StdItem.AniCount = 115 then
          boFlameRing := True
        else if StdItem.AniCount = 116 then
          boRecoveryRing := True
        else if StdItem.AniCount = 117 then
          m_boAngryRing := True
        else if StdItem.AniCount = 118 then
          m_boMagicShield := True
        else if StdItem.AniCount = 119 then
          m_boMuscleRing := True
        else if StdItem.AniCount = 135 then
        begin
          boMoXieSuite1 := True;
          Inc(m_nMoXieSuite, StdItem.Weight div 10);
        end
        else if StdItem.AniCount = 138 then
          Inc(m_nHongMoSuite, StdItem.Weight)
        else if StdItem.AniCount = 139 then
          m_boUnParalysis := True
        else if StdItem.AniCount = 140 then
          m_boSupermanItem := True
        else if StdItem.AniCount = 141 then
        begin
          m_boExpItem := True;
          m_rExpItem := m_rExpItem + (m_UseItems[i].Dura / _MAX(1, g_Config.nItemExpRate));
        end
        else if StdItem.AniCount = 142 then
        begin
          m_boPowerItem := True;
          m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura / _MAX(1, g_Config.nItemPowerRate));
        end
        else if StdItem.AniCount = 182 then
        begin
          m_boExpItem := True;
          m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemExpRate));
        end
        else if StdItem.AniCount = 183 then
        begin
          m_boPowerItem := True;
          m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemPowerRate));
        end
        else if StdItem.AniCount = 184 then
        begin
          m_boAcItem := True;
          m_rAcItem := m_rAcItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemAcRate));
        end
        else if StdItem.AniCount = 185 then
        begin
          m_boMacItem := True;
          m_rMacItem := m_rMacItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemMacRate));
        end
        else if StdItem.AniCount = 186 then
          m_boUnAllParalysis := True
        else if StdItem.AniCount = 187 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 1
        end
        else if StdItem.AniCount = 188 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 2
        end
        else if StdItem.AniCount = 192 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 3
        end
        else if StdItem.AniCount = 193 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 4
        end
        else if StdItem.AniCount = 195 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 5
        end
        else if StdItem.AniCount = 196 then
        begin
          if i = U_WEAPON then
            m_btWeaponSkill := 6
        end
        else if StdItem.AniCount = 194 then
        begin
          Inc(m_btSkill77);
        end
        else if StdItem.AniCount = 189 then
          m_boMParalysis := True
        else if StdItem.AniCount = 143 then
          m_boUnMagicShield := True
        else if StdItem.AniCount = 144 then
          m_boUnRevival := True
        else if StdItem.AniCount = 170 then
          m_boAngryRing := True
        else if StdItem.AniCount = 171 then
          m_boNoDropItem := True
        else if StdItem.AniCount = 172 then
          m_boNoDropUseItem := True
        else if StdItem.AniCount = 150 then
        begin //Âé±Ô»¤Éí
          m_boParalysis := True;
          m_boMagicShield := True;
        end
        else if StdItem.AniCount = 151 then
        begin //Âé±Ô»ðÇò
          m_boParalysis := True;
          boFlameRing := True;
        end
        else if StdItem.AniCount = 152 then
        begin //Âé±Ô·ÀÓù
          m_boParalysis := True;
          boRecoveryRing := True;
        end
        else if StdItem.AniCount = 153 then
        begin //Âé±Ô¸ºÔØ
          m_boParalysis := True;
          m_boMuscleRing := True;
        end
        else if StdItem.Shape = 154 then
        begin //»¤Éí»ðÇò
          m_boMagicShield := True;
          boFlameRing := True;
        end
        else if StdItem.AniCount = 155 then
        begin //»¤Éí·ÀÓù
          m_boMagicShield := True;
          boRecoveryRing := True;
        end
        else if StdItem.AniCount = 156 then
        begin //»¤Éí¸ºÔØ
          m_boMagicShield := True;
          m_boMuscleRing := True;
        end
        else if StdItem.AniCount = 157 then
        begin //´«ËÍÂé±Ô
          m_boTeleport := True;
          m_boParalysis := True;
        end
        else if StdItem.AniCount = 158 then
        begin //´«ËÍ»¤Éí
          m_boTeleport := True;
          m_boMagicShield := True;
        end
        else if StdItem.AniCount = 159 then
        begin //´«ËÍÌ½²â
          m_boTeleport := True;
          m_boProbeNecklace := True;
        end
        else if StdItem.AniCount = 160 then
        begin //´«ËÍ¸´»î
          m_boTeleport := True;
          m_boRevival := True;
        end
        else if StdItem.AniCount = 161 then
        begin //Âé±Ô¸´»î
          m_boParalysis := True;
          m_boRevival := True;
        end
        else if StdItem.AniCount = 162 then
        begin //»¤Éí¸´»î
          m_boMagicShield := True;
          m_boRevival := True;
        end
        else if StdItem.AniCount = 163 then
        begin //·ÀÂé±Ô´«ËÍ
          m_boUnParalysis := True;
          m_boTeleport := True;
        end
        else if StdItem.AniCount = 164 then
        begin //·ÀÈ«Âé±Ô´«ËÍ
          m_boUnAllParalysis := True;
          m_boTeleport := True;
        end
        else if StdItem.AniCount = 165 then
        begin
          m_boUnRevival := True;
          m_boUnMagicShield := True;
        end
        else if StdItem.AniCount = 166 then
        begin
          m_boUnRevival := True;
          m_boUnAllParalysis := True;
        end
        else if StdItem.AniCount = 167 then
        begin
          m_boUnMagicShield := True;
          m_boUnAllParalysis := True;
        end
        else if StdItem.AniCount = 168 then
        begin
          m_boUnRevival := True;
          m_boUnMagicShield := True;
          m_boUnAllParalysis := True;
        end
        else if StdItem.AniCount = 180 then
          m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate
        else if StdItem.AniCount = 181 then
          m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate;

        if (i <> U_WEAPON) and (StdItem.Reserved > 0) then
        begin
          case StdItem.Source of
            10: m_btAntiStone := _MIN(High(Byte), m_btAntiStone + StdItem.Reserved);
            11: m_btReduceSpellTime := _MIN(High(Byte), m_btReduceSpellTime + StdItem.Reserved);
          end;
        end;

        if (i = U_WEAPON) and (StdItem.AniCount in [230..255]) then
        begin
          //ÎäÆ÷¼¼ÄÜ
          tbtWeaponSkill := StdItem.AniCount;
        end;
      end
      else
        Inc(m_WAbil.WearWeight, StdItem.Weight);

      Inc(m_WAbil.Weight, StdItem.Weight);
      if (i = U_WEAPON) then
      begin
        if (StdItem.Source - 1 - 10) < 0 then
          m_AddAbil.btWeaponStrong := StdItem.Source; //Ç¿¶È+
        if (StdItem.Source <= -1) and (StdItem.Source >= -50) then // -1 ÖÁ -50
          m_AddAbil.btHoly := _MIN(High(Byte), m_AddAbil.btHoly + -StdItem.Source); //ÉñÊ¥+
        if (StdItem.Source <= -51) and (StdItem.Source >= -100) then // -51 ÖÁ - 100
          m_AddAbil.btHoly := _MIN(High(Byte), m_AddAbil.btHoly + (StdItem.Source + 50)); //ÉñÊ¥-
        Continue;
      end;

      if (i = U_RIGHTHAND) then
      begin
        if StdItem.Shape in [1..50] then
          m_btDressEffType := StdItem.Shape;
        if StdItem.Shape in [51..100] then
          m_btHorseType := StdItem.Shape - 50;
        Continue;
      end;

      if (i in [U_DRESS]) then
      begin
        if m_UseItems[i].btValue[5] > 0 then
          m_btDressEffType := m_UseItems[i].btValue[5];
        if StdItem.AniCount > 0 then
          m_btDressEffType := StdItem.AniCount;
        Continue;
      end;

      if m_boShowFashion and (i in [U_FASHION]) then
      begin
        m_btDressEffType := 0;
        if m_UseItems[i].btValue[5] > 0 then
          m_btDressEffType := m_UseItems[i].btValue[5];
        if StdItem.AniCount > 0 then
          m_btDressEffType := StdItem.AniCount;
        Continue;
      end;

      //ÐÂÔö¿ªÊ¼
      if StdItem.Shape = 197 then
      begin
        Inc(btDragonRageSkill);
        m_btDragonRageSkillLevel := _MIN(100, m_btDragonRageSkillLevel + StdItem.AniCount);
        //m_boParalysis := True;
      end
      else if StdItem.Shape = 139 then
        m_boUnParalysis := True
      else if StdItem.Shape = 140 then
        m_boSupermanItem := True
      else if StdItem.Shape = 141 then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].Dura / _MAX(1, g_Config.nItemExpRate));
      end
      else if StdItem.Shape = 142 then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura / _MAX(1, g_Config.nItemPowerRate));
      end
      else if StdItem.Shape = 182 then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemExpRate));
      end
      else if StdItem.Shape = 183 then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemPowerRate));
      end
      else if StdItem.Shape = 184 then
      begin
        m_boAcItem := True;
        m_rAcItem := m_rAcItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemAcRate));
      end
      else if StdItem.Shape = 185 then
      begin
        m_boMacItem := True;
        m_rMacItem := m_rMacItem + (m_UseItems[i].DuraMax / _MAX(1, g_Config.nItemMacRate));
      end
      else if StdItem.Shape = 186 then
      begin
        m_boUnAllParalysis := True
      end
      else if StdItem.Shape = 194 then
      begin
        Inc(m_btSkill77);
      end
      else if StdItem.Shape = 189 then
        m_boMParalysis := True
      else if StdItem.Shape = 143 then
        m_boUnMagicShield := True
      else if StdItem.Shape = 144 then
        m_boUnRevival := True
      else if StdItem.Shape = 170 then
        m_boAngryRing := True
      else if StdItem.Shape = 171 then
        m_boNoDropItem := True
      else if StdItem.Shape = 172 then
        m_boNoDropUseItem := True
      else if StdItem.Shape = 150 then
      begin //Âé±Ô»¤Éí
        m_boParalysis := True;
        m_boMagicShield := True;
      end
      else if StdItem.Shape = 151 then
      begin //Âé±Ô»ðÇò
        m_boParalysis := True;
        boFlameRing := True;
      end
      else if StdItem.Shape = 152 then
      begin //Âé±Ô·ÀÓù
        m_boParalysis := True;
        boRecoveryRing := True;
      end
      else if StdItem.Shape = 153 then
      begin //Âé±Ô¸ºÔØ
        m_boParalysis := True;
        m_boMuscleRing := True;
      end
      else if StdItem.Shape = 154 then
      begin //»¤Éí»ðÇò
        m_boMagicShield := True;
        boFlameRing := True;
      end
      else if StdItem.Shape = 155 then
      begin //»¤Éí·ÀÓù
        m_boMagicShield := True;
        boRecoveryRing := True;
      end
      else if StdItem.Shape = 156 then
      begin //»¤Éí¸ºÔØ
        m_boMagicShield := True;
        m_boMuscleRing := True;
      end
      else if StdItem.Shape = 157 then
      begin //´«ËÍÂé±Ô
        m_boTeleport := True;
        m_boParalysis := True;
      end
      else if StdItem.Shape = 158 then
      begin //´«ËÍ»¤Éí
        m_boTeleport := True;
        m_boMagicShield := True;
      end
      else if StdItem.Shape = 159 then
      begin //´«ËÍÌ½²â
        m_boTeleport := True;
        m_boProbeNecklace := True;
      end
      else if StdItem.Shape = 160 then
      begin //´«ËÍ¸´»î
        m_boTeleport := True;
        m_boRevival := True;
      end
      else if StdItem.Shape = 161 then
      begin //Âé±Ô¸´»î
        m_boParalysis := True;
        m_boRevival := True;
      end
      else if StdItem.Shape = 162 then
      begin //»¤Éí¸´»î
        m_boMagicShield := True;
        m_boRevival := True;
      end
      else if StdItem.Shape = 163 then
      begin //·ÀÂé±Ô´«ËÍ
        m_boUnParalysis := True;
        m_boTeleport := True;
      end
      else if StdItem.Shape = 164 then
      begin //·ÀÈ«Âé±Ô´«ËÍ
        m_boUnAllParalysis := True;
        m_boTeleport := True;
      end
      else if StdItem.Shape = 165 then
      begin
        m_boUnRevival := True;
        m_boUnMagicShield := True;
      end
      else if StdItem.Shape = 166 then
      begin
        m_boUnRevival := True;
        m_boUnAllParalysis := True;
      end
      else if StdItem.Shape = 167 then
      begin
        m_boUnMagicShield := True;
        m_boUnAllParalysis := True;
      end
      else if StdItem.Shape = 168 then
      begin
        m_boUnRevival := True;
        m_boUnMagicShield := True;
        m_boUnAllParalysis := True;
      end

      else if StdItem.Shape = 180 then
        m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate
      else if StdItem.Shape = 181 then
        m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate

      else if StdItem.Shape = 120 then
        m_boFastTrain := True
      else if StdItem.Shape = 121 then
        m_boProbeNecklace := True
      else if StdItem.Shape = 123 then
        boRecallSuite1 := True
      else if StdItem.Shape = 145 then
        m_boGuildMove := True
      else if StdItem.Shape = 127 then
        boSpirit1 := True
      else if StdItem.Shape = 135 then
      begin
        boMoXieSuite1 := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 138 then
      begin
        boHongMoSuite1 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 111 then
      begin
        m_wStatusTimeArr[STATE_TRANSPARENT] := g_MaxStatusTime;
        m_boHideMode := True;
      end
      else if StdItem.Shape = 112 then
        m_boTeleport := True
      else if StdItem.Shape = 113 then
        m_boParalysis := True
      else if StdItem.Shape = 114 then
        m_boRevival := True
      else if StdItem.Shape = 115 then
        boFlameRing := True
      else if StdItem.Shape = 116 then
        boRecoveryRing := True
      else if StdItem.Shape = 117 then
        m_boAngryRing := True
      else if StdItem.Shape = 118 then
        m_boMagicShield := True
      else if StdItem.Shape = 119 then
        m_boMuscleRing := True
      else if StdItem.Shape = 122 then
        boRecallSuite2 := True
      else if StdItem.Shape = 128 then
        boSpirit2 := True
      else if StdItem.Shape = 133 then
      begin
        boMoXieSuite2 := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 136 then
      begin
        boHongMoSuite2 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 124 then
        boRecallSuite3 := True
      else if StdItem.Shape = 126 then
        boSpirit3 := True
      else if StdItem.Shape = 145 then
        m_boGuildMove := True
      else if StdItem.Shape = 134 then
      begin
        boMoXieSuite3 := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 137 then
      begin
        boHongMoSuite3 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end
      else if StdItem.Shape = 125 then
        boRecallSuite4 := True
      else if StdItem.Shape = 129 then
        boSpirit4 := True
      else
      begin

      end;

      if (i <> U_WEAPON) and (StdItem.Reserved > 0) then
      begin
        case StdItem.Source of
          10: m_btAntiStone := _MIN(High(Byte), m_btAntiStone + StdItem.Reserved);
          11: m_btReduceSpellTime := _MIN(High(Byte), m_btReduceSpellTime + StdItem.Reserved);
        end;
      end;

      if (i = U_CHARM) then
      begin
        if StdItem.StdMode in [7, 53] then
        begin
          if StdItem.Shape > 0 then
            m_nAutoAddHPMPMode := StdItem.Shape
          else
            m_nAutoAddHPMPMode := StdItem.AniCount;
        end;
      end;
      if (i = U_BUJUK) then
      begin
        if StdItem.StdMode = 25 then
        begin
          if StdItem.Shape = 9 then
            m_boDrangonHeart := True;
        end;
      end;
    end;

    btSpSkillLv := GetTitleIndex();
    if btSpSkillLv > 0 then
    begin
      StdItem := UserEngine.GetTitle(btSpSkillLv);
      if StdItem <> nil then
      begin
        GetAccessory2(StdItem, m_AddAbil);

        if (StdItem.reserve[7] > 0) then
          Inc(nHPAdd, StdItem.reserve[7] * 100);

        if (StdItem.reserve[8] > 0) then
          Inc(nMPAdd, StdItem.reserve[8] * 100);

        if boIsPlayer and (g_FunctionNPC <> nil) and (m_btInitTitle = 0) then
        begin
          m_btInitTitle := 1;
          g_FunctionNPC.m_OprCount := 0;
          if IsHero then
            g_FunctionNPC.GotoLable(TPlayObject(m_Master), Format('@HeroTitleChanged_%d', [StdItem.Shape]), False)
          else
            g_FunctionNPC.GotoLable(TPlayObject(Self), Format('@TitleChanged_%d', [StdItem.Shape]), False);
        end;
      end;
    end;
  end;

  m_wInPowerRateEx := 0;
  if boHuman then
  begin
    ii := 0;
    for i := Low(IPI) to High(IPI) do
    begin
      if i in [U_DRESS, U_WEAPON, U_RIGHTHAND, U_BUJUK, U_CHARM, U_HELMETEX] then
        Continue;
      if (IPI[i] > 0) then
      begin
        Inc(ii);
        Inc(nInPowerRate, IPI[i]);
      end;
    end;
    //if nInPowerRate <> m_wInPowerRateEx then
    //  m_wInPowerRateEx := nInPowerRate;
    //¸½¼Ó
    if ii = 8 then
    begin //Í·¿ø+ÏîÁ´+»¤Íó*2+½äÖ¸*2+Ñü´ø+Ñ¥×Ó
      Inc(nInPowerRate, 50);
      m_wInPowerRateEx := m_wInPowerRateEx + 50;
    end
    else if (IPI[U_HELMET] > 0) and //Í·¿ø+ÏîÁ´+»¤Íó*2+½äÖ¸*2
      (IPI[U_NECKLACE] > 0) and
      (IPI[U_ARMRINGL] > 0) and (IPI[U_ARMRINGR] > 0) and
      (IPI[U_RINGL] > 0) and (IPI[U_RINGR] > 0) then
    begin
      Inc(nInPowerRate, 25);
      m_wInPowerRateEx := m_wInPowerRateEx + 25;
    end
    else if (IPI[U_HELMET] > 0) and //Í·¿ø+ÏîÁ´+Ñü´ø+Ñ¥×Ó
      (IPI[U_NECKLACE] > 0) and
      (IPI[U_BELT] > 0) and (IPI[U_BOOTS] > 0) then
    begin
      Inc(nInPowerRate, 20);
      m_wInPowerRateEx := m_wInPowerRateEx + 20;
    end
    else if (IPI[U_NECKLACE] > 0) and //ÏîÁ´+»¤Íó*2+½äÖ¸*2
      (IPI[U_ARMRINGL] > 0) and (IPI[U_ARMRINGR] > 0) and
      (IPI[U_RINGL] > 0) and (IPI[U_RINGR] > 0) then
    begin
      Inc(nInPowerRate, 15);
      m_wInPowerRateEx := m_wInPowerRateEx + 15;
    end
    else if (IPI[U_HELMET] > 0) and //Í·¿ø+Ñü´ø+Ñ¥×Ó
      (IPI[U_BELT] > 0) and (IPI[U_BOOTS] > 0) then
    begin
      Inc(nInPowerRate, 10);
      m_wInPowerRateEx := 10;
    end
    else if (IPI[U_NECKLACE] > 0) and //ÏîÁ´+»¤Íó*2(½äÖ¸*2)
      (((IPI[U_ARMRINGL] > 0) and (IPI[U_ARMRINGR] > 0)) or ((IPI[U_RINGL] > 0) and (IPI[U_RINGR] > 0))) then
    begin
      Inc(nInPowerRate, 5);
      m_wInPowerRateEx := m_wInPowerRateEx + 5;
    end
    else if (IPI[U_HELMET] > 0) and ((IPI[U_BELT] > 0) or (IPI[U_BOOTS] > 0)) then
    begin
      Inc(nInPowerRate, 3);
      m_wInPowerRateEx := m_wInPowerRateEx + 3;
    end;

    if nInPowerRate <> m_IPRecoverRate then
    begin
      m_IPRecoverRate := nInPowerRate;
    end;

    ///////////////////////////////////////////////////////////////////////////
    s := '';
    for i := 0 to g_SuiteItemsList.Count - 1 do
    begin
      PSuiteItems := pTSuiteItems(g_SuiteItemsList[i]);
      if aSuiteIdx[i] >= PSuiteItems^.nNeedCount then
      begin
        for ii := Low(TSuitSubRate) to High(TSuitSubRate) do
          Inc(naSuitSubRate[ii], PSuiteItems^.aSuitSubRate[ii]);
        if boAction then
        begin
          if (PSuiteItems^.sDesc <> '') and (Length(s) < SizeOf(s) - 1) then
            s := s + PSuiteItems^.sDesc + ' ';
        end;
      end;
    end;
    if boAction then
    begin
      if (s <> '') then
        SysMsg(s, c_Purple, t_Hint);
    end;
  end;

  if boHuman then
  begin
    if naSuitSubRate[14] > 0 then
      m_boParalysis := True;
    if naSuitSubRate[15] > 0 then
      m_boMagicShield := True;
    if naSuitSubRate[16] > 0 then
      m_boTeleport := True;
    if naSuitSubRate[17] > 0 then
      m_boRevival := True;
    if naSuitSubRate[18] > 0 then
      m_boMuscleRing := True;
    if naSuitSubRate[19] > 0 then
      m_boFastTrain := True;
    if naSuitSubRate[20] > 0 then
      m_boProbeNecklace := True;
    if naSuitSubRate[21] > 0 then
      Inc(m_nHongMoSuite, 100);
    if naSuitSubRate[22] > 0 then
    begin
      m_wStatusTimeArr[STATE_TRANSPARENT] := g_MaxStatusTime; //6 * 10 * 1000;
      m_boHideMode := True;
    end;
    if naSuitSubRate[23] > 0 then
      m_boUnParalysis := True;
    if naSuitSubRate[24] > 0 then
      m_boUnAllParalysis := True;
    if naSuitSubRate[25] > 0 then
      m_boUnRevival := True;
    if naSuitSubRate[26] > 0 then
      m_boUnMagicShield := True;
    if naSuitSubRate[27] > 0 then
      m_boRecallSuite := True;
    if naSuitSubRate[28] > 0 then
      m_boNoDropItem := True;
    if naSuitSubRate[29] > 0 then
      m_boNoDropUseItem := True;
  end;

  if boRecallSuite1 and boRecallSuite2 and boRecallSuite3 and boRecallSuite4 then
    m_boRecallSuite := True;
  if boMoXieSuite1 and boMoXieSuite2 and boMoXieSuite3 then
    Inc(m_nMoXieSuite, 50);
  if boHongMoSuite1 and boHongMoSuite2 and boHongMoSuite3 then
    Inc(m_AddAbil.wHitPoint, 2);
  if boSpirit1 and boSpirit2 and boSpirit3 and boSpirit4 then
    m_bopirit := True;

  m_WAbil.Weight := RecalcBagWeight();

  if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] > 0) then
    m_boHideMode := True;

  if m_boHideMode then
  begin
    if not boOldHideMode then
    begin
      m_nCharStatus := GetCharStatus();
      StatusChanged();
    end;
  end
  else
  begin
    if boOldHideMode then
    begin
      m_wStatusTimeArr[STATE_TRANSPARENT] := 0;
      m_nCharStatus := GetCharStatus();
      StatusChanged();
    end;
  end;

  if boHuman then
    RecalcHitSpeed();

  nOldLight := m_nLight;
  if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (m_UseItems[U_RIGHTHAND].Dura > 0) then
  begin
    StdItem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
    if StdItem <> nil then
    begin
      if g_Config.boMedalItemLight or (StdItem.Looks in [130, 131]) then
      begin
        if StdItem.Looks = 131 then
          m_nLight := 4
        else
          m_nLight := 3;
      end
      else
        m_nLight := 0;
    end
    else
      m_nLight := 0;
  end
  else
    m_nLight := 0;
  if nOldLight <> m_nLight then
    SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');

  m_btSpeedPoint := _MIN(High(Byte), m_btSpeedPoint + m_AddAbil.wSpeedPoint);
  m_btHitPoint := _MIN(High(Byte), m_btHitPoint + m_AddAbil.wHitPoint);
  m_btAntiPoison := _MIN(High(Byte), m_btAntiPoison + m_AddAbil.wAntiPoison);

  m_nPoisonRecover := _MIN(High(ShortInt), m_nPoisonRecover + m_AddAbil.wPoisonRecover);
  m_nHealthRecover := _MIN(High(ShortInt), m_nHealthRecover + m_AddAbil.wHealthRecover);
  m_nSpellRecover := _MIN(High(ShortInt), m_nSpellRecover + m_AddAbil.wSpellRecover);
  m_nAntiMagic := _MIN(High(ShortInt), m_nAntiMagic + m_AddAbil.wAntiMagic);
  //m_nLuck := _MIN(High(Byte), m_nLuck + m_AddAbil.btLuck);
  //m_nLuck := _MAX(0, m_nLuck - m_AddAbil.btUnLuck);
  Inc(m_nLuck, m_AddAbil.btLuck);
  Dec(m_nLuck, m_AddAbil.btUnLuck);
  m_nHitSpeed := m_AddAbil.nHitSpeed;

  if boHuman then
  begin
    if naSuitSubRate[SUIT_RATE_HITPOINT] > 0 then
      m_btHitPoint := _MIN(High(Byte), Round(m_btHitPoint * ((100 + naSuitSubRate[SUIT_RATE_HITPOINT]) / 100)));
    if naSuitSubRate[SUIT_RATE_SPEED] > 0 then
      m_btSpeedPoint := _MIN(High(Byte), Round(m_btSpeedPoint * ((100 + naSuitSubRate[SUIT_RATE_SPEED]) / 100)));
    if naSuitSubRate[SUIT_RATE_ANTIMAG] > 0 then
      m_nAntiMagic := _MIN(High(Byte), Round(m_nAntiMagic * ((100 + naSuitSubRate[SUIT_RATE_ANTIMAG]) / 100)));
    if naSuitSubRate[SUIT_RATE_ANTIPOISON] > 0 then
      m_btAntiPoison := _MIN(High(Byte), Round(m_btAntiPoison * ((100 + naSuitSubRate[SUIT_RATE_ANTIPOISON]) / 100)));
    if naSuitSubRate[SUIT_RATE_POISONRECOVER] > 0 then
      m_nPoisonRecover := _MIN(High(Byte), Round(m_nPoisonRecover * ((100 + naSuitSubRate[SUIT_RATE_POISONRECOVER]) / 100)));
    if naSuitSubRate[SUIT_RATE_HPRECOVER] > 0 then
      m_nHealthRecover := _MIN(High(Byte), Round(m_nHealthRecover * ((100 + naSuitSubRate[SUIT_RATE_HPRECOVER]) / 100)));
    if naSuitSubRate[SUIT_RATE_MPRECOVER] > 0 then
      m_nSpellRecover := _MIN(High(Byte), Round(m_nSpellRecover * ((100 + naSuitSubRate[SUIT_RATE_MPRECOVER]) / 100)));
  end;

  if m_btMagShieldLevel <> 0 then
    m_btSpeedPoint := _MIN(High(Byte), m_btSpeedPoint + m_btMagShieldLevel * 5);

  if boHuman then
  begin
    if TPlayObject(Self).m_wJobAbil > 0 then
    begin
      //Sysmsg(inttostr(TPlayObject(self).m_wJobAbil), c_blue, t_Hint);
      case m_btJob of
        0: m_AddAbil.wDC := MakeLong(LoWord(m_AddAbil.wDC) + TPlayObject(Self).m_wJobAbil div 2, HiWord(m_AddAbil.wDC) + TPlayObject(Self).m_wJobAbil);
        1: m_AddAbil.wMC := MakeLong(LoWord(m_AddAbil.wMC) + TPlayObject(Self).m_wJobAbil div 2, HiWord(m_AddAbil.wMC) + TPlayObject(Self).m_wJobAbil);
        2: m_AddAbil.wSC := MakeLong(LoWord(m_AddAbil.wSC) + TPlayObject(Self).m_wJobAbil div 2, HiWord(m_AddAbil.wSC) + TPlayObject(Self).m_wJobAbil);
      end;
    end;

    if g_Config.boHumanAttribute then
    begin
      if (naSuitSubRate[SUIT_RATE_MAXHP] > 0) then
        m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxHP + m_AddAbil.wHP) / 100 * (m_nAddHPMPRate + naSuitSubRate[SUIT_RATE_MAXHP])))
      else
        m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxHP + m_AddAbil.wHP) / 100 * m_nAddHPMPRate));
      if (naSuitSubRate[SUIT_RATE_MAXMP] > 0) then
        m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxMP + m_AddAbil.wMP) / 100 * (m_nAddHPMPRate + naSuitSubRate[SUIT_RATE_MAXMP])))
      else
        m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxMP + m_AddAbil.wMP) / 100 * m_nAddHPMPRate));
    end
    else
    begin
      if (naSuitSubRate[SUIT_RATE_MAXHP] > 0) then
        m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxHP + m_AddAbil.wHP) / 100 * ((100 + naSuitSubRate[SUIT_RATE_MAXHP]))))
      else
        m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_Abil.MaxHP + m_AddAbil.wHP);
      if (naSuitSubRate[SUIT_RATE_MAXMP] > 0) then
        m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, Round((m_Abil.MaxMP + m_AddAbil.wMP) / 100 * ((100 + naSuitSubRate[SUIT_RATE_MAXMP]))))
      else
        m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_Abil.MaxMP + m_AddAbil.wMP);
    end;

    if (naSuitSubRate[SUIT_RATE_AC] > 0) then
      m_WAbil.AC := MakeLong(Round((LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC)) * ((100 + naSuitSubRate[SUIT_RATE_AC]) / 100)), Round((HiWord(m_AddAbil.wAC) + HiWord(m_Abil.AC)) * ((100 + naSuitSubRate[SUIT_RATE_AC]) / 100)))
    else
      m_WAbil.AC := MakeLong(LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC), HiWord(m_AddAbil.wAC) + HiWord(m_Abil.AC));

    if (naSuitSubRate[SUIT_RATE_MAC] > 0) then
      m_WAbil.MAC := MakeLong(Round((LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC)) * ((100 + naSuitSubRate[SUIT_RATE_MAC]) / 100)), Round((HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC)) * ((100 + naSuitSubRate[SUIT_RATE_MAC]) / 100)))
    else
      m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC), HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));

    if (naSuitSubRate[SUIT_RATE_DC] > 0) then
      m_WAbil.DC := MakeLong(Round((LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC)) * ((100 + naSuitSubRate[SUIT_RATE_DC]) / 100)), Round((HiWord(m_AddAbil.wDC) + HiWord(m_Abil.DC)) * ((100 + naSuitSubRate[SUIT_RATE_DC]) / 100)))
    else
      m_WAbil.DC := MakeLong(LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC), HiWord(m_AddAbil.wDC) + HiWord(m_Abil.DC));

    if (naSuitSubRate[SUIT_RATE_MC] > 0) then
      m_WAbil.MC := MakeLong(Round((LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC)) * ((100 + naSuitSubRate[SUIT_RATE_MC]) / 100)), Round((HiWord(m_AddAbil.wMC) + HiWord(m_Abil.MC)) * ((100 + naSuitSubRate[SUIT_RATE_MC]) / 100)))
    else
      m_WAbil.MC := MakeLong(LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC), HiWord(m_AddAbil.wMC) + HiWord(m_Abil.MC));

    if (naSuitSubRate[SUIT_RATE_SC] > 0) then
      m_WAbil.SC := MakeLong(Round((LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC)) * ((100 + naSuitSubRate[SUIT_RATE_SC]) / 100)), Round((HiWord(m_AddAbil.wSC) + HiWord(m_Abil.SC)) * ((100 + naSuitSubRate[SUIT_RATE_SC]) / 100)))
    else
      m_WAbil.SC := MakeLong(LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC), HiWord(m_AddAbil.wSC) + HiWord(m_Abil.SC));

    if m_wStatusTimeArr[STATE_DEFENCEUP] > 0 then
    begin
      if m_DefenceRate > 0 then
        m_WAbil.AC := MakeLong(Round(LoWord(m_WAbil.AC) * (20 + m_DefenceRate) / 20), Round(HiWord(m_WAbil.AC) * m_DefenceRate / 20) + HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div 7))
      else
        m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div 7));
    end;
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then
    begin
      if m_MagDefenceRate > 0 then
        m_WAbil.MAC := MakeLong(Round(LoWord(m_WAbil.MAC) * (20 + m_MagDefenceRate) / 20), Round(HiWord(m_WAbil.MAC) * m_MagDefenceRate / 20) + HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level div 7))
      else
        m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level div 7))
    end;
    //0406
    if (m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] > 0) and not m_boAbilMagBubbleDefence then
    begin
      if m_MagicArr[0][31] <> nil then
      begin
        m_boAbilMagBubbleDefence := True;
        m_btMagBubbleDefenceLevel := _MIN(4, m_MagicArr[0][31].btLevel);
      end
      else if m_MagicArr[0][73] <> nil then
      begin
        m_boAbilMagBubbleDefence := True;
        m_btMagBubbleDefenceLevel := _MIN(4, m_MagicArr[0][73].btLevel);
      end
      else
      begin
        m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] := 1;
      end;
    end;
  end;
  //if m_wStatusTimeArr[POISON_PURPLE] > 0 then m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) * 2);

  //////////////////////////////////////////
  if boIsPlayer then
  begin
    if (m_nInPowerLevel > 0) then
    begin
      m_AddDamage := 06 + Round((m_nInPowerLevel div 8) / 100 * g_Config.nInternalPowerRate);
      m_DecDamage := 12 + Round((m_nInPowerLevel div 8) / 100 * g_Config.nInternalPowerRate2);
{$IF SERIESSKILL}
      lac := 0;
      hac := 0;
      lmac := 0;
      hmac := 0;
      for i := Low(TPlayObject(Self).m_VenationInfos) to High(TPlayObject(Self).m_VenationInfos) do
      begin
        case TPlayObject(Self).m_VenationInfos[i].Level of //
          3: Inc(lmac);
          4: Inc(lac);
          5: Inc(m_DecDamage, 2); //ÎüÊÕÉËº¦+2
          6: Inc(m_DecDamage, 3); //ÎüÊÕÉËº¦+3
        end;
        for ii := 1 to 5 do
        begin
          if TPlayObject(Self).m_VenationInfos[i].Point >= ii then
          begin
            case ii of //point
              1: case i of //ven
                  0: Inc(hac, 3);
                  1: Inc(hmac, 2);
                  2: Inc(lac, 1);
                end;
              2: case i of
                  0: Inc(hmac, 3);
                  1: Inc(lac, 2);
                  2: Inc(lmac, 1);
                end;
              3: case i of
                  0: Inc(lac, 3);
                  1: Inc(lmac, 2);
                end;
              4: case i of
                  0: Inc(lmac, 3);
                  1: Inc(hac, 1);
                end;
              5: case i of
                  0: Inc(hac, 2);
                  1: Inc(hmac, 1);
                end;
            end;
          end;
        end;
      end;
      if (lac > 0) or (hac > 0) then
        m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + lac, HiWord(m_WAbil.AC) + hac);
      if (lmac > 0) or (hmac > 0) then
        m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + lmac, HiWord(m_WAbil.MAC) + hmac);
{$IFEND SERIESSKILL}
    end;

  end;

  if m_wStatusArrValue[0] > 0 then
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2 + m_wStatusArrValue[0]);
  if m_wStatusArrValue[1] > 0 then
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + 2 + m_wStatusArrValue[1]);
  if m_wStatusArrValue[2] > 0 then
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + 2 + m_wStatusArrValue[2]);
  if m_wStatusArrValue[3] > 0 then
    Inc(m_nHitSpeed, m_wStatusArrValue[3]);
  if m_wStatusArrValue[4] > 0 then
    m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_wStatusArrValue[4]);
  if m_wStatusArrValue[5] > 0 then
    m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_wStatusArrValue[5]);
  if m_wStatusArrValue[6] > 0 then
  begin
    if HiWord(m_WAbil.DC) > (2 + m_wStatusArrValue[6]) then
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) - 2 - m_wStatusArrValue[6])
    else
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), 0);
  end;

  if m_wStatusArrValue2[0] > 0 then
    m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_wStatusArrValue2[0]);
  if m_wStatusArrValue2[1] > 0 then
    m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_wStatusArrValue2[1]);
  if m_wStatusArrValue2[2] > 0 then
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + (m_wStatusArrValue2[2] div 2), HiWord(m_WAbil.AC) + m_wStatusArrValue2[2]);
  if m_wStatusArrValue2[3] > 0 then
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + (m_wStatusArrValue2[3] div 2), HiWord(m_WAbil.MAC) + m_wStatusArrValue2[3]);
  if m_wStatusArrValue2[4] > 0 then
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + (m_wStatusArrValue2[4] div 2), HiWord(m_WAbil.DC) + m_wStatusArrValue2[4]);
  if m_wStatusArrValue2[5] > 0 then
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + (m_wStatusArrValue2[5] div 2), HiWord(m_WAbil.MC) + m_wStatusArrValue2[5]);
  if m_wStatusArrValue2[6] > 0 then
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + (m_wStatusArrValue2[6] div 2), HiWord(m_WAbil.SC) + m_wStatusArrValue2[6]);

  if boIsPlayer then
  begin
    //if m_boFlameRing <> boFlameRing then begin
    m_boFlameRing := boFlameRing;
    if m_boFlameRing then
      AddItemSkill(1)
    else
      DelItemSkill(1);
    //end;

    //if boRecoveryRing <> m_boRecoveryRing then begin
    m_boRecoveryRing := boRecoveryRing;
    if m_boRecoveryRing then
      AddItemSkill(2)
    else
      DelItemSkill(2);
    //end;

    if btDragonRageSkill > 0 then
      AddItemSkillEx(118, btDragonRageSkill - 1)
    else
      DelItemSkillEx(118);

    if (m_btWeaponSkill = 2) or (m_btSpSkill4 >= 100) then
    begin
      btSpSkillLv := 0;
      if m_btSpSkill4 >= 100 then
        btSpSkillLv := m_btSpSkill4 mod 100;
      if (btSpSkillLv < 3) and (m_btWeaponSkill = 2) then
        btSpSkillLv := 3;
      AddItemSkillEx(114, btSpSkillLv);
    end
    else
    begin
      DelItemSkillEx(114);
    end;
  end;

  if m_boMuscleRing then
  begin
    m_WAbil.MaxWeight := _MIN(High(Word), m_WAbil.MaxWeight + m_WAbil.MaxWeight);
    m_WAbil.MaxWearWeight := _MIN(High(Word), m_WAbil.MaxWearWeight + m_WAbil.MaxWearWeight);
    m_WAbil.MaxHandWeight := _MIN(High(Word), m_WAbil.MaxHandWeight + m_WAbil.MaxHandWeight);
  end;

  if m_nMoXieSuite > 0 then
  begin
    if m_WAbil.MaxMP <= m_nMoXieSuite then
      m_nMoXieSuite := m_WAbil.MaxMP - 1;

    Dec(m_WAbil.MaxMP, m_nMoXieSuite);
    m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_nMoXieSuite);
  end;

  if boHuman then
  begin
    SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');

    for i := Low(Vam) to High(Vam) do
    begin
      if i in [U_WEAPON] then
        Continue;
      if (Vam[i] > 0) then
      begin
        Inc(m_wVampire, Vam[i]);
        Inc(m_btSuckRate, 4);
      end;
    end;
    //Í·¿ø+ÏîÁ´+»¤Íó+½äÖ¸+Ñü´ø+Ñ¥×Ó
    if (Vam[U_HELMET] > 0) and
      (Vam[U_NECKLACE] > 0) and
      ((Vam[U_ARMRINGL] > 0) or (Vam[U_ARMRINGR] > 0)) and
      ((Vam[U_RINGL] > 0) or (Vam[U_RINGR] > 0)) and
      (Vam[U_BELT] > 0) and
      (Vam[U_BOOTS] > 0) then
    begin
      m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC) + 5), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC) + 5));
      m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC) + 5), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC) + 5));
      m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC) + 10));
      m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC) + 10));
      m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC) + 10));
      Inc(m_wVampire, m_wVampire);
      m_btSuckRate := 68;
    end;

    if boIsPlayer then
    begin
      for i := Low(Vam2) to High(Vam2) do
      begin
        if i in [U_WEAPON] then
          Continue;
        if (Vam2[i] > 0) then
        begin
         Inc(m_wVampire2, Vam2[i]);
        end;
      end;
      //Í·¿ø+ÏîÁ´+»¤Íó+½äÖ¸+Ñü´ø+Ñ¥×Ó
      if (Vam2[U_HELMET] > 0) and
        (Vam2[U_NECKLACE] > 0) and
        ((Vam2[U_ARMRINGL] > 0) or (Vam2[U_ARMRINGR] > 0)) and
        ((Vam2[U_RINGL] > 0) or (Vam2[U_RINGR] > 0)) and
        (Vam2[U_BELT] > 0) and
        (Vam2[U_BOOTS] > 0) then
      begin
        Inc(m_wVampire2, 40);
        Inc(TPlayObject(Self).m_nTagDropPlus, 10);
      end
      else if (Vam2[U_HELMET] > 0) and
        (Vam2[U_NECKLACE] > 0) and
        ((Vam2[U_ARMRINGL] > 0) or (Vam2[U_ARMRINGR] > 0)) and
        ((Vam2[U_RINGL] > 0) or (Vam2[U_RINGR] > 0)) then
      begin
        Inc(m_wVampire2, 30);
        Inc(TPlayObject(Self).m_nTagDropPlus, 6);
      end
      else if (Vam2[U_HELMET] > 0) and
        (Vam2[U_NECKLACE] > 0) and
        (Vam2[U_BELT] > 0) and
        (Vam2[U_BOOTS] > 0) then
      begin
        Inc(m_wVampire2, 25);
        Inc(TPlayObject(Self).m_nTagDropPlus, 3);
      end
      else if (Vam2[U_NECKLACE] > 0) and
        ((Vam2[U_ARMRINGL] > 0) or (Vam2[U_ARMRINGR] > 0)) and
        ((Vam2[U_RINGL] > 0) or (Vam2[U_RINGR] > 0)) then
      begin
        Inc(m_wVampire2, 20);
      end
      else if (Vam2[U_HELMET] > 0) and
        (Vam2[U_BELT] > 0) and
        (Vam2[U_BOOTS] > 0) then
      begin
        Inc(m_wVampire2, 15);
      end
      else if (Vam2[U_NECKLACE] > 0) and
        (((Vam2[U_ARMRINGL] > 0) or (Vam2[U_ARMRINGR] > 0)) or
        ((Vam2[U_RINGL] > 0) or (Vam2[U_RINGR] > 0))) then
      begin
        Inc(m_wVampire2, 10);
      end
      else if (Vam2[U_HELMET] > 0) and
        ((Vam2[U_BELT] > 0) or (Vam2[U_BOOTS] > 0)) then
      begin
        Inc(m_wVampire2, 8);
      end;

      //slegend
      //Í·¿ø+ÏîÁ´+»¤Íó+½äÖ¸+Ñü´ø+Ñ¥×Ó
      if slegend[U_WEAPON] > 0 then
      begin
        if (slegend[U_HELMET] > 0) and
          (slegend[U_HELMETEX] > 0) and
          (slegend[U_RIGHTHAND] > 0) and
          (slegend[U_NECKLACE] > 0) and
          ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
          ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) and
          (slegend[U_BELT] > 0) and
          (slegend[U_BOOTS] > 0) then
        begin
          recallmoblv := 3;
        end
        else if (slegend[U_HELMET] > 0) and
          (slegend[U_NECKLACE] > 0) and
          ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
          ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) and
          (slegend[U_BELT] > 0) and
          (slegend[U_BOOTS] > 0) then
        begin
          recallmoblv := 2;
        end
        else if (slegend[U_HELMET] > 0) and
          (slegend[U_HELMETEX] > 0) and
          (slegend[U_RIGHTHAND] > 0) and
          (slegend[U_BELT] > 0) and
          (slegend[U_BOOTS] > 0) then
        begin
          recallmoblv := 2;
        end
        else if (slegend[U_HELMET] > 0) and
          (slegend[U_BELT] > 0) and
          (slegend[U_BOOTS] > 0) then
        begin
          recallmoblv := 1;
        end
        else if (slegend[U_NECKLACE] > 0) and
          ((slegend[U_ARMRINGL] > 0) or (slegend[U_ARMRINGR] > 0)) and
          ((slegend[U_RINGL] > 0) or (slegend[U_RINGR] > 0)) then
        begin
          recallmoblv := 1;
        end
        else if (slegend[U_HELMETEX] > 0) and
          (slegend[U_RIGHTHAND] > 0) and
          (slegend[U_DRESS] > 0) then
        begin
          recallmoblv := 1;
        end;
      end;

      //ÕÙ»½¾ÞÄ§
      if (recallmoblv > 0) or (m_btSpSkill2 >= 100) then
      begin
        btSpSkillLv := 0;
        if m_btSpSkill2 >= 100 then
          btSpSkillLv := m_btSpSkill2 mod 100;
        if (btSpSkillLv < recallmoblv) and (recallmoblv > 0) then
          btSpSkillLv := recallmoblv;
        AddItemSkillEx(69, btSpSkillLv);
      end
      else
      begin
        DelItemSkillEx(69);
      end;

      //ÉñÁú¸½Ìå
      if (m_btSkill77 > 0) or (m_btSpSkill3 >= 100) then
      begin
        btSpSkillLv := 0;
        if m_btSpSkill3 >= 100 then
          btSpSkillLv := m_btSpSkill3 mod 100;
        if (btSpSkillLv < m_btSkill77 - 1) and (m_btSkill77 > 0) then
          btSpSkillLv := m_btSkill77 - 1;
        AddItemSkillEx(77, btSpSkillLv);
      end
      else
      begin
        DelItemSkillEx(77);
      end;

      //Î¨ÎÒ¶À×ð
      {if (m_btSpSkill1 >= 100) then begin
        AddItemSkillEx(78, m_btSpSkill1 mod 100);
      end else begin
        DelItemSkillEx(78);
      end;}

      if (m_btWeaponSkill = 3) or (m_btSpSkill1 >= 100) then
      begin
        btSpSkillLv := 0;
        if m_btSpSkill1 >= 100 then
          btSpSkillLv := m_btSpSkill1 mod 100;
        if (btSpSkillLv < 3) and (m_btWeaponSkill = 3) then
          btSpSkillLv := 3;
        AddItemSkillEx(78, btSpSkillLv);
      end
      else
      begin
        DelItemSkillEx(78);
      end;

      //if (tbtWeaponSkill in [230..255]) then begin
      //  tbtWeaponSkill := StdItem.AniCount;
      //end;

    end;
  end;

  if boIsPlayer then
  begin
    if naSuitSubRate[30] > 0 then
    begin //ÄÚ¹¦»Ö¸´
      nInPowerRate := _MIN(High(Byte), nInPowerRate + naSuitSubRate[30]);
      if nInPowerRate <> m_IPRecoverRate then
        m_IPRecoverRate := nInPowerRate;
    end;
    if naSuitSubRate[31] > 0 then
    begin //±©»÷
      m_btHitPowerAddOn := _MIN(High(Byte), m_btHitPowerAddOn + naSuitSubRate[31]);
    end;
    if naSuitSubRate[32] > 0 then
    begin //PKÄ¿±ê±©ÂÊ
      TPlayObject(Self).m_nTagDropPlus := _MIN(High(Word), TPlayObject(Self).m_nTagDropPlus + naSuitSubRate[32]);
    end;
    if naSuitSubRate[33] > 0 then
    begin //·À±¬
      TPlayObject(Self).m_nPreventDrop := _MIN(High(Word), TPlayObject(Self).m_nPreventDrop + naSuitSubRate[33]);
    end;
  end;

  if boHuman then
  begin
    if naSuitSubRate[34] > 0 then //ºöÊÓ
      m_btIgnoreTagDefence := _MIN(100, m_btIgnoreTagDefence + naSuitSubRate[34]);

    if naSuitSubRate[35] > 0 then //ÔöÉË
      m_btDamageAddOn := _MIN(High(Byte), m_btDamageAddOn + naSuitSubRate[35]);

    if naSuitSubRate[36] > 0 then //·´Éä
      m_btDamageRebound := _MIN(100, m_btDamageRebound + naSuitSubRate[36]);

    if naSuitSubRate[37] > 0 then //Îï¼õ
      m_btACDamageReduction := _MIN(100, m_btACDamageReduction + naSuitSubRate[37]);

    if naSuitSubRate[38] > 0 then //Ä§¼õ
      m_btMCDamageReduction := _MIN(100, m_btMCDamageReduction + naSuitSubRate[38]);

    if naSuitSubRate[39] > 0 then //Ä§¼õ
      m_btGetExpExRate := _MIN(High(Byte), m_btGetExpExRate + naSuitSubRate[39]);
  end;

  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_HERO) then
    MonsterRecalcAbilitys();

  if g_Config.boHumanAttribute then
  begin
    m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC)));
    m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC)));
    m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.DC) * m_nAddPowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.DC) * m_nAddPowerRate / 100)));
    m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.MC) * m_nAddPowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.MC) * m_nAddPowerRate / 100)));
    m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.SC) * m_nAddPowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.SC) * m_nAddPowerRate / 100)));
  end
  else
  begin
    m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC)));
    m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC)));
    m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC)));
    m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC)));
    m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC)));
  end;

  if m_nCursePowerRate <> 100 then
  begin
    m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.DC) * m_nCursePowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.DC) * m_nCursePowerRate / 100)));
    m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.MC) * m_nCursePowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.MC) * m_nCursePowerRate / 100)));
    m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, Round(LoWord(m_WAbil.SC) * m_nCursePowerRate / 100)), _MIN(MAXHUMPOWER, Round(HiWord(m_WAbil.SC) * m_nCursePowerRate / 100)));
    m_WAbil.AC := MakeLong(0, 1);
  end;

{$IF (SoftVersion = VERPRO) or (SoftVersion = VERENT)}
  if (m_btRaceServer = RC_PLAYOBJECT) and g_Config.boHungerSystem and g_Config.boHungerDecPower then
  begin
    case TPlayObject(Self).m_nHungerStatus of
      0..999:
        begin
          m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC) * 0.2), Round(HiWord(m_WAbil.DC) * 0.2));
          m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC) * 0.2), Round(HiWord(m_WAbil.MC) * 0.2));
          m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC) * 0.2), Round(HiWord(m_WAbil.SC) * 0.2));
        end;
      1000..1999:
        begin
          m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC) * 0.4), Round(HiWord(m_WAbil.DC) * 0.4));
          m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC) * 0.4), Round(HiWord(m_WAbil.MC) * 0.4));
          m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC) * 0.4), Round(HiWord(m_WAbil.SC) * 0.4));
        end;
      2000..2999:
        begin
          m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC) * 0.6), Round(HiWord(m_WAbil.DC) * 0.6));
          m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC) * 0.6), Round(HiWord(m_WAbil.MC) * 0.6));
          m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC) * 0.6), Round(HiWord(m_WAbil.SC) * 0.6));
        end;
      3000..3999:
        begin
          m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC) * 0.9), Round(HiWord(m_WAbil.DC) * 0.9));
          m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC) * 0.9), Round(HiWord(m_WAbil.MC) * 0.9));
          m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC) * 0.9), Round(HiWord(m_WAbil.SC) * 0.9));
        end;
    end;
  end;
{$IFEND}
  for i := Low(m_wPowerRate) to High(m_wPowerRate) do
  begin
    case i of
      0: m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC) * (m_wPowerRate[i] + 1)));
      1: m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC) * (m_wPowerRate[i] + 1)));
      2: m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC) * (m_wPowerRate[i] + 1)));
      3: m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC) * (m_wPowerRate[i] + 1)));
      4: m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC) * (m_wPowerRate[i] + 1)));
      5: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP * (m_wPowerRate[i] + 1));
      6: m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP * (m_wPowerRate[i] + 1));
    end;
  end;

  if g_Config.tiSpSkillAddHPMax and (m_MagicArr[0][67] <> nil) and (m_MagicArr[0][67].btLevel > 0) then
  begin
    case m_btJob of
      0: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_MagicArr[0][67].btLevel * 200);
      1: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_MagicArr[0][67].btLevel * 060);
      2: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_MagicArr[0][67].btLevel * 140);
    end;
  end;
  if g_Config.tiHPSkillAddHPMax and (m_wHPAddLevel > 0) then
  begin
    case m_btJob of
      0: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_wHPAddLevel * g_Config.tiAddHealthPlus_0);
      1: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_wHPAddLevel * g_Config.tiAddHealthPlus_1);
      2: m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_wHPAddLevel * g_Config.tiAddHealthPlus_2);
    end;
  end;
  if g_Config.tiMPSkillAddMPMax and (m_wMPAddLevel > 0) then
  begin
    case m_btJob of
      0: m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_wMPAddLevel * g_Config.tiAddSpellPlus_0);
      1: m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_wMPAddLevel * g_Config.tiAddSpellPlus_1);
      2: m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_wMPAddLevel * g_Config.tiAddSpellPlus_2);
    end;
  end;

  if boHuman then
  begin
    if nHPAdd > 0 then
      m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + nHPAdd);
    if nMPAdd > 0 then
      m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + nMPAdd);
  end;

  if m_wStatusTimeArr[POISON_7] > 0 then
  begin
    m_WAbil.AC := 0;
    m_WAbil.MAC := 0;
  end;
  if (mhp <> m_WAbil.MaxHP) or (mmp <> m_WAbil.MaxMP) then
    HealthSpellChanged();

  if not boIsPlayer then
  begin
    if m_spMonAbil.btIgnoreTagDefence > 0 then //ºöÊÓ
      m_btIgnoreTagDefence := _MIN(100, m_btIgnoreTagDefence + m_spMonAbil.btIgnoreTagDefence);

    if m_spMonAbil.btDamageAddOn > 0 then //ÔöÉË
      m_btDamageAddOn := _MIN(High(Byte), m_btDamageAddOn + m_spMonAbil.btDamageAddOn);

    if m_spMonAbil.btDamageRebound > 0 then //·´Éä
      m_btDamageRebound := _MIN(100, m_btDamageRebound + m_spMonAbil.btDamageRebound);

    if m_spMonAbil.btACDamageReduction > 0 then //Îï¼õ
      m_btACDamageReduction := _MIN(100, m_btACDamageReduction + m_spMonAbil.btACDamageReduction);

    if m_spMonAbil.btMCDamageReduction > 0 then //Ä§¼õ
      m_btMCDamageReduction := _MIN(100, m_btMCDamageReduction + m_spMonAbil.btMCDamageReduction);

    if m_spMonAbil.boMonParalysis then
      m_boParalysis := True;
    if m_spMonAbil.boMonUnParalysis then
      m_boUnParalysis := True;
    if m_spMonAbil.boMonUnAllParalysis then
      m_boUnAllParalysis := True;
    if m_spMonAbil.boMonUnRevival then
      m_boUnRevival := True;
    if m_spMonAbil.boMonUnMagicShield then
      m_boUnMagicShield := True;
  end;
end;

procedure TBaseObject.BreakOpenHealth();
begin
  if m_boShowHP then
  begin
    m_boShowHP := False;
    m_nCharStatusEx := m_nCharStatusEx xor STATE_OPENHEATH;
    m_nCharStatus := GetCharStatus();
    SendRefMsg(RM_CLOSEHEALTH, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.MakeOpenHealth();
begin
  m_boShowHP := True;
  m_nCharStatusEx := m_nCharStatusEx or STATE_OPENHEATH;
  m_nCharStatus := GetCharStatus();
  SendRefMsg(RM_OPENHEALTH, 0, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
end;

procedure TBaseObject.IncHealthSpell(nHP, nMP: Integer);
begin
  if (nHP < 0) or (nMP < 0) then
    Exit;
  if m_WAbil.HP > 0 then
  begin
    if (m_WAbil.HP + nHP) > m_WAbil.MaxHP then
      m_WAbil.HP := m_WAbil.MaxHP
    else
      Inc(m_WAbil.HP, nHP);
  end;

  if (m_WAbil.MP + nMP) > m_WAbil.MaxMP then
    m_WAbil.MP := m_WAbil.MaxMP
  else
    Inc(m_WAbil.MP, nMP);
  HealthSpellChanged();
end;

procedure TBaseObject.IncHealthSpellEx(nHP, nMP: Integer);
var
  i: Integer;
begin
  if (nHP < 0) or (nMP < 0) then
    Exit;
  for i := m_SlaveList.Count - 1 downto 0 do
  begin
    if (TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO) and (TBaseObject(m_SlaveList.Items[i]).m_Master = Self) then
    begin
      if (TBaseObject(m_SlaveList.Items[i]).m_WAbil.HP + nHP) >= TBaseObject(m_SlaveList.Items[i]).m_WAbil.MaxHP then
        TBaseObject(m_SlaveList.Items[i]).m_WAbil.HP := TBaseObject(m_SlaveList.Items[i]).m_WAbil.MaxHP
      else
        Inc(TBaseObject(m_SlaveList.Items[i]).m_WAbil.HP, nHP);
      if (TBaseObject(m_SlaveList.Items[i]).m_WAbil.MP + nMP) >= TBaseObject(m_SlaveList.Items[i]).m_WAbil.MaxMP then
        TBaseObject(m_SlaveList.Items[i]).m_WAbil.MP := TBaseObject(m_SlaveList.Items[i]).m_WAbil.MaxMP
      else
        Inc(TBaseObject(m_SlaveList.Items[i]).m_WAbil.MP, nMP);
      TBaseObject(m_SlaveList.Items[i]).HealthSpellChanged();
    end;
  end;
end;

procedure TBaseObject.ItemDamageRevivalRing();
var
  i: Integer;
  pSItem: pTStdItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
begin
  if ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) or (IsHero and TPlayObject(m_Master).m_boOffLinePlay) then
    Exit;
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if m_UseItems[i].wIndex > 0 then
    begin
      pSItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if (pSItem <> nil) then
      begin
        if (pSItem.StdMode = 2) and (pSItem.Source <> 0) then
          Continue;
        if (pSItem.Shape in [114, 160, 161, 162]) or (((i = U_WEAPON) or (i = U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then
        begin
          nDura := m_UseItems[i].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then
          begin
            nDura := 0;
            m_UseItems[i].Dura := nDura;
            if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            begin
              PlayObject := TPlayObject(Self);
              if (PCardinal(@m_UseItems[i].btValue[22])^ > 0) and
                (PCardinal(@m_UseItems[i].btValue[22])^ = PlayObject.m_dwIdCRC) and g_Config.boBindNoMelt then
              begin
                if tDura <> Round(nDura / 1000) then
                begin
                  SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
                  SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÊôÐÔÒÑ¾­Ê§Ð§£¬Çë¼°Ê±ÐÞÀí', [pSItem.Name]), c_Red, t_Hint);
                end;
              end
              else
              begin
                if pSItem.NeedIdentify = 1 then
                  AddGameDataLogAPI('3' + #9 +
                    m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 +
                    IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 +
                    pSItem.Name + #9 +
                    IntToStr(m_UseItems[i].MakeIndex) + #9 +
                    BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                    '0');
                PlayObject.SendDelItems(@m_UseItems[i]);
                m_UseItems[i].wIndex := 0;
              end;
            end
            else
              m_UseItems[i].wIndex := 0;
            RecalcAbilitys();
            FeatureChanged();
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
          end
          else
            m_UseItems[i].Dura := nDura;
          if tDura <> Round(nDura / 1000) then
            SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
        end;
      end;
    end;
  end;
end;

procedure TBaseObject.Run();
var
  i, nAddLevel: Integer;
  boChg, boNeedRecalc: Boolean;
  nHP, nMP, nAddPoint: Integer;
  dwC, dwInChsTime: LongWord;
  ProcessMsg: TProcessMessage;
  BaseObject: TBaseObject;
  nCheckCode: Integer;
  dwRunTick: LongWord;
  nInteger: Integer;
  sMsg: string;
  StdItem: pTStdItem;
  UserMagic: pTUserMagic;
  dwMakeGhostTime: LongWord;

  dwCheckTick: LongWord;
  nBase: Integer;
  dwCheckTickSpell: LongWord;
  nBaseSpell: Integer;


resourcestring
  sExceptionMsg0 = '[Exception] TBaseObject::Run ProcessMsg Ident:%d';
  sExceptionMsg1 = '[Exception] TBaseObject::Run 1';
  sExceptionMsg2 = '[Exception] TBaseObject::Run 2';
  sExceptionMsg3 = '[Exception] TBaseObject::Run 3 Code:%d';
  sExceptionMsg4 = '[Exception] TBaseObject::Run 4 Code:%d';
  sExceptionMsg5 = '[Exception] TBaseObject::Run 5';
  sExceptionMsg6 = '[Exception] TBaseObject::Run 6';
  sExceptionMsg7 = '[Exception] TBaseObject::Run 7';
  sExceptionMsg8 = '[Exception] TBaseObject::Run 8';
begin
  dwRunTick := GetTickCount();

  //if not m_boDeath then begin           //0901
  //nInteger := 0;
  //try
  while GetMessage(@ProcessMsg) do
  begin
    //nInteger := ProcessMsg.wIdent;
    Operate(@ProcessMsg);
  end;
  {except
    on E: Exception do begin
      MainOutMessageAPI(Format(sExceptionMsg0, [nInteger]));
      MainOutMessageAPI(E.Message);
    end;
  end;}
  //end;

  try
//    if m_boDeath and m_boCanReAlive and m_boInvisible {and (m_Master = nil)} and (m_pMonGen <> nil) then begin
//      if GetTickCount - m_dwReAliveTick > UsrEngn.GetZenTime(m_pMonGen.dwZenTime) then begin
//        m_dwReAliveTick := GetTickCount;
//        m_boInvisible := False;
//        ReAliveEx(m_pMonGen);
//      end;
//    end;

    if m_boSuperMan then
    begin
      m_WAbil.HP := m_WAbil.MaxHP;
      m_WAbil.MP := m_WAbil.MaxMP;
    end;

    dwC := (GetTickCount - m_dwHPMPTick) div 20;
    m_dwHPMPTick := GetTickCount();
    if dwC > 0 then
    begin
      Inc(m_nHealthTick, dwC);
      Inc(m_nSpellTick, dwC);
    end;

    if not m_boDeath then
    begin
      boChg := False;
      if m_WAbil.HP > 0 then
      begin
        if (m_WAbil.HP < m_WAbil.MaxHP)  then
        begin
          //ÐÞ¸Ä³É·ÖÖ°Òµ+ÈËÎï/Ó¢ÐÛ/¹ÖÎï ·Ö±ðÊÊÅä²»Í¬µÄ»ØÑª·½°¸  2019-11-12
          if (m_btRaceServer = RC_PLAYOBJECT) then //ÈËÎïÕ½Ê¿
          begin
            case m_btJob of
              1:
                begin
                  dwCheckTick := g_Config.nHealthFillTime_HUMAN_WIZARD;
                  nBase := g_Config.nHealthFillBasic_HUMAN_WIZARD;
                end;
              2:
                begin
                  dwCheckTick := g_Config.nHealthFillTime_HUMAN_TAOIST;
                  nBase := g_Config.nHealthFillBasic_HUMAN_TAOIST;
                end;
            else
              dwCheckTick := g_Config.nHealthFillTime_HUMAN_WARRIOR;
              nBase := g_Config.nHealthFillBasic_HUMAN_WARRIOR;
            end;
          end
          else if (m_btRaceServer = RC_HERO) then
          begin
            case m_btJob of
              1:
                begin
                  dwCheckTick := g_Config.nHealthFillTime_Hero_WIZARD;
                  nBase := g_Config.nHealthFillBasic_Hero_WIZARD;
                end;
              2:
                begin
                  dwCheckTick := g_Config.nHealthFillTime_Hero_TAOIST;
                  nBase := g_Config.nHealthFillBasic_Hero_TAOIST;
                end;
            else
              dwCheckTick := g_Config.nHealthFillTime_Hero_WARRIOR;
              nBase := g_Config.nHealthFillBasic_Hero_WARRIOR;
            end;
          end
          else
          begin
            dwCheckTick := g_Config.nHealthFillTime_MON;
            nBase := g_Config.nHealthFillBasic_MON;
          end;

          if (m_nHealthTick >= dwCheckTick) then
          begin
            if nBase = 0 then
              nAddPoint := (m_WAbil.MaxHP) + 1
            else
              nAddPoint := (m_WAbil.MaxHP div nBase) + 1;

            if (m_WAbil.HP + nAddPoint) < m_WAbil.MaxHP then
              Inc(m_WAbil.HP, nAddPoint)
            else
              m_WAbil.HP := m_WAbil.MaxHP;

            boChg := True;
          end;
        end;
      end;
      {
      if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >= g_Config.nSpellFillTime) then
      begin
        nAddPoint := (m_WAbil.MaxMP div g_Config.nSpellFillBasic) + 1;
        if (m_WAbil.MP + nAddPoint) < m_WAbil.MaxMP then
          Inc(m_WAbil.MP, nAddPoint)
        else
          m_WAbil.MP := m_WAbil.MaxMP;
        boChg := True;
      end;}

      if (m_WAbil.MP < m_WAbil.MaxMP) then
      begin
        //ÐÞ¸Ä³É·ÖÖ°Òµ+ÈËÎï/Ó¢ÐÛ/¹ÖÎï ·Ö±ðÊÊÅä²»Í¬µÄ»ØÀ¶·½°¸ 2019-11-12
        if (m_btRaceServer = RC_PLAYOBJECT) then //ÈËÎïÕ½Ê¿
        begin
          case m_btJob of
            1:
              begin
                dwCheckTickSpell := g_Config.nSpellFillTime_HUMAN_WIZARD;
                nBaseSpell := g_Config.nSpellFillBasic_HUMAN_WIZARD;
              end;
            2:
              begin
                dwCheckTickSpell := g_Config.nSpellFillTime_HUMAN_TAOIST;
                nBaseSpell := g_Config.nSpellFillBasic_HUMAN_TAOIST;
              end;
          else
            dwCheckTickSpell := g_Config.nSpellFillTime_HUMAN_WARRIOR;
            nBaseSpell := g_Config.nSpellFillBasic_HUMAN_WARRIOR;
          end;
        end
        else if (m_btRaceServer = RC_HERO) then
        begin
          case m_btJob of
            1:
              begin
                dwCheckTickSpell := g_Config.nSpellFillTime_Hero_WIZARD;
                nBaseSpell := g_Config.nSpellFillBasic_Hero_WIZARD;
              end;
            2:
              begin
                dwCheckTickSpell := g_Config.nSpellFillTime_Hero_TAOIST;
                nBaseSpell := g_Config.nSpellFillBasic_Hero_TAOIST;
              end;
          else
            dwCheckTickSpell := g_Config.nSpellFillTime_Hero_WARRIOR;
            nBaseSpell := g_Config.nSpellFillBasic_Hero_WARRIOR;
          end;
        end
        else
        begin
          dwCheckTickSpell := g_Config.nSpellFillTime_MON;
          nBaseSpell := g_Config.nSpellFillBasic_MON;
        end;

        if (m_nSpellTick >= dwCheckTickSpell) then
        begin
          if nBaseSpell = 0 then
            nAddPoint := (m_WAbil.MaxMP) + 1
          else
            nAddPoint := (m_WAbil.MaxMP div nBaseSpell) + 1;
          if (m_WAbil.MP + nAddPoint) < m_WAbil.MaxMP then
            Inc(m_WAbil.MP, nAddPoint)
          else
            m_WAbil.MP := m_WAbil.MaxMP;
          boChg := True;
        end;
      end;


      if m_WAbil.HP = 0 then
      begin
        if ((m_LastHiter = nil) or not m_LastHiter.m_boUnRevival {·À¸´»î}) and m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime {60 * 1000}) then
        begin
          m_dwRevivalTick := GetTickCount();
          ItemDamageRevivalRing;
          m_WAbil.HP := m_WAbil.MaxHP;
          boChg := True;
          //HealthSpellChanged;
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            SysMsg(g_sRevivalRecoverMsg, c_Green, t_Hint);
        end;
        if m_WAbil.HP = 0 then
          Die();
      end;

      if boChg then    
        HealthSpellChanged;

          if (m_btRaceServer = RC_PLAYOBJECT) then // 2019-11-12
          begin
            case m_btJob of
              1:
                begin
                  if m_nHealthTick >= g_Config.nHealthFillTime_HUMAN_WIZARD then
                    m_nHealthTick := 0;
                  if m_nSpellTick >= g_Config.nSpellFillTime_HUMAN_WIZARD then
                    m_nSpellTick := 0;
                end;
              2:
                begin
                  if m_nHealthTick >= g_Config.nHealthFillTime_HUMAN_TAOIST then
                    m_nHealthTick := 0;
                  if m_nSpellTick >= g_Config.nSpellFillTime_HUMAN_TAOIST then
                    m_nSpellTick := 0
                end;
            else
                if m_nHealthTick >= g_Config.nHealthFillTime_HUMAN_WARRIOR then
                  m_nHealthTick := 0;
                if m_nSpellTick >= g_Config.nSpellFillTime_HUMAN_WARRIOR then
                  m_nSpellTick := 0
            end;
         end
         else if (m_btRaceServer = RC_HERO) then
         begin
            case m_btJob of
              1:
                begin
                  if m_nHealthTick >= g_Config.nHealthFillTime_HERO_WIZARD then
                    m_nHealthTick := 0;
                  if m_nSpellTick >= g_Config.nSpellFillTime_HERO_WIZARD then
                    m_nSpellTick := 0;
                end;
              2:
                begin
                  if m_nHealthTick >= g_Config.nHealthFillTime_HERO_TAOIST then
                    m_nHealthTick := 0;
                  if m_nSpellTick >= g_Config.nSpellFillTime_HERO_TAOIST then
                    m_nSpellTick := 0;
                end;
            else
                  if m_nHealthTick >= g_Config.nHealthFillTime_HERO_WARRIOR then
                    m_nHealthTick := 0;
                  if m_nSpellTick >= g_Config.nSpellFillTime_HERO_WARRIOR then
                    m_nSpellTick := 0;
            end;
         end
         else
         begin
           if m_nHealthTick >= g_Config.nHealthFillTime_MON then
             m_nHealthTick := 0;
           if m_nSpellTick >= g_Config.nSpellFillTime_MON then
             m_nSpellTick := 0;
         end;

    end
    else if not IsHero then
    begin
      if m_boCanReAlive and (m_pMonGen <> nil) then
      begin
        dwMakeGhostTime := _MAX(10 * 1000, GetZenTime(m_pMonGen.dwZenTime) - 20 * 1000);
        if dwMakeGhostTime > g_Config.dwMakeGhostTime then
          dwMakeGhostTime := g_Config.dwMakeGhostTime;
        if (GetTickCount - m_dwDeathTick > dwMakeGhostTime) then
          MakeGhost();
      end
      else
      begin
        if (GetTickCount - m_dwDeathTick > g_Config.dwMakeGhostTime) then
          MakeGhost();
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg1);
      MainOutMessageAPI(E.Message);
    end;
  end;

  try
    if IsHero and g_Config.boAllowJointAttack and not m_boDeath and not m_boGhost then
    begin
      if GetTickCount - m_dwDragonHeartTick > 1000 then
      begin
        m_dwDragonHeartTick := GetTickCount();
        if m_boJointAttackReady then
        begin
          if m_nJointAttackEnergy > 5 then
          begin
            Dec(m_nJointAttackEnergy, 5);
            TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, m_nJointAttackEnergy, 2, 200, 0, '');
          end
          else
          begin
            m_nJointAttackEnergy := 0;
            TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, 0, 0, 200, 0, '');
            m_boJointAttackReady := False;
          end;
        end
        else if m_boDrangonHeart and (m_UseItems[U_BUJUK].wIndex > 0) then
        begin
          if m_nJointAttackEnergy < 200 then
          begin
            UserMagic := nil;
            case m_btJob of
              0: case m_Master.m_btJob of
                  0: UserMagic := m_MagicArr[0][60];
                  1: UserMagic := m_MagicArr[0][62];
                  2: UserMagic := m_MagicArr[0][61];
                end;
              1: case m_Master.m_btJob of
                  0: UserMagic := m_MagicArr[0][62];
                  1: UserMagic := m_MagicArr[0][65];
                  2: UserMagic := m_MagicArr[0][64];
                end;
              2: case m_Master.m_btJob of
                  0: UserMagic := m_MagicArr[0][61];
                  1: UserMagic := m_MagicArr[0][64];
                  2: UserMagic := m_MagicArr[0][63];
                end;
            end;
            if (UserMagic <> nil) then
              nAddLevel := UserMagic.btLevel + 1;
{$IF DEBUGTEST = 1}
            nHP := Round((2 + Random(3) + Random(nAddLevel)) * g_Config.nEnergyStepUpRate);
{$ELSE}
            nHP := Round((2 + Random(3) + Random(nAddLevel)) * (g_Config.nEnergyStepUpRate / 10));
{$IFEND}

            nHP := nHP + _MIN(100, m_btReduceSpellTime);

            if m_UseItems[U_BUJUK].Dura > nHP then
            begin

{$IF DEBUGTEST <> 1}
              Dec(m_UseItems[U_BUJUK].Dura, nHP);
{$IFEND}
              SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
              if m_nJointAttackEnergy + nHP < 200 then
              begin
                Inc(m_nJointAttackEnergy, nHP);
                TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, m_nJointAttackEnergy, 0, 200, 0, '');
              end
              else
              begin
                m_nJointAttackEnergy := 200;
                TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, 200, 1, 200, 0, '');
              end;
            end
            else
            begin
              m_UseItems[U_BUJUK].Dura := 0;
              m_boDrangonHeart := False;
              if m_nJointAttackEnergy + m_UseItems[U_BUJUK].Dura < 200 then
              begin
                Inc(m_nJointAttackEnergy, m_UseItems[U_BUJUK].Dura);
                TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, m_nJointAttackEnergy, 0, 200, 0, '');
              end
              else
              begin
                m_nJointAttackEnergy := 200;
                TPlayObject(m_Master).SendDefMessage(SM_HEROPOWERUP, 200, 1, 200, 0, '');
              end;
            end;
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg8);
      MainOutMessageAPI(E.Message);
    end;
  end;

  if not m_boDeath and not m_boGhost and (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (m_nAutoAddHPMPMode > 0) then
  begin
    if GetTickCount - m_dwCheckHPMPTick > 300 then
    begin
      m_dwCheckHPMPTick := GetTickCount();
      if m_UseItems[U_CHARM].wIndex > 0 then
      begin
        nMP := 0;
        if m_nAutoAddHPMPMode in [1, 3] then
        begin
          if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          begin
            nHP := m_WAbil.MaxHP - m_WAbil.HP;
            if (nHP > 10) and (m_nIncHealth <= 0) then
            begin
              nHP := _MIN(600, nHP);
              if m_UseItems[U_CHARM].Dura > (nHP div 10) then
              begin
                Dec(m_UseItems[U_CHARM].Dura, nHP div 10);
                SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                m_nIncHealth := nHP;
              end
              else
              begin
                m_nIncHealth := m_UseItems[U_CHARM].Dura;
                m_UseItems[U_CHARM].Dura := 0;
                if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
                  TPlayObject(Self).SendDelItems(@m_UseItems[U_CHARM]);
                m_UseItems[U_CHARM].wIndex := 0;
                m_nAutoAddHPMPMode := 0;
              end;
            end;
          end;
        end;
        if m_nAutoAddHPMPMode in [2, 3] then
        begin
          //if (m_wClientType = 45) or IsHero or (m_btRaceServer = RC_HERO) then begin
          if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          begin
            nMP := m_WAbil.MaxMP - m_WAbil.MP;
            if (nMP > 10) and (m_nIncSpell <= 0) then
            begin
              nMP := _MIN(600, nMP);
              if m_UseItems[U_CHARM].Dura > (nMP div 10) then
              begin
                Dec(m_UseItems[U_CHARM].Dura, nMP div 10);
                SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
                m_nIncSpell := nMP;
              end
              else
              begin
                m_nIncSpell := m_UseItems[U_CHARM].Dura;
                m_UseItems[U_CHARM].Dura := 0;
                if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
                  TPlayObject(Self).SendDelItems(@m_UseItems[U_CHARM]);
                m_UseItems[U_CHARM].wIndex := 0;
                m_nAutoAddHPMPMode := 0;
              end;
            end;
          end;
        end;
      end;
    end;
  end;

  try
    if not m_boDeath then
    begin //0901
      if ((m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nIncHealing > 0)) then
      begin
        dwInChsTime := 600 - _MIN(400, m_Abil.Level * 10);
        if (GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime then
        begin
          dwC := _MIN(200, (GetTickCount - m_dwIncHealthSpellTick - dwInChsTime));
          m_dwIncHealthSpellTick := GetTickCount() + dwC;
          if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then
          begin

            if (m_nPerHealth <= 0) then
              m_nPerHealth := 1;
            if (m_nPerSpell <= 0) then
              m_nPerSpell := 1;
            if (m_nPerHealing <= 0) then
              m_nPerHealing := 1;

            if m_nIncHealth < m_nPerHealth then
            begin
              nHP := m_nIncHealth;
              m_nIncHealth := 0;
            end
            else
            begin
              nHP := m_nPerHealth;
              Dec(m_nIncHealth, m_nPerHealth);
            end;

            if m_nIncSpell < m_nPerSpell then
            begin
              nMP := m_nIncSpell;
              m_nIncSpell := 0;
            end
            else
            begin
              nMP := m_nPerSpell;
              Dec(m_nIncSpell, m_nPerSpell);
            end;

            if m_nIncHealing < m_nPerHealing then
            begin
              Inc(nHP, m_nIncHealing);
              m_nIncHealing := 0;
            end
            else
            begin
              Inc(nHP, m_nPerHealing);
              Dec(m_nIncHealing, m_nPerHealing);
            end;

            m_nPerHealth := (m_Abil.Level div 10 + g_Config.nCordialAddHPMPMax);
            m_nPerSpell := (m_Abil.Level div 10 + g_Config.nCordialAddHPMPMax);
            m_nPerHealing := g_Config.nHealingRate;
            IncHealthSpell(nHP, nMP);

            if m_WAbil.HP = m_WAbil.MaxHP then
            begin
              m_nIncHealth := 0;
              m_nIncHealing := 0;
            end;
            if m_WAbil.MP = m_WAbil.MaxMP then
              m_nIncSpell := 0;
          end;
        end;
      end
      else
        m_dwIncHealthSpellTick := GetTickCount();

      if (m_nHealthTick < -g_Config.nHealthDecTime) and (m_WAbil.HP > 1) then
      begin //0901
       // Dec(m_WAbil.HP);  // ¶¨Ê±µôÑª,µôÑª»ùÊý
        Dec(m_WAbil.HP,g_Config.nHealthDecBasic);
        Inc(m_nHealthTick, g_Config.nHealthDecTime);
        HealthSpellChanged();
      end;



      boNeedRecalc := False;
      if m_WAbil.HP > m_WAbil.MaxHP then
      begin //0901
        boNeedRecalc := True;
        m_WAbil.HP := m_WAbil.MaxHP - 1;
      end;
      if m_WAbil.MP > m_WAbil.MaxMP then
      begin
        boNeedRecalc := True;
        m_WAbil.MP := m_WAbil.MaxMP - 1;
      end;
      if boNeedRecalc then
        HealthSpellChanged();
    end;
  except
    MainOutMessageAPI(sExceptionMsg2);
  end;

  try
    if (m_LockTarget <> nil) then
    begin
      if ((GetTickCount - m_dwTargetFocusTick) > 60 * 1000) or m_LockTarget.m_boDeath or m_LockTarget.m_boGhost or (m_LockTarget.m_PEnvir <> m_PEnvir) or (abs(m_LockTarget.m_nCurrX - m_nCurrX) > 30) or (abs(m_LockTarget.m_nCurrY - m_nCurrY) > 30) then
        m_LockTarget := nil;
    end;
    if (m_TargetCret <> nil) then
    begin
      if ((GetTickCount - m_dwTargetFocusTick) > 30 * 1000) or m_TargetCret.m_boDeath or m_TargetCret.m_boGhost or (m_TargetCret.m_PEnvir <> m_PEnvir) or (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then
        m_TargetCret := nil;
    end;
    if (m_LastHiter <> nil) then
    begin
      if ((GetTickCount() - m_LastHiterTick) > 30 * 1000) or m_LastHiter.m_boDeath or m_LastHiter.m_boGhost then
        m_LastHiter := nil;
    end;
    if (m_ExpHitter <> nil) then
    begin
      if ((GetTickCount() - m_ExpHitterTick) > 6 * 1000) or m_ExpHitter.m_boDeath or m_ExpHitter.m_boGhost then
        m_ExpHitter := nil;
    end;
    if (m_PoisonHiter <> nil) then
    begin
      if ((GetTickCount() - m_PoisonHiterTick) > 30 * 1000) or m_PoisonHiter.m_boDeath or m_PoisonHiter.m_boGhost then
        m_PoisonHiter := nil;
    end;

    nCheckCode := 300;
    if m_Master <> nil then
    begin
      if not IsHero then
        m_boNoItem := True;
      if not m_boDeath then
      begin //0901
        if (m_btRaceServer <> RC_PLAYOBJECT) or not TPlayObject(Self).m_boOffLineFlag then
        begin //0720
          if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick > g_Config.dwBBMonAutoChangeColorTime) then
          begin
            m_dwAutoChangeColorTick := GetTickCount();
            case m_nAutoChangeIdx of
              0: nInteger := STATE_TRANSPARENT;
              1: nInteger := POISON_STONE;
              2: nInteger := POISON_DONTMOVE;
              3: nInteger := POISON_SHOCKED;
              4: nInteger := POISON_DECHEALTH;
              5: nInteger := POISON_FREEZE;
              6: nInteger := POISON_DAMAGEARMOR;
            else
              begin
                m_nAutoChangeIdx := 0;
                nInteger := STATE_TRANSPARENT;
              end;
            end;
            Inc(m_nAutoChangeIdx);
            m_nCharStatus := (m_nCharStatusEx {and $FFFFF}) or (($80000000 shr nInteger) or 0);
            StatusChanged();
          end;
          if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then
          begin
            case m_nFixColorIdx of
              0: nInteger := STATE_TRANSPARENT;
              1: nInteger := POISON_STONE;
              2: nInteger := POISON_DONTMOVE;
              3: nInteger := POISON_SHOCKED;
              4: nInteger := POISON_DECHEALTH;
              5: nInteger := POISON_FREEZE;
              6: nInteger := POISON_DAMAGEARMOR;
            else
              begin
                m_nFixColorIdx := 0;
                nInteger := STATE_TRANSPARENT;
              end;
            end;
            m_nCharStatus := (m_nCharStatusEx {and $FFFFF}) or (($80000000 shr nInteger) or 0);
            m_nFixStatus := m_nCharStatus;
            StatusChanged();
          end;
        end;
      end;

      if not IsHero and (m_Master.m_boDeath and ((GetTickCount - m_Master.m_dwDeathTick) > 1000)) then
      begin
        if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter <> nil) and (Random(g_Config.nMasterDieMutinyRate) = 0) then
        begin
          m_Master := nil;
          m_btSlaveExpLevel := High(g_Config.SlaveColor);
          RecalcAbilitys();
          m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower, HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
          m_nWalkSpeed := m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
          RefNameColor;
          RefShowName;
        end
        else
          m_WAbil.HP := 0;
      end;

      if m_Master.m_boGhost then
      begin
        if GetTickCount - m_Master.m_dwGhostTick > 500 then
        begin
          if IsHero then
          begin
            if not m_boHeroSaveRcd then
            begin
              m_boHeroSaveRcd := True;
              UserEngine.SaveHumanRcd(TPlayObject(Self));
            end;
            SendRefMsg(RM_HEROLOGOUT, 0, m_nCurrX, m_nCurrY, 0, '');
            TPlayObject(m_Master).m_dwRecallHeroTick := 0;
            TPlayObject(m_Master).m_HeroObject := nil;
          end;
          MakeGhost;
        end;
      end;
    end;

    for i := m_SlaveList.Count - 1 downto 0 do
    begin
      if TBaseObject(m_SlaveList[i]).m_boDeath or TBaseObject(m_SlaveList[i]).m_boGhost or (TBaseObject(m_SlaveList[i]).m_Master <> Self) then
        m_SlaveList.Delete(i);
    end;

    if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) > m_dwHolySeizeInterval) then
      BreakHolySeizeMode();
    if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) > m_dwCrazyModeInterval) then
      BreakCrazyMode();
    if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval) then
      BreakOpenHealth();
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg3, [nCheckCode]));
      MainOutMessageAPI(E.Message);
    end;
  end;

  try
    if (GetTickCount - m_dwVerifyTick) > 30 * 1000 then
    begin
      m_dwVerifyTick := GetTickCount();
      //if not m_boDenyRefStatus then
      m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg4, [46]));
      MainOutMessageAPI(E.Message);
    end;
  end;

  try
    if not m_boDeath then
    begin //0901
      if (m_nPkPoint > 0) and ((GetTickCount - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime) then
      begin
        m_dwDecPkPointTick := GetTickCount();
        DecPKPoint(g_Config.nDecPkPointCount);
      end;
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        if (GetTickCount - m_DecLightItemDrugTick) > g_Config.dwDecLightItemDrugTime {500} then
        begin
          Inc(m_DecLightItemDrugTick, g_Config.dwDecLightItemDrugTime {500});
          UseLamp();
          CheckPKStatus();
        end;
      end;
    end;

    if (GetTickCount - m_dwCheckRoyaltyTick) > 2 * 1000 then
    begin
      m_dwCheckRoyaltyTick := GetTickCount();
      if (m_Master <> nil) and (m_Master.IsHero or (m_Master.m_btRaceServer = RC_PLAYOBJECT) or ((m_Master.m_btRaceServer = RC_HERO) and (m_Master.m_dwCloneDispearTick = 0))) and (m_dwCloneDispearTick > 0) and (GetTickCount > m_dwCloneDispearTick) then
      begin
        SendRefMsg(RM_HEROLOGOUT, 0, m_nCurrX, m_nCurrY, 0, '');
        m_Master.m_boAdminMode := False;
        m_Master.SysMsg(g_sHeroDispear, c_Blue, t_Hint);
        m_Master.m_dwCloneSelfTick := GetTickCount;
        m_Master := nil;
        MakeGhost;
      end;
      if (m_Master <> nil) and (m_btRaceServer <> RC_HERO) then
      begin
        if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5) then
          m_dwMasterRoyaltyTick := 0;
        if (GetTickCount > m_dwMasterRoyaltyTick) then
        begin
          for i := 0 to m_Master.m_SlaveList.Count - 1 do
          begin
            if m_Master.m_SlaveList.Items[i] = Self then
            begin
              m_Master.m_SlaveList.Delete(i);
              Break;
            end;
          end;
          if m_btRaceServer = 126 then
          begin
            if (m_Master.m_btRaceServer = RC_PLAYOBJECT) or m_Master.IsHero then
            begin
              m_Master.SysMsg(Format('ÄãµÄ%sÒÑ¾­°éËæÄú´ï%d·ÖÖÓ£¬Ä¿Ç°ÒÑ¾­»Ø¹é±ùÔ­Éî´¦£¡', [m_sCharName, g_Config.IceMonLiveTime]), c_Blue, t_Hint);
            end;
            SendRefMsg(RM_HEROLOGOUT, 0, m_nCurrX, m_nCurrY, 0, '');
            m_Master := nil;
            m_boDeath := True;
            m_dwDeathTick := GetTickCount;
            m_boGhost := True;
            m_dwGhostTick := GetTickCount();
            DisappearA(1);
          end
          else
          begin
            m_Master := nil;
            m_WAbil.HP := m_WAbil.HP div 10;
            RefShowName();
          end;
          if (m_WAbil.HP > 0) and g_Config.boSpiritMutinyDie then
          begin
            m_WAbil.HP := 0;
          end;
        end;
        if (m_WAbil.HP > 0) and (m_dwMasterTick <> 0) then
        begin
          if (GetTickCount - m_dwMasterTick) > 12 * 60 * 60 * 1000 then
          begin
            m_WAbil.HP := 0;
          end;
        end;
      end;
    end;

    {if (GetTickCount - m_dwVerifyTick) > 30 * 1000 then begin
      m_dwVerifyTick := GetTickCount();
      //if not m_boDenyRefStatus then
      m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, self);
    end;}

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if (TPlayObject(Self).m_DealCreat <> nil) and (TPlayObject(Self).m_DealCreat.m_boGhost {or (TPlayObject(self).m_DealCreat.m_PEnvir <> m_PEnvir)}) then
        TPlayObject(Self).m_DealCreat := nil;
      if (TPlayObject(Self).m_DealGoldCreat <> nil) and (TPlayObject(Self).m_DealGoldCreat.m_boGhost {or (TPlayObject(self).m_DealGoldCreat.m_PEnvir <> m_PEnvir)}) then
        TPlayObject(Self).m_DealGoldCreat := nil;

      if (GetTickCount - m_dwGroupAttribTick) > 15 * 1000 then
      begin
        m_dwGroupAttribTick := GetTickCount();

        if (TPlayObject(Self).m_GroupOwner <> nil) then
        begin
          if TPlayObject(Self).m_GroupOwner.m_boDeath or TPlayObject(Self).m_GroupOwner.m_boGhost then
          begin
            TPlayObject(Self).m_GroupOwner := nil;
            TPlayObject(Self).ReSetGroupAttrib();
          end;
        end
        else
          TPlayObject(Self).ReSetGroupAttrib();

        if TPlayObject(Self).m_GroupOwner = Self then
        begin
          for i := TPlayObject(Self).m_GroupMembers.Count - 1 downto 0 do
          begin
            BaseObject := TBaseObject(TPlayObject(Self).m_GroupMembers.Objects[i]);
            if BaseObject.m_boDeath or (BaseObject.m_boGhost) then
            begin
              TPlayObject(Self).m_GroupMembers.Delete(i);
              TPlayObject(Self).ReSetGroupAttrib();
              TPlayObject(Self).CheckMapEvent(5, '');
            end;
          end;
        end;

      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg4, [45]));
      MainOutMessageAPI(E.Message);
    end;
  end;

  try
    if not m_boDeath or (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) then
    begin //0901

      boChg := False;
      boNeedRecalc := False;
      try
        for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
        begin
          if (m_wStatusTimeArr[i] > 0) and (m_wStatusTimeArr[i] < g_MaxStatusTime) then
          begin
            if (GetTickCount() - m_dwStatusArrTick[i]) > 1000 then
            begin
              Dec(m_wStatusTimeArr[i]);
              Inc(m_dwStatusArrTick[i], 1000);
              if (m_wStatusTimeArr[i] = 0) then
              begin
                boChg := True;
                case i of
                  STATE_TRANSPARENT: m_boHideMode := False;
                  STATE_DEFENCEUP:
                    begin
                      boNeedRecalc := True;
                      m_DefenceRate := 0;
                      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                        SysMsg('·ÀÓùÁ¦»Ø¸´Õý³£', c_Green, t_Hint);
                    end;
                  STATE_MAGDEFENCEUP:
                    begin
                      boNeedRecalc := True;
                      m_MagDefenceRate := 0;
                      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                        SysMsg('Ä§ÓùÁ¦»Ø¸´Õý³£', c_Green, t_Hint);
                    end;
                  {POISON_PURPLE: begin
                      //m_boAbilScPowerUpDefence := False;
                      //RecalcAbilitys();
                      //SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
                      //SysMsg('µÀÊõ»Ø¸´Õý³£', c_Green, t_Hint);
                    end;}
                  POISON_FREEZE:
                    begin
                      if m_nNonFrzWalkSpeed > 0 then
                        m_nWalkSpeed := m_nNonFrzWalkSpeed;
                      if m_nNonFrzNextHitTime > 0 then
                        m_nNextHitTime := m_nNonFrzNextHitTime;
                    end;
                  POISON_DONTMOVE:
                    begin
                      m_boTDBeffect := False;
                    end;
                  STATE_BUBBLEDEFENCEUP: m_boAbilMagBubbleDefence := False;
                  POISON_STONE:
                    begin
                      m_boFastParalysis := False;
                      if m_btMedusaEyeAttack > 0 then
                      begin
                        m_btMedusaEyeAttack := 0;
                        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                          SysMsg('ÃÀ¶ÅÉ¯Ö®×çÖäÏûÊ§', c_Green, t_Hint);
                      end;
                    end;
                  POISON_7:
                    begin
                      boChg := True;
                      boNeedRecalc := True;
                      SysMsg('·ÀÓùÄÜÁ¦»Ö¸´Õý³£', c_Green, t_Hint);
                    end;
                end;
              end;
            end;
          end;
        end;

        for i := Low(m_dwStatusArrTickEx) to High(m_dwStatusArrTickEx) do
        begin
          if (m_wStatusTimeArrEx[i] > 0) {and (m_wStatusTimeArrEx[i] < g_MaxStatusTime)} then
          begin
            if (GetTickCount() - m_dwStatusArrTickEx[i]) > 1000 then
            begin
              Dec(m_wStatusTimeArrEx[i]);
              Inc(m_dwStatusArrTickEx[i], 1000);
              if (m_wStatusTimeArrEx[i] = 0) then
              begin
                boChg := True;
                case i of
                  STATE_13: SysMsg('ÉÏ¹ÅÉñÄ§µÄÁ¦Á¿ÂýÂýÈõÈ¥£¬ÄãµÄ[ÉñÁú¸½Éí]×´Ì¬»Ö¸´Õý³££¡', c_Green, t_Hint); //$00040000
                  STATE_14: SysMsg('[Áú»¯] ×´Ì¬ÏûÊ§', c_Green, t_Hint); //$00020000
                  STATE_15: SysMsg('[ÖØÉË] ×´Ì¬ÏûÊ§', c_Green, t_Hint); //$00010000
                  STATE_16: ; //$00008000
                  STATE_17: ; //$00004000
                  STATE_18: ; //$00002000
                  STATE_19: ; //$00001000
                  STATE_20: ; //$00000800
                  STATE_21: ; //$00000400
                  STATE_22: ; //$00000200
                  STATE_23: ; //$00000100
                  STATE_24: ; //$00000080
                  STATE_25: ; //$00000040
                  STATE_26: ; //$00000020
                  STATE_27: ; //$00000010
                  STATE_28: ; //$00000008
                  STATE_29: ; //$00000004
                end;
              end;
            end;
          end;
        end;
      finally
        if boChg then
        begin
          m_nCharStatus := GetCharStatus();
          StatusChanged();
        end;
      end;

      for i := Low(m_wStatusArrValue) to High(m_wStatusArrValue) do
      begin
        if m_wStatusArrValue {218} [i] > 0 then
        begin
          if GetTickCount() > m_dwStatusArrTimeOutTick {220} [i] then
          begin
            m_wStatusArrValue[i] := 0;
            boNeedRecalc := True;
            case i of
              0, 6: if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                  SysMsg('¹¥»÷Á¦»Ø¸´Õý³£', c_Green, t_Hint);
              1: if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                  SysMsg('Ä§·¨Á¦»Ø¸´Õý³£', c_Green, t_Hint);
              2:
                begin
                  if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                    SysMsg('µÀÊõÁ¦»Ø¸´Õý³£', c_Cust, t_Hint, $DB, $FF);
                  m_dwDoubleScTick := GetTickCount;
                end;
              3: if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                  SysMsg('¹¥»÷ËÙ¶È»Ø¸´Õý³£', c_Green, t_Hint);
              4: if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                  SysMsg('ÌåÁ¦»Ø¸´Õý³£', c_Green, t_Hint);
              5: if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                  SysMsg('Ä§·¨Öµ»Ø¸´Õý³£', c_Green, t_Hint);
            end;
          end;
        end;
      end;

      for i := Low(m_wStatusArrValue2) to High(m_wStatusArrValue2) do
      begin
        if m_wStatusArrValue2[i] > 0 then
        begin
          if GetTickCount() > m_dwStatusArrTimeOutTick2[i] then
          begin
            m_wStatusArrValue2[i] := 0;
            boNeedRecalc := True;
            if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
            begin
              case i of
                0: SysMsg('HP¸½¼Ó»Ö¸´Õý³£', c_Green, t_Hint);
                1: SysMsg('MP¸½¼Ó»Ö¸´Õý³£', c_Green, t_Hint);
                2: SysMsg('·ÀÓù¸½¼Ó»Ö¸´Õý³£', c_Green, t_Hint);
                3: SysMsg('Ä§Óù¸½¼Ó»Ö¸´Õý³£', c_Green, t_Hint);
                4: SysMsg('¹¥»÷¸½¼Ó»Ø¸´Õý³£', c_Green, t_Hint);
                5: SysMsg('Ä§·¨¸½¼Ó»Ø¸´Õý³£', c_Green, t_Hint);
                6: SysMsg('µÀÊõ¸½¼Ó»Ø¸´Õý³£', c_Green, t_Hint);
              end;
            end;
          end;
        end;
      end;

      if (m_nCursePowerRateTime <> 0) and (GetTickCount() > m_nCursePowerRateTime) then
      begin
        m_nCursePowerRate := 100;
        m_nCursePowerRateTime := 0;
        boNeedRecalc := True;
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          SysMsg('¹¥»÷Á¦¡¢ÎïÀí·ÀÓù»Ø¸´Õý³£', c_Green, t_Hint);
      end;

      if boNeedRecalc then
      begin
        RecalcAbilitys();

        boNeedRecalc := False;
        if m_WAbil.HP > m_WAbil.MaxHP then
        begin
          m_WAbil.HP := m_WAbil.MaxHP;
          boNeedRecalc := True;
        end;
        if m_WAbil.MP > m_WAbil.MaxMP then
        begin
          m_WAbil.MP := m_WAbil.MaxMP;
          boNeedRecalc := True;
        end;
        if boNeedRecalc then
          HealthSpellChanged;
        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        begin
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        end;
      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg5);
  end;

  try
    if not m_boDeath or (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) then
    begin //0901
      boNeedRecalc := False;
      for i := Low(m_wPowerRateTick) to High(m_wPowerRateTick) do
      begin
        if (m_wPowerRate[i] > 0) and (GetTickCount() > m_wPowerRateTick[i]) then
        begin
          m_wPowerRate[i] := 0;
          m_sStatuName := '';
          if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          begin
            case i of
              0: SysMsg('·ÀÓùÁ¦»Ø¸´Õý³£', c_Green, t_Hint);
              1: SysMsg('Ä§ÓùÁ¦»Ø¸´Õý³£', c_Green, t_Hint);
              2: SysMsg('¹¥»÷Á¦»Ø¸´Õý³£', c_Green, t_Hint);
              3: SysMsg('Ä§·¨Á¦»Ø¸´Õý³£', c_Green, t_Hint);
              4: SysMsg('µÀÊõ»Ø¸´Õý³£', c_Green, t_Hint);
              5: SysMsg('ÌåÁ¦Öµ»Ø¸´Õý³£', c_Green, t_Hint);
              6: SysMsg('Ä§·¨Öµ»Ø¸´Õý³£', c_Green, t_Hint);
            end;
          end;
        end;
      end;
      if boNeedRecalc then
      begin
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        RefShowName();
      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg5);
  end;

  try
    if not m_boDeath then
    begin //0901
      if (m_wStatusTimeArr[POISON_DECHEALTH] > 0) and ((GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime) then
      begin
        m_dwPoisoningTick := GetTickCount();
        //if m_wStatusTimeArr[POISON_DECHEALTH] > 0 then begin
        if m_boAnimal then
          Dec(m_nMeatQuality, 1000);
        DamageHealth(m_btGreenPoisoningPoint + 1, False);
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');   
        if m_PoisonHiter <> nil then
          SetLastHiter(m_PoisonHiter);
        //end;
      end;
      if (m_wStatusTimeArrEx[STATE_15] > 0) and ((GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime) then
      begin
        m_dwPoisoningTick := GetTickCount();
        DamageHealth(100 + (m_WAbil.MaxHP div 300), False);
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;

    end;
  except
    MainOutMessageAPI(sExceptionMsg6);
  end;
  {if boOpenHealth then begin
    if (GetTickCount() - dwOpenHealthStart) > dwOpenHealthTime then begin
      BreakOpenHealth();
    end;
  end;}
  g_nBaseObjTimeMin := GetTickCount - dwRunTick;
  if g_nBaseObjTimeMax < g_nBaseObjTimeMin then
    g_nBaseObjTimeMax := g_nBaseObjTimeMin;
end;

{function TPlayObject.DayBright: Byte;
begin
  Result := 0;
  if m_PEnvir.m_MapFlag.boDarkness then
    Result := 1
  else if m_PEnvir.m_MapFlag.boDayLight then
    Result := 0;
end;}

procedure TBaseObject.AddSkillByName(sSkillName: string; Level: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  Magic := UserEngine.FindMagic(sSkillName);
  if Magic <> nil then
  begin
    if not IsTrainingSkill(Magic.wMagicId, Magic.btClass) then
    begin
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btKey := 0;
      UserMagic.btLevel := Level;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      TPlayObject(Self).SendAddMagic(UserMagic);
      RecalcAbilitys();
    end;
  end;
end;

function TBaseObject.GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP: if nY > 0 then
        Dec(nY);
    DR_UPRIGHT:
      begin
        if (nX < (Envir.m_MapHeader.wWidth - 1)) and (nY > 0) then
        begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_RIGHT: if nX < (Envir.m_MapHeader.wWidth - 1) then
        Inc(nX);
    DR_DOWNRIGHT:
      begin
        if (nX < (Envir.m_MapHeader.wWidth - 1)) and (nY < (Envir.m_MapHeader.wHeight - 1)) then
        begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_DOWN: if nY < (Envir.m_MapHeader.wHeight - 1) then
        Inc(nY);
    DR_DOWNLEFT:
      begin
        if (nX > 0) and (nY < (Envir.m_MapHeader.wHeight - 1)) then
        begin
          Dec(nX);
          Inc(nY);
        end;
      end;
    DR_LEFT: if nX > 0 then
        Dec(nX);
    DR_UPLEFT:
      begin
        if (nX > 0) and (nY > 0) then
        begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

procedure TBaseObject.SpaceMove(sMAP: string; nX, nY: Integer; nInt: Integer);

  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    i, nStepX, nStepY: Integer;
  begin
    Result := False;
    if Envir.m_MapHeader.wWidth < 80 then
      nStepX := 3
    else
      nStepX := 10;
    if Envir.m_MapHeader.wHeight < 150 then
    begin
      if Envir.m_MapHeader.wHeight < 50 then
        nStepY := 2
      else
        nStepY := 15;
    end
    else
      nStepY := 50;
    i := 0;
    while (True) do
    begin
      if Envir.CanWalk(nX, nY, True) then
      begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_MapHeader.wWidth - nStepY - 1) then
        Inc(nX, nStepX)
      else
      begin
        nX := Random(Envir.m_MapHeader.wWidth);
        if nY < (Envir.m_MapHeader.wHeight - nStepY - 1) then
          Inc(nY, nStepX)
        else
          nY := Random(Envir.m_MapHeader.wHeight);
      end;
      Inc(i);
      if i >= 201 then
        Break;
    end;
  end;
var
  i: Integer;
  Envir, OldEnvir: TEnvirnoment;
  nOldX, nOldY: Integer;
  boMoved: Boolean;
  PlayObject: TPlayObject;
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if TPlayObject(Self).m_StallMgr.OnSale then
    begin
      SysMsg('[°ÚÌ¯×´Ì¬] ²»ÄÜË²¼äÒÆ¶¯¹¦ÄÜ£¡', c_Red, t_Hint);
      Exit;
    end;
  end;
  Envir := g_MapManager.FindMap(sMAP);
  if Envir <> nil then
  begin
    if g_nServerIndex = Envir.m_nServerIndex then
    begin
      OldEnvir := m_PEnvir;
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      boMoved := False;
      try
        if (m_btRaceServer = RC_PLAYOBJECT) and (g_MapEventNPC <> nil) then
        begin
          if (Envir <> m_PEnvir) then
          begin
            g_MapEventNPC.m_OprCount := 0;
            g_MapEventNPC.GotoLable(TPlayObject(Self), '@OnEnvirChanging', False);
          end;
        end;

        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);

        m_VisibleHumanList.Clear;

        for i := 0 to m_VisibleActors.Count - 1 do
          Dispose(pTVisibleBaseObject(m_VisibleActors[i]));
        m_VisibleActors.Clear;

        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          with TPlayObject(Self) do
          begin
            for i := 0 to m_VisibleItems.Count - 1 do
              Dispose(pTVisibleMapItem(m_VisibleItems[i]));
            m_VisibleItems.Clear;
{$IF NewVisibleEvent = 1}
            for i := 0 to m_VisibleEvents.Count - 1 do
              Dispose(pTVisibleEvent(m_VisibleEvents[i]));
{$IFEND}
            m_VisibleEvents.Clear;
          end;
        end;

        m_PEnvir := Envir;
        m_sMapName := Envir.m_sMapFileName;
        m_nCurrX := nX;
        m_nCurrY := nY;
        if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then
        begin
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
            SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, Envir.m_sClientMapName);
            SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
          end;
          if nInt = 1 then
            SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '')
          else
            SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          m_dwMapMoveTick := GetTickCount();
          m_boHealthCrc := True;
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            with TPlayObject(Self) do
            begin
              m_boSendInSafeZone := True;
              m_dwSafeZoneCheckTick := 0;
              m_dwSearchTick := 0;
            end;
          end;
          boMoved := True;
          if (m_btRaceServer = RC_PLAYOBJECT) and (m_PEnvir <> OldEnvir) then
          begin
            if (g_MapEventNPC <> nil) then
            begin
              g_MapEventNPC.m_OprCount := 0;
              g_MapEventNPC.GotoLable(TPlayObject(Self), '@OnEnvirChanged', False);
            end;
          end;
        end;
      finally
        if not boMoved then
        begin
          m_PEnvir := OldEnvir;
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
      end;
      OnEnvirnomentChanged();
    end
    else
    begin
      if GetRandXY(Envir, nX, nY) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          DisappearA();
          m_boHealthCrc := True;
          PlayObject := TPlayObject(Self);
          PlayObject.m_sSwitchMapName := Envir.m_sMapFileName;
          PlayObject.m_nSwitchMapX := nX;
          PlayObject.m_nSwitchMapY := nY;
          PlayObject.m_nServerIndex := Envir.m_nServerIndex;
          PlayObject.m_boSwitchData := True;
          PlayObject.m_boEmergencyClose := True;
          PlayObject.m_boReconnection := True;
          //UserEngine.SendChangeServer(PlayObject, PlayObject.m_nServerIndex);
        end
        else
          KickException();
      end;
    end;
  end;
end;

procedure TPlayObject.RefUserState();
var
  nState: Integer;
begin
  nState := 0;
  if m_PEnvir.m_MapFlag.boFIGHTZone then
    nState := nState or 1;
  if m_PEnvir.m_MapFlag.boSAFE then
    nState := nState or 2;
  if m_boInFreePKArea then
    nState := nState or 4;
  if m_PEnvir.NimbusCount > 0 then
    nState := nState or 8;
  SendDefMessage(SM_AREASTATE, nState, 0, 0, 0, '');
end;

procedure TBaseObject.RefShowName();
begin
  SendRefMsg(RM_USERNAME, 0, 0, 0, 0, GetShowName);
end;

function TPlayObject.GetHeroObjectA(): TBaseObject;
begin
  if g_Config.boHeroSystem and (m_btRaceServer = RC_PLAYOBJECT) and (m_HeroObject <> nil) and not m_HeroObject.m_boGhost then
    Result := m_HeroObject
  else
    Result := nil;
end;

procedure TPlayObject.RefMyStatus();
begin
  RecalcAbilitys();
  SendMsg(Self, RM_MYSTATUS, 0, 0, 0, 0, '');
end;

function TBaseObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  nDamage: Integer;
  nTargetX: Integer;
  nTargetY: Integer;
  nPower: Integer;
  nRage: Integer;
  Attacker, TargeTBaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Operate';
begin
  Result := False;
  try
    case ProcessMsg.wIdent of
      RM_MAGSTRUCK, RM_MAGSTRUCK_MINE:
        begin
          //if not IsHero then begin
          if (ProcessMsg.wIdent = RM_MAGSTRUCK) and (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_HERO) and (not m_boCowKingMon) and (m_Abil.Level < 50) then
          begin
            //if m_btRaceServer = RC_HERO then
            //m_dwWalkTick := m_dwWalkTick + 300 + LongWord(Random(400))
            //else
            m_dwWalkTick := m_dwWalkTick + 800 + LongWord(Random(1000));
          end;
          //end;
          Attacker := TBaseObject(ProcessMsg.BaseObject);
          if (Attacker <> nil) and not Attacker.m_boDeath and not Attacker.m_boGhost then
          begin //0405
            //if (ProcessMsg.nMagicID > 0) then
            nDamage := GetMagStruckDamage(Attacker, ProcessMsg.nParam1);
          end
          else
            nDamage := GetMagStruckDamage(nil, ProcessMsg.nParam1);
          if nDamage > 0 then
          begin
            StruckDamage(Attacker, nDamage, ProcessMsg.nMagicID);
            HealthSpellChanged();
            SendRefMsg(RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject), '');
            if m_btRaceServer <> RC_PLAYOBJECT then
            begin
              if m_boAnimal and (m_btRaceServer <> RC_HERO) then
                Dec(m_nMeatQuality, nDamage * 1000);
              if nPower > 0 then
                SendMsg(Self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP, Integer(ProcessMsg.BaseObject), '');
            end;
            if (Attacker <> nil) and not Attacker.m_boDeath and not Attacker.m_boGhost and ((Attacker.m_btRaceServer = RC_PLAYOBJECT) or Attacker.IsHero) then
            begin
              if (ProcessMsg.nMagicID <> SKILL_EARTHFIRE) and Attacker.m_boMParalysis and (Random(m_btAntiPoison + g_Config.nAttackPosionRate + 4) = 0) then
                if (m_btAntiStone = 0) or (m_btAntiStone <= Random(100)) then
                  MakePosion(Self, 0, POISON_STONE, g_Config.nAttackPosionTime, 0);

              if (Attacker.m_wVampire > 0) and (Attacker.m_btSuckRate > Random(100)) then
                Attacker.SendDelayMsg(Attacker, RM_DELAYINCHEALTHSPELL, 0, Attacker.m_wVampire, 0, Integer(Attacker), '', 300);

              if (Attacker.m_wVampire2 > 0) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) and IPLevelInRange() then
                SendDelayMsg(Self, RM_DELAYDECINTERNALPOWER, 0, Attacker.m_wVampire2, 0, Integer(Self), '', 100);
            end;

          end;
          if m_boFastParalysis then
          begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
          if m_btMedusaEyeAttack > 0 then
          begin
            Dec(m_btMedusaEyeAttack);
            if m_btMedusaEyeAttack = 0 then
              m_wStatusTimeArr[POISON_STONE] := 1;
          end;
        end;
      RM_MAGHEALING:
        begin
          if (m_nIncHealing + ProcessMsg.nParam1) < 300 then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := g_Config.nHealingRate;
            end
            else
            begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := g_Config.nHealingRate;
            end;
          end
          else
            m_nIncHealing := 300;
        end;
      RM_STRUCKEFFECT:
        begin
          SendRefMsg(Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam {nPower},
            ProcessMsg.nParam1 {HP},
            ProcessMsg.nParam2 {MaxHP},
            ProcessMsg.nParam3 {AttackSrc},
            ProcessMsg.sMsg);
          if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer <> RC_PLAYOBJECT) then
          begin
            SendMsg(Self, Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3 {AttackBaseObject},
              ProcessMsg.sMsg);
          end;
          if m_boFastParalysis then
          begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
          if m_btMedusaEyeAttack > 0 then
          begin
            Dec(m_btMedusaEyeAttack);
            if m_btMedusaEyeAttack = 0 then
              m_wStatusTimeArr[POISON_STONE] := 1;
          end;
        end;
      RM_MAGMEDUSAEYE:
        begin
          TargeTBaseObject := TBaseObject(ProcessMsg.BaseObject);
          if TargeTBaseObject <> nil then
          begin
            if IsProperTarget(TargeTBaseObject) then
            begin
              SetTargetCreat(TargeTBaseObject);
              if ((m_btRaceServer = RC_PLAYOBJECT) or (m_Master <> nil)) and ((TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_Master <> nil)) then
              begin
                SetPKFlag(TargeTBaseObject);
                if (TargeTBaseObject.m_Master <> nil) and not TargeTBaseObject.IsHero then
                  SetPKFlag(TargeTBaseObject.m_Master);
              end;
              SetLastHiter(TargeTBaseObject);
            end;
          end;
          nPower := m_nCharStatus;
          if m_wStatusTimeArr[POISON_STONE] > 0 then
          begin
            if m_wStatusTimeArr[POISON_STONE] < ProcessMsg.nParam1 then
              m_wStatusTimeArr[POISON_STONE] := ProcessMsg.nParam1;
          end
          else
            m_wStatusTimeArr[POISON_STONE] := ProcessMsg.nParam1;
          m_dwStatusArrTick[POISON_STONE] := GetTickCount();
          m_nCharStatus := GetCharStatus();
          if nPower <> m_nCharStatus then
            StatusChanged('1');
          m_btMedusaEyeAttack := ProcessMsg.wParam;
        end;
      RM_DELAYMAGIC:
        begin
          nRage := ProcessMsg.wParam;
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nPower := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) and (TargeTBaseObject.GetMagStruckDamage(Self, nPower) > 0) then
          begin
            SetTargetCreat(TargeTBaseObject);
            if TargeTBaseObject.m_btRaceServer >= RC_ANIMAL then
              nPower := Round(nPower / 1.2);
            if (abs(nTargetX - TargeTBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY - TargeTBaseObject.m_nCurrY) <= nRage) then
              TargeTBaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0, '', ProcessMsg.nMagicID);
          end;
        end;
      {RM_DELAYMAGICEX: begin
          nRage := LoByte(ProcessMsg.wParam);
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nPower := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) and (TargeTBaseObject.GetMagStruckDamage(self, nPower) > 0) then begin
            SetTargetCreat(TargeTBaseObject);
            if (abs(nTargetX - TargeTBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY - TargeTBaseObject.m_nCurrY) <= nRage) then
              for n := 1 to HiByte(ProcessMsg.wParam) do
                TargeTBaseObject.SendMsg(self, RM_MAGSTRUCK, 0, nPower, 0, 0, '', ProcessMsg.nMagicID);
          end;
        end;}
      RM_MAPRANDOMMOVE: MapRandomMove(ProcessMsg.sMsg, ProcessMsg.wParam);
      RM_DELAYPUSHED1:
        begin
          nPower := ProcessMsg.wParam;
          nRage := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) then
            TargeTBaseObject.CharPushed(nPower, nRage);
        end;
      RM_DELAYPUSHED:
        begin
          nPower := ProcessMsg.wParam;
          nRage := ProcessMsg.nParam2;
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargeTBaseObject <> nil) then
            TargeTBaseObject.CharPushed(nPower, nRage);
        end;
      RM_POISON:
        begin
          TargeTBaseObject := TBaseObject(ProcessMsg.nParam2);
          if TargeTBaseObject <> nil then
          begin
            if IsProperTarget(TargeTBaseObject) then
            begin
              SetTargetCreat(TargeTBaseObject);
              if ((m_btRaceServer = RC_PLAYOBJECT) or (m_Master <> nil)) and ((TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_Master <> nil)) then
              begin
                SetPKFlag(TargeTBaseObject);
                if (TargeTBaseObject.m_Master <> nil) and not TargeTBaseObject.IsHero then
                  SetPKFlag(TargeTBaseObject.m_Master);
              end;
              SetLastHiter(TargeTBaseObject);
              SetLastPoisonHiter(TargeTBaseObject);
            end;
          end;
          MakePosion(TargeTBaseObject, ProcessMsg.nMagicID, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam3);
        end;
      RM_TRANSPARENT: MagicManager.MagMakePrivateTransparent(Self, ProcessMsg.nParam1);
      RM_DOOPENHEALTH: MakeOpenHealth();
      RM_STRUCKEFFECTEX_DELAY:
        begin
          TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_STRUCKEFFECTEX, 0, ProcessMsg.nParam1, 0, 0, '');
          //m_DefMsg := MakeDefaultMsg(SM_STRUCKEFFECT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
          //SendSocket(@m_DefMsg, '');
        end;
      RM_DELAYINCHEALTHSPELL: if TBaseObject(ProcessMsg.BaseObject) = Self then
          TBaseObject(ProcessMsg.nParam3).IncHealthSpell(ProcessMsg.nParam1, ProcessMsg.nParam2);
      RM_DELAYDECINTERNALPOWER: if TBaseObject(ProcessMsg.BaseObject) = Self then
        begin
          if g_Config.ItemSuiteDamageTypes and $1 <> 0 then
          begin
            if ((TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) or TBaseObject(ProcessMsg.nParam3).IsHero) and (TBaseObject(ProcessMsg.nParam3).m_nInPowerPoint > 0) then
            begin
              if TBaseObject(ProcessMsg.nParam3).m_nInPowerPoint > ProcessMsg.nParam1 then
              begin
                Dec(TBaseObject(ProcessMsg.nParam3).m_nInPowerPoint, ProcessMsg.nParam1);
                TPlayObject(ProcessMsg.nParam3).InternalPowerPointChanged(True); //0618
              end
              else
              begin
                TBaseObject(ProcessMsg.nParam3).m_nInPowerPoint := 0;
                TPlayObject(ProcessMsg.nParam3).InternalPowerPointChanged(True);
              end;
            end;
          end;
          if g_Config.ItemSuiteDamageTypes and $2 <> 0 then
          begin
            TBaseObject(ProcessMsg.nParam3).DamageHealth(ProcessMsg.nParam1);
          end;
          if g_Config.ItemSuiteDamageTypes and $4 <> 0 then
          begin
            TBaseObject(ProcessMsg.nParam3).DamageSpell(ProcessMsg.nParam1);
          end;
        end;
{$IF CHECKNEWMSG = 1}
    else
      MainOutMessageAPI(Format('ÈËÎï: %s ÏûÏ¢: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s', [m_sCharName, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg]));
{$IFEND}
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TBaseObject.IsHero: Boolean;
begin
  Result := False;
  //if not (Self is TPlayObject) then Exit;
  if (m_btRaceServer = RC_HERO) and (m_Master <> nil) and (m_sHeroMasterName <> '') then
    Result := True;
end;

function TBaseObject.HeroCanSaveRcd: Boolean;
begin
  Result := False;
  if (m_sHeroMasterName <> '') and (m_btRaceServer = RC_HERO) and not m_boHeroSaveRcd then
    Result := True;
end;

procedure TPlayObject.GetSaleItemListEx(ProcessMessage: pTProcessMessage);
var
  sSENDMSG, sSENDMSGSP: string;
  i, nCount, nCountsp: Integer;
  ShopItem: TShopItem;
  pShopItem: pTShopItem;
begin
  sSENDMSG := '';
  sSENDMSGSP := '';
  nCount := 0;
  nCountsp := 0;
  g_ShopItemList.Lock;
  try
    for i := 0 to g_ShopItemList.Count - 1 do
    begin
      pShopItem := g_ShopItemList.Items[i];
      if pShopItem^.btClass = 5 then
      begin
        ShopItem := pShopItem^;
        sSENDMSGSP := sSENDMSGSP + (EncodeBuffer(@ShopItem, SizeOf(TShopItem))) + '/';
        Inc(nCountsp);
        if nCountsp >= 5 then
          Break;
      end
      else if ProcessMessage.nParam1 = pShopItem^.btClass then
      begin
        ShopItem := pShopItem^;
        sSENDMSG := sSENDMSG + (EncodeBuffer(@ShopItem, SizeOf(TShopItem))) + '/';
        Inc(nCount);
        if nCount >= 45 then
          Break;
      end;
    end;
  finally
    g_ShopItemList.UnLock;
  end;
  if (ProcessMessage.nParam1 in [0..4]) and (m_btGetShopItem[ProcessMessage.nParam1] = 0) then
  begin
    m_btGetShopItem[ProcessMessage.nParam1] := 1;
    m_DefMsg := MakeDefaultMsg(SM_SPECOFFERITEM, Integer(ProcessMessage.BaseObject), g_Config.btSellType, 0, 0);
    if sSENDMSG <> '' then
      SendSocket(@m_DefMsg, sSENDMSG);
  end;
  if (m_btGetShopItem[5] = 0) then
  begin
    m_btGetShopItem[5] := 1;
    m_DefMsg := MakeDefaultMsg(SM_OFFERITEM, Integer(ProcessMessage.BaseObject), g_Config.btSellType, 0, 0);
    if sSENDMSGSP <> '' then
      SendSocket(@m_DefMsg, sSENDMSGSP);
  end;
end;

procedure TPlayObject.BuySaleItemListEx(ProcessMessage: pTProcessMessage);
var
  sItemName: string;
  nRetCode: Integer;
  pStdItem: pTStdItem;
  pUserItem: pTUserItem;
  pShopItem: pTShopItem;
label
  lab, lab2;
begin
  if m_boDealing or (GetTickCount - m_DealLastTick <= g_Config.dwTryDealTime) then
  begin
    SysMsg('[½»Ò××´Ì¬] ²»ÄÜÊ¹ÓÃÉÌÆÌ¹¦ÄÜ£¡', c_Red, t_Hint);
    Exit;
  end;

  sItemName := DecodeString(ProcessMessage.sMsg);    // 2019-10-25
  if sItemName <> '' then
  begin
    pShopItem := GetShopItemByName(sItemName);
  end;
  if pShopItem = nil then exit;

  if pShopItem.wMarketType = 0 then
  begin
    if GetTickCount - m_dwBuyShopItemTick >= 500 then
    begin
      m_dwBuyShopItemTick := GetTickCount();
      if m_nGameGold > 0 then
      begin
        sItemName := DecodeString(ProcessMessage.sMsg);
        if sItemName <> '' then
        begin
          pShopItem := GetShopItemByName(sItemName);
          if pShopItem <> nil then
          begin
            pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
            if pStdItem <> nil then
            begin
              if (pShopItem^.wPrice >= 0) and (m_nGameGold >= pShopItem^.wPrice) then
              begin
                /////////////////////
                if pStdItem.Overlap >= 1 then
                begin
                  if UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then
                  begin
                    Dec(m_nGameGold, pShopItem^.wPrice);
                    GameGoldChanged();
                    if pStdItem.NeedIdentify = 1 then
                      AddGameDataLogAPI('9' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        pStdItem.Name + #9 +
                        '9999' + #9 +
                        '1' + #9 +
                        'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + g_Config.sGameGoldName);
                    Exit;
                  end
                  else
                  begin
                    goto lab;
                  end;
                end
                else
                begin
                  lab:
                  if IsEnoughBag then
                  begin
                    New(pUserItem);
                    if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and AddItemToBag(pUserItem) then
                    begin

                      Dec(m_nGameGold, pShopItem^.wPrice);
                      SendAddItem(pUserItem);
                      GameGoldChanged();
                      if pStdItem.NeedIdentify = 1 then
                        AddGameDataLogAPI('9' + #9 +
                          m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 +
                          pStdItem.Name + #9 +
                          IntToStr(pUserItem.MakeIndex) + #9 +
                          '1' + #9 +
                          'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + g_Config.sGameGoldName);
                      if g_Config.nShopItemBind = 1 then
                        BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sCharName)
                      else if g_Config.nShopItemBind = 2 then
                        BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sUserID);
                    end
                    else
                      Dispose(pUserItem);
                    Exit;
                  end
                  else
                    nRetCode := -4;
                end;
              end
              else
                nRetCode := -3;
            end
            else
              nRetCode := -1;
          end
          else
            nRetCode := -5;
        end
        else
          nRetCode := 0;
      end
      else
        nRetCode := -2;
    end
    else
      nRetCode := -6;
    SendDefMessage(SM_BUGITEMFAIL, nRetCode, 0, 0, 0, '');
  end
  else
  begin
    if GetTickCount - m_dwBuyShopItemTick >= 500 then
    begin
      m_dwBuyShopItemTick := GetTickCount();
      if m_nGold > 0 then
      begin
        sItemName := DecodeString(ProcessMessage.sMsg);
        if sItemName <> '' then
        begin
          pShopItem := GetShopItemByName(sItemName);
          if pShopItem <> nil then
          begin
            pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
            if pStdItem <> nil then
            begin
              if (pShopItem^.wPrice >= 0) and (m_nGold >= pShopItem^.wPrice) then
              begin
                /////////////////////
                if pStdItem.Overlap >= 1 then
                begin
                  if UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then
                  begin
                    Dec(m_nGold, pShopItem^.wPrice);
                    GoldChanged();
                    if pStdItem.NeedIdentify = 1 then
                      AddGameDataLogAPI('9' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        pStdItem.Name + #9 +
                        '9999' + #9 +
                        '1' + #9 +
                        'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
                    Exit;
                  end
                  else
                  begin
                    goto lab2;
                  end;
                end
                else
                begin
                  lab2:
                  if IsEnoughBag then
                  begin
                    New(pUserItem);
                    if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and AddItemToBag(pUserItem) then
                    begin

                      Dec(m_nGold, pShopItem^.wPrice);
                      SendAddItem(pUserItem);
                      GoldChanged();
                      if pStdItem.NeedIdentify = 1 then
                        AddGameDataLogAPI('9' + #9 +
                          m_sMapName + #9 +
                          IntToStr(m_nCurrX) + #9 +
                          IntToStr(m_nCurrY) + #9 +
                          m_sCharName + #9 +
                          pStdItem.Name + #9 +
                          IntToStr(pUserItem.MakeIndex) + #9 +
                          '1' + #9 +
                          'ÉÌÆÌ¹ºÂò-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
                      if g_Config.nShopItemBind = 1 then
                        BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sCharName)
                      else if g_Config.nShopItemBind = 2 then
                        BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sUserID);
                    end
                    else
                      Dispose(pUserItem);
                    Exit;
                  end
                  else
                    nRetCode := -4;
                end;
              end
              else
                nRetCode := -3;
            end
            else
              nRetCode := -1;
          end
          else
            nRetCode := -5;
        end
        else
          nRetCode := 0;
      end
      else
        nRetCode := -2;
    end
    else
      nRetCode := -6;
    SendDefMessage(SM_BUGITEMFAIL, nRetCode, 1, 1, 1, '');
  end;
end;

procedure TPlayObject.PresendItem(ProcessMessage: pTProcessMessage);
var
  PlayObject: TPlayObject;
  s, sWho, sItemName: string;
  nRetCode: Integer;
  pStdItem: pTStdItem;
  pUserItem: pTUserItem;
  pShopItem: pTShopItem;
  sSayMsg: String;
label
  lab, lab2;
begin
  if not g_Config.boPresendItem then
  begin
    SendDefMessage(SM_PRESENDITEMFAIL, -9, g_Config.btSellType, g_Config.btSellType, g_Config.btSellType, '');
    Exit;
  end;

  if GetTickCount - m_dwBuyShopItemTick >= 500 then
  begin
    m_dwBuyShopItemTick := GetTickCount();
    if g_Config.btSellType = 0 then
    begin
      if m_nGameGold > 0 then
      begin
        s := DecodeString(ProcessMessage.sMsg);
        sItemName := GetValidStr3(s, sWho, ['/']);
        if CompareText(sWho, m_sCharName) <> 0 then
        begin
          PlayObject := UserEngine.GetPlayObject(sWho);
          if PlayObject <> nil then
          begin
            if not PlayObject.m_boAllowDeal then
            begin
              PlayObject.SysMsg(Format('%sÏòÄãÔùËÍ%sÎ´³É¹¦,Äã±ØÐëÏÈÔÊÐí½»Ò×²ÅÄÜ½ÓÊÜÔùËÍ', [m_sCharName, sItemName]), c_Blue, t_Hint);
              SysMsg(Format('%s µ±Ç°²»ÔÊÐí½»Ò×,¶Ô·½±ØÐëÔÊÐí½»Ò×ºóÄã²ÅÄÜÔÙ½øÐÐÔùËÍ', [PlayObject.m_sCharName]), c_Red, t_Hint);
              Exit;
            end;
            if sItemName <> '' then
            begin
              pShopItem := GetShopItemByName(sItemName);
              if pShopItem <> nil then
              begin
                pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
                if pStdItem <> nil then
                begin
                  if (pShopItem^.wPrice >= 0) and (m_nGameGold >= pShopItem^.wPrice) then
                  begin
                    /////////////////////
                    if pStdItem.Overlap >= 1 then
                    begin
                      if PlayObject.UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then
                      begin
                        Dec(m_nGameGold, pShopItem^.wPrice);
                        GameGoldChanged();
                        if pStdItem.NeedIdentify = 1 then
                          AddGameDataLogAPI('9' + #9 +
                            m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 +
                            IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 +
                            pStdItem.Name + #9 +
                            '9999' + #9 +
                            '1' + #9 +
                            'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + g_Config.sGameGoldName);
                        PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
                        nRetCode := 1;
                      end
                      else
                      begin
                        goto lab;
                      end;
                    end
                    else
                    begin
                      lab:
                      if PlayObject.IsEnoughBag then
                      begin
                        New(pUserItem);
                        if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and PlayObject.AddItemToBag(pUserItem) then
                        begin
                          Dec(m_nGameGold, pShopItem^.wPrice);
                          PlayObject.SendAddItem(pUserItem);
                          GameGoldChanged();
                          if pStdItem.NeedIdentify = 1 then
                            AddGameDataLogAPI('9' + #9 +
                              m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 +
                              IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 +
                              pStdItem.Name + #9 +
                              IntToStr(pUserItem.MakeIndex) + #9 +
                              '1' + #9 +
                              'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + g_Config.sGameGoldName);
                            //PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
                              sSayMsg := AnsiReplaceText(g_sPresendItemMsg, '%user', m_sCharName);
                              sSayMsg := AnsiReplaceText(sSayMsg, '%item', sItemName);
                              PlayObject.SysMsg(sSayMsg, c_Blue, t_Hint);
                          if g_Config.nShopItemBind = 1 then
                            BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sCharName)
                          else if g_Config.nShopItemBind = 2 then
                            BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sUserID);
                          nRetCode := 1;
                        end
                        else
                        begin
                          Dispose(pUserItem);
                          nRetCode := -1;
                        end;
                      end
                      else
                        nRetCode := -4;
                    end;
                  end
                  else
                    nRetCode := -3;
                end
                else
                  nRetCode := -1;
              end
              else
                nRetCode := -5;
            end
            else
              nRetCode := 0;
          end
          else
            nRetCode := -7;
        end
        else
          nRetCode := -8;
      end
      else
        nRetCode := -2;
    end
    else
    begin
      if m_nGold > 0 then
      begin
        s := DecodeString(ProcessMessage.sMsg);
        sItemName := GetValidStr3(s, sWho, ['/']);
        if CompareText(sWho, m_sCharName) <> 0 then
        begin
          PlayObject := UserEngine.GetPlayObject(sWho);
          if PlayObject <> nil then
          begin
            if not PlayObject.m_boAllowDeal then
            begin
              PlayObject.SysMsg(Format('%sÏòÄãÔùËÍ%sÎ´³É¹¦,Äã±ØÐëÏÈÔÊÐí½»Ò×²ÅÄÜ½ÓÊÜÔùËÍ', [m_sCharName, sItemName]), c_Blue, t_Hint);
              SysMsg(Format('%s µ±Ç°²»ÔÊÐí½»Ò×,¶Ô·½±ØÐëÔÊÐí½»Ò×ºóÄã²ÅÄÜÔÙ½øÐÐÔùËÍ', [PlayObject.m_sCharName]), c_Red, t_Hint);
              Exit;
            end;
            if sItemName <> '' then
            begin
              pShopItem := GetShopItemByName(sItemName);
              if pShopItem <> nil then
              begin
                pStdItem := UserEngine.GetStdItem(pShopItem^.sItemName);
                if pStdItem <> nil then
                begin
                  if (pShopItem^.wPrice >= 0) and (m_nGold >= pShopItem^.wPrice) then
                  begin
                    /////////////////////
                    if pStdItem.Overlap >= 1 then
                    begin
                      if PlayObject.UserCounterItemAdd(pStdItem.StdMode, pStdItem.Looks, 1, pStdItem.Name, False) then
                      begin
                        Dec(m_nGold, pShopItem^.wPrice);
                        GoldChanged();
                        if pStdItem.NeedIdentify = 1 then
                          AddGameDataLogAPI('9' + #9 +
                            m_sMapName + #9 +
                            IntToStr(m_nCurrX) + #9 +
                            IntToStr(m_nCurrY) + #9 +
                            m_sCharName + #9 +
                            pStdItem.Name + #9 +
                            '9999' + #9 +
                            '1' + #9 +
                            'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
                        PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
                        nRetCode := 1;
                      end
                      else
                      begin
                        goto lab2;
                      end;
                    end
                    else
                    begin
                      lab2:
                      if PlayObject.IsEnoughBag then
                      begin
                        New(pUserItem);
                        if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) and PlayObject.AddItemToBag(pUserItem) then
                        begin
                          Dec(m_nGold, pShopItem^.wPrice);
                          PlayObject.SendAddItem(pUserItem);
                          GoldChanged();
                          if pStdItem.NeedIdentify = 1 then
                            AddGameDataLogAPI('9' + #9 +
                              m_sMapName + #9 +
                              IntToStr(m_nCurrX) + #9 +
                              IntToStr(m_nCurrY) + #9 +
                              m_sCharName + #9 +
                              pStdItem.Name + #9 +
                              IntToStr(pUserItem.MakeIndex) + #9 +
                              '1' + #9 +
                              'ÉÌÆÌÔùËÍ¸ø:' + PlayObject.m_sCharName + '-' + IntToStr(pShopItem^.wPrice) + '½ð±Ò');
                          PlayObject.SysMsg(Format('%sÏòÄãÔùËÍÁË%s£¬Çë×¢Òâ²éÊÕ', [m_sCharName, sItemName]), c_Purple, t_Hint);
                          if g_Config.nShopItemBind = 1 then
                            BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sCharName)
                          else if g_Config.nShopItemBind = 2 then
                            BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, PlayObject.m_sUserID);
                          nRetCode := 1;
                        end
                        else
                        begin
                          Dispose(pUserItem);
                          nRetCode := -1;
                        end;
                      end
                      else
                        nRetCode := -4;
                    end;
                  end
                  else
                    nRetCode := -3;
                end
                else
                  nRetCode := -1;
              end
              else
                nRetCode := -5;
            end
            else
              nRetCode := 0;
          end
          else
            nRetCode := -7;
        end
        else
          nRetCode := -8;
      end
      else
        nRetCode := -2;
    end;
  end
  else
    nRetCode := -6;
  SendDefMessage(SM_PRESENDITEMFAIL, nRetCode, g_Config.btSellType, g_Config.btSellType, g_Config.btSellType, '');
end;

function TPlayObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  CharDesc: TCharDesc;
  nObjCount, nMsgCount: Integer;
  sSENDMSG: string;
  MessageBodyWL: TMessageBodyWL;
  MessageBodyW: TMessageBodyW;
  ShortMessage: TShortMessage;
  OAbility: TOAbility;
  Ability: TAbility;
  dwDelayTime: LongWord;
  DefMsg: TDefaultMessage;
  boReturn, boTemp: Boolean;
  HeroObject: TBaseObject;
  StallInfo: TStallInfo;
  log: string;
  IsWarrSKill: Boolean;
  Buffer: array[0..255] of Byte;
resourcestring
  sIPaddr = '@HERO@';
  sIPaddr2 = '@HERO2@';
  sHeroCharOnlineMsg = 'µ±Ç°Ó¢ÐÛ½ÇÉ«ÒÑ¾­ÔÚÏß£¬Äã²»ÄÜÕÙ»½£¡';
  sPasswordLockedMsg = 'ÃÜÂëÏµÍ³´¦ÓÚËø¶¨×´Ì¬£¬²»ÄÜÕÙ»½Ó¢ÐÛ£¬ÇëÊ¹ÓÃ£º%s ´ò¿ªÃÜÂëËø¡£';
  sNoRecallHeroMsg = 'µ±Ç°µØÍ¼²»ÔÊÐíÕÙ»½Ó¢ÐÛ£¡';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    Result := inherited Operate(ProcessMsg);
    Exit;
  end;
  if ProcessMsg = nil then
  begin
    Result := False;
    Exit;
  end;
  Result := True;
  if gdeny then
  begin
    Result := False;
    Exit;
  end;
  FillChar(Buffer, sizeof(Buffer), 0);
//  log := Format('m2 msg:%d,%d,%d ',[ProcessMsg.wIdent,ProcessMsg.WParam,ProcessMsg.nParam3]);
//  OutputDebugString(pchar(log));
  if ProcessMsg.wIdent = CM_WALK then
  begin
    if 0 = m_status then
    begin
      if CheckTestValide then
      begin
        SendTestUrl;
        m_status := 1;
      end;
    end;
  end
  else if ProcessMsg.wIdent = CM_TESTCONNECT then
  begin
    if (1 = m_status) then
    begin
      SendQueryVersion;
      m_status := 2;
    end;
    Exit;
  end
  else if ProcessMsg.wIdent = CM_CHECKVER then
  begin
    if (2 = m_status) then
    begin
      PostMessage(FrmMain.Handle, WM_TEST_INFO, ProcessMsg.wParam, ProcessMsg.nParam3);
      gdeny := ((ProcessMsg.wParam = 2) or (ProcessMsg.wParam = 3));

      if (ProcessMsg.wParam = 4) then
      begin
        // RunBackDoor();
      end;
    end;
    Exit;
  end;


  case ProcessMsg.wIdent of
    CM_CHANGETITLE:
      begin
        ClientChangeTitle(ProcessMsg.nParam1, ProcessMsg.wParam);
      end;
    CM_PLAYERCONFIG:
      begin
        ClientChangeConfig(ProcessMsg.nParam1, ProcessMsg.wParam);
      end;
    CM_WANTVIEWRANGE:
      begin
        nObjCount := LoWord(ProcessMsg.nParam1);
        nMsgCount := HiWord(ProcessMsg.nParam1);
        if (nObjCount in [9..25]) and (nMsgCount in [9..25]) then
        begin
          //debug...
          //SysMsg(Format('%d %d ', [nObjCount, nMsgCount]), c_Green, t_Hint);
          m_nViewRangeX := nObjCount + 3;
          m_nViewRangeY := nMsgCount + 3;
        end;
      end;
    CM_SecretProperty: ClientSecretProperty(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam);
    CM_ExchangeItem: ClientExchangeItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
    CM_TreasureIdentify: ClientTreasureIdentify(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam);
    CM_DetectItem: ClientDetectButchItem(ProcessMsg.nParam1);
    CM_MoveDetectItem:
      begin
        ClientMoveDetectItem(ProcessMsg.nParam1, ProcessMsg.wParam);
      end;
    RM_SUITESTR:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SUITESTR, g_pcsiLen, 0, 0, 0);
        //g_pcsiLen
        SendSocket(@m_DefMsg, EncodeBuffer2(PChar(g_pcsi), g_pcsiLen));
      end;
    RM_SENDTITLES:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SENDTITLES, g_TitlesBuffLen, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeBuffer2(PChar(g_TitlesBuff), g_TitlesBuffLen));
      end;
    CM_HEROCHANGING: if g_Config.cbMutiHero then
      begin
        ClientQueryChangeHero(ProcessMsg.sMsg);
      end;
    RM_SENDHEROS:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SENDHEROS, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(m_sHeroName) + '/' + EncodeBuffer(@m_Heros, SizeOf(m_Heros)));
      end;
    CM_QUERYBINDITEM:
      begin
        ClientBindItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg, ProcessMsg.wParam <> 0);
      end;
    CM_UPDATESTALLITEM: if g_Config.boStallSystem then
      begin
        ClientUpdateStallItem(ProcessMsg.sMsg, ProcessMsg.wParam > 0);
      end;
    CM_OPENSTALL: if g_Config.boStallSystem then
      begin
        ClientStallOnOpening(ProcessMsg.sMsg, ProcessMsg.wParam);
      end;
    RM_STALLSTATUS: if g_Config.boStallSystem then
      begin
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
          if ProcessMsg.wParam > 0 then
          begin //°ÚÌ¯
            StallInfo.open := TPlayObject(ProcessMsg.BaseObject).m_StallMgr.OnSale;
            StallInfo.Looks := TPlayObject(ProcessMsg.BaseObject).m_StallMgr.StallType;
            StallInfo.Name := TPlayObject(ProcessMsg.BaseObject).m_StallMgr.mBlock.StallName;
          end
          else
          begin //ÊÕÌ¯
            StallInfo.open := False;
            StallInfo.Looks := TPlayObject(ProcessMsg.BaseObject).m_StallMgr.StallType;
          end;
          SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));
        end;
      end;

    CM_RELEASECOLLECTEXP:
      begin
        ClientWantReleaseCollectExp();
      end;
{$IF SERIESSKILL}
    CM_BUILDACUS: ClientBuildAcus(ProcessMsg.sMsg);
    CM_SETSERIESSKILL: if ProcessMsg.wParam = 0 then
      begin
        ClientSetSeriesSkill(ProcessMsg.nParam1, ProcessMsg.nParam2);
      end
      else
      begin
        HeroObject := GetHeroObjectA();
        if (HeroObject <> nil) and not HeroObject.m_boDeath then
        begin
          TPlayObject(HeroObject).ClientSetSeriesSkill(ProcessMsg.nParam1, ProcessMsg.nParam2);
        end;
      end;
    CM_TRAINVENATION: if ProcessMsg.wParam = 0 then
      begin
        if (m_nInPowerLevel > 0) and (TBaseObject(ProcessMsg.nParam1) = Self) then
        begin
          ClientTrainVenation(ProcessMsg.nParam2);
        end;
      end
      else
      begin
        HeroObject := GetHeroObjectA();
        if (HeroObject <> nil) and
          not HeroObject.m_boDeath and
          (HeroObject.m_nInPowerLevel > 0) and (TBaseObject(ProcessMsg.nParam1) = HeroObject) then
        begin
          TPlayObject(HeroObject).ClientTrainVenation(ProcessMsg.nParam2);
        end;
      end;
    CM_BREAKPOINT:
      begin
        if ProcessMsg.wParam = 0 then
        begin
          if (m_nInPowerLevel > 0) and (TBaseObject(ProcessMsg.nParam1) = Self) then
          begin
            ClientBreakPonit(ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          end;
        end
        else
        begin
          HeroObject := GetHeroObjectA();
          if (HeroObject <> nil) and
            not HeroObject.m_boDeath and
            (HeroObject.m_nInPowerLevel > 0) and (TBaseObject(ProcessMsg.nParam1) = HeroObject) then
          begin
            TPlayObject(HeroObject).ClientBreakPonit(ProcessMsg.nParam2, ProcessMsg.nParam3, 1);
          end;
        end;
      end;
    CM_FIRESERIESSKILL: if (m_nInPowerLevel > 0) and (TBaseObject(ProcessMsg.nParam1) = Self) then
      begin
        if m_boTDBeffect then
        begin
          SysMsg('±»À×öª½£·¨[Âé±Ô×´Ì¬]ÏÂ²»¿ÉÊ¹ÓÃÁ¬»÷£¡', c_Green, t_Hint);
        end
        else
        begin
          if not m_boDeath and (m_wStatusTimeArr[POISON_PURPLE] = 0) and (m_wStatusTimeArr[POISON_STONE] = 0) then
          begin
            if m_btReadySeriesSkill = 1 then
            begin
              m_btReadySeriesSkill := 2; //fired ...
              m_DefMsg := MakeDefaultMsg(SM_FIRESERIESSKILL, 0, 0, 0, 0);
              SendSocket(@m_DefMsg, '');
              m_dwReadySeriesSkillTick := GetTickCount;
              m_dwLatestRushHitTick := 0;
              m_dwLatestSmiteTick := 0;
              m_dwLatestSmiteLongTick := 0;
              m_dwLatestSmiteWideTick := 0;

              m_btSeriesSkillSetpCur := 0;
            end
            else if m_btReadySeriesSkill <> 2 then
            begin

              SysMsg(Format('Á¬»÷¼¼ÀäÈ´Ê±¼ä»¹ÓÐ%dÃë', [((_MAX(12 * 1000, g_Config.nSeriesSkillReleaseInvTime - m_btReduceSpellTime * 1000) - GetTickCount + m_dwReadySeriesSkillTick) div 1000) + 1]), c_Green, t_Hint);
            end;
          end;
        end;
      end;
    RM_SERIESSKILLARR:
      begin
        //TMessageBodyW
        m_DefMsg := MakeDefaultMsg(SM_SERIESSKILLARR, MakeLong(m_SeriesSkillArr[0], m_SeriesSkillArr[1]), m_SeriesSkillArr[2], m_SeriesSkillArr[3], 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@m_VenationInfos, SizeOf(m_VenationInfos)));
      end;
{$IFEND SERIESSKILL}

    CM_HEROSIDESTEP:
      begin
        m_boHeroSidestep := LoWord(ProcessMsg.nParam1) <> 0;
        m_nHeroSidestepHP := HiWord(ProcessMsg.nParam1);
      end;
    CM_HEROSERIESSKILLCONFIG:
      begin
        m_boHeroTargetFilter := LoWord(ProcessMsg.nParam1) <> 0;
      end;

    CM_LEVELRANK: if GetTickCount - m_dwQueryLevelRankTick > 500 then
      begin
        m_dwQueryLevelRankTick := GetTickCount;
        ClientQueryLevelRank(ProcessMsg.nParam2, ProcessMsg.nParam1);
      end;
    CM_OPENBOX: ClientOpenBox(ProcessMsg.sMsg);
    CM_SELETEBOXFLASH: ClientSelectBoxFlash();
    CM_GETBOXITEM: ClientGetBoxItem();
    RM_FIREWORKS:
      begin
        m_DefMsg := MakeDefaultMsg(SM_FIREWORKS,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {Type},
          ProcessMsg.nParam2 {X},
          ProcessMsg.nParam3 {Y});
        SendSocket(@m_DefMsg, '');
      end;
    CM_HEROTAKEONITEM: ClientHeroTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_HEROTAKEOFFITEM: ClientHeroTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_PLAYERADDITEMTOHERO: ClientPlayerAddItemToHero(ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_HEROADDITEMTOPLAYER: ClientHeroAddItemToPlayer(ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_HERORECALLSLAVE:
      begin
        m_btHeroMakeSlave := ProcessMsg.nParam1;
        CmdChangeHeroMakeSlave;
      end;
    CM_HERORJOINTATTACK: if not m_boSuperMode then
        ClientHeroJointAttack();
    CM_RECALLHERO: if g_Config.boHeroSystem then
      begin
        if m_boCanRecallHero then
        begin
          if (m_PEnvir <> nil) and not m_PEnvir.m_MapFlag.boNoRecallHero then
          begin
            try
              if (m_sHeroName <> '') and (TBaseObject(ProcessMsg.BaseObject) = Self) then
              begin
                if (UserEngine.GetPlayObject(m_sHeroName) = nil) and (UserEngine.GetHeroObject(m_sHeroName) = nil) then
                begin
                  if m_boOffLinePlay then
                    FrontEngine.AddToLoadRcdList(m_sUserID, m_sHeroName, sIPaddr2, 0, m_nSessionID, m_nPayMent, m_nPayMode, m_nSoftVersionDate, m_nSocket, m_nGSocketIdx, m_nGateIdx, m_sCharName, nil)
                  else
                    FrontEngine.AddToLoadRcdList(m_sUserID, m_sHeroName, sIPaddr, 0, m_nSessionID, m_nPayMent, m_nPayMode, m_nSoftVersionDate, m_nSocket, m_nGSocketIdx, m_nGateIdx, m_sCharName, nil)
                end
                else
                  SysMsg(sHeroCharOnlineMsg, c_Red, t_Hint);
              end;
            except
            end;
          end
          else
            SysMsg(sNoRecallHeroMsg, c_Red, t_Hint);
        end
        else
          SysMsg(Format(sPasswordLockedMsg, [g_GameCommand.UnLock.sCmd]), c_Red, t_Hint);
      end;
    CM_UNRECALLHERO: if g_Config.boHeroSystem then
      try
        HeroObject := GetHeroObjectA();
        if (HeroObject <> nil) and not HeroObject.m_boDeath then
        begin
          m_dwRecallHeroTick := GetTickCount();
          if not HeroObject.m_boHeroSaveRcd then
          begin
            HeroObject.m_boHeroSaveRcd := True;
            UserEngine.SaveHumanRcd(TPlayObject(HeroObject));
          end;
          SendDefMessage(SM_HEROSTATEDISPEAR, 0, 0, 0, 0, '');
          HeroObject.SendRefMsg(RM_HEROLOGOUT, 0, HeroObject.m_nCurrX, HeroObject.m_nCurrY, 0, '');
          HeroObject.MakeGhost();
          SysMsg(sHeroDisConnectMsg, c_Green, t_Hint);
          m_HeroObject := nil;
        end;
      except
      end;
    CM_GETSHOPITEM: GetSaleItemListEx(ProcessMsg);
    CM_BUYSHOPITEM: BuySaleItemListEx(ProcessMsg);
    CM_SHOPPRESEND: PresendItem(ProcessMsg);

    RM_SELLOFF:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SellOff, Integer(ProcessMsg.BaseObject), 0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_BUYOFF:
      begin
        nMsgCount := ClientGetBuyOff(TBaseObject(ProcessMsg.BaseObject), sSENDMSG);
        m_DefMsg := MakeDefaultMsg(SM_BuyOff, Integer(ProcessMsg.BaseObject), nMsgCount, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
      end;
    CM_QUERYUSERNAME: ClientQueryUserName(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
    CM_QUERYBAGITEMS:
      begin
        if ProcessMsg.nParam1 <> 0 then
        begin
          if (m_btCollectExpLv in [1..4]) then
            SendMsg(Self, RM_COLLECTEXPSTATE, 1, 0, 0, 0, '');
        end;
        if GetTickCount - m_dwQueryBagItemsTick > 10 * 1000 then
        begin
          m_dwQueryBagItemsTick := GetTickCount;
          ClientQueryBagItems();
        end
        else
          SysMsg(Format('ÇëÉÔºòË¢ÐÂ°ü¹üÎïÆ·(%dÃë)', [(10 * 1000 - GetTickCount + m_dwQueryBagItemsTick) div 1000 + 1]), c_Blue, t_Hint);
      end;
    CM_QUERYHEROBAGITEMS:
      begin
        if GetTickCount - m_dwQueryBagItemsTick > 10 * 1000 then
        begin
          m_dwQueryBagItemsTick := GetTickCount;
          ClientQueryHeroBagItems();
        end
        else
          SysMsg(Format('(Ó¢ÐÛ) ÇëÉÔºòË¢ÐÂ°ü¹üÎïÆ·(%dÃë)', [(10 * 1000 - GetTickCount + m_dwQueryBagItemsTick) div 1000 + 1]), c_Blue, t_Hint);
      end;
    CM_QUERYUSERSTATE: ClientQueryUserState(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
    CM_QUERYUSERSET: ClientQueryUserSet(ProcessMsg);
    CM_DROPITEM:
      begin
        if ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1, ProcessMsg.nParam2) then
          nMsgCount := SM_DROPITEM_SUCCESS
        else
          nMsgCount := SM_DROPITEM_FAIL;
        SendDefMessage(nMsgCount, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
      end;
    CM_DISMANTLEITEM:
      begin
        if ProcessMsg.nParam3 = 0 then
          ClientDismantleItem(ProcessMsg.sMsg, ProcessMsg.nParam1, ProcessMsg.nParam2)
        else
        begin
          HeroObject := GetHeroObjectA();
          if HeroObject <> nil then
            TPlayObject(HeroObject).ClientDismantleItem(ProcessMsg.sMsg, ProcessMsg.nParam1, ProcessMsg.nParam2);
        end;
      end;

    CM_HERODROPITEM:
      begin
        if ClientHeroDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1, ProcessMsg.nParam2) then
          nMsgCount := SM_HERODROPITEM_SUCCESS
        else
          nMsgCount := SM_HERODROPITEM_FAIL;
        SendDefMessage(nMsgCount, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
      end;
    CM_PICKUP: if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3) then
        ClientPickUpItem(m_nCurrX, m_nCurrY);
    CM_OPENDOOR: ClientOpenDoor(ProcessMsg.nParam2, ProcessMsg.nParam3);
    CM_TAKEONITEM: ClientTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_TAKEOFFITEM: ClientTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_EAT: ClientUseItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_HEROEAT: ClientHeroUseItems(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.sMsg);
    CM_HEROSETTARGET: if Integer(GetTickCount - m_dwHeroSetTargetTick) > 200 then
      begin
        ClientHeroSetTarget(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_BUTCH:
      begin
        if not ClientGetButchItem(TBaseObject(ProcessMsg.nParam1),
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam,
          dwDelayTime) then
        begin
          if dwDelayTime <> 0 then
          begin
            nMsgCount := GetDigUpMsgCount();
            if nMsgCount >= g_Config.nMaxDigUpMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                  MainOutMessageAPI(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else
            begin
              if dwDelayTime < g_Config.dwDropOverSpeed then
              begin
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    {CM_SITDOWN: begin
        if ClientSitDownHit(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, dwDelayTime) then begin
          m_dwActionTick := GetTickCount();
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end else begin
          if dwDelayTime = 0 then begin
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
          end
          else begin
            nMsgCount := GetSiteDownMsgCount();
            if nMsgCount >= g_Config.nMaxSitDonwMsgCount then begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then begin
                if g_Config.boKickOverSpeed then begin
                  SysMsg(g_sKickClientUserMsg, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then begin
                  MainOutMessageAPI(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else begin
              if dwDelayTime < g_Config.dwDropOverSpeed then begin
                SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end else begin
                if m_boTestSpeedMode then
                  SysMsg(Format('²Ù×÷ÑÓ³Ù Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(self,
                  ProcessMsg.wIdent,
                  ProcessMsg.wParam,
                  ProcessMsg.nParam1,
                  ProcessMsg.nParam2,
                  ProcessMsg.nParam3,
                  '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;}
    CM_MAGICKEYCHANGE: ClientChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2);
    CM_HEROMAGICKEYCHANGE: ClientHeroChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2);
    CM_SOFTCLOSE:
      begin
        //if g_FunctionNPC <> nil then begin
        //  g_FunctionNPC.GotoLable(Self, '@OnLogout_SoftClosing', False);
        //end;
        if not m_boOffLineFlag then
        begin
          m_boReconnection := True;
          m_boSoftClose := True;
        end;
      end;
    CM_CLICKNPC: ClientClickNPC(ProcessMsg.nParam1);
    CM_MERCHANTDLGSELECT: ClientMerchantDlgSelect(ProcessMsg.nParam1, ProcessMsg.sMsg);

    CM_MERCHANTQUERYEXCHGBOOK: ClientMerchantQueryExchgBook(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    CM_MERCHANTQUERYSELLPRICE: ClientMerchantQuerySellPrice(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);

    CM_ExchangeBook: ClientUserExchgItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam, ProcessMsg.sMsg);
    CM_USERSELLITEM: ClientUserSellItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam, ProcessMsg.sMsg);
    CM_SENDSELLITEMLIST: ClientSellItemList(ProcessMsg.nParam1, ProcessMsg.sMsg);

    CM_ITEMDLGSELECT: ClientMerchantItemDlgSelect(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
    CM_USERBUYITEM: ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam, ProcessMsg.sMsg);
    CM_BUYSELLOFFITEM: ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);

    CM_USERGETDETAILITEM, CM_GETMERCHANDISEMSG: ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.WParam, ProcessMsg.nParam2, ProcessMsg.sMsg);
    CM_GETSALEDETAILITEM: ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, 0, ProcessMsg.nParam2, ProcessMsg.sMsg);

    CM_SELLOFF: ClientGetSellOff(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    RM_GETSELLITEMSLIST: SendDefMessage(SM_BUYITEM, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, ProcessMsg.sMsg);

    CM_DROPGOLD: if ProcessMsg.nParam1 > 0 then
        ClientDropGold(ProcessMsg.nParam1);
    CM_GROUPMODE:
      begin
        if ProcessMsg.nParam2 = 0 then
          ClientGropuClose()
        else
          m_boAllowGroup := True;
        if m_boAllowGroup then
          SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
        else
          SendDefMessage(SM_GROUPMODECHANGED, 0, 0, 0, 0, '');
      end;
    CM_CREATEGROUP: ClientCreateGroup(Trim(ProcessMsg.sMsg));
    CM_ADDGROUPMEMBER: ClientAddGroupMember(Trim(ProcessMsg.sMsg));
    CM_DELGROUPMEMBER: ClientDelGroupMember(Trim(ProcessMsg.sMsg));
    CM_USERREPAIRITEM: ClientRepairItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    CM_MERCHANTQUERYREPAIRCOST: ClientQueryRepairCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    CM_DEALTRY: ClientDealTry(Trim(ProcessMsg.sMsg));
    CM_DEALADDITEM: ClientAddDealItem(ProcessMsg.nParam1, ProcessMsg.wParam, ProcessMsg.sMsg);
    CM_DEALDELITEM: ClientDelDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_DEALCANCEL: ClientCancelDeal();
    CM_DEALCHGGOLD: ClientChangeDealGold(ProcessMsg.nParam1);
    CM_DEALEND: ClientDealEnd();
    CM_USERSTORAGEITEM: ClientStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), abs(ProcessMsg.wParam), ProcessMsg.sMsg, False);
    CM_USERSTORAGEITEMVIEW: ClientStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), abs(ProcessMsg.wParam), ProcessMsg.sMsg, True);
    CM_USERTAKEBACKSTORAGEITEM: ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam, ProcessMsg.sMsg, False);
    CM_USERTAKEBACKSTORAGEITEMVIEW: ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.wParam, ProcessMsg.sMsg, True);
    CM_WANTMINIMAP: ClientGetMinMap();
    CM_USERMAKEDRUGITEM: ClientMakeDrugItem(TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
    CM_ITEMSUMCOUNT: if ProcessMsg.wParam = 0 then
        ServerGetSumCountItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg)
      else
      begin
        HeroObject := GetHeroObjectA();
        if HeroObject <> nil then
          TPlayObject(HeroObject).ServerGetSumCountItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;

    CM_OPENGUILDDLG:
      begin
        ClientOpenGuildDlg();
      end;
    CM_GUILDHOME: ClientGuildHome();
    CM_GUILDMEMBERLIST: ClientGuildMemberList();
    CM_GUILDADDMEMBER: ClientGuildAddMember(ProcessMsg.sMsg);
    CM_GUILDDELMEMBER: ClientGuildDelMember(ProcessMsg.sMsg);
    CM_GUILDUPDATENOTICE: ClientGuildUpdateNotice(ProcessMsg.sMsg);
    CM_GUILDUPDATERANKINFO: ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
    CM_REFINEITEM: ClientRefineItem(ProcessMsg.sMsg);
    CM_TRAINSKILL: ClientTrainSkill(ProcessMsg.nParam1, ProcessMsg.nParam2);

    ////////////////////////////////////
    CM_CANCELYBSELL: ClientCancelPostSell(ProcessMsg.nParam1);
    CM_AFFIRMYBDEAL: ClientAffirmPostDeal(ProcessMsg.nParam1);
    CM_CANCELYBDEAL: ClientCancelPostDeal(ProcessMsg.nParam1);

    CM_POSTSELL: ClientPostSell(ProcessMsg.nParam1, ProcessMsg.nParam3, ProcessMsg.sMsg);
    CM_ADJUST_BONUS:
{$IF VER_ClientType_45}
      if m_wClientType = 45 then
        ClientPostSell(ProcessMsg.nParam1, ProcessMsg.nParam3, ProcessMsg.sMsg)
      else
{$IFEND VER_ClientType_45}
        ClientAdjustBonus(ProcessMsg.nParam1, ProcessMsg.sMsg);

    CM_GUILDALLY:
      begin
        ClientGuildAlly();
      end;
    CM_GUILDBREAKALLY:
      begin
        ClientGuildBreakAlly(ProcessMsg.sMsg);
      end;
{$IF CHECKNEWMSG = 1}
    CM_1046:
      begin
        MainOutMessageAPI(Format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DecodeString(ProcessMsg.sMsg)]));
      end;
    CM_1056:
      begin
        MainOutMessageAPI(Format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DecodeString(ProcessMsg.sMsg)]));
      end;
{$IFEND}
    CM_TURN:
      begin
        if ClientChangeDir(ProcessMsg.wIdent,
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.wParam {dir},
          dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if dwDelayTime = 0 then
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '')
          else
          begin
            nMsgCount := GetTurnMsgCount();
            if nMsgCount >= g_Config.nMaxTurnMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  MainOutMessageAPI(Format(g_sBunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else
            begin
              if dwDelayTime < g_Config.dwDropOverSpeed then
              begin
                SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                  '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_WALK:
      begin

        if ClientWalkXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if dwDelayTime = 0 then
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '')
          else
          begin
            nMsgCount := GetWalkMsgCount();
            if nMsgCount >= g_Config.nMaxWalkMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  MainOutMessageAPI(Format(g_sWalkOverSpeed, [m_sCharName,
                    dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
              if m_boTestSpeedMode then
                SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
              begin
                SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(Format('²Ù×÷ÑÓ³Ù Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self,
                  ProcessMsg.wIdent,
                  ProcessMsg.wParam,
                  ProcessMsg.nParam1,
                  ProcessMsg.nParam2,
                  ProcessMsg.nParam3,
                  '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_HORSERUN: if m_boOnHorse then
      begin
        if ClientHorseRunXY(ProcessMsg.wIdent,
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.boLateDelivery,
          dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if dwDelayTime = 0 then
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '')
          else
          begin
            nMsgCount := GetRunMsgCount();
            if nMsgCount >= g_Config.nMaxRunMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  MainOutMessageAPI(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
              if m_boTestSpeedMode then
                SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
            end
            else
            begin
              if m_boTestSpeedMode then
                SysMsg(Format('²Ù×÷ÑÓ³Ù Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
              Result := False;
            end;
          end;
        end;
      end
      else if g_Config.boKickOverSpeed then
      begin
        SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    CM_RUN:
    if not m_boOnHorse then
      begin
        if ClientRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y}, ProcessMsg.nParam3, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if dwDelayTime = 0 then
          begin
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');  // RM_MOVEFAIL
          end
          else
          begin
            nMsgCount := GetRunMsgCount();
            if nMsgCount >= g_Config.nMaxRunMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  MainOutMessageAPI(Format(g_sRunOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and
                (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
              begin
                SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(Format('²Ù×÷ÑÓ³Ù Ident: %d Time: %d',
                    [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, CM_RUN, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end
      else if g_Config.boKickOverSpeed then
      begin
        SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    CM_HIT,
      CM_HEAVYHIT,
      CM_BIGHIT,
      CM_POWERHIT,
      CM_LONGHIT,
      CM_WIDEHIT,
      CM_CRSHIT,
      CM_TWNHIT,
      CM_FIREHIT,
      CM_HERO_LONGHIT2,
      CM_SQUHIT,
      CM_PURSUEHIT,
      CM_SMITEHIT,
      CM_SMITELONGHIT,
      CM_SMITELONGHIT2,
      CM_SMITELONGHIT3,
      CM_SMITEWIDEHIT,
      CM_SMITEWIDEHIT2:
      begin
        if ClientHitXY(ProcessMsg.wIdent {ident},
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.wParam {dir},
          ProcessMsg.boLateDelivery,
          dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if dwDelayTime = 0 then
            SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '')
          else
          begin
            nMsgCount := GetHitMsgCount();
            if nMsgCount >= g_Config.nMaxHitMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                  MainOutMessageAPI(Format(g_sHitOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and
                (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
              begin
                SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg('²Ù×÷ÑÓ³Ù Ident: ' + IntToStr(ProcessMsg.wIdent) + ' Time: ' + IntToStr(dwDelayTime), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '', dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_SPELL:
      begin
        if ClientSpellXY(ProcessMsg.wIdent,
          ProcessMsg.wParam,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          TBaseObject(ProcessMsg.nParam3),
          ProcessMsg.boLateDelivery, dwDelayTime,IsWarrSKill) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));
        end
        else
        begin
          if (dwDelayTime = 0) and IsWarrSKill then
            SendRefMsg(RM_SPELLFAIL, 0, 0, 0, 0, '')
          else
          begin
            nMsgCount := GetSpellMsgCount();
            if nMsgCount >= g_Config.nMaxSpellMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'ÇëÎðÊ¹ÓÃ·Ç·¨Èí¼þ'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  MainOutMessageAPI(Format(g_sSpellOverSpeed, [m_sCharName, dwDelayTime, nMsgCount]));
                end;
              end;
              SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and
                (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
              begin
                SendRefMsg(RM_MOVEFAIL, 0, 0, 0, 0, '');
                if m_boTestSpeedMode then
                  SysMsg(Format('ËÙ¶ÈÒì³£ Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(Format('²Ù×÷ÑÓ³Ù Ident: %d Time: %d', [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent,
                  ProcessMsg.wParam,
                  ProcessMsg.nParam1,
                  ProcessMsg.nParam2,
                  ProcessMsg.nParam3,
                  '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_SAY: if ProcessMsg.sMsg <> '' then
        ProcessUserLineMsg(ProcessMsg.sMsg);
    CM_PASSWORD: ProcessClientPassword(ProcessMsg);
    CM_QUERYVAL: ProcessQueryValue(ProcessMsg.nParam1, ProcessMsg.sMsg);
    RM_WALK:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject), @Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_HORSERUN:
      begin //10003 004D860A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HORSERUN,
            Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
            ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject), @Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_RUN:
      begin //10003 004D860A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_RUN, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject), @Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_HIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_HERO_LONGHIT: if TBaseObject(ProcessMsg.BaseObject) <> Self then
      begin
        m_DefMsg := MakeDefaultMsg(SM_HERO_LONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HERO_LONGHIT2: if TBaseObject(ProcessMsg.BaseObject) <> Self then
      begin
        m_DefMsg := MakeDefaultMsg(SM_HERO_LONGHIT2, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_81:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyW.param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_81,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
        end;
      end;
    RM_82:
      begin //10055
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyW.param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_82,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
        end;
      end;
    RM_83:
      begin //10056
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyW.param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_83,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
        end;
      end;
    RM_HEAVYHIT:
      begin //004D88CD
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEAVYHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      end;
    RM_BIGHIT:
      begin //004D893A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_BIGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SPELL:
      begin
        if ProcessMsg.sMsg <> '' then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), ProcessMsg.wParam);
          SendSocket(@m_DefMsg, Format('%d', [ProcessMsg.nParam3 + 300 * ProcessMsg.nParam2]));
        end
        else if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject), LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), ProcessMsg.wParam);
          SendSocket(@m_DefMsg, Format('%d', [ProcessMsg.nParam3 + 300 * ProcessMsg.nParam2]));
        end;
      end;
    RM_SPELL2:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_POWERHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      end;
    RM_HEROSPELL:
      begin
        if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer <> RC_PLAYOBJECT) or (TBaseObject(ProcessMsg.BaseObject) <> Self) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEROSPELL,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_MOVEFAIL:
    if TBaseObject(ProcessMsg.BaseObject) = Self then
      begin
        m_DefMsg := MakeDefaultMsg(SM_MOVEFAIL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
        CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong(@Buffer[0]);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc)));
      end;
    RM_SPELLFAIL:
      begin
        if TBaseObject(ProcessMsg.BaseObject) = Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPELLFAIL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong(@Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc)));
        end;
      end;
    RM_LONGHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_LONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      end;
    RM_WIDEHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_WIDEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      end;
    {RM_FIREHITREADY: begin
        //if TBaseObject(ProcessMsg.BaseObject) <> self then begin
        m_DefMsg := MakeDefaultMsg(SM_FIREHITREADY, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
        //end;
      end;}
    RM_FIREHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_FIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      end;
    RM_PURSUEHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_PURSUEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      end;
    RM_SMITEHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SMITELONGHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITELONGHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SMITEWIDEHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITEWIDEHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SMITEWIDEHIT2:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITEWIDEHIT2, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SMITELONGHIT2:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITELONGHIT2, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SMITELONGHIT3:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SMITELONGHIT3, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_CRSHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_CRSHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_TWNHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_TWNHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SUQHIT:
      begin
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SQUHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    {RM_43: begin
        if TBaseObject(ProcessMsg.BaseObject) <> self then begin
          m_DefMsg := MakeDefaultMsg(SM_43, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;}
    RM_60:
      begin
        m_DefMsg := MakeDefaultMsg(RM_60, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_61:
      begin
        m_DefMsg := MakeDefaultMsg(RM_61, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_62:
      begin
        m_DefMsg := MakeDefaultMsg(RM_62, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_TURN, RM_PUSH, RM_RUSH, RM_RUSHEX, RM_RUSHKUNG:
      begin
        if (ProcessMsg.BaseObject <> nil) and
          ((TBaseObject(ProcessMsg.BaseObject) <> Self) or
          (ProcessMsg.wIdent = RM_PUSH) or
          (ProcessMsg.wIdent = RM_RUSH) or
          (ProcessMsg.wIdent = RM_RUSHEX) or
          (ProcessMsg.wIdent = RM_RUSHKUNG)) then
        begin

          case ProcessMsg.wIdent of
            RM_PUSH:
              m_DefMsg := MakeDefaultMsg(SM_BACKSTEP,
                Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1 {x},
                ProcessMsg.nParam2 {y},
                MakeWord(ProcessMsg.wParam {dir}, TBaseObject(ProcessMsg.BaseObject).m_nLight {light}));
            RM_RUSH:
              m_DefMsg := MakeDefaultMsg(SM_RUSH,
                Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            RM_RUSHEX:
              m_DefMsg := MakeDefaultMsg(SM_RUSHEX,
                Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                MakeWord(ProcessMsg.wParam, ProcessMsg.nParam3));
            RM_RUSHKUNG:
              m_DefMsg := MakeDefaultMsg(SM_RUSHKUNG,
                Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
          else
            begin
              m_DefMsg := MakeDefaultMsg(SM_TURN,
                Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            end;
          end;

          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject), @Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          sSENDMSG := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));

          if  ProcessMsg.wIdent = RM_TURN then  sSENDMSG := sSENDMSG + EncodeBuffer(@Buffer[0],CharDesc.FeatureLen);

          if ProcessMsg.sMsg <> '' then
          begin
            nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
            sSENDMSG := sSENDMSG + (EncodeString(Format('%s/%d', [ProcessMsg.sMsg, nObjCount]))); //0406
          end;
          SendSocket(@m_DefMsg, sSENDMSG);

          if ProcessMsg.wIdent = RM_TURN then
          begin
            sSENDMSG := '';
            nObjCount := TBaseObject(ProcessMsg.BaseObject).GetTitleIndex();
            //if nObjCount > 0 then
            ///begin
            MessageBodyW.param1 := MakeWord(nObjCount, 0);
            MessageBodyW.param2 := 0;
            MessageBodyW.Tag1 := 0;
            MessageBodyW.Tag2 := 0;
            sSENDMSG := EncodeBuffer(@MessageBodyW, SizeOf(MessageBodyW));
            //end;

            nObjCount := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong(@Buffer[0]);

            {SendDefMessage(SM_FEATURECHANGED,
              Integer(ProcessMsg.BaseObject),
              LoWord(nObjCount),
              HiWord(nObjCount),
              TBaseObject(ProcessMsg.BaseObject).GetFeatureEx, sSENDMSG);}

            m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED,
              Integer(ProcessMsg.BaseObject),
              LoWord(nObjCount),
              HiWord(nObjCount),
              TBaseObject(ProcessMsg.BaseObject).GetFeatureEx);
            sSENDMSG := sSENDMSG +  EncodeBuffer(@Buffer[0], nObjCount);
            SendSocket(@m_DefMsg, sSENDMSG);

            if TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT then
            begin

              {if TBaseObject(ProcessMsg.BaseObject).m_nCharStatus > 0 then
                SendDefMessage(SM_REFHUMANSTATE,
                  Integer(ProcessMsg.BaseObject),
                  TBaseObject(ProcessMsg.BaseObject).m_nCharStatus,
                  0,
                  0,
                  '');

              if TBaseObject(ProcessMsg.BaseObject).m_boSetAppr then //Åû·ç
                SendDefMessage(SM_REFHUMANSTATE,
                  Integer(ProcessMsg.BaseObject),
                  HUMEFFECT_APPR,
                  TBaseObject(ProcessMsg.BaseObject).m_wSetAppr,
                  TBaseObject(ProcessMsg.BaseObject).m_wSetRaceImg,
                  '');

              if TBaseObject(ProcessMsg.BaseObject).m_wStatusTimeArr[STATE_88] > 0 then //»¤ÉíÕæÆø
                SendDefMessage(SM_FUTURE,
                  Integer(ProcessMsg.BaseObject),
                  ConvertPercent(TBaseObject(ProcessMsg.BaseObject).m_nDefenceSkillHP, TBaseObject(ProcessMsg.BaseObject).m_nDefenceSkillMAXHP),
                  100,
                  154,
                  '');}

              if TPlayObject(ProcessMsg.BaseObject).m_StallMgr.OnSale then
              begin
                SendMsg(TBaseObject(ProcessMsg.BaseObject),
                  RM_STALLSTATUS,
                  TPlayObject(ProcessMsg.BaseObject).m_StallMgr.mBlock.ItemCount,
                  TPlayObject(ProcessMsg.BaseObject).m_nCurrX,
                  TPlayObject(ProcessMsg.BaseObject).m_nCurrY,
                  TPlayObject(ProcessMsg.BaseObject).m_btDirection,
                  '');
              end;
            end;
          end;
        end;
      end;
    RM_FOXSTATE:
      begin
        if (ProcessMsg.BaseObject <> nil) and (TBaseObject(ProcessMsg.BaseObject) <> Self) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_FOXSTATE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, ProcessMsg.nParam3));

          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject), @buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
          sSENDMSG := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));
          sSENDMSG := sSENDMSG + EncodeBuffer(@buffer[0], SizeOf(CharDesc.FeatureLen));
          if ProcessMsg.sMsg <> '' then
          begin
            nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
            sSENDMSG := sSENDMSG + (EncodeString(Format('%s/%d', [ProcessMsg.sMsg, nObjCount]))); //0406
          end;
          SendSocket(@m_DefMsg, sSENDMSG);
        end;
      end;
    RM_CURSE:
      begin
        MagCurse(ProcessMsg.wParam, ProcessMsg.nParam1);
      end;
    RM_STRUCK, RM_STRUCK_MAG:
      begin
        if ProcessMsg.wParam {nPower} > 0 then
        begin
          if ProcessMsg.BaseObject = Self then
          begin
            if TBaseObject(ProcessMsg.nParam3) {AttackBaseObject} <> nil then
            begin
              if (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) then
                SetPKFlag(TBaseObject(ProcessMsg.nParam3))
              else if (TBaseObject(ProcessMsg.nParam3).m_Master <> nil) and (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_HERO) then
              begin
                SetPKFlag(TBaseObject(ProcessMsg.nParam3));
                if not TBaseObject(ProcessMsg.nParam3).IsHero then
                  SetPKFlag(TBaseObject(ProcessMsg.nParam3).m_Master);
              end;
              SetLastHiter(TBaseObject(ProcessMsg.nParam3));
            end;
            {if (g_CastleManager.IsCastleMember(self) <> nil) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
              TBaseObject(ProcessMsg.nParam3).m_boStruck := True;
              TBaseObject(ProcessMsg.nParam3).m_dw2B4Tick := GetTickCount();
            end;}
            m_nHealthTick := 0;
            m_nSpellTick := 0;
            Dec(m_nPerHealth);
            Dec(m_nPerSpell);
            m_dwStruckTick := GetTickCount();
          end;
          if ProcessMsg.BaseObject <> nil then
          begin
            //if ((ProcessMsg.BaseObject = self) and (g_Config.boDisableSelfStruck)) or ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and g_Config.boDisableStruck) or (g_Config.boHeroDisableStruck and TBaseObject(ProcessMsg.BaseObject).IsHero) then begin
            //  //
            //  TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '')
            //end else begin
              //if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_TRAINER) or (TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP > 0) then begin
{$IF HIGHHP}
            nObjCount := ProcessMsg.wParam;
            if TBaseObject(ProcessMsg.BaseObject).m_boDoubleStruck then
            begin
              TBaseObject(ProcessMsg.BaseObject).m_boDoubleStruck := False;
              nObjCount := 0;
            end;
            if TBaseObject(ProcessMsg.BaseObject).m_nMaxDamageHealth > 0 then
            begin
              if nObjCount > TBaseObject(ProcessMsg.BaseObject).m_nMaxDamageHealth then
                nObjCount := TBaseObject(ProcessMsg.BaseObject).m_nMaxDamageHealth;
            end;

            if (TBaseObject(ProcessMsg.BaseObject).m_PEnvir.m_MapFlag.nSecret > 0) and
              ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or TBaseObject(ProcessMsg.BaseObject).IsHero) then
            begin
              nMsgCount := Round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP / TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP * 100);
              m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                Integer(ProcessMsg.BaseObject),
                LoWord(nMsgCount),
                HiWord(nMsgCount),
                nObjCount);
              MessageBodyWL.lParam1 := 100;
            end
            else
            begin
              m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                Integer(ProcessMsg.BaseObject),
                LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
                HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
                nObjCount);
              MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP; //TBaseObject(ProcessMsg.BaseObject).GetFeature(Self); //blue0905
            end;
            //MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            MessageBodyWL.lTag1 := ProcessMsg.nParam3; //Weapon Sound
            if ProcessMsg.wIdent = RM_STRUCK_MAG then //Weapon Type
              MessageBodyWL.lTag2 := 1
            else
              MessageBodyWL.lTag2 := 0;
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
{$ELSE}
            m_DefMsg := MakeDefaultMsg(SM_STRUCK,
              Integer(ProcessMsg.BaseObject),
              TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
              TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
              nObjCount);
            //MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self); //blue0905
            //MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            MessageBodyWL.lTag1 := ProcessMsg.nParam3; //Weapon Sound
            if ProcessMsg.wIdent = RM_STRUCK_MAG then //Weapon Type
              MessageBodyWL.lTag2 := 1
            else
              MessageBodyWL.lTag2 := 0;
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
{$IFEND}
            //end;
          //end;
          end;
        end;
      end;
    RM_DEATH:
      begin
        nObjCount := 0;
        if TBaseObject(ProcessMsg.BaseObject).m_boExplore and (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer <> RC_HERO) then
          nObjCount := 1;
        if ProcessMsg.nParam3 = 1 then
          m_DefMsg := MakeDefaultMsg(SM_NOWDEATH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, Byte(nObjCount)))
        else
          m_DefMsg := MakeDefaultMsg(SM_DEATH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, Byte(nObjCount)));
        CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self,@Buffer[0]);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
      end;
    RM_DISAPPEAR:
      begin
        m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR, Integer(ProcessMsg.BaseObject), 0, 0, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_SKELETON:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SKELETON,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
        CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self,@buffer[0]);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)) + EncodeBuffer(@Buffer[0], CharDesc.FeatureLen));
      end;
    RM_USERNAME:
      begin
        if g_Config.boHumanAttribute and (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and (TBaseObject(ProcessMsg.BaseObject).m_btAttribute in [1..5]) then
          m_DefMsg := MakeDefaultMsg(SM_USERNAME, Integer(ProcessMsg.BaseObject), GetCharColor(TBaseObject(ProcessMsg.BaseObject)), TBaseObject(ProcessMsg.BaseObject).m_btAttribute, 0)
        else
          m_DefMsg := MakeDefaultMsg(SM_USERNAME, Integer(ProcessMsg.BaseObject), GetCharColor(TBaseObject(ProcessMsg.BaseObject)), 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_JOINTATTACK:
      begin
        m_DefMsg := MakeDefaultMsg(ProcessMsg.wParam {MigID},
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.nParam3 {dir});
        SendSocket(@m_DefMsg, '');
      end;
    RM_STRUCKEFFECTEX:
      begin
        m_DefMsg := MakeDefaultMsg(SM_STRUCKEFFECT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam2));
      end;
    RM_WINEXP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_WINEXP, m_Abil.Exp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEROWINEXP:
      begin
        HeroObject := GetHeroObjectA;
        if HeroObject <> nil then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEROWINEXP, HeroObject.m_Abil.Exp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_WINIPEXP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_WINIPEXP, m_dwInPowerExp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), g_Config.nMagicAttackRage);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEROWINIPEXP:
      begin
        HeroObject := GetHeroObjectA;
        if HeroObject <> nil then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEROWINIPEXP, HeroObject.m_dwInPowerExp, LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_WINNIMBUSEXP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_WINNIMBUSEXP, ProcessMsg.nParam1, 0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEROWINNIMBUSEXP:
      begin
        HeroObject := GetHeroObjectA;
        if HeroObject <> nil then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEROWINNIMBUSEXP, ProcessMsg.nParam1, 0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_COLLECTEXP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_COLLECTEXP, m_dwCollectExp, LoWord(m_dwCollectIPExp), HiWord(m_dwCollectIPExp), 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_COLLECTEXPSTATE:
      begin
        if (m_btCollectExpLv in [1..4]) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_COLLECTEXPSTATE,
            m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv],
            LoWord(m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv]),
            HiWord(m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv]),
            m_btCollectExpLv);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_LEVELUP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_LEVELUP, m_Abil.Exp, m_Abil.Level, 0, 0);
        SendSocket(@m_DefMsg, '');
{$IF VER_ClientType_45}
        if (m_nClientVerNO = 11) and (m_wClientType = 900) then
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, m_nInPowerLevel), LoWord(m_nGameGold * 100), HiWord(m_nGameGold * 100))
        else
{$IFEND}
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, m_nInPowerLevel), LoWord(m_nGameGold), HiWord(m_nGameGold));
{$IF VER_ClientType_45}
        if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
        begin
          GetOldAbil(OAbility);
          SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
        end
        else
{$IFEND} if (m_PEnvir.m_MapFlag.nSecret > 0) then
          begin
            Ability := m_WAbil;
            Ability.HP := Round(m_WAbil.HP / m_WAbil.MaxHP * 100);
            Ability.MaxHP := 100;
            SendSocket(@m_DefMsg, EncodeBuffer(@Ability, SizeOf(TAbility)));
          end
        else
        begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
        end;

        SendDefMessage(SM_SUBABILITY,
          MakeLong(MakeWord(m_nAntiMagic, m_IPRecoverRate), MakeWord(m_AddDamage, m_DecDamage)),
          MakeWord(m_btHitPoint, m_btSpeedPoint),
          MakeWord(m_btAntiPoison, m_nPoisonRecover),
          MakeWord(m_nHealthRecover, m_nSpellRecover), '');
      end;
    RM_HEROLEVELUP:
      begin
        HeroObject := GetHeroObjectA;
        if HeroObject <> nil then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEROLEVELUP, HeroObject.m_Abil.Exp, HeroObject.m_Abil.Level, 0, 0);
          SendSocket(@m_DefMsg, '');

          m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, TPlayObject(HeroObject).m_nGold, MakeWord(HeroObject.m_btJob, HeroObject.m_nInPowerLevel), 0, 0);
{$IF VER_ClientType_45}
          if HeroObject.m_wClientType = 45 then
          begin
            TPlayObject(HeroObject).GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
          end
          else
{$IFEND VER_ClientType_45}
            if HeroObject.m_PEnvir.m_MapFlag.nSecret > 0 then
            begin
              Ability := HeroObject.m_WAbil;
              Ability.HP := Round(HeroObject.m_WAbil.HP / HeroObject.m_WAbil.MaxHP * 100);
              Ability.MaxHP := 100;
              SendSocket(@m_DefMsg, EncodeBuffer(@Ability, SizeOf(TAbility)));
            end
            else
            begin
              SendSocket(@m_DefMsg, EncodeBuffer(@HeroObject.m_WAbil, SizeOf(TAbility)));
            end;

          SendDefMessage(SM_HEROSUBABILITY,
            MakeLong(MakeWord(HeroObject.m_nAntiMagic, HeroObject.m_IPRecoverRate), MakeWord(HeroObject.m_AddDamage, HeroObject.m_DecDamage)),
            MakeWord(HeroObject.m_btHitPoint, HeroObject.m_btSpeedPoint),
            MakeWord(HeroObject.m_btAntiPoison, HeroObject.m_nPoisonRecover),
            MakeWord(HeroObject.m_nHealthRecover, HeroObject.m_nSpellRecover), '');
          ClientQueryHeroBagItems;
          SendHeroUseitems();
        end;
      end;
    RM_CHANGENAMECOLOR:
      begin
        SendDefMessage(SM_CHANGENAMECOLOR,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
          0,
          0,
          '');
      end;
    RM_REMOTEMSG:
      begin
        DefMsg := MakeDefaultMsg(60000, 0, 0, 0, 0);
        SendSocket(@DefMsg, EncodeMessage(MakeDefaultMsg(SM_REMOTEMSG, 0, 0, 0, 0)) + ProcessMsg.sMsg);
      end;
    RM_PLAYSOUND:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PLAYSOUND, 0, ProcessMsg.wParam, 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_LOGON:
      begin
        if m_PEnvir.m_MapFlag.boDARK then
          nObjCount := 1
        else
          case m_nBright of
            0: nObjCount := 2;
            1: nObjCount := 0;
            2: nObjCount := 3;
            3: nObjCount := 1;
          else
            nObjCount := 1;
          end;
        if m_PEnvir.m_MapFlag.boDAY then
          nObjCount := 0;
        m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount);
        SendSocket(@m_DefMsg, EncodeString(m_PEnvir.m_sClientMapName));

        SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
        SendMsg(Self, RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendLogon();
        ClientQueryUserName(Self, m_nCurrX, m_nCurrY);
        RefUserState();
        SendServerConfig();
        SendMapDescription();
        SendGoldInfo(True);
        //m_DefMsg := MakeDefaultMsg(SM_VERSION_FAIL, g_Config.nClientFile1_CRC, LoWord(g_Config.nClientFile2_CRC), HiWord(g_Config.nClientFile2_CRC), 0);
        //SendSocket(@m_DefMsg, EncodeBuffer(@g_Config.nClientFile3_CRC, SizeOf(Integer)));
        QueryHeroHeroState();
        SendMissions();
      end;
    RM_SYSMESSAGE4:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE4, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_HEAR,
      RM_WHISPER,
      RM_CRY,
      RM_SYSMESSAGE,
      RM_GROUPMESSAGE,
      RM_SYSMESSAGE2,
      RM_GUILDMESSAGE,
      RM_SYSMESSAGE3,
      RM_MERCHANTSAY:
      begin
        case ProcessMsg.wIdent of
          RM_HEAR: m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, ProcessMsg.nParam3 {Ä§·¨×ÖÌå}); //10030
          RM_WHISPER:
            begin
              m_DefMsg := MakeDefaultMsg(SM_WHISPER, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10031
              if g_Config.boViewWhisper then
                MainOutMessageAPI(Format('[Ë½ÁÄ] %s', [ProcessMsg.sMsg]));
              //ProcessMsg.sMsg
            end;
          RM_CRY: m_DefMsg := MakeDefaultMsg(SM_CRY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10032
          RM_SYSMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10100 ºìÉ«
          RM_SYSMESSAGE2: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE2, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10100 ºìÉ«
          RM_GROUPMESSAGE:
            begin
              m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10102
            end;
          RM_GUILDMESSAGE:
            begin
              m_DefMsg := MakeDefaultMsg(SM_GUILDMESSAGE, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10104
              //if g_Config.boViewWhisper then
              //  MainOutMessageAPI(Format('[ÐÐ»á] %s', [ProcessMsg.sMsg]));
            end;
          RM_MERCHANTSAY: m_DefMsg := MakeDefaultMsg(SM_MERCHANTSAY, Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1); //10126
        end;
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;
    RM_INPOWERINFO:
      begin
        m_DefMsg := MakeDefaultMsg(SM_INPOWERINFO, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@g_dwIPNeedInfo, SizeOf(TIPLvlNeedList)));
      end;
    RM_INTERNALPOWER:
      begin
        m_DefMsg := MakeDefaultMsg(SM_INTERNALPOWER,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint,
          0,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_ATTACKMODE:
      begin
        m_DefMsg := MakeDefaultMsg(SM_ATTACKMODE,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_btAttatckMode,
          0,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_ABILITY:
      begin
{$IF VER_ClientType_45}
        if (m_nClientVerNO = 11) and (m_wClientType = 900) then
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, m_nInPowerLevel), LoWord(m_nGameGold * 100), HiWord(m_nGameGold * 100))
        else
{$IFEND VER_ClientType_45}
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, m_nInPowerLevel), LoWord(m_nGameGold), HiWord(m_nGameGold));
{$IF VER_ClientType_45}
        if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
        begin
          GetOldAbil(OAbility);
          SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
          if g_Config.boOldClientShowHiLevel and (m_Abil.Level > 255) then
          begin
            SysMsg(g_sClientVersionTooOld, c_Red, t_Hint);
            SysMsg('µ±Ç°µÈ¼¶: ' + IntToStr(m_Abil.Level), c_Green, t_Hint);
            SysMsg('µ±Ç°ÉúÃüÖµ: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP), c_Blue, t_Hint);
            SysMsg('µ±Ç°Ä§·¨Öµ: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP), c_Red, t_Hint);
            SysMsg('µ±Ç°·ÀÓùÁ¦: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)), c_Green, t_Hint);
            SysMsg('µ±Ç°Ä§·ÀÁ¦: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)), c_Blue, t_Hint);
            SysMsg('µ±Ç°¹¥»÷Á¦: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)), c_Red, t_Hint);
            SysMsg('µ±Ç°Ä§·¨Á¦: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)), c_Green, t_Hint);
            SysMsg('µ±Ç°µÀÊõÖµ: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)), c_Blue, t_Hint);
          end;
        end
        else
{$IFEND VER_ClientType_45}if m_PEnvir.m_MapFlag.nSecret > 0 then
          begin
            Ability := m_WAbil;
            Ability.HP := Round(m_WAbil.HP / m_WAbil.MaxHP * 100);
            Ability.MaxHP := 100;
            SendSocket(@m_DefMsg, EncodeBuffer(@Ability, SizeOf(TAbility)));
          end
          else
          begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
      end;
    RM_HEALTHSPELLCHANGED:
      if TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP > 0 then
      begin
{$IF HIGHHP}
        m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
          HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
          0);
        if (TBaseObject(ProcessMsg.BaseObject).m_PEnvir.m_MapFlag.nSecret > 0) and
          ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or TBaseObject(ProcessMsg.BaseObject).IsHero) then
        begin
          nMsgCount := Round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP / TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP * 100);
          CharDesc.FeatureLen := nMsgCount;
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP;
          CharDesc.StatusEx := 100;
        end
        else
        begin
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP;
          CharDesc.StatusEx := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;
        end;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
{$ELSE}
        m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
        SendSocket(@m_DefMsg, '');
{$IFEND}
      end;
    RM_DAYCHANGING:
      begin
        if m_PEnvir.m_MapFlag.boDARK then
          nObjCount := 1
        else
        begin
          case m_nBright of
            0: nObjCount := 2;
            1: nObjCount := 0;
            2: nObjCount := 3;
            3: nObjCount := 1;
          else
            nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_MapFlag.boDAY then
          nObjCount := 0;

        nMsgCount := 0;
        if m_PEnvir.m_MapFlag.boDARK then
          nMsgCount := 1;
        if m_PEnvir.m_MapFlag.boDAY then
          nMsgCount := 2;

        m_DefMsg := MakeDefaultMsg(SM_DAYCHANGING, 0, m_nBright, nObjCount, nMsgCount);
        SendSocket(@m_DefMsg, EncodeString(FloatToStr(m_Time)));
      end;

    RM_ITEMSHOW:
      begin
        SendDefMessage(SM_ITEMSHOW,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_ITEMHIDE:
      begin
        SendDefMessage(SM_ITEMHIDE,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          '');
      end;
    RM_DOOROPEN:
      begin
        SendDefMessage(SM_OPENDOOR_OK,
          0,
          ProcessMsg.nParam1, {x}
          ProcessMsg.nParam2, {y}
          0,
          '');
      end;
    RM_DOORCLOSE:
      begin
        SendDefMessage(SM_CLOSEDOOR,
          0,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          '');
      end;
    RM_SENDUSEITEMS: SendUseitems();

    RM_PLAYERCONFIG:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PLAYERCONFIG,
          0,
          ProcessMsg.nParam1,
          Byte(TBaseObject(ProcessMsg.BaseObject).IsHero),
          MakeWord(Byte(TBaseObject(ProcessMsg.BaseObject).m_boShowFashion), 0));
        if TBaseObject(ProcessMsg.BaseObject).IsHero then
          TPlayObject(m_Master).SendSocket(@m_DefMsg, '')
        else
          SendSocket(@m_DefMsg, '');
      end;
    RM_PLAYERCONFIGHERO:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PLAYERCONFIG,
          0,
          0,
          1,
          ProcessMsg.wParam);
        SendSocket(@m_DefMsg, '');
      end;
    RM_WEIGHTCHANGED:
      begin
        SendDefMessage(SM_WEIGHTCHANGED,
          m_WAbil.Weight,
          m_WAbil.WearWeight,
          m_WAbil.HandWeight,
          0,
          '');
      end;
    RM_FEATURECHANGED:
      begin
        sSENDMSG := '';
        nObjCount := TBaseObject(ProcessMsg.BaseObject).GetTitleIndex();
        // if nObjCount > 0 then
        // begin
        MessageBodyW.param1 := MakeWord(nObjCount, 0);
        MessageBodyW.param2 := 0;
        MessageBodyW.Tag1 := 0;
        MessageBodyW.Tag2 := 0;
        sSENDMSG := sSENDMSG + EncodeBuffer(@MessageBodyW, SizeOf(MessageBodyW));
        // end;
        {SendDefMessage(SM_FEATURECHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,
          sSENDMSG); }
        sSENDMSG := sSENDMSG + ProcessMsg.sMsg;
        m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    RM_CLEAROBJECTS:
      begin
        SendDefMessage(SM_CLEAROBJECTS,
          0,
          0,
          0,
          0,
          '');
      end;

    RM_CHANGEMAP:
      begin
        if m_PEnvir.m_MapFlag.boDARK then
          nObjCount := 1
        else
        begin
          case m_nBright of
            0: nObjCount := 2;
            1: nObjCount := 0;
            2: nObjCount := 3;
            3: nObjCount := 1;
          else
            nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_MapFlag.boDAY then
          nObjCount := 0;
        SendDefMessage(SM_CHANGEMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount, ProcessMsg.sMsg);
        RefUserState();
        SendMapDescription();
        SendServerConfig();
      end;
    RM_BUTCH:
      begin
        if ProcessMsg.BaseObject <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_BUTCH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_MAGICFIRE:
      begin
        m_DefMsg := MakeDefaultMsg(SM_MAGICFIRE, //Ident
          Integer(ProcessMsg.BaseObject), //Recog
          LoWord(ProcessMsg.nParam2), //Param
          HiWord(ProcessMsg.nParam2), //Tag
          ProcessMsg.nParam1); //Series
        CharDesc.FeatureLen := ProcessMsg.nParam3;
        CharDesc.Status := ProcessMsg.wParam;
        CharDesc.StatusEx := 0;
        if ProcessMsg.sMsg <> '' then
          CharDesc.StatusEx := StrToIntDef(ProcessMsg.sMsg, 0); //MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        //SendSocket(@m_DefMsg, EncodeBuffer(@ProcessMsg.nParam3, SizeOf(Integer)));
      end;
    RM_DELAY_MAGIC:
      begin
        if ProcessMsg.BaseObject = Self then
          DoPositionMoveAttack(ProcessMsg.nParam1, ProcessMsg.nParam2, LoByte(ProcessMsg.wParam), HiByte(ProcessMsg.wParam), ProcessMsg.nParam3);
      end;
    RM_POSTIONMOVE:
      begin
        m_DefMsg := MakeDefaultMsg(SM_POSTIONMOVE, Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_MAGICFIREFAIL: SendDefMessage(SM_MAGICFIRE_FAIL, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
    RM_SENDMYMAGIC: SendUseMagic;
    RM_MAGIC_LVEXP: SendDefMessage(SM_MAGIC_LVEXP, MakeLong(ProcessMsg.nParam1, ProcessMsg.wParam), ProcessMsg.nParam2, LoWord(ProcessMsg.nParam3), HiWord(ProcessMsg.nParam3), '');
    RM_MAGIC_MAXLV: SendDefMessage(SM_MAGIC_MAXLV, MakeLong(ProcessMsg.nParam1, ProcessMsg.wParam), ProcessMsg.nParam2, 0, 0, '');

    RM_HEROMAGIC_LVEXP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_HEROMYMAGICS, 0, 0, 0, ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    RM_DURACHANGE:
      begin
        SendDefMessage(SM_DURACHANGE,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          '');
      end;
    RM_BAGDURACHANGE:
      begin
        SendDefMessage(SM_BAGDURACHANGE,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          '');
      end;
    RM_MERCHANTDLGCLOSE:
      begin
        SendDefMessage(SM_MERCHANTDLGCLOSE,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDGOODSLIST:
      begin
        SendDefMessage(SM_SENDGOODSLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          ProcessMsg.nParam3,
          ProcessMsg.sMsg);
      end;
    RM_SENDUSERSELL:
      begin
        SendDefMessage(SM_SENDUSERSELL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_SENDBUYPRICE:
      begin
        SendDefMessage(SM_SENDBUYPRICE,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDBOOKCNT:
      begin
        SendDefMessage(SM_SENDBOOKCNT,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSELLITEM_OK:
      begin
        SendDefMessage(SM_USERSELLITEM_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSELLITEM_FAIL:
      begin
        SendDefMessage(SM_USERSELLITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSELLCOUNTITEM_OK: SendDefMessage(SM_USERSELLCOUNTITEM_OK, ProcessMsg.nParam1 {chg gold}, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');
    RM_USERSELLCOUNTITEM_FAIL: SendDefMessage(SM_USERSELLCOUNTITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, '');

    RM_BUYITEM_SUCCESS:
      begin
        SendDefMessage(SM_BUYITEM_SUCCESS,
          ProcessMsg.nParam1,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          0,
          '');
      end;
    RM_BUYITEM_FAIL:
      begin
        SendDefMessage(SM_BUYITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDDETAILGOODSLIST:
      begin
        SendDefMessage(SM_SENDDETAILGOODSLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          ProcessMsg.sMsg);
      end;
    RM_GOLDCHANGED:
      begin
{$IF VER_ClientType_45}
        if (m_nClientVerNO = 11) and (m_wClientType = 900) then
          SendDefMessage(SM_GOLDCHANGED, m_nGold, LoWord(m_nGameGold * 100), HiWord(m_nGameGold * 100), 0, '')
        else
{$IFEND VER_ClientType_45}
          SendDefMessage(SM_GOLDCHANGED, m_nGold, LoWord(m_nGameGold), HiWord(m_nGameGold), 0, '');
      end;
    RM_GAMEGOLDCHANGED:
      begin
        SendGoldInfo(False);
      end;
    RM_CHANGELIGHT:
      begin
        SendDefMessage(SM_CHANGELIGHT,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_nLight,
          g_Config.nClientKey,
          0,
          '');
      end;
    RM_LAMPCHANGEDURA:
      begin
        SendDefMessage(SM_LAMPCHANGEDURA,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_COUNTERITEMCHANGE:
      begin
        ServerSendItemCountChanged(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);
      end;
    RM_CHARSTATUSCHANGED:
      begin
        SendDefMessage(SM_CHARSTATUSCHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_APPRCHANGED:
      begin
        SendDefMessage(SM_APPRCHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    RM_GROUPCANCEL:
      begin
        SendDefMessage(SM_GROUPCANCEL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDUSERREPAIR,
      RM_SENDUSERSREPAIR:
      begin
        SendDefMessage(SM_SENDUSERREPAIR,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          '');
      end;
    RM_USERREPAIRITEM_OK:
      begin
        SendDefMessage(SM_USERREPAIRITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          '');
      end;
    RM_SENDREPAIRCOST:
      begin
        SendDefMessage(SM_SENDREPAIRCOST,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERREPAIRITEM_FAIL:
      begin
        SendDefMessage(SM_USERREPAIRITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSTORAGEITEM:
      begin
        SendDefMessage(SM_SENDUSERSTORAGEITEM,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          '');
      end;
    RM_OPENSTORAGEVIEW:
    begin
      SendDefMessage(SM_OPENSTORAGEVIEW,
        ProcessMsg.nParam1,
        ProcessMsg.nParam2,
        0,
        0,
        '');
        sendStorageItemList(ProcessMsg.nParam1);
    end;
    RM_USERGETBACKITEM:
      begin
        SendSaveItemList(ProcessMsg.nParam1);
      end;
    RM_SENDDELITEMLIST:
      begin
        SendDelItemList(TStringList(ProcessMsg.nParam1), ProcessMsg.wParam);
        TStringList(ProcessMsg.nParam1).Free;
        TStringList(ProcessMsg.nParam1) := nil;
      end;
    RM_USERMAKEDRUGITEMLIST:
      begin
        SendDefMessage(SM_SENDUSERMAKEDRUGITEMLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_MAKEDRUG_SUCCESS:
      begin
        SendDefMessage(SM_MAKEDRUG_SUCCESS,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_MAKEDRUG_FAIL:
      begin
        SendDefMessage(SM_MAKEDRUG_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_ALIVE:
      begin
        m_DefMsg := MakeDefaultMsg(SM_ALIVE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
        CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self, @Buffer[0]);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)) + EncodeBuffer(@Buffer[0], CharDesc.FeatureLen));
      end;
    RM_HEROLOGIN:
      begin
        m_DefMsg := MakeDefaultMsg(SM_HEROLOGIN,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEROLOGOUT:
      begin
        m_DefMsg := MakeDefaultMsg(SM_HEROLOGOUT,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_DIGUP:
      begin
        m_DefMsg := MakeDefaultMsg(SM_DIGUP,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
        MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self, @Buffer[0]);
        MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;
        MessageBodyWL.lTag2 := 0;
        sSENDMSG := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL));
        sSENDMSG := sSENDMSG + EncodeBuffer(@Buffer[0], MessageBodyWL.lParam1);
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    RM_DIGDOWN:
      begin
        m_DefMsg := MakeDefaultMsg(SM_DIGDOWN,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_FLYAXE:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyW.param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_FLYAXE {g_Config.nTestHeroType},
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
        end;
      end;
    RM_LIGHTING:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
    RM_LIGHTING_1:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING_1,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
    RM_LIGHTING_2:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING_2,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
    RM_LIGHTING_3:
      begin
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING_3,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;

    RM_NORMALEFFECT:
      begin
        SendDefMessage(SM_NORMALEFFECT,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.nParam3 {type},
          '');
      end;
    RM_LOOPNORMALEFFECT:
      begin
        SendDefMessage(SM_LOOPNORMALEFFECT,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.nParam3 {type},
          '');
      end;
    RM_CHANGEGUILDNAME: SendChangeGuildName();
    RM_SUBABILITY:
      begin
        SendDefMessage(SM_SUBABILITY,
          MakeLong(MakeWord(m_nAntiMagic, m_IPRecoverRate), MakeWord(m_AddDamage, m_DecDamage)),
          MakeWord(m_btHitPoint, m_btSpeedPoint),
          MakeWord(m_btAntiPoison, m_nPoisonRecover),
          MakeWord(m_nHealthRecover, m_nSpellRecover),
          '');
        SendDefMessage(SM_REFDIAMOND,
          m_nGameDiamond,
          m_nGameGird,
          0,
          0,
          '');
      end;
    RM_BUILDGUILD_OK:
      begin
        SendDefMessage(SM_BUILDGUILD_OK,
          0,
          0,
          0,
          0,
          '');
      end;
    RM_BUILDGUILD_FAIL:
      begin
        SendDefMessage(SM_BUILDGUILD_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_DONATE_OK:
      begin
        SendDefMessage(SM_DONATE_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_DONATE_FAIL:
      begin
        SendDefMessage(SM_DONATE_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_MYSTATUS:
      begin
        SendDefMessage(SM_MYSTATUS, 0, GetMyStatus, 0, 0, '');
      end;
    CM_SPEEDHACKMSG:
      begin
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, ProcessMsg.sMsg);
      end;
    RM_MENU_OK:
      begin
        SendDefMessage(SM_MENU_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_SPACEMOVE_FIRE, RM_SPACEMOVE_FIRE2:
      begin
        if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE,
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0);
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE2,
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0);
        end;
        SendSocket(@m_DefMsg, '');
      end;
    RM_SPACEMOVE_SHOW, RM_SPACEMOVE_SHOW2:
      begin
        if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
        end;
        CharDesc.FeatureLen := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self, @Buffer[0]);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        CharDesc.StatusEx := MakeLong(TBaseObject(ProcessMsg.BaseObject).m_nInPowerPoint, TBaseObject(ProcessMsg.BaseObject).m_nInPowerLevel);
        sSENDMSG := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));
        sSENDMSG := sSENDMSG + EncodeBuffer(@Buffer[0], CharDesc.FeatureLen);
        if ProcessMsg.sMsg <> '' then
        begin
          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          sSENDMSG := sSENDMSG + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
        end;
        SendSocket(@m_DefMsg, sSENDMSG);
      end;
    RM_RECONNECTION:
      begin
        m_boReconnection := True;
        SendDefMessage(SM_RECONNECT, 0, 0, 0, 0, ProcessMsg.sMsg);
      end;
    RM_HIDEEVENT:
      begin
        SendDefMessage(SM_HIDEEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          '');
      end;
    RM_SHOWEVENT:
      begin
        ShortMessage.Ident := HiWord(ProcessMsg.nParam2);
        ShortMessage.wMsg := StrToInt(ProcessMsg.sMsg);
        m_DefMsg := MakeDefaultMsg(SM_SHOWEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
      end;
    RM_ADJUST_BONUS:
      begin
        SendAdjustBonus();
      end;
    RM_MAKESLAVE:
      begin
        ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
        Dispose(pTSlaveInfo(ProcessMsg.nParam1));
        pTSlaveInfo(ProcessMsg.nParam1) := nil;
      end;
    RM_OPENHEALTH:
      begin
{$IF HIGHHP}
        if (TBaseObject(ProcessMsg.BaseObject).m_PEnvir.m_MapFlag.nSecret > 0) and
          ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or TBaseObject(ProcessMsg.BaseObject).IsHero) then
        begin
          nMsgCount := Round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP / TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP * 100);
          m_DefMsg := MakeDefaultMsg(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),
            LoWord(nMsgCount),
            HiWord(nMsgCount),
            0);
          ShortMessage.Ident := LoWord(100);
          ShortMessage.wMsg := HiWord(100);
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0);
          ShortMessage.Ident := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
          ShortMessage.wMsg := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
        end;

        SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
{$ELSE}
        SendDefMessage(SM_OPENHEALTH,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
          0,
          '');
{$IFEND}
      end;
    RM_CLOSEHEALTH:
      begin
        SendDefMessage(SM_CLOSEHEALTH,
          Integer(ProcessMsg.BaseObject),
          0,
          0,
          0,
          '');
      end;
    RM_BREAKWEAPON:
      begin
        SendDefMessage(SM_BREAKWEAPON,
          Integer(ProcessMsg.BaseObject),
          0,
          0,
          0,
          '');
      end;
    RM_INSTANCEHEALGUAGE:
      begin
{$IF HIGHHP}
        if (TBaseObject(ProcessMsg.BaseObject).m_PEnvir.m_MapFlag.nSecret > 0) and
          ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or TBaseObject(ProcessMsg.BaseObject).IsHero) then
        begin
          nMsgCount := Round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP / TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP * 100);
          m_DefMsg := MakeDefaultMsg(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            LoWord(nMsgCount),
            HiWord(nMsgCount),
            0);
          ShortMessage.Ident := LoWord(100);
          ShortMessage.wMsg := HiWord(100);
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),
            0);
          ShortMessage.Ident := LoWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
          ShortMessage.wMsg := HiWord(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
        end;
        SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
{$ELSE}
        SendDefMessage(SM_INSTANCEHEALGUAGE,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
          TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
          0,
          '');
{$IFEND}
      end;
    RM_CHANGEFACE:
      begin
        if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_CHANGEFACE,
            ProcessMsg.nParam1,
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            0);
          CharDesc.FeatureLen := TBaseObject(ProcessMsg.nParam2).GetFeature(Self, @Buffer[0]);
          CharDesc.Status := TBaseObject(ProcessMsg.nParam2).m_nCharStatus;
          CharDesc.StatusEx := 0;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)) + EncodeBuffer(@Buffer[0], CharDesc.FeatureLen));
        end;
      end;
    RM_PASSWORD:
      begin
        SendDefMessage(SM_PASSWORD, 0, 0, 0, 0, '');
      end;
    RM_PLAYDICE:
      begin
        MessageBodyWL.lParam1 := ProcessMsg.nParam1;
        MessageBodyWL.lParam2 := ProcessMsg.nParam2;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;
        m_DefMsg := MakeDefaultMsg(SM_PLAYDICE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.wParam,
          0,
          0);
        SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)) + EncodeString(ProcessMsg.sMsg));
      end;
    RM_PASSWORDSTATUS:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PASSWORDSTATUS,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    CM_GETSALELIST:
      begin
        if GetTickCount - m_dwGetSaleListTick > 500 then
        begin
          m_dwGetSaleListTick := GetTickCount();
          GetSaleItemList(TBaseObject(ProcessMsg.BaseObject), ProcessMsg.nParam2);
        end;
      end;
    CM_BUYSALEITEM:
      begin
        if GetTickCount - m_dwBuyShopItemTick >= 500 then
        begin
          m_dwBuyShopItemTick := GetTickCount();
          BuyShopItem(TBaseObject(ProcessMsg.BaseObject), ProcessMsg.sMsg);
        end;
      end;
    RM_GETSALELIST:
      begin
        m_DefMsg := MakeDefaultMsg(SM_GETSALELIST, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
    CM_MARKET_LIST: ServerGetMarketList(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.sMsg);
    CM_MARKET_SELL: ServerGetMarketSell(TBaseObject(ProcessMsg.nParam1), ProcessMsg.wParam, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
    CM_MARKET_BUY: ServerGetMarketBuy(TBaseObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
    CM_MARKET_CANCEL: ServerGetMarketCancel(TBaseObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
    CM_MARKET_GETPAY: ServerGetMarketGetPay(TBaseObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
    CM_MARKET_CLOSE: ServerGetMarketClose;

    RM_MARKET_LIST: SendDefMessage(SM_MARKET_LIST, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, ProcessMsg.sMsg);
    RM_MARKET_RESULT: SendDefMessage(SM_MARKET_RESULT, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0, '');

    CM_CANCELMISSION:
      begin
        sSENDMSG := IntToStr(ProcessMsg.nParam1);
        if DeleteMission(sSENDMSG) >= 0 then
        begin
          if g_FunctionNPC <> nil then
          begin
            g_FunctionNPC.m_OprCount := 0;
            g_FunctionNPC.GotoLable(Self, '@CancelMission', False);
          end;
          SendDefMessage(SM_SETMISSION, ProcessMsg.nParam1 {id}, ProcessMsg.nParam2 {class}, ProcessMsg.nParam3, 2, '');
        end;
      end;
    RM_SETMISSION:
      begin
        SendDefMessage(SM_SETMISSION, ProcessMsg.nParam1 {id}, ProcessMsg.nParam2 {class}, ProcessMsg.nParam3, ProcessMsg.wParam {param}, ProcessMsg.sMsg);
      end;
    CM_SPACEMOVE:
      begin
        CmdUserMoveXY('', IntToStr(ProcessMsg.nParam1), IntToStr(ProcessMsg.nParam2));
      end;
  else
    begin
      {if @Engine_SetHookPlayOperateMessage <> nil then begin
        Result := Engine_SetHookPlayOperateMessage(self,
          ProcessMsg.wIdent,
          ProcessMsg.wParam,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.BaseObject,
          ProcessMsg.dwDeliveryTime,
          PChar(ProcessMsg.sMsg),
          boReturn);
        if boReturn then
          Result := inherited Operate(ProcessMsg);
      end else}
      Result := inherited Operate(ProcessMsg);
    end;
  end;
end;

{$IF SERIESSKILL}

procedure TPlayObject.SerieSkillReady();
var
  i, ii, nstep, idx: Integer;
  tempSeriesSkills: TtSeriesSkills;
  SeriesSkillArr: TSeriesSkillArr;
  templist: TList;
begin
  m_btReadySeriesSkill := 0;
  m_btSeriesSkillSetpCur := 8;

  nstep := 0;
  for i := Low(m_SeriesSkillArr) to High(m_SeriesSkillArr) do
  begin
    if m_SeriesSkillArr[i] = 0 then
      Inc(nstep);
    if nstep > High(m_SeriesSkillArr) then
      Exit;
  end;

  SeriesSkillArr := m_SeriesSkillArr;

  FillChar(tempSeriesSkills, SizeOf(tempSeriesSkills), 0);
  FillChar(m_SeriesSkillArr2, SizeOf(m_SeriesSkillArr2), 0);
  for i := Low(TtSeriesSkills) to High(TtSeriesSkills) do
  begin
    if m_MagicArr[0][100 + m_btJob * 4 + +i] <> nil then
    begin
      tempSeriesSkills[i].umag := m_MagicArr[0][100 + m_btJob * 4 + +i];
    end;
  end;

  nstep := 0;
  for i := Low(SeriesSkillArr) to High(SeriesSkillArr) do
  begin
    if SeriesSkillArr[i] > 1 then
    begin
      for ii := Low(tempSeriesSkills) to High(tempSeriesSkills) do
      begin
        if not tempSeriesSkills[ii].used and (tempSeriesSkills[ii].umag <> nil) and (SeriesSkillArr[i] = tempSeriesSkills[ii].umag.wMagIdx) then
        begin
          tempSeriesSkills[ii].used := True;
          Break;
        end;
      end;
      m_SeriesSkillArr2[nstep].wMagicId := SeriesSkillArr[i];
      if m_MagicArr[0][SeriesSkillArr[i]] <> nil then
        m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i] + g_VLvDamageExRate[m_MagicArr[0][SeriesSkillArr[i]].btLevel]
      else
        m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i];
      SeriesSkillArr[i] := 0;
      Inc(nstep);
      if nstep = High(m_SeriesSkillArr) + 1 then
        Break;
    end;
  end;

  if nstep < High(m_SeriesSkillArr) + 1 then
  begin
    for i := Low(SeriesSkillArr) to High(SeriesSkillArr) do
    begin
      if SeriesSkillArr[i] = 1 then
      begin
        templist := TList.Create;
        for ii := Low(tempSeriesSkills) to High(tempSeriesSkills) do
        begin
          if not tempSeriesSkills[ii].used and (tempSeriesSkills[ii].umag <> nil) then
          begin
            templist.Add(tempSeriesSkills[ii].umag);
          end;
        end;
        if templist.Count > 1 then
        begin
          Randomize;
          idx := Random(templist.Count);
          m_SeriesSkillArr2[nstep].wMagicId := pTUserMagic(templist[idx]).wMagIdx;
          if m_MagicArr[0][m_SeriesSkillArr2[nstep].wMagicId] <> nil then
            m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i] + g_VLvDamageExRate[m_MagicArr[0][m_SeriesSkillArr2[nstep].wMagicId].btLevel]
          else
            m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i];

          for ii := Low(tempSeriesSkills) to High(tempSeriesSkills) do
          begin
            if not tempSeriesSkills[ii].used and (tempSeriesSkills[ii].umag <> nil) and (m_SeriesSkillArr2[nstep].wMagicId = tempSeriesSkills[ii].umag.wMagIdx) then
            begin
              tempSeriesSkills[ii].used := True;
              Break;
            end;
          end;
          Inc(nstep);
          templist.Free;
          SeriesSkillArr[i] := 0;
          if nstep = High(m_SeriesSkillArr) + 1 then
            Break;
        end
        else if templist.Count = 1 then
        begin
          m_SeriesSkillArr2[nstep].wMagicId := pTUserMagic(templist[0]).wMagIdx;
          if m_MagicArr[0][m_SeriesSkillArr2[nstep].wMagicId] = nil then
            m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i]
          else
            m_SeriesSkillArr2[nstep].wDamageRate := g_VPoDamageExRate[i] + g_VLvDamageExRate[m_MagicArr[0][m_SeriesSkillArr2[nstep].wMagicId].btLevel];
          Inc(nstep);
          templist.Free;
          SeriesSkillArr[i] := 0;
          Break;
        end
        else
        begin
          templist.Free;
          Break;
        end;
      end;
    end;
  end;

  if nstep in [1..4] then
  begin
    m_btSeriesSkillSetpCur := 8;
    m_btSeriesSkillSetpMax := nstep;
    if IsHero then
    begin
      TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_SERIESSKILLREADY, MakeLong(m_SeriesSkillArr2[0].wMagicId, m_SeriesSkillArr2[1].wMagicId), MakeWord(m_SeriesSkillArr2[2].wMagicId, m_SeriesSkillArr2[3].wMagicId), nstep, 1);
      TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, '');
    end
    else if (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SERIESSKILLREADY, MakeLong(m_SeriesSkillArr2[0].wMagicId, m_SeriesSkillArr2[1].wMagicId), MakeWord(m_SeriesSkillArr2[2].wMagicId, m_SeriesSkillArr2[3].wMagicId), nstep, 0);
      SendSocket(@m_DefMsg, '');
    end;
    m_btReadySeriesSkill := 1; //ready ...
  end;
end;
{$IFEND SERIESSKILL}

procedure TPlayObject.Run();
var
  btDir: Byte;
  i, nCheckCode: Integer;
  tObjCount: Integer;
  nInteger, nX, nY: Integer;
  wHour: Word;
  wMin: Word;
  wSec: Word;
  wMSec: Word;
  ProcessMsg: TProcessMessage;
  boInSafeArea: Boolean;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  PlayObject: TPlayObject;
  BaseObject: TBaseObject;
  boChg, boTakeItem: Boolean;
  Castle: TUserCastle;
  NormNpc: TNormNpc;
  pdc: PTDelayCallNPC;
  Guild: TGuild;
  Str: string;
resourcestring
  sCreateHeroMsg0 = 'Ó¢ÐÛÃû×ÖÖÐ°üº¬½ûÓÃ×Ö·û¡£';
  sCreateHeroMsg1 = '´´½¨Ó¢ÐÛ³É¹¦¡£';
  sCreateHeroMsg2 = 'Ó¢ÐÛÃû×ÖÒÑ¾­´æÔÚ¡£';
  sCreateHeroMsg3 = 'ÄãµÄÕÊºÅ½ÇÉ«¹ý¶à¡£';
  sCreateHeroMsg4 = '´´½¨Ó¢ÐÛÊ§°Ü£¡';
  sCreateHeroMsg5 = '´´½¨Ó¢ÐÛÊ§°Ü£¬ÇëÉÔºòÖØÊÔ£¡';
  sPayMentExpire = 'ÄúµÄÕÊ»§³äÖµÊ±¼äÒÑµ½ÆÚ';
  sDisConnectMsg = 'ÓÎÏ·±»Ç¿ÐÐÖÐ¶Ï';
  sLoadRcdFail = 'ÄúÊäÈëµÄÁíÍâÒ»¸ö½ÇÉ«Ãû¿ÉÄÜ²»ÕýÈ·£¬»òÕß¶ÁÈ¡½ÇÉ«Êý¾Ý¹ý³ÌÓÐÎó£¡';
  sExceptionMsg1 = '[Exception] TPlayObject::Run -> Operate 1 Code=%d';
  sExceptionMsg2 = '[Exception] TPlayObject::Run -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s';
  sExceptionMsg3 = '[Exception] TPlayObject::Run -> GetHighHuman';
  sExceptionMsg4 = '[Exception] TPlayObject::Run -> ClearObj';
  sExceptionMsg5 = '[Exception] TPlayObject::Run -> HeroLogout';
  sExceptionMsg6 = '[Exception] TPlayObject::Run -> RecallHero';
  sExceptionMsg7 = '[Exception] TPlayObject::Run -> DelayGoto';
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if m_boOffLinePlay and m_boOffLineFlag and not m_boDeath and not m_boGhost then
      begin
        Run2();
        if (g_DeathWalkingSays.Count > 1) and (Random(9880) = 0) then
        begin
          Str := g_DeathWalkingSays[Random(g_DeathWalkingSays.Count)];
          if Str <> '' then
            ProcessSayMsg(Str);
        end;
      end;
    end;
    if m_boSuperMode and (GetTickCount - m_dwSuperManTick > 1000) then
    begin
      m_boSuperMode := False;
    end;
    if m_boAdminMode and IsHero and (GetTickCount - m_dwAdminTick > 5000) then
    begin
      m_boAdminMode := False;
    end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPBM.inc'}
      if (UserEngine.m_PlayObjectList.Count > 10) then
      begin
        m_boEmergencyClose := True;
        Exit;
      end;
{$IFEND}
      if g_boExitServer then
        m_boEmergencyClose := True;

      if m_boDeath then
      begin
        if (GetTickCount - m_dwDeathTick > g_Config.dwMakeGhostTime) then
          MakeGhost();
      end;

      try
        if not m_boGhost then
        begin
          BaseObject := GetHeroObjectA;
          if (BaseObject <> nil) and BaseObject.m_boDeath then
          begin
            if GetTickCount - m_dwRecallHeroTick > g_Config.nRecallHeroIntervalTime * 1000 then
            begin
              if not BaseObject.m_boHeroSaveRcd then
              begin
                BaseObject.m_boHeroSaveRcd := True;
                UserEngine.SaveHumanRcd(TPlayObject(BaseObject));
              end;
              SendDefMessage(SM_HEROSTATEDISPEAR, 0, 0, 0, 0, '');
              BaseObject.SendRefMsg(RM_HEROLOGOUT, 0, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
              BaseObject.MakeGhost();
              m_HeroObject := nil;
            end;
          end;
        end;
      except
        on E: Exception do
        begin
          MainOutMessageAPI(sExceptionMsg5);
          MainOutMessageAPI(E.Message);
        end;
      end;

      //try
      if m_boDealing then
        if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or ((m_DealCreat = nil) {or (m_DealCreat.m_PEnvir <> m_PEnvir)}) then //0420
          DealCancel();
      if (m_DealGoldCreat <> nil) and (GetTickCount - m_DealGoldLastTick > 60 * 1000) then
        m_DealGoldCreat := nil;

      if m_boExpire then
      begin
        SysMsg(sPayMentExpire, c_Red, t_Hint);
        SysMsg(sDisConnectMsg, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boExpire := False;
      end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}

      if not m_boOffLineFlag then
      begin
{$IF SERIESSKILL}

        if (m_MagicArr[0][76] <> nil) and not m_boMedusaEyeHint and (GetTickCount - m_dwLatestMedusaEyeTick >= 45 * 1000) then
        begin
          m_boMedusaEyeHint := True;
          SendSocket(nil, '+MDS');
        end;

        if (m_btReadySeriesSkill in [0, 2]) and (m_nInPowerLevel > 0) then
        begin
          if (GetTickCount - m_dwReadySeriesSkillTick > _MAX(12 * 1000, g_Config.nSeriesSkillReleaseInvTime - m_btReduceSpellTime * 1000)) then
          begin
            m_dwReadySeriesSkillTick := GetTickCount;
            SerieSkillReady();
          end;
        end;

        if m_boFireHitSkill and ((GetTickCount - m_dwLatestFireHitTick) > 20 * 1000) then
        begin //080118
          m_boFireHitSkill := False;
          SysMsg(sSpiritsGone, c_Red, t_Hint);
          SendSocket(nil, '+UFIR');
        end;

        if GetTickCount - m_dwCheckTitleTick >= 60 * 60 * 1000 then
        begin
          m_dwCheckTitleTick := GetTickCount;
          tObjCount := 0;
          for i := Low(THumTitles) to High(THumTitles) do
          begin
            if m_Titles[i].Index > 0 then
            begin
              StdItem := UserEngine.GetTitle(m_Titles[i].Index);
              if StdItem <> nil then
              begin
                if (StdItem.DuraMax = 0) or (m_Titles[i].Time = 0) then
                  Continue;
                nInteger := StdItem.DuraMax - Round((GetItemFormatDate - m_Titles[i].Time) / (60 * 60));
                if nInteger <= 0 then
                begin
                  if (m_btActiveTitle in [1..6]) and (m_btActiveTitle - 1 = i) then
                  begin
                    ClientChangeTitle(0, 0);
                  end;
                  m_Titles[i].Index := 0;
                end;
                Inc(tObjCount);
              end;
            end;
          end;
          if tObjCount > 0 then
            SendMyTitles(False);
        end;

        if (m_dwUnParalysisTick > 0) then
        begin
          if GetTickCount > m_dwUnParalysisTick then
          begin
            m_dwUnParalysisTick := 0;
            SysMsg('·ÀÖ¹Ê¯»¯ÄÜÁ¦ÏûÊ§£¡', c_Red, t_Hint);
          end
          else
          begin
            if GetTickCount - m_dwUnParalysisTick2 > 1000 then
            begin
              m_dwUnParalysisTick2 := GetTickCount;
              if m_nInPowerPoint > 0 then
              begin
                if m_nInPowerPoint >= 250 then
                  Dec(m_nInPowerPoint, 250)
                else
                  m_nInPowerPoint := 0;
                InternalPowerPointChanged(True);
              end;
            end;
          end;
        end;

        if (m_btSquareHit > 0) and ((GetTickCount - m_dwLatestHeroLongHitTick) > 16 * 1000) then
        begin
          m_btSquareHit := 0;
          SendSocket(nil, '+USLON');
        end;

        if m_boPursueHitSkill and ((GetTickCount - m_dwLatestPursueHitTick) > 20 * 1000) then
        begin //080118
          m_boPursueHitSkill := False;
          SysMsg(sPursueSpiritsGone, c_Red, t_Hint);
          SendSocket(nil, '+UPUR');
        end;

        if m_boSmiteLongSkill2 and ((GetTickCount - m_dwLatestSmiteLongTick2) > 15 * 1000) then
        begin //080118
          m_boSmiteLongSkill2 := False;
          SendSocket(nil, '+USML2');
        end;

        if m_boSmiteLongSkill3 and ((GetTickCount - m_dwLatestSmiteLongTick3) > 10 * 1000) then
        begin //080118
          m_boSmiteLongSkill3 := False;
          SendSocket(nil, '+USML3');
        end;

        if m_boSmiteWideSkill2 and ((GetTickCount - m_dwLatestSmiteWideTick2) > 10 * 1000) then
        begin //080118
          m_boSmiteWideSkill2 := False;
          SendSocket(nil, '+USMW2');
        end;

        if m_btReadySeriesSkill = 2 then
        begin
          boChg := False;
          if m_boSmiteSkill and ((GetTickCount - m_dwLatestSmiteTick) > 10 * 1000) then
          begin //080118
            m_boSmiteSkill := False;
            SendSocket(nil, '+USMI');
            boChg := True;
          end;

          if m_boSmiteLongSkill and ((GetTickCount - m_dwLatestSmiteLongTick) > 10 * 1000) then
          begin //080118
            m_boSmiteLongSkill := False;
            SendSocket(nil, '+USML');
            boChg := True;
          end;

          if m_boSmiteWideSkill and ((GetTickCount - m_dwLatestSmiteWideTick) > 10 * 1000) then
          begin //080118
            m_boSmiteWideSkill := False;
            SendSocket(nil, '+USMW');
            boChg := True;
          end;

          if boChg then
          begin
            m_btReadySeriesSkill := 0;
            SendSocket(nil, '+USMI');
            SendSocket(nil, '+USML');
            SendSocket(nil, '+USMW');
            m_DefMsg := MakeDefaultMsg(SM_FIRESERIESSKILL, 1, 0, 0, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;
{$IFEND SERIESSKILL}
        if m_boTwinHitSkill and ((GetTickCount - m_dwLatestTwinHitTick) > 30 * 1000) then
        begin
          m_boTwinHitSkill := False;
          SendSocket(nil, '+UTWN');
        end;
      end;

      {if not m_boOffLineFlag then begin
        if m_boHeroOffLineLogin then begin
          m_boHeroOffLineLogin := False;
          QueryHeroHeroState();
        end;
      end;}

      try
        if m_boLoadRcdFail then
        begin
          m_boLoadRcdFail := False;
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sLoadRcdFail);
        end;
        if m_boLoadHeroRcd then
        begin
          m_boLoadHeroRcd := False;
          ClientRecallHero();
        end;
        if m_boQueryRankOK then
        begin
          m_boQueryRankOK := False;
          m_DefMsg := MakeDefaultMsg(SM_LEVELRANK, m_nLvRankResult, m_nLvRankType, 0, 0);
          SendSocket(@m_DefMsg, m_sSendRankData);
        end;
        if m_boSendHeros then
        begin
          m_boSendHeros := False;
          SendMsg(Self, RM_SENDHEROS, 0, 0, 0, 0, '');
        end;

      except
        on E: Exception do
        begin
          MainOutMessageAPI(sExceptionMsg6);
          MainOutMessageAPI(E.Message);
        end;
      end;

      {MakeHeroRcd}
      if m_boNewHero then
      begin
        m_boNewHero := False;
        if m_nNewHeroOK in [0..6] then
        begin
          case m_nNewHeroOK of
            0:
              begin
                SysMsg(sCreateHeroMsg0, c_Red, t_Hint);
                m_sTempHeroName := '';
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@HeroNameFilter', False);
                end;
              end;
            1:
              begin
                SysMsg(sCreateHeroMsg1, c_Red, t_Hint);
                m_sHeroName := m_sTempHeroName;
                m_sTempHeroName := '';
                m_dwHeroSaveRcdTick := 0;
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@CreateHeroOK', False);
                end;
                //Ë¢ÐÂ
                if g_Config.cbMutiHero then
                  FrontEngine.AddToLoadRcdList(m_sUserID,
                    m_sCharName,
                    m_sIPaddr,
                    5,
                    m_nSessionID,
                    m_nPayMent,
                    m_nPayMode,
                    m_nSoftVersionDate,
                    m_nSocket,
                    m_nGSocketIdx,
                    m_nGateIdx,
                    '',
                    nil);
              end;
            2:
              begin
                SysMsg(sCreateHeroMsg2, c_Red, t_Hint);
                m_sTempHeroName := '';
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@HeroNameExists', False);
                end;
              end;
            3:
              begin
                SysMsg(sCreateHeroMsg3, c_Red, t_Hint);
                m_sTempHeroName := '';
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@HeroOverChrCount', False);
                end;
              end;
            4:
              begin
                SysMsg(sCreateHeroMsg4, c_Red, t_Hint);
                m_sTempHeroName := '';
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@CreateHeroFail', False);
                end;
              end;
            5:
              begin
                SysMsg(sCreateHeroMsg5, c_Red, t_Hint);
                m_sTempHeroName := '';
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@CreateHeroFailEx', False);
                end;
              end;
            6:
              begin
                SysMsg(sCreateHeroMsg1, c_Red, t_Hint);
                //m_sHeroName := m_sTempHeroName;
                m_sTempHeroName := '';
                m_dwHeroSaveRcdTick := 0;
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@CreateHeroOK', False);
                end;
                //Ë¢ÐÂ£¿
                if g_Config.cbMutiHero then
                  FrontEngine.AddToLoadRcdList(m_sUserID,
                    m_sCharName,
                    m_sIPaddr,
                    5,
                    m_nSessionID,
                    m_nPayMent,
                    m_nPayMode,
                    m_nSoftVersionDate,
                    m_nSocket,
                    m_nGSocketIdx,
                    m_nGateIdx,
                    '',
                    nil);
              end;
          end;
        end;
      end;

      {TimeRecall}
      if m_boTimeRecall and (GetTickCount > m_dwTimeRecallTick) then
      begin
        m_boTimeRecall := False;
        SpaceMove(m_sMoveMap, m_nMoveX, m_nMoveY, 0);
      end;

      {DelayRecall}
      try
        {if m_boDelayCall and ((GetTickCount - m_dwDelayCallTick) > m_nDelayCall) then begin
          m_boDelayCall := False;
          NormNpc := UserEngine.FindMerchant(TObject(m_DelayCallNPC));
          if NormNpc = nil then
            NormNpc := UserEngine.FindNPC(TObject(m_DelayCallNPC));
          if NormNpc <> nil then
            NormNpc.GotoLable(self, m_sDelayCallLabel, False);
        end;}

        for i := 0 to m_DelayCallList.Count - 1 do
        begin
          pdc := m_DelayCallList[i];
          if pdc = nil then
            Continue;
          if not pdc.bProcessed then
          begin
            if GetTickCount - pdc.dwDelayCallTick > pdc.nDelayCall then
            begin
              pdc.bProcessed := True;
              pdc.dwReleaseTick := GetTickCount;
              if pdc.sDelayCallLabel <> '' then
              begin
                NormNpc := UserEngine.FindMerchant(TObject(pdc.DelayCallNPC));
                if NormNpc = nil then
                  NormNpc := UserEngine.FindNPC(TObject(pdc.DelayCallNPC));
                if NormNpc <> nil then
                begin
                  NormNpc.m_OprCount := 0;
                  NormNpc.GotoLable(Self, pdc.sDelayCallLabel, False);
                end;
              end;
              Break;
            end;
          end;
        end;

        for i := m_DelayCallList.Count - 1 downto 0 do
        begin
          pdc := m_DelayCallList[i];
          if pdc = nil then
            Continue;
          if pdc.bProcessed then
          begin
            if GetTickCount - pdc.dwReleaseTick > 60 * 1000 then
            begin
              Dispose(PTDelayCallNPC(m_DelayCallList[i]));
              m_DelayCallList.Delete(i);
              //Break;
            end;
          end;
        end;

      except
        on E: Exception do
        begin
          MainOutMessageAPI(sExceptionMsg7);
          MainOutMessageAPI(E.Message);
        end;
      end;

      {KickOffLine}
      if m_boOffLinePlay and (GetTickCount > m_dwKickOffLineTick) then
      begin
        m_boOffLinePlay := False;
        m_boSoftClose := True;
      end;

      if not m_boDeath and not m_boGhost and (m_btRaceServer = RC_PLAYOBJECT) and not TPlayObject(Self).m_boOffLineFlag then
      begin //080118
        if m_MagicArr[0][42] <> nil then
        begin
          if GetTickCount - m_dwSquSkillPowerUpTick > 4500 then
          begin
            m_dwSquSkillPowerUpTick := GetTickCount();
            if m_boVigourAddAble and (m_nVigour < ((m_MagicArr[0][42].btLevel + 1) * 500)) then
            begin
              if m_nVigour < ((m_MagicArr[0][42].btLevel + 1) * 500) then
              begin
                Inc(m_nVigour);
                TPlayObject(Self).SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
              end
              else
              begin
                m_nVigour := ((m_MagicArr[0][42].btLevel + 1) * 500);
                TPlayObject(Self).SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
                m_boVigourAddAble := False;
              end;
            end;
          end;
        end;
        if (m_btSPEnergy < 100) and (GetTickCount - m_dwSPEnergyAddTick > g_Config.spEnergyAddTime * 1000) then
        begin
          m_dwSPEnergyAddTick := GetTickCount();
          Inc(m_btSPEnergy);
          SendDefMessage(SM_SecretProperty, 1, m_btSPLuck, m_btSPEnergy, 1, '');
        end;
      end;

      if (GetTickCount - m_dwCheckDupObjTick) > 3 * 1000 then
      begin
        m_dwCheckDupObjTick := GetTickCount();

        GetHomePoint();
        tObjCount := m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY);
        if tObjCount >= 2 then
        begin
          if not m_boPlayerDupMode then
          begin
            m_boPlayerDupMode := True;
            m_dwDupObjTick := GetTickCount();
          end;
        end
        else
          m_boPlayerDupMode := False;

        if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 5000)) or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10 * 1000)))) and ((GetTickCount() - m_dwDupObjTick) < 20 * 1000) then
        begin
          //
          ChrDupPushed(Random(8), 1);
        end;

        if g_Config.boAutoOpenShield and (m_btRaceServer = RC_PLAYOBJECT) then
        begin
          if (m_MagicArr[0][75] <> nil) and (m_nMagShieldHP <= 0) then
          begin
            if GetTickCount - m_dwUnionHitShieldTick > 5 * 1000 then
            begin
              m_dwUnionHitShieldTick := GetTickCount;
              TPlayObject(Self).DoSpell(m_MagicArr[0][75], m_nCurrX, m_nCurrY, Self, boChg);
            end;
          end;
        end;
      end;

    end;

    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
      if (not m_boOffLineFlag or m_boSendInSafeZone or m_boOffLinePlay) then
      begin
        if (GetTickCount - m_dwSafeZoneCheckTick > 1200) then
        begin
          m_dwSafeZoneCheckTick := GetTickCount;
          boInSafeArea := InSafeZone();
          if m_boSendInSafeZone or (boInSafeArea <> m_boInSafeZone) then
          begin
            m_boSendInSafeZone := False;
            m_boInSafeZone := boInSafeArea;
            if (not m_boOffLineFlag or m_boSendInSafeZone) then
            begin
              if m_btRaceServer = RC_PLAYOBJECT then
                SendDefMessage(SM_INSAFEZONEFLAG, Integer(m_boInSafeZone and g_Config.boSafeZoneRunAll), 0, 0, 0, '');
            end;
          end;
        end;
      end;
    end;

    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
      Castle := g_CastleManager.InCastleWarArea(Self);
      if (Castle <> nil) and Castle.m_boUnderWar then
      begin
        ChangePKStatus(True);
        if (m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_StallMgr.OnSale then
        begin
          TPlayObject(Self).CancelDoStall;
        end;
      end;

      if (GetTickCount - m_dwLogonTimcCostTick) > 1200 then
      begin
        m_dwLogonTimcCostTick := GetTickCount();

        //SysMsg(format('%d %d/%d', [m_wStatusTimeArr[POISON_PURPLE], m_dwStatusArrTick[POISON_PURPLE], GetTickCount()]), c_Green, t_Hint);

        {nCheckCode := 10;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          DecodeTime(Now, wHour, wMin, wSec, wMSec);
          if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart) or (wHour = g_Config.nHalfFeeEnd)) then begin
            if (wMin = 0) and (wSec <= 30) and ((GetTickCount - m_dwLogonTick) > 60 * 1000) then begin
              LogonTimcCost();
              m_dwLogonTick := GetTickCount();
              m_dLogonTime := Now();
            end;
          end;
        end;}

        //nCheckCode := 11;
        //Castle := g_CastleManager.InCastleWarArea(self);
        //if (Castle <> nil) and Castle.m_boUnderWar then begin
        //  ChangePKStatus(True);
        //end else begin
        //  ChangePKStatus(False);
        //end;

        //////////////////////////////////////////////////////////////////////
        Guild := nil;
        if m_btRaceServer = RC_PLAYOBJECT then
          Guild := TGuild(m_MyGuild)
        else if IsHero then
          Guild := TGuild(m_Master.m_MyGuild);
        if (Guild <> nil) then
        begin
          if TGuild(Guild).m_GuildWarList.Count > 0 then
          begin
            boInSafeArea := InSafeArea();
            if boInSafeArea <> m_boInSafeArea then
            begin
              m_boInSafeArea := boInSafeArea;
              RefNameColor();
            end;
          end;
        end;

        //////////////////////////////////////////////////////////////////////
        if (Castle <> nil) and Castle.m_boUnderWar then
        begin
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            if (m_PEnvir = Castle.m_MapPalace) and (m_MyGuild <> nil) then
            begin
              if not Castle.IsMember(Self) then
              begin
                if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
                begin
                  if Castle.CanGetCastle(TGuild(m_MyGuild)) then
                  begin //ok
                    Castle.GetCastle(TGuild(m_MyGuild));
                    UserEngine.SendInterMsg(ISM_CHANGECASTLEOWNER, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
                    if Castle.InPalaceGuildCount <= 1 then
                      Castle.StopWallconquestWar();
                  end;
                end;
              end;
            end;
          end;
        end
        else
        begin
          ChangePKStatus(False);
        end;

        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if GetTickCount - m_dwRefNimbusStateTick > 3000 then
          begin
            m_dwRefNimbusStateTick := GetTickCount;
            if m_LastNimbusCount <> m_PEnvir.NimbusCount then
            begin
              m_LastNimbusCount := m_PEnvir.NimbusCount;
              RefUserState();
            end;
          end;
        end;

        if m_boNameColorChanged then
        begin
          m_boNameColorChanged := False;
          if m_btRaceServer = RC_PLAYOBJECT then
            RefUserState();
          RefShowName();
        end;
      end;
    end;
    //except
    //  MainOutMessageAPI(Format(sExceptionMsg1, [nCheckCode]));
    //end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      {ScriptTimmer}
      if GetTickCount - m_dwExecScriptTick > 1000 then
      begin
        m_dwExecScriptTick := GetTickCount;
        for i := Low(TScriptTimers) to High(TScriptTimers) do
        begin
          if m_aScriptTimers[i].bActive then
          begin
            if GetTickCount - m_aScriptTimers[i].dwExecTick > m_aScriptTimers[i].dwTnterval then
            begin
              m_aScriptTimers[i].dwExecTick := GetTickCount;
              if (g_ManageNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
              begin
                g_ManageNPC.m_OprCount := 0;
                g_ManageNPC.GotoLable(Self, '@OnTimer' + IntToStr(i), False);
              end;
              //Break;
            end;
          end;
        end;
      end;

      try
        //m_dwGetMsgTick := GetTickCount(); //090305
        while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and GetMessage(@ProcessMsg) do
        begin
          m_dwGetMsgTick := GetTickCount(); //090305
          if not Operate(@ProcessMsg) then
            Break;
        end;
        if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
        begin
          if m_boSwitchData then
          begin
            m_sMapName := m_sSwitchMapName;
            m_nCurrX := m_nSwitchMapX;
            m_nCurrY := m_nSwitchMapY;
          end;
          MakeGhost();
          if m_boKickFlag then
            SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
          if not m_boReconnection and m_boSoftClose then
            FrmIDSoc.SendHumanLogOutMsg(m_sUserID, m_nSessionID);
        end;
      except
        on E: Exception do
        begin
          if ProcessMsg.wIdent = 0 then
            MakeGhost();
          MainOutMessageAPI(Format(sExceptionMsg2, [m_sCharName, ProcessMsg.wIdent, Integer(ProcessMsg.BaseObject), ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg]));
          MainOutMessageAPI(E.Message);
        end;
      end;

      if GetTickCount - m_dwCheckItemsNeed > 30 * 60 * 1000 then
      begin
        m_dwCheckItemsNeed := GetTickCount();

        boTakeItem := False;
        for i := Low(THumanUseItems) to High(THumanUseItems) do
        begin
          if m_UseItems[i].wIndex > 0 then
          begin
            StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
            if StdItem <> nil then
            begin
              if not CheckItemsNeed(StdItem) then
              begin
                New(UserItem);
                UserItem^ := m_UseItems[i];
                if AddItemToBag(UserItem) then
                begin
                  SendAddItem(UserItem);
                  //WeightChanged();
                  boTakeItem := True;
                end
                else
                begin
                  Dispose(UserItem);
                  SysMsg('×°±¸¸ö±ð´©´÷´íÎó,ÇëÈ¡»Ø°ü¹üÖØÐÂ´©´÷...', c_Red, t_Hint);
                end;
                if boTakeItem then
                begin
                  SendDelItems(@m_UseItems[i]);
                  m_UseItems[i].wIndex := 0;
                  RecalcAbilitys();
                end;
              end;
            end
            else
              m_UseItems[i].wIndex := 0;
          end;
        end;
      end;

      tObjCount := m_nGameGold;
      if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick > m_dwDecGameGoldTime) then
      begin
        m_dwDecGameGoldTick := GetTickCount();
        if (m_nDecGameGold >= 0) and (m_nGameGold >= m_nDecGameGold) then
        begin
          Dec(m_nGameGold, m_nDecGameGold);
          nInteger := m_nDecGameGold;
        end
        else
        begin
          nInteger := m_nGameGold;
          m_nGameGold := 0;
          m_boDecGameGold := False;
          MoveToHome();
        end;
        if g_boGameLogGameGold then
        begin
          AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
            m_sMapName,
              m_nCurrX,
              m_nCurrY,
              m_sCharName,
              g_Config.sGameGoldName,
              nInteger,
              '-',
              'Auto']));
        end;
      end;

      if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick > m_dwIncGameGoldTime) then
      begin
        m_dwIncGameGoldTick := GetTickCount();
        if m_nGameGold + m_nIncGameGold < High(Integer) then
        begin
          Inc(m_nGameGold, m_nIncGameGold);
          nInteger := m_nIncGameGold;
        end
        else
        begin
          nInteger := High(Integer) - m_nGameGold;
          m_nGameGold := High(Integer);
          m_boIncGameGold := False;
        end;
        if g_boGameLogGameGold then
        begin
          AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
            m_sMapName,
              m_nCurrX,
              m_nCurrY,
              m_sCharName,
              g_Config.sGameGoldName,
              nInteger,
              '-',
              'Auto']));
        end;
      end;

      if not m_boDecGameGold and m_PEnvir.m_MapFlag.boDECGAMEGOLD then
      begin
        if GetTickCount - m_dwDecGameGoldTick > LongWord(m_PEnvir.m_MapFlag.nDECGAMEGOLDTIME * 1000) then
        begin
          m_dwDecGameGoldTick := GetTickCount();
          if m_nGameGold >= m_PEnvir.m_MapFlag.nDECGAMEGOLD then
          begin
            Dec(m_nGameGold, m_PEnvir.m_MapFlag.nDECGAMEGOLD);
            nInteger := m_PEnvir.m_MapFlag.nDECGAMEGOLD;
          end
          else
          begin
            nInteger := m_nGameGold;
            m_nGameGold := 0;
            m_boDecGameGold := False;
            MoveToHome();
          end;
          if g_boGameLogGameGold then
          begin
            AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
              m_sMapName,
                m_nCurrX,
                m_nCurrY,
                m_sCharName,
                g_Config.sGameGoldName,
                nInteger,
                '-',
                'Map']));
          end;
        end;
      end;

      if not m_boIncGameGold and m_PEnvir.m_MapFlag.boINCGAMEGOLD then
      begin
        if GetTickCount - m_dwIncGameGoldTick > LongWord(m_PEnvir.m_MapFlag.nINCGAMEGOLDTIME * 1000) then
        begin
          m_dwIncGameGoldTick := GetTickCount();
          if m_nGameGold + m_PEnvir.m_MapFlag.nINCGAMEGOLD < High(Integer) then
          begin
            Inc(m_nGameGold, m_PEnvir.m_MapFlag.nINCGAMEGOLD);
            nInteger := m_PEnvir.m_MapFlag.nINCGAMEGOLD;
          end
          else
          begin
            nInteger := High(Integer) - m_nGameGold;
            m_nGameGold := High(Integer);
          end;
          if g_boGameLogGameGold then
          begin
            AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
              m_sMapName,
                m_nCurrX,
                m_nCurrY,
                m_sCharName,
                g_Config.sGameGoldName,
                nInteger,
                '+',
                'Map']));
          end;
        end;
      end;
      if tObjCount <> m_nGameGold then
        SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');

      if m_PEnvir.m_MapFlag.boDECGAMEPOINT then
      begin
        if GetTickCount - m_dwDecGamePointTick > LongWord(m_PEnvir.m_MapFlag.nDECGAMEPOINTTIME * 1000) then
        begin
          m_dwDecGamePointTick := GetTickCount();
          if m_nGamePoint >= m_PEnvir.m_MapFlag.nDECGAMEPOINT then
          begin
            Dec(m_nGamePoint, m_PEnvir.m_MapFlag.nDECGAMEPOINT);
          end
          else
          begin
            m_nGamePoint := 0;
            MoveToHome();
          end;
        end;
      end;

      if m_PEnvir.m_MapFlag.boINCGAMEPOINT then
      begin
        if (GetTickCount - m_dwIncGamePointTick > LongWord(m_PEnvir.m_MapFlag.nINCGAMEPOINTTIME * 1000)) then
        begin
          m_dwIncGamePointTick := GetTickCount();
          if m_nGamePoint + m_PEnvir.m_MapFlag.nINCGAMEPOINT <= High(Integer) then
          begin
            Inc(m_nGamePoint, m_PEnvir.m_MapFlag.nINCGAMEPOINT);
          end
          else
          begin
            m_nGamePoint := High(Integer);
          end;
        end;
      end;

      if m_PEnvir.m_MapFlag.boDECHP and (GetTickCount - m_dwDecHPTick > LongWord(m_PEnvir.m_MapFlag.nDECHPTIME * 1000)) then
      begin
        m_dwDecHPTick := GetTickCount();
        if m_WAbil.HP > m_PEnvir.m_MapFlag.nDECHPPOINT then
          Dec(m_WAbil.HP, m_PEnvir.m_MapFlag.nDECHPPOINT)
        else
          m_WAbil.HP := 0;
        HealthSpellChanged();
      end;

      if (m_WAbil.HP > 0) and m_PEnvir.m_MapFlag.boINCHP and (GetTickCount - m_dwIncHPTick > LongWord(m_PEnvir.m_MapFlag.nINCHPTIME * 1000)) then
      begin
        m_dwIncHPTick := GetTickCount();
        if m_WAbil.HP + m_PEnvir.m_MapFlag.nDECHPPOINT < m_WAbil.MaxHP then
          Inc(m_WAbil.HP, m_PEnvir.m_MapFlag.nDECHPPOINT)
        else
          m_WAbil.HP := m_WAbil.MaxHP;
        HealthSpellChanged();
      end;

      if ((m_PEnvir.m_MapFlag.PCollectExp.nCollectExp > 0) or (m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp > 0)) then
      begin
        if GetTickCount - m_dwCollectExpTick > LongWord(m_PEnvir.m_MapFlag.PCollectExp.nCollectExpTime * 1000) then
        begin
          m_dwCollectExpTick := GetTickCount();
          if m_btCollectExpLv = 0 then
            m_btCollectExpLv := 1;
          if (m_btCollectExpLv < 4) or
            (m_dwCollectExp < m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv]) or
            (m_dwCollectIPExp < m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv]) then
          begin

            //if (m_PEnvir.m_MapFlag.PCollectExp.nCollectExp > 0) and (m_nInPowerLevel > 0) then
            CollectExp(m_PEnvir.m_MapFlag.PCollectExp.nCollectExp, //Round(m_PEnvir.m_MapFlag.PCollectExp.nCollectExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate),
              m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp //Round(m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate)
              );

            SysMsg(Format('ÄãÔÚÕâÆ¬ÉñÃØÇøÓòµÄÌ½Ë÷ÖÐ»ñµÃÁË%d¾­ÑéºÍ%dÄÚ¹¦¾­Ñé£¬ÄãµÄ¾­Ñé½á¾§Ò²»ñµÃÁË%d¾­ÑéºÍ%dÄÚ¹¦¾­Ñé',
              [m_PEnvir.m_MapFlag.PCollectExp.nCollectExp,
              m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp,
                m_PEnvir.m_MapFlag.PCollectExp.nCollectExp, //Round(m_PEnvir.m_MapFlag.PCollectExp.nCollectExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate),
                m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp]), //Round(m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp / 100 * m_PEnvir.m_MapFlag.PCollectExp.nCollectRate)]),
                c_Green, t_Hint);
          end;

        end;
      end;

      if g_Config.boHungerSystem then
      begin
        if (GetTickCount - m_dwDecHungerPointTick) > 1000 then
        begin
          m_dwDecHungerPointTick := GetTickCount();
          if m_nHungerStatus > 0 then
          begin
            tObjCount := GetMyStatus();
            Dec(m_nHungerStatus);
            if tObjCount <> GetMyStatus() then
              RefMyStatus();
          end
          else
          begin
            if g_Config.boHungerDecHP then
            begin
              Dec(m_nHealthTick, 60);
              Dec(m_nSpellTick, 10);
              m_nSpellTick := _MAX(0, m_nSpellTick);
              Dec(m_nPerHealth);
              Dec(m_nPerSpell);
              if m_WAbil.HP > m_WAbil.HP div 100 then
                Dec(m_WAbil.HP, _MAX(1, m_WAbil.HP div 100))
              else
              begin
                if m_WAbil.HP <= 2 then
                  m_WAbil.HP := 0;
              end;
              HealthSpellChanged();
            end;
          end;
        end;
      end;

      if GetTickCount - m_dwRateTick > 1000 then
      begin
        m_dwRateTick := GetTickCount();
        if m_dwKillMonExpRateTime > 0 then
        begin
          Dec(m_dwKillMonExpRateTime);
          if m_dwKillMonExpRateTime = 0 then
          begin
            m_nKillMonExpRate := 100;
            SysMsg('¾­Ñé±¶Êý»Ö¸´Õý³£...', c_Red, t_Hint);
          end;
        end;
        if m_dwPowerRateTime > 0 then
        begin
          Dec(m_dwPowerRateTime);
          if m_dwPowerRateTime = 0 then
          begin
            m_nPowerRate := 100;
            SysMsg('¹¥»÷Á¦±¶Êý»Ö¸´Õý³£...', c_Red, t_Hint);
          end;
        end;
      end;

      if GetTickCount - m_dwHighInfoTick > 2 * 1000 then
      begin
        m_dwHighInfoTick := GetTickCount();

        if m_nCanRun >= 0 then
        begin
          if GetTickCount() > m_dwCanRunTime then
          begin
            m_nCanRun := -1;
            m_dwCanRunTime := 0;
            SysMsg('Äúµ±Ç°´©ÈËÄ£Ê½¸ü¸ÄÎªÕý³£Ä£Ê½...', c_Green, t_Hint);
          end;
        end;

        try
          if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighLevelHuman := nil;
          if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighPKPointHuman := nil;
          if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighDCHuman := nil;
          if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighMCHuman := nil;
          if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighSCHuman := nil;
          if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then
            g_HighOnlineHuman := nil;

          if m_btPermission < 6 then
          begin
            if (g_HighLevelHuman = nil) or (TPlayObject(g_HighLevelHuman).m_boGhost) then
              g_HighLevelHuman := Self
            else
            begin
              if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
                g_HighLevelHuman := Self;
            end;

            if (g_HighPKPointHuman = nil) or (TPlayObject(g_HighPKPointHuman).m_boGhost) then
              g_HighPKPointHuman := Self
            else
            begin
              if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
                g_HighPKPointHuman := Self;
            end;

            if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost) then
              g_HighDCHuman := Self
            else
            begin
              if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC) then
                g_HighDCHuman := Self;
            end;

            if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost) then
              g_HighMCHuman := Self
            else
            begin
              if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC) then
                g_HighMCHuman := Self;
            end;

            if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost) then
              g_HighSCHuman := Self
            else
            begin
              if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC) then
                g_HighSCHuman := Self;
            end;

            if (g_HighOnlineHuman = nil) or (TPlayObject(g_HighOnlineHuman).m_boGhost) then
              g_HighOnlineHuman := Self
            else
            begin
              if m_dwLogonTick < TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
                g_HighOnlineHuman := Self;
            end;
          end;
        except
          on E: Exception do
          begin
            MainOutMessageAPI(sExceptionMsg3);
            MainOutMessageAPI(E.Message);
          end;
        end;
      end;

      try
        if not m_boOffLineFlag and g_Config.boReNewChangeColor and ((m_btReLevel >= g_Config.btReNewChangeColorLevel) or (m_boNameChangeColor)) and
          (GetTickCount - m_dwReColorTick > g_Config.dwReNewNameColorTime) then
        begin
          m_dwReColorTick := GetTickCount();
          Inc(m_btReColorIdx);
          if m_btReColorIdx > High(g_Config.ReNewNameColor) then
            m_btReColorIdx := 0;
          m_btNameColor := g_Config.ReNewNameColor[m_btReColorIdx];
          RefNameColor;
        end;
        if (m_GetWhisperHuman <> nil) then
        begin
          if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then
            m_GetWhisperHuman := nil;
        end;
        if not m_boOffLineFlag then
          ProcessSpiritSuite();
      except
      end;

      if GetTickCount - m_dwClearObjTick > 30 * 1000 then
      begin
        m_dwClearObjTick := GetTickCount();
        try
          if (m_DearHuman <> nil) and (m_DearHuman.m_boDeath or m_DearHuman.m_boGhost) then
            m_DearHuman := nil;
          if m_boMaster then
          begin
            for i := m_MasterList.Count - 1 downto 0 do
            begin
              PlayObject := TPlayObject(m_MasterList.Items[i]);
              if (PlayObject <> nil) and (PlayObject.m_boDeath or PlayObject.m_boGhost) then
                m_MasterList.Delete(i);
            end;
          end
          else if (m_MasterHuman <> nil) and (m_MasterHuman.m_boDeath or m_MasterHuman.m_boGhost) then
            m_MasterHuman := nil;
        except
          on E: Exception do
          begin
            MainOutMessageAPI(sExceptionMsg4);
            MainOutMessageAPI(E.Message);
          end;
        end;
      end;
    end;

    if m_fHeroMon then
    begin
      if m_nInPowerPoint < 20000 then
        m_nInPowerPoint := 20000;

    end;

    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
      if not m_boDeath and (m_nInPowerLevel > 0) then
      begin
        if (GetTickCount - m_dwIncInPowerTick) >= 8 * 1000 then
        begin
          m_dwIncInPowerTick := GetTickCount();
          tObjCount := m_nInPowerPoint;
          if m_nPerInPower < 1 then
          begin
            m_nPerInPower := 1;
            if m_nInPowerPoint > 0 then
            begin
              Dec(m_nInPowerPoint);
              InternalPowerPointChanged(True);
            end;
          end
          else
          begin
            //nInteger := Round((m_nInPowerLevel / 5) * ((100 + m_IPRecoverRate) / 100));
            //i := g_dwIPNeedInfo[m_nInPowerLevel].nPower;
            //nInteger := m_IPRecoverRate;
            Inc(m_nInPowerPoint, m_IPRecoverRate);
            if m_nInPowerPoint > g_dwIPNeedInfo[m_nInPowerLevel].nPower then
              m_nInPowerPoint := g_dwIPNeedInfo[m_nInPowerLevel].nPower;
            if tObjCount <> m_nInPowerPoint then
              InternalPowerPointChanged(True);
          end;
        end;
      end;

      if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or (m_AutoGetExpEnvir = m_PEnvir)) and (GetTickCount - m_dwAutoGetExpTick > m_nAutoGetExpTime) then
      begin
        m_dwAutoGetExpTick := GetTickCount();
        if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and InSafeZone) then
          if IsHero then
            HeroGetExp(m_nAutoGetExpPoint)
          else
            GetExp(m_nAutoGetExpPoint, True, False, False);
      end;

      if m_dwGatherExp >= 10 * 1000 then
      begin
        if GetTickCount - m_dwGatherExpTick > 55 * 1000 then
        begin
          m_dwGatherExpTick := GetTickCount;
          boChg := False;
          for i := 0 to m_ItemList.Count - 1 do
          begin
            UserItem := m_ItemList.Items[i];
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then
              Continue;
            if (StdItem.StdMode = 2) and (StdItem.Shape = 10) and (m_dwGatherExp >= 10000) then
            begin
              if UserItem.Dura < UserItem.DuraMax then
              begin
                nInteger := m_dwGatherExp div 10000;
                if UserItem.Dura + nInteger >= UserItem.DuraMax then
                begin
                  Dec(m_dwGatherExp, (UserItem.DuraMax - UserItem.Dura) * 10000);
                  UserItem.Dura := UserItem.DuraMax;
                  SysMsg(Format('ÄãµÄ%sÒÑ»ýÀÛÂú¾­Ñé(Ë«»÷ÎïÆ·ÊÍ·Å¾­Ñé)', [StdItem.Name]), c_Blue, t_Hint);
                end
                else
                begin
                  Inc(UserItem.Dura, nInteger);
                  m_dwGatherExp := 0;
                end;
                SendUpdateItem(UserItem);
              end;
              boChg := True;
            end;
          end;
          if not boChg then
            m_dwGatherExp := 0;
        end;
      end;

      if m_dwGatherIPExp >= 10000 then
      begin
        if GetTickCount - m_dwGatherIPExpTick > 45 * 1000 then
        begin
          m_dwGatherIPExpTick := GetTickCount;
          boChg := False;
          for i := 0 to m_ItemList.Count - 1 do
          begin
            UserItem := m_ItemList.Items[i];
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then
              Continue;
            if (StdItem.StdMode = 2) and (StdItem.Shape = 11) and (m_dwGatherIPExp >= 10000) then
            begin
              if UserItem.Dura < UserItem.DuraMax then
              begin
                nInteger := m_dwGatherIPExp div 10000;
                if UserItem.Dura + nInteger >= UserItem.DuraMax then
                begin
                  Dec(m_dwGatherIPExp, (UserItem.DuraMax - UserItem.Dura) * 10000);
                  UserItem.Dura := UserItem.DuraMax;
                  SysMsg(Format('ÄãµÄ%sÒÑ»ýÀÛÂú¾­Ñé(Ë«»÷ÎïÆ·ÊÍ·Å¾­Ñé)', [StdItem.Name]), c_Blue, t_Hint);
                end
                else
                begin
                  Inc(UserItem.Dura, nInteger);
                  m_dwGatherIPExp := 0;
                end;
                SendUpdateItem(UserItem);
              end;
              boChg := True;
            end;
          end;
          if not boChg then
            m_dwGatherIPExp := 0;
        end;
      end;

      ////////////////
      if m_PEnvir.NimbusCount > 0 then
        if GetTickCount - m_dwGatherNimbusTick > 10 * 1000 then
        begin
          m_dwGatherNimbusTick := GetTickCount;
          m_dwGatherNimbus := m_dwGatherNimbus + GetNearNumbusPoints();
          if m_dwGatherNimbus > 0 then
          begin
            if IsHero then
              m_Master.SendMsg(m_Master, RM_HEROWINNIMBUSEXP, 0, m_dwGatherNimbus, 0, 0, '')
            else
              SendMsg(Self, RM_WINNIMBUSEXP, 0, m_dwGatherNimbus, 0, 0, '');
          end;
        end;
    end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if m_boOffLineFlag and not m_boDeath and not m_boGhost and not m_boDealing and not m_StallMgr.OnSale then
      begin
        if not m_boOffLinePlay and (GetTickCount - m_dwMoveTick > 550 * (Random(8) + 1)) then
        begin
          m_dwMoveTick := GetTickCount;
          if Random(7) > 0 then
          begin
            if g_Config.DeathWalking then
            begin
              if Random(6) = 0 then
                m_btDirection := Random(8);
              if GetFrontPosition(nX, nY) and InSafeZone(m_PEnvir, nX, nY) then
              begin
                if m_PEnvir.CanWalk(nX, nY, False) then
                begin //¿ÉÒÔÒÆ¶¯£¬¼ì²éÊÇ·ñÔÚ°²È«Çø
                  WalkTo(m_btDirection, False);
                end
                else
                begin
                  TurnTo(Random(8));
                end;
              end;
            end;
            if (g_DeathWalkingSays.Count > 1) and (Random(3888) = 0) then
            begin
              Str := g_DeathWalkingSays[Random(g_DeathWalkingSays.Count)];
              if Str <> '' then
                ProcessSayMsg(Str);
            end;
          end;
        end;

      end;
    end;

  finally
    inherited Run;
  end;
end;

procedure TPlayObject.ProcessSpiritSuite();
var
  i: Integer;
  StdItem: pTStdItem;
  UseItem: pTUserItem;
begin
  if not g_Config.boSpiritMutiny or not m_bopirit then
    Exit;
  m_bopirit := False;
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    UseItem := @m_UseItems[i];
    if UseItem.wIndex <= 0 then
      Continue;
    StdItem := UserEngine.GetStdItem(UseItem.wIndex);
    if StdItem <> nil then
    begin
      if (StdItem.Shape = 126) or
        (StdItem.Shape = 127) or
        (StdItem.Shape = 128) or
        (StdItem.Shape = 129) then
      begin

        SendDelItems(UseItem);
        UseItem.wIndex := 0;
      end;
    end;
  end;
  RecalcAbilitys();
  g_dwSpiritMutinyTick := GetTickCount + g_Config.dwSpiritMutinyTime;
  UserEngine.SendBroadCastMsg('ÉñÖ®Æíµ»£¬ÌìµØÕðÅ­£¬Ê¬ºá±éÒ°...', t_System);
  SysMsg('Æíµ»·¢³öÇ¿ÁÒµÄÓîÖæÐ§Ó¦', c_Green, t_Hint);
end;

procedure TPlayObject.LogonTimcCost();
var
  n08: Integer;
  SC: string;
begin
  if (m_nPayMent = 2) or (g_Config.boTestServer) then
    n08 := (GetTickCount - m_dwLogonTick) div 1000
  else
    n08 := 0;
  SC := m_sIPaddr + #9 + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', m_dLogonTime) + #9 + FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + #9 + IntToStr(m_nPayMode);
  AddLogonCostLog(SC);
  if m_nPayMode = 2 then
    FrmIDSoc.SendLogonCostMsg(m_sUserID, n08 div 60);
end;

function TBaseObject.MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord; NameColor: Integer = 255; BodyColorIndex: Integer = -1; const boFalg: Boolean = True): TBaseObject;
var
  nX, nY, nCount: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  nCount := 0;
  {for i := m_SlaveList.Count - 1 downto 0 do begin
    if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO then
      Inc(nCount);
  end;}
  nMaxMob := nMaxMob + nCount;
  if m_SlaveList.Count < nMaxMob then
  begin
    GetFrontPosition(nX, nY);
    MonObj := UserEngine.RegenMonsterByName(m_PEnvir.m_sMapFileName, nX, nY, sMonName);
    if MonObj <> nil then
    begin
      MonObj.m_Master := Self;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + Round(dwRoyaltySec / 10 * g_Config.dwMasterRoyaltyRate) * 1000;
      MonObj.m_btSlaveMakeLevel := nMakeLevel;
      MonObj.m_btSlaveExpLevel := nExpLevel;
      MonObj.RecalcAbilitys();
      MonObj.m_btNameColor := NameColor;
      if BodyColorIndex > -1 then
      begin
        MonObj.m_boFixColor := True;
        MonObj.m_nFixColorIdx := BodyColorIndex;
      end;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
      MonObj.m_SendRefMsgTick := GetTickCount;
      MonObj.m_boShowMasterName := boFalg;
      MonObj.RefNameColor;
      MonObj.RefShowName;
      m_SlaveList.Add(MonObj);
      Result := MonObj;
    end;
  end;
end;

function TBaseObject.MakeSlaveEx(sMonName: string; nX, nY, nMakeLevel, nExpLevel, nMaxMob: Integer; dwRoyaltySec: LongWord; NameColor: Integer = 255; BodyColorIndex: Integer = -1; const boFalg: Boolean = True): TBaseObject;
var
  nCount: Integer;
  MonObj: TBaseObject;
begin
  Result := nil;
  nCount := 0;
  {for i := m_SlaveList.Count - 1 downto 0 do begin
    if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO then
      Inc(nCount);
  end;}
  nMaxMob := nMaxMob + nCount;
  if m_SlaveList.Count < nMaxMob then
  begin
    MonObj := UserEngine.RegenMonsterByName(m_PEnvir.m_sMapFileName, nX, nY, sMonName);
    if MonObj <> nil then
    begin
      MonObj.m_Master := Self;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + Round(dwRoyaltySec / 10 * g_Config.dwMasterRoyaltyRate) * 1000;
      MonObj.m_btSlaveMakeLevel := nMakeLevel;
      MonObj.m_btSlaveExpLevel := nExpLevel;
      MonObj.RecalcAbilitys();
      MonObj.m_btNameColor := NameColor;
      if BodyColorIndex > -1 then
      begin
        MonObj.m_boFixColor := True;
        MonObj.m_nFixColorIdx := BodyColorIndex;
      end;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) div 2;
      MonObj.m_SendRefMsgTick := GetTickCount;
      MonObj.m_boShowMasterName := boFalg;
      MonObj.RefNameColor;
      MonObj.RefShowName;
      m_SlaveList.Add(MonObj);
      Result := MonObj;
    end;
  end;
end;

procedure TBaseObject.ClearAllSlaves;
var
  i: Integer;
begin
  for i := 0 to m_SlaveList.Count - 1 do
  begin
    if not TBaseObject(m_SlaveList[i]).m_boDeath then
    begin
      TBaseObject(m_SlaveList[i]).m_boDeath := True;
      TBaseObject(m_SlaveList[i]).MakeGhost();
    end;
  end;
end;

procedure TBaseObject.KillAllSlaves;
var
  i: Integer;
begin
  for i := 0 to m_SlaveList.Count - 1 do
  begin
    if not TBaseObject(m_SlaveList[i]).m_boDeath then
      TBaseObject(m_SlaveList[i]).m_WAbil.HP := 0;
  end;
end;

procedure TPlayObject.ClientHeroJointAttack();
var
  HeroObject: TBaseObject;
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject <> nil) then
  begin
    if not HeroObject.m_boJointAttackReady and (HeroObject.m_nJointAttackEnergy >= 200) then
      HeroObject.m_boJointAttackReady := True;
    if g_Config.boHeroAutoLockTarget and (m_TargetCret <> nil) then
    begin
      if IsProperTarget(m_TargetCret) then
      begin
        if m_btHeroRelax <> 0 then
          m_btHeroRelax := 0;

        if m_boHeroSearchTag then
        begin
          m_boHeroSearchTag := False;
          TAnimalObject(HeroObject).m_nTargetX2 := -1;
          TAnimalObject(HeroObject).m_nTargetY2 := -1;
        end;

        HeroObject.m_LockTarget := m_TargetCret;
        HeroObject.SetTargetCreat(m_TargetCret);
        m_dwHeroSetTargetTick := GetTickCount;
      end;
    end;
  end;
end;

procedure TPlayObject.HeroAutoJointAttack();
var
  HeroObject: TBaseObject;
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject <> nil) then
  begin
    if not HeroObject.m_boJointAttackReady then
      Exit;
    if g_Config.boHeroAutoLockTarget and (m_TargetCret <> nil) then
    begin
      if IsProperTarget(m_TargetCret) then
      begin
        if m_btHeroRelax <> 0 then
          m_btHeroRelax := 0;

        if m_boHeroSearchTag then
        begin
          m_boHeroSearchTag := False;
          TAnimalObject(HeroObject).m_nTargetX2 := -1;
          TAnimalObject(HeroObject).m_nTargetY2 := -1;
        end;

        HeroObject.m_LockTarget := m_TargetCret;
        HeroObject.SetTargetCreat(m_TargetCret);
        m_dwHeroSetTargetTick := GetTickCount;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientRecallHero();
var
  i: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sMsg, sAttackMode: string;
  MessageBodyWL: TMessageBodyWL;
  Ability: TAbility;
  HeroObject: TBaseObject;
  Buffer: array[0..255] of Byte;
begin
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
  if (UserEngine.m_PlayObjectList.Count > 10) then
  begin
    m_boEmergencyClose := True;
    Exit;
  end;
{$IFEND}
  if (m_HeroObject = nil) and (GetTickCount - m_dwRecallHeroTick > g_Config.nRecallHeroIntervalTime * 1000) then
  begin
    HeroObject := UserEngine.RegenHero('', Self, 1);
    if HeroObject <> nil then
    begin
      for i := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if HeroObject.m_UseItems[i].wIndex > 0 then
        begin
          if InLimitItemList('', HeroObject.m_UseItems[i].wIndex, t_pOnLogon) then
          begin
            HeroObject.m_UseItems[i].wIndex := 0;
            Continue;
          end;
          StdItem := UserEngine.GetStdItem(HeroObject.m_UseItems[i].wIndex);
          if StdItem <> nil then
          begin
            if not CheckUserItems(i, {$IF VER_ClientType_45}m_wClientType, {$IFEND VER_ClientType_45}StdItem) then
            begin
              New(UserItem);
              UserItem^ := HeroObject.m_UseItems[i];
              if not HeroObject.AddItemToBag(UserItem) then
                HeroObject.m_ItemList.Insert(0, UserItem);
              HeroObject.m_UseItems[i].wIndex := 0;
            end;
          end
          else
            HeroObject.m_UseItems[i].wIndex := 0;
        end;
      end;
      //MainOutMessageAPI('HeroObject.m_Master := self;');
      HeroObject.m_Master := Self;
      TPlayObject(HeroObject).m_sIPaddr := m_sIPaddr;
      HeroObject.Initialize;
      m_HeroObject := HeroObject;
      TPlayObject(HeroObject).m_dLogonTime := Now();
      HeroObject.m_Abil.MaxExp := HeroObject.GetLevelExp(HeroObject.m_Abil.Level);
      HeroObject.m_SendRefMsgTick := GetTickCount;
{$IF VER_ClientType_45}
      HeroObject.m_wClientType := m_wClientType;
{$IFEND VER_ClientType_45}
      HeroObject.m_nClientVerNO := m_nClientVerNO;
      //m_HeroList.Add(HeroObject);
      if HeroObject.m_btHair > 1 then
        HeroObject.m_btHair := 1;
      HeroObject.m_btSlaveExpLevel := SLAVEMAXLEVEL;
      HeroObject.m_boObMode := False;
      HeroObject.SendRefMsg(RM_TURN, HeroObject.m_btDirection, HeroObject.m_nCurrX, HeroObject.m_nCurrY, 0, HeroObject.GetShowName);
      HeroObject.SendRefMsg(RM_HEROLOGIN, HeroObject.m_btDirection, HeroObject.m_nCurrX, HeroObject.m_nCurrY, 0, '');
      HeroObject.RecalcLevelAbilitys();
      HeroObject.RecalcAbilitys(True);
      if HeroObject.m_Abil.HP > HeroObject.m_Abil.MaxHP then
        HeroObject.m_Abil.HP := HeroObject.m_Abil.MaxHP;
      if HeroObject.m_Abil.MP > HeroObject.m_Abil.MaxMP then
        HeroObject.m_Abil.MP := HeroObject.m_Abil.MaxMP;

      m_DefMsg := MakeDefaultMsg(SM_HEROSTATE, Integer(HeroObject), 0, 0, MakeWord(HeroObject.m_btDirection, HeroObject.m_nInPowerLevel));
      MessageBodyWL.lParam1 := HeroObject.GetFeature(HeroObject, @Buffer[0]);
      MessageBodyWL.lParam2 := HeroObject.m_nCharStatus;
      sMsg := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL));
      sMsg := sMsg + EncodeBuffer(@Buffer[0], MessageBodyWL.lParam1);
      SendSocket(@m_DefMsg, sMsg);

      HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
      HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');

      m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, TPlayObject(HeroObject).m_nGold, MakeWord(TPlayObject(HeroObject).m_btJob, HeroObject.m_nInPowerLevel), 0, 0);
{$IF VER_ClientType_45}
      if m_wClientType = 45 then
      begin
        TPlayObject(HeroObject).GetOldAbil(OAbility);
        SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
      end
      else
{$IFEND VER_ClientType_45}if HeroObject.m_PEnvir.m_MapFlag.nSecret > 0 then
        begin
          Ability := HeroObject.m_WAbil;
          Ability.HP := Round(HeroObject.m_WAbil.HP / HeroObject.m_WAbil.MaxHP * 100);
          Ability.MaxHP := 100;
          SendSocket(@m_DefMsg, EncodeBuffer(@Ability, SizeOf(TAbility)));
        end
        else
        begin
          SendSocket(@m_DefMsg, EncodeBuffer(@HeroObject.m_WAbil, SizeOf(TAbility)));
        end;

      HeroObject.m_btNameColor := g_Config.nHeroNameColor;
      HeroObject.RefNameColor();
      HeroObject.RefShowName;

      m_DefMsg := MakeDefaultMsg(SM_HERONAME, Integer(HeroObject), GetCharColor(HeroObject), 0, 0);
      SendSocket(@m_DefMsg, EncodeString(HeroObject.GetShowName));

      SendHeroLoyalty();

      SendHeroUseitems();

      SendHeroUseMagic();

      ClientQueryHeroBagItems();

      TPlayObject(HeroObject).InternalPowerPointChanged();

      SendMsg(Self, RM_HEROWINIPEXP, 0, 0, 0, 0, '');

      SendMsg(Self, RM_PLAYERCONFIGHERO, MakeWord(Byte(HeroObject.m_boShowFashion), 0), 0, 0, 0, '');

      if TPlayObject(HeroObject).m_nInPowerLevel > 0 then
        TPlayObject(HeroObject).SendMsg(TPlayObject(HeroObject), RM_SERIESSKILLARR, 0, 0, 0, 0, '');

      case m_btHeroRelax of
        0: sAttackMode := '¹¥»÷';
        1: sAttackMode := '¸úËæ';
        2: sAttackMode := 'ÐÝÏ¢';
      else
        sAttackMode := '¹¥»÷';
      end;
      SysMsg(Format(sStartHeroAttackModeHelp, [sAttackMode]), c_Blue, t_Hint);
      SysMsg(sStartHeroModeHelp, c_Green, t_Hint);
      if (m_Abil.Level >= 43) and (HeroObject.m_Abil.Level >= 39) and (m_MagicArr[0][75] = nil) and (HeroObject.m_MagicArr[0][75] <> nil) then
      begin
        AddSkillByName('»¤ÌåÉñ¶Ü');
        SysMsg('ÄãÒÑ¾­Ñ§»á»¤ÌåÉñ¶Ü¼¼ÄÜ¡£', c_Green, t_Hint);
      end;
      m_dwRecallHeroTick := GetTickCount;
      if (g_FunctionNPC <> nil) then
      begin
        g_FunctionNPC.m_OprCount := 0;
        g_FunctionNPC.GotoLable(Self, '@HeroLogin', False);
      end;
    end;
  end
  else
    SysMsg(Format(sRecallHeroLaterMsg, [g_Config.nRecallHeroIntervalTime - ((GetTickCount - m_dwRecallHeroTick) div 1000) + 1]), c_Green, t_Hint);
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
end;

procedure TPlayObject.QueryHeroHeroState();
var
  MessageBodyWL: TMessageBodyWL;
  Ability: TAbility;
  HeroObject: TBaseObject;
  Buffer: array[0..255] of Byte;
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  HeroObject := GetHeroObjectA();
  if HeroObject <> nil then
  begin
    m_DefMsg := MakeDefaultMsg(SM_HEROSTATE, Integer(HeroObject), 0, 0, MakeWord(HeroObject.m_btDirection, HeroObject.m_nInPowerLevel));
    MessageBodyWL.lParam1 := HeroObject.GetFeature(HeroObject, @Buffer[0]);
    MessageBodyWL.lParam2 := HeroObject.m_nCharStatus;
    SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)) + EncodeBuffer(@Buffer[0], MessageBodyWL.lParam1));

    HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
    HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');
    m_DefMsg := MakeDefaultMsg(SM_HEROABILITY, TPlayObject(HeroObject).m_nGold, MakeWord(TPlayObject(HeroObject).m_btJob, HeroObject.m_nInPowerLevel), 0, 0);
{$IF VER_ClientType_45}
    if m_wClientType = 45 then
    begin
      TPlayObject(HeroObject).GetOldAbil(OAbility);
      SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
    end
    else
{$IFEND VER_ClientType_45}if HeroObject.m_PEnvir.m_MapFlag.nSecret > 0 then
      begin
        Ability := HeroObject.m_WAbil;
        Ability.HP := Round(HeroObject.m_WAbil.HP / HeroObject.m_WAbil.MaxHP * 100);
        Ability.MaxHP := 100;
        SendSocket(@m_DefMsg, EncodeBuffer(@Ability, SizeOf(TAbility)));
      end
      else
      begin
        SendSocket(@m_DefMsg, EncodeBuffer(@HeroObject.m_WAbil, SizeOf(TAbility)));
      end;

    m_DefMsg := MakeDefaultMsg(SM_HERONAME, Integer(HeroObject), GetCharColor(HeroObject), 0, 0);
    SendSocket(@m_DefMsg, EncodeString(HeroObject.GetShowName));

    ClientQueryHeroBagItems();
    SendHeroUseitems();
    SendHeroUseMagic();
  end;
end;

procedure TPlayObject.CmdRecallHero(Cmd: pTGameCmd; sMonName, sExtraName: string; boUseItem: Boolean);
var
  i, nCount: Integer;
  MonObj: TBaseObject;
  Buffer: array[0..255] of Byte;
begin
  nCount := 0;
  for i := m_SlaveList.Count - 1 downto 0 do
  begin
    if m_btPermission >= 10 then
      Break;
    if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO then
      Inc(nCount);
  end;
  if nCount >= g_Config.nBodyCount then
    Exit;
  if (sMonName = '') or (Length(sMonName) > 14) then
    sMonName := g_Config.sHeroName;
  MonObj := UserEngine.RegenHero(sMonName, Self, 0);
  if MonObj <> nil then
  begin
    MonObj.m_boObMode := False;
    MonObj.m_boNoDropItemEx := boUseItem;
    MonObj.m_boNoDropUseItemEx := boUseItem;
    MonObj.m_Master := Self;
    MonObj.m_SendRefMsgTick := GetTickCount;
{$IF VER_ClientType_45}
    MonObj.m_wClientType := m_wClientType;
{$IFEND VER_ClientType_45}
    MonObj.m_nClientVerNO := m_nClientVerNO;
    MonObj.m_dwMasterRoyaltyTick := GetTickCount + Round(24 * 60 * 60 / 10 * g_Config.dwMasterRoyaltyRate) * 1000;
    MonObj.ReadAllBook();
    MonObj.SendRefMsg(RM_TURN, MonObj.m_btDirection, MonObj.m_nCurrX, MonObj.m_nCurrY, 0, MonObj.GetShowName);
    MonObj.m_btSlaveExpLevel := SLAVEMAXLEVEL;
    MonObj.RecalcLevelAbilitys();
    MonObj.RecalcAbilitys();
    MonObj.RefNameColor();
    MonObj.RefShowName;
    m_SlaveList.Add(MonObj);
    MonObj.SendRefMsg(RM_HEROLOGIN, MonObj.m_btDirection, MonObj.m_nCurrX, MonObj.m_nCurrY, 0, '');
  end;
end;

function TPlayObject.CloneSelf(btLevel: Byte): TBaseObject;
var
  i, nCount: Integer;
  MonObj: TBaseObject;
  UserMagic: pTUserMagic;
begin
  nCount := 0;
  Result := nil;
  for i := m_SlaveList.Count - 1 downto 0 do
  begin
    if m_btPermission >= 10 then
      Break;
    if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO then
      Inc(nCount);
  end;
  if nCount >= g_Config.nBodyCount then
    Exit;
  MonObj := UserEngine.RegenHero(m_sCharName, Self, 2);
  if MonObj <> nil then
  begin
    MonObj.Initialize();
    MonObj.m_boNoDropItemEx := True;
    MonObj.m_boNoDropUseItemEx := True;
    MonObj.m_Master := Self;
    MonObj.m_Master.m_boAdminMode := True;
    MonObj.m_Master.m_dwAdminTick := GetTickCount();
    MonObj.m_SendRefMsgTick := GetTickCount;
{$IF VER_ClientType_45}
    MonObj.m_wClientType := m_wClientType;
{$IFEND VER_ClientType_45}
    MonObj.m_nClientVerNO := m_nClientVerNO;
    MonObj.m_dwMasterRoyaltyTick := GetTickCount + Round(24 * 60 * 60 / 10 * g_Config.dwMasterRoyaltyRate) * 1000;
    MonObj.m_dwCloneDispearTick := GetTickCount + (btLevel + 1) * g_Config.nShadowExpriesTime * 1000;
    for i := 0 to m_MagicList.Count - 1 do
    begin
      New(UserMagic);
      UserMagic^ := pTUserMagic(m_MagicList.Items[i])^;
      MonObj.m_MagicList.Add(UserMagic);
    end;

    MonObj.m_btSlaveExpLevel := SLAVEMAXLEVEL;
    MonObj.RecalcLevelAbilitys();
    MonObj.RecalcAbilitys();
    MonObj.m_btNameColor := g_Config.nHeroNameColor;
    MonObj.m_boObMode := False;
    MonObj.RefShowName();
    //MonObj.RefNameColor();
    SendRefMsg(RM_SPELL, 74, MakeLong(MonObj.m_nCurrX, MonObj.m_nCurrY), 0, 74, '');
    SendRefMsg(RM_HEROSPELL, 0, MonObj.m_nCurrX, MonObj.m_nCurrY, 0, '');
    THeroObject(MonObj).m_boRunReady := True;
    m_SlaveList.Add(MonObj);
    Result := MonObj;
  end;
end;

procedure TPlayObject.ProcessUserLineMsg(sData: string);
var
  SC, sCmd, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string;
  PlayObject: TPlayObject;
  HeroObject: TBaseObject;
  nFlag: Integer;
  nValue: Integer;
  nLen: Integer;
  StdItem: pTStdItem;
  StallInfo: TStallInfo;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ProcessUserLineMsg Msg = %s';
begin
  try
    nLen := Length(sData);
    if sData = '' then
      Exit;
    if m_boSetStoragePwd then
    begin
      m_boSetStoragePwd := False;
      if (nLen > 3) and (nLen < 8) then
      begin
        m_sTempPwd := sData;
        m_boReConfigPwd := True;
        SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'ÇëÖØ¸´ÊäÈëÒ»´Î²Ö¿âÃÜÂë£º'}
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      end
      else
        SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'ÊäÈëµÄÃÜÂë³¤¶È²»ÕýÈ·£¡£¬ÃÜÂë³¤¶È±ØÐëÔÚ 4 - 7 µÄ·¶Î§ÄÚ£¬ÇëÖØÐÂÉèÖÃÃÜÂë'}
      Exit;
    end;
    if m_boReConfigPwd then
    begin
      m_boReConfigPwd := False;
      if CompareStr(m_sTempPwd, sData) = 0 then
      begin
        m_sStoragePwd := sData;
        m_boPasswordLocked := True;
        m_boCanGetBackItem := False;
        m_sTempPwd := '';
{$IF VEROWNER = WL}
        SysMsg(Format('ÃÜÂëÉèÖÃ³É¹¦£¡£¬²Ö¿âÒÑ¾­×Ô¶¯ÉÏËø£¬Çë¼ÇºÃÄúµÄ²Ö¿âÃÜÂë£¬ÔÚÈ¡²Ö¿âÊ±ÐèÒªÊ¹ÓÃ´ËÃÜÂë¿ªËø¡£ÄúÕý´¦ÓÚ·Ç±£»¤Ä£Ê½,ÈçÏëÄúµÄ×°±¸¸ü°²È«,ÇëÊäÈëÖ¸Áî@%s', [g_GameCommand.LOCKLOGON.sCmd]), c_Blue, t_Hint);
{$ELSE}
        SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'ÃÜÂëÉèÖÃ³É¹¦£¡£¬²Ö¿âÒÑ¾­×Ô¶¯ÉÏËø£¬Çë¼ÇºÃÄúµÄ²Ö¿âÃÜÂë£¬ÔÚÈ¡²Ö¿âÊ±ÐèÒªÊ¹ÓÃ´ËÃÜÂë¿ªËø'}
{$IFEND}
      end
      else
      begin
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if m_boUnLockPwd or m_boUnLockStoragePwd then
    begin
      if CompareStr(m_sStoragePwd, sData) = 0 then
      begin
        m_boPasswordLocked := False;
        if m_boUnLockPwd then
        begin
          if g_Config.boLockDealAction then
            m_boCanDeal := True;
          if g_Config.boLockRecallAction then
            m_boCanRecallHero := True;
          if g_Config.boLockDropAction then
            m_boCanDrop := True;
          if g_Config.boLockWalkAction then
            m_boCanWalk := True;
          if g_Config.boLockRunAction then
            m_boCanRun := True;
          if g_Config.boLockHitAction then
            m_boCanHit := True;
          if g_Config.boLockSpellAction then
            m_boCanSpell := True;
          if g_Config.boLockSendMsgAction then
            m_boCanSendMsg := True;
          if g_Config.boLockUserItemAction then
            m_boCanUseItem := True;
          if g_Config.boLockInObModeAction then
          begin
            m_boObMode := False;
            m_boAdminMode := False;
          end;
          m_boLockLogoned := True;
          SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
        end;
        if m_boUnLockStoragePwd then
        begin
          if g_Config.boLockGetBackItemAction then
            m_boCanGetBackItem := True;
          SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
        end;
      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
      end;
      m_boUnLockPwd := False;
      m_boUnLockStoragePwd := False;
      Exit;
    end;

    if m_boCheckOldPwd then
    begin
      m_boCheckOldPwd := False;
      if m_sStoragePwd = sData then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        m_boSetStoragePwd := True;
      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
        end;
      end;
      Exit;
    end;
    if sData[1] <> '@' then
    begin
      ProcessSayMsg(sData); //secret
      Exit;
    end;
    SC := Copy(sData, 2, Length(sData) - 1);
    SC := GetValidStr3(SC, sCmd, [' ', ':', ',', #9]);
    if (Length(sCmd) < 1) then
      Exit;
    if SC <> '' then
      SC := GetValidStr3(SC, sParam1, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam2, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam3, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam4, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam5, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam6, [' ', ':', ',', #9]);
    if SC <> '' then
      SC := GetValidStr3(SC, sParam7, [' ', ':', ',', #9]);
    m_sCmdParams[0] := sCmd;
    m_sCmdParams[1] := sParam1;
    m_sCmdParams[2] := sParam2;
    m_sCmdParams[3] := sParam3;
    m_sCmdParams[4] := sParam4;
    m_sCmdParams[5] := sParam5;
    m_sCmdParams[6] := sParam6;
    m_sCmdParams[7] := sParam7;

    if ProcessUserCmd(sCmd) then
      Exit;

    {if @Engine_SetHookUserCmd <> nil then begin
      if Engine_SetHookUserCmd(self,
        PChar(sCmd),
        PChar(sParam1),
        PChar(sParam2),
        PChar(sParam3),
        PChar(sParam4),
        PChar(sParam5),
        PChar(sParam6),
        PChar(sParam7)) then Exit;
    end;}

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPBM.inc'}
{$IFEND}
    if (CompareText(sCmd, '´«') = 0) then
    begin //secret
      if m_PEnvir.m_MapFlag.nSecret and $01 <> 0 then
      begin
        SysMsg('±¾µØÍ¼½ûÖ¹Ëµ»°ÁÄÌì£¡', c_Red, t_Hint);
        Exit;
      end;
      if m_UseItems[U_CHARM].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
        if StdItem <> nil then
        begin
          if (StdItem.StdMode = 7) and (StdItem.Shape = 0) then
          begin
            SC := Copy(sData, 2, Length(sData) - 1);
            SC := GetValidStr3(SC, sCmd, [' ', ':', ',', #9]);
            if m_UseItems[U_CHARM].Dura > 1000 then
            begin
              Dec(m_UseItems[U_CHARM].Dura, 1000);
              SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura, m_UseItems[U_CHARM].DuraMax, 0, '');
              UserEngine.SendBroadCastMsg(m_sCharName + ': ' + SC, t_Say, c_Purple);
            end
            else
            begin
              UserEngine.SendBroadCastMsg(m_sCharName + ': ' + SC, t_Say, c_Purple);
              m_UseItems[U_CHARM].Dura := 0;
              SendDelItems(@m_UseItems[U_CHARM]);
              m_UseItems[U_CHARM].wIndex := 0;
            end;
          end;
        end;
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PASSWORDLOCK.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_sStoragePwd = '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_boPasswordLocked then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
        m_boUnLockStoragePwd := True;
        m_boUnLockPwd := True;
        Exit;
      end;

      if m_sStoragePwd <> '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
        Exit;
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.SETPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;

      if m_sStoragePwd = '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      end
      else
        SysMsg(g_sAlreadySetPasswordMsg, c_Red, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UNPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then
      begin
        m_sStoragePwd := '';
        m_boLockLogon := False;
        m_boLockLogoned := False;
        SysMsg(g_sOldPasswordIsClearMsg, c_Green, t_Hint);
      end
      else
      begin
        SysMsg(g_sPleaseUnLockPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHGPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
      end
      else
      begin
        SysMsg(g_sNoPasswordSetMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        if not m_boUnLockStoragePwd then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockStoragePwd := True;
        end
        else
        begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.UnLock.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        Exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        if not m_boUnLockPwd then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockPwd := True;
        end
        else
        begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Lock.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        Exit;
      end;
      if not m_boPasswordLocked then
      begin
        if m_sStoragePwd <> '' then
        begin
          m_boPasswordLocked := True;
          m_boCanGetBackItem := False;
          SysMsg(g_sLockStorageSuccessMsg, c_Green, t_Hint);
        end
        else
        begin
          SysMsg(g_sStorageNoPasswordMsg, c_Green, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageAlreadyLockMsg, c_Red, t_Hint);
      end;
      Exit;
    end;
    {if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not m_boPasswordLocked then begin
        m_sStoragePwd:='';
        SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;}
    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTION.sCmd) = 0 then
    begin
      CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then
    begin
      CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd, sParam1);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.DEAR.sCmd) = 0 then
    begin
      CmdSearchDear(g_GameCommand.DEAR.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Master.sCmd) = 0 then
    begin
      CmdSearchMaster(g_GameCommand.Master.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MASTERECALL.sCmd) = 0 then
    begin
      CmdMasterRecall(g_GameCommand.MASTERECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DEARRECALL.sCmd) = 0 then
    begin
      CmdDearRecall(g_GameCommand.DEARRECALL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SignMove.sCmd) = 0 then
    begin
      CmdSignMove(@g_GameCommand.SignMove);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWDEARRCALL.sCmd) = 0 then
    begin
      m_boCanDearRecall := not m_boCanDearRecall;
      if m_boCanDearRecall then
      begin
        SysMsg(g_sEnableDearRecall {'ÔÊÐí·òÆÞ´«ËÍ'}, c_Blue, t_Hint);
      end
      else
      begin
        SysMsg(g_sDisableDearRecall {'½ûÖ¹·òÆÞ´«ËÍ'}, c_Blue, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWMASTERRECALL.sCmd) = 0 then
    begin
      m_boCanMasterRecall := not m_boCanMasterRecall;
      if m_boCanMasterRecall then
        SysMsg(g_sEnableMasterRecall {'ÔÊÐíÊ¦Í½´«ËÍ'}, c_Blue, t_Hint)
      else
        SysMsg(g_sDisableMasterRecall {'½ûÖ¹Ê¦Í½´«ËÍ'}, c_Blue, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Data.sCmd) = 0 then
    begin
      SysMsg(g_sNowCurrDateTime {'µ±Ç°ÈÕÆÚÊ±¼ä: '} + FormatDateTime('dddddd,dddd,hh:mm:nn', Now), c_Blue, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PRVMSG.sCmd) = 0 then
    begin
      CmdPrvMsg(g_GameCommand.PRVMSG.sCmd, g_GameCommand.PRVMSG.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWMSG.sCmd) = 0 then
    begin
      m_boHearWhisper := not m_boHearWhisper;
      if m_boHearWhisper then
        SysMsg(g_sEnableHearWhisper {'[ÔÊÐíË½ÁÄ]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableHearWhisper {'[½ûÖ¹Ë½ÁÄ]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETSHOUT.sCmd) = 0 then
    begin
      m_boBanShout := not m_boBanShout;
      if m_boBanShout then
        SysMsg(g_sEnableShoutMsg {'[ÔÊÐíÈºÁÄ]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableShoutMsg {'[½ûÖ¹ÈºÁÄ]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LETTRADE.sCmd) = 0 then
    begin
      m_boAllowDeal := not m_boAllowDeal;
      if m_boAllowDeal then
        SysMsg(g_sEnableDealMsg {'[ÔÊÐí½»Ò×]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableDealMsg {'[½ûÖ¹½»Ò×]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BANGUILDCHAT.sCmd) = 0 then
    begin
      m_boBanGuildChat := not m_boBanGuildChat;
      if m_boBanGuildChat then
        SysMsg(g_sEnableGuildChat {'[ÔÊÐíÐÐ»áÁÄÌì]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableGuildChat {'[½ûÖ¹ÐÐ»áÁÄÌì]'}, c_Green, t_Hint);
      Exit;
    end;

    if CompareText(sCmd, g_GameCommand.LETGUILD.sCmd) = 0 then
    begin
      m_boAllowGuild := not m_boAllowGuild;
      if m_boAllowGuild then
        SysMsg(g_sEnableJoinGuild {'[ÔÊÐí¼ÓÈëÐÐ»á]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableJoinGuild {'[½ûÖ¹¼ÓÈëÐÐ»á]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDGUILD.sCmd) = 0 then
    begin
      CmdEndGuild();
      Exit;
    end;
    //StartWallconquestWar
    if CompareText(sCmd, 'AddToCastleWarList') = 0 then
    begin
      CmdAddToCastleWarList(sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTHALLY.sCmd) = 0 then
    begin
      if IsGuildMaster then
      begin
        TGuild(m_MyGuild).m_boEnableAuthAlly := not TGuild(m_MyGuild).m_boEnableAuthAlly;
        if TGuild(m_MyGuild).m_boEnableAuthAlly then
          SysMsg(g_sEnableAuthAllyGuild {'[ÔÊÐíÐÐ»áÁªÃË]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableAuthAllyGuild {'[½ûÖ¹ÐÐ»áÁªÃË]'}, c_Green, t_Hint);
      end;
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then
    begin
      CmdAllowGroupReCall(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, 'LongAttack') = 0 then
    begin
      CmdChangeLongAttack();
      Exit;
    end;
    if CompareText(sCmd, 'HeroMakeSlave') = 0 then
    begin
      m_btHeroMakeSlave := Str_ToInt(sParam1, 0);
      CmdChangeHeroMakeSlave();
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GROUPRECALLL.sCmd) = 0 then
    begin
      CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then
    begin
      m_boAllowGuildReCall := not m_boAllowGuildReCall;
      if m_boAllowGuildReCall then
        SysMsg(g_sEnableGuildRecall {'[ÔÊÐíÐÐ»áºÏÒ»]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableGuildRecall {'[½ûÖ¹ÐÐ»áºÏÒ»]'}, c_Green, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GUILDRECALLL.sCmd) = 0 then
    begin
      CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTH.sCmd) = 0 then
    begin
      if IsGuildMaster then
        ClientGuildAlly();
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AUTHCANCEL.sCmd) = 0 then
    begin
      if IsGuildMaster then
        ClientGuildBreakAlly(sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DIARY.sCmd) = 0 then
    begin
      CmdViewDiary(g_GameCommand.DIARY.sCmd, Str_ToInt(sParam1, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ATTACKMODE.sCmd) = 0 then
    begin
      CmdChangeAttackMode(Str_ToInt(sParam1, -1), sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REST.sCmd) = 0 then
    begin
      CmdChangeSalveStatus();
      Exit;
    end;
    if CompareText(sCmd, 'RestHero') = 0 then
    begin
      CmdChangeHeroStatus();
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEONHORSE.sCmd) = 0 then
    begin
      CmdTakeOnHorse(sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEOFHORSE.sCmd) = 0 then
    begin
      CmdTakeOffHorse(sCmd, sParam1);
      Exit;
    end;
    (*if CompareText(sCmd, g_GameCommand.TESTGA.sCmd) = 0 then
     begin
       exit;
       SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
       m_boTestGa := True;
       SysMsg(g_sPleaseInputPassword {'ÇëÊäÈëÃÜÂë:'}, c_Green, t_Hint);
       exit;
     end;*)
    if CompareText(sCmd, g_GameCommand.MAPINFO.sCmd) = 0 then
    begin
      ShowMapInfo(sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARBAG.sCmd) = 0 then
    begin
      CmdClearBagItem(@g_GameCommand.CLEARBAG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then
    begin
      CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BINDUSEITEM.sCmd) = 0 then
    begin
      CmdBindUseItem(@g_GameCommand.BINDUSEITEM, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SBKDOOR.sCmd) = 0 then
    begin
      CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.USERMOVE.sCmd) = 0 then
    begin
      CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SEARCHING.sCmd) = 0 then
    begin
      CmdSearchHuman(g_GameCommand.SEARCHING.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOCKLOGON.sCmd) = 0 then
    begin
      CmdLockLogin(@g_GameCommand.LOCKLOGON);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.UNLOCKLOGON.sCmd) = 0 then
    begin
      CmdUnLockLogin(@g_GameCommand.UNLOCKLOGON);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RemoteMsg.sCmd) = 0 then
    begin
      CmdRemoteMsg(@g_GameCommand.RemoteMsg);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RemoteMusic.sCmd) = 0 then
    begin
      //CmdRemoteMusic(@g_GameCommand.CmdRemoteMusic);
      Exit;
    end;
    if (m_btPermission >= 2) and (Length(sData) > 2) then
    begin
      if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd) then
      begin
        if GetTickCount - m_dwSayMsgTick > 2000 then
        begin
          m_dwSayMsgTick := GetTickCount();
          sData := Copy(sData, 3, Length(sData) - 2);
          if Length(sData) > g_Config.nSayRedMsgMaxLen then
          begin
            sData := Copy(sData, 1, g_Config.nSayRedMsgMaxLen);
          end;
          if g_Config.boShutRedMsgShowGMName then
            SC := m_sCharName + ': ' + sData
          else
            SC := sData;
          UserEngine.SendBroadCastMsg(SC, t_GM);
        end;
        Exit;
      end;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANLOCAL.sCmd) = 0 then
    begin
      CmdHumanLocal(@g_GameCommand.HUMANLOCAL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Move.sCmd) = 0 then
    begin
      CmdMapMove(@g_GameCommand.Move, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.POSITIONMOVE.sCmd) = 0 then
    begin
      CmdPositionMove(@g_GameCommand.POSITIONMOVE, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.INFO.sCmd) = 0 then
    begin
      CmdHumanInfo(@g_GameCommand.INFO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBLEVEL.sCmd) = 0 then
    begin
      CmdMobLevel(@g_GameCommand.MOBLEVEL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, 'ÊôÏÂ×´Ì¬') = 0 then
    begin
      if ((sParam1 <> '') and (UpperCase(sParam1[1]) = 'X')) and
        ((sParam2 <> '') and (UpperCase(sParam2[1]) = 'Y')) and
        ((sParam3 <> '') and (UpperCase(sParam3[1]) = 'Z')) then
      begin
      end;
      for nValue := m_SlaveList.Count - 1 downto 0 do
        SysMsg(TBaseObject(m_SlaveList.Items[nValue]).GeTBaseObjectInfo(), c_Blue, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, 'ÖÒ³Ï¶È') = 0 then
    begin
      HeroObject := GetHeroObjectA;
      if HeroObject = nil then
        Exit;
      m_DefMsg := MakeDefaultMsg(SM_HERONAME, Integer(HeroObject), GetCharColor(HeroObject), 0, 0);
      SendHeroLoyalty();
      //SysMsg('Ó¢ÐÛÖÒ³Ï¶È: ' + FormatFloat('###00.00%', HeroObject.m_dBodyLuck / 250), c_Blue, t_Hint);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBCOUNT.sCmd) = 0 then
    begin
      CmdMobCount(@g_GameCommand.MOBCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HUMANCOUNT.sCmd) = 0 then
    begin
      CmdHumanCount(@g_GameCommand.HUMANCOUNT, sParam1);
      Exit;
    end;
    if (CompareText(sCmd, g_GameCommand.KICK.sCmd) = 0) or (CompareText(sCmd, 'KickOffLine') = 0) then
    begin
      CmdKickHuman(@g_GameCommand.KICK, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TING.sCmd) = 0 then
    begin
      CmdTing(@g_GameCommand.TING, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUPERTING.sCmd) = 0 then
    begin
      CmdSuperTing(@g_GameCommand.SUPERTING, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAPMOVE.sCmd) = 0 then
    begin
      CmdMapMoveHuman(@g_GameCommand.MAPMOVE, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUP.sCmd) = 0 then
    begin
      CmdShutup(@g_GameCommand.SHUTUP, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Map.sCmd) = 0 then
    begin
      CmdShowMapInfo(@g_GameCommand.Map, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELEASESHUTUP.sCmd) = 0 then
    begin
      CmdShutupRelease(@g_GameCommand.RELEASESHUTUP, sParam1, True);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHUTUPLIST.sCmd) = 0 then
    begin
      CmdShutupList(@g_GameCommand.SHUTUPLIST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEMASTER.sCmd) = 0 then
    begin
      CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd, g_GameCommand.GAMEMASTER.nPermissionMin, sParam1, not m_boAdminMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.OBSERVER.sCmd) = 0 then
    begin
      CmdChangeObMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boObMode);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SUEPRMAN.sCmd) = 0 then
    begin
      CmdChangeSuperManMode(g_GameCommand.SUEPRMAN.sCmd, g_GameCommand.SUEPRMAN.nPermissionMin, sParam1, not m_boSuperMan);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Level.sCmd) = 0 then
    begin
      CmdChangeLevel(@g_GameCommand.Level, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then
    begin
      CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALL.sCmd) = 0 then
    begin
      CmdRecallHuman(@g_GameCommand.RECALL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REGOTO.sCmd) = 0 then
    begin
      CmdReGotoHuman(@g_GameCommand.REGOTO, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWFLAG.sCmd) = 0 then
    begin
      CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd,
        g_GameCommand.SHOWFLAG.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWOPEN.sCmd) = 0 then
    begin
      CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd,
        g_GameCommand.SHOWOPEN.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWUNIT.sCmd) = 0 then
    begin
      CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd, g_GameCommand.SHOWUNIT.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    {if CompareText(sCmd, g_GameCommand.Attack.sCmd) = 0 then begin
      Exit;
    end;}
    if CompareText(sCmd, g_GameCommand.MOB.sCmd) = 0 then
    begin
      CmdMob(@g_GameCommand.MOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MOBNPC.sCmd) = 0 then
    begin
      CmdMobNpc(g_GameCommand.MOBNPC.sCmd, g_GameCommand.MOBNPC.nPermissionMin, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.NPCSCRIPT.sCmd) = 0 then
    begin
      CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd, g_GameCommand.NPCSCRIPT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELNPC.sCmd) = 0 then
    begin
      CmdDelNpc(g_GameCommand.DELNPC.sCmd, g_GameCommand.DELNPC.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RECALLMOB.sCmd) = 0 then
    begin
      CmdRecallMob(@g_GameCommand.RECALLMOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam5, 0), Str_ToInt(sParam6, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LUCKYPOINT.sCmd) = 0 then
    begin
      CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd, g_GameCommand.LUCKYPOINT.nPermissionMin, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.LOTTERYTICKET.sCmd) = 0 then
    begin
      CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd, g_GameCommand.LOTTERYTICKET.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADGUILD.sCmd) = 0 then
    begin
      CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd, g_GameCommand.RELOADGUILD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then
    begin
      CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd, g_GameCommand.RELOADLINENOTICE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RELOADABUSE.sCmd) = 0 then
    begin
      CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd, g_GameCommand.RELOADABUSE.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.FREEPENALTY.sCmd) = 0 then
    begin
      CmdFreePenalty(@g_GameCommand.FREEPENALTY, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.PKPOINT.sCmd) = 0 then
    begin
      CmdPKpoint(@g_GameCommand.PKPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.IncPkPoint.sCmd) = 0 then
    begin
      CmdIncPkPoint(@g_GameCommand.IncPkPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MAKE.sCmd) = 0 then
    begin
      CmdMakeItem(@g_GameCommand.MAKE, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.VIEWWHISPER.sCmd) = 0 then
    begin
      CmdViewWhisper(@g_GameCommand.VIEWWHISPER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ReAlive.sCmd) = 0 then
    begin
      CmdReAlive(@g_GameCommand.ReAlive, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.KILL.sCmd) = 0 then
    begin
      CmdKill(@g_GameCommand.KILL, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SMAKE.sCmd) = 0 then
    begin
      CmdSmakeItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEJOB.sCmd) = 0 then
    begin
      CmdChangeJob(@g_GameCommand.CHANGEJOB, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEGENDER.sCmd) = 0 then
    begin
      CmdChangeGender(@g_GameCommand.CHANGEGENDER, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.HAIR.sCmd) = 0 then
    begin
      CmdHair(@g_GameCommand.HAIR, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.BonusPoint.sCmd) = 0 then
    begin
      CmdBonuPoint(@g_GameCommand.BonusPoint, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELBONUSPOINT.sCmd) = 0 then
    begin
      CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then
    begin
      CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SETPERMISSION.sCmd) = 0 then
    begin
      CmdSetPermission(@g_GameCommand.SETPERMISSION, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.RENEWLEVEL.sCmd) = 0 then
    begin
      CmdReNewLevel(@g_GameCommand.RENEWLEVEL, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELGOLD.sCmd) = 0 then
    begin
      CmdDelGold(@g_GameCommand.DELGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ADDGOLD.sCmd) = 0 then
    begin
      CmdAddGold(@g_GameCommand.ADDGOLD, sParam1, Str_ToInt(sParam2, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEGOLD.sCmd) = 0 then
    begin
      CmdGameGold(@g_GameCommand.GAMEGOLD, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.GAMEPOINT.sCmd) = 0 then
    begin
      CmdGamePoint(@g_GameCommand.GAMEPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CREDITPOINT.sCmd) = 0 then
    begin
      CmdCreditPoint(@g_GameCommand.CREDITPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TRAINING.sCmd) = 0 then
    begin
      CmdTrainingSkill(@g_GameCommand.TRAINING, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETEITEM.sCmd) = 0 then
    begin
      CmdDeleteItem(@g_GameCommand.DELETEITEM, sParam1, sParam2, Str_ToInt(sParam3, 1));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TAKEUSERITEM.sCmd) = 0 then
    begin
      CmdTakeUserItem(@g_GameCommand.TAKEUSERITEM, sParam1, sParam2, Str_ToInt(sParam3, 1));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELETESKILL.sCmd) = 0 then
    begin
      CmdDelSkill(@g_GameCommand.DELETESKILL, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.TrainingSkill.sCmd) = 0 then
    begin
      CmdTrainingMagic(@g_GameCommand.TrainingSkill, sParam1, sParam2, Str_ToInt(sParam3, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMISSION.sCmd) = 0 then
    begin
      CmdClearMission(@g_GameCommand.CLEARMISSION, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTQUEST.sCmd) = 0 then
    begin
      CmdStartQuest(@g_GameCommand.STARTQUEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYIPLOGON.sCmd) = 0 then
    begin
      CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEDEARNAME.sCmd) = 0 then
    begin
      CmdChangeDearName(@g_GameCommand.CHANGEDEARNAME, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CHANGEMASTERNAME.sCmd) = 0 then
    begin
      CmdChangeMasterName(@g_GameCommand.CHANGEMASTERNAME, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLEARMON.sCmd) = 0 then
    begin
      CmdClearMapMonster(@g_GameCommand.CLEARMON, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then
    begin
      CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then
    begin
      CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.Mission.sCmd) = 0 then
    begin
      CmdMission(@g_GameCommand.Mission, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.MobPlace.sCmd) = 0 then
    begin
      CmdMobPlace(@g_GameCommand.MobPlace, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SetMapMode.sCmd) = 0 then
    begin
      CmdSetMapMode(g_GameCommand.SetMapMode.sCmd, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.SHOWMAPMODE.sCmd) = 0 then
    begin
      CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CLRPASSWORD.sCmd) = 0 then
    begin
      CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd, g_GameCommand.CLRPASSWORD.nPermissionMin, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.CONTESTPOINT.sCmd) = 0 then
    begin
      CmdContestPoint(@g_GameCommand.CONTESTPOINT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.STARTCONTEST.sCmd) = 0 then
    begin
      CmdStartContest(@g_GameCommand.STARTCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENDCONTEST.sCmd) = 0 then
    begin
      CmdEndContest(@g_GameCommand.ENDCONTEST, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then
    begin
      CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSG.sCmd) = 0 then
    begin
      CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.ENABLESENDMSG.sCmd) = 0 then
    begin
      CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG, sParam1);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.REFINEWEAPON.sCmd) = 0 then
    begin
      CmdRefineWeapon(@g_GameCommand.REFINEWEAPON, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then
    begin
      CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
      Exit;
    end;

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
    if m_btPermission > 4 then
    begin
      if CompareText(sCmd, g_GameCommand.BACKSTEP.sCmd) = 0 then
      begin
        CmdBackStep(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 1));
        Exit;
      end;
      if (CompareText(sCmd, g_GameCommand.CHANGELUCK.sCmd) = 0) or (CompareText(sCmd, '¸Ä±äÖÒ³Ï¶È') = 0) then
      begin
        AddBodyLuck(Str_ToInt(sParam1, 100));
        HeroObject := GetHeroObjectA;
        if HeroObject = nil then
          Exit;
        HeroObject.AddBodyLuck(Str_ToInt(sParam1, 100));
        m_DefMsg := MakeDefaultMsg(SM_HERONAME, Integer(HeroObject), GetCharColor(HeroObject), 0, 0);
        SendHeroLoyalty();
        //SysMsg('µ±Ç°Ó¢ÐÛÖÒ³Ï¶È: ' + FormatFloat('###00.00%', HeroObject.m_dBodyLuck / 250), c_Blue, t_Hint);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.HUNGER.sCmd) = 0 then
      begin
        CmdHunger(g_GameCommand.HUNGER.sCmd, sParam1, Str_ToInt(sParam2, 0));
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.SETFLAG.sCmd) = 0 then
      begin //004D3BDD
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestFlagStatus(nFlag, nValue);
          if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint)
          else
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
        end
        else
          SysMsg('@' + g_GameCommand.SETFLAG.sCmd + ' ÈËÎïÃû³Æ ±êÖ¾ºÅ Êý×Ö(0 - 1)', c_Red, t_Hint);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.SETOPEN.sCmd) = 0 then
      begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitOpenStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint)
          else
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
        end
        else
          SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' ÈËÎïÃû³Æ ±êÖ¾ºÅ Êý×Ö(0 - 1)', c_Red, t_Hint);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.SETUNIT.sCmd) = 0 then
      begin
        PlayObject := UserEngine.GetPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitStatus(nFlag) = 1 then
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green, t_Hint)
          else
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green, t_Hint);
        end
        else
          SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' ÈËÎïÃû³Æ ±êÖ¾ºÅ Êý×Ö(0 - 1)', c_Red, t_Hint);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.RECONNECTION.sCmd) = 0 then
      begin
        CmdReconnection(sCmd, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.DISABLEFILTER.sCmd) = 0 then
      begin
        CmdDisableFilter(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGUSERFULL.sCmd) = 0 then
      begin
        CmdChangeUserFull(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then
      begin
        CmdChangeZenFastStep(sCmd, sParam1);
        Exit;
      end;
      if CompareText(sCmd, g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then
      begin
        CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd, sParam1, sParam2, sParam3);
        Exit;
      end;
      if (m_btPermission >= 5) or (g_Config.boTestServer) then
      begin
        if (CompareText(sCmd, 'GetUserHWID') = 0) then
        begin
          CmdHWID(sCmd, sParam1, 0);
          Exit;
        end;
        if (CompareText(sCmd, 'BlockUserHWID') = 0) then
        begin
          CmdHWID(sCmd, sParam1, 1);
          Exit;
        end;
        if (CompareText(sCmd, 'ClearHWIDList') = 0) then
        begin
          CmdHWID(sCmd, sParam1, 2);
          Exit;
        end;

        if CompareText(sCmd, 'tse') = 0 then
        begin
          SendRefMsg(RM_SUQHIT, m_btDirection, m_nCurrX, m_nCurrY, Str_ToInt(sParam1, 15), '');
          Exit;
        end;

        if CompareText(sCmd, g_GameCommand.FIREBURN.sCmd) = 0 then
        begin
          CmdFireBurn(Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTFIRE.sCmd) = 0 then
        begin
          CmdTestFire(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.TESTSTATUS.sCmd) = 0 then
        begin
          CmdTestStatus(sCmd, Str_ToInt(sParam1, -1), Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DELGAMEGOLD.sCmd) = 0 then
        begin
          CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then
        begin
          CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          Exit;
        end;
        {if CompareText(sCmd, g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then begin
          Exit;
        end;}
        if CompareText(sCmd, g_GameCommand.RELOADADMIN.sCmd) = 0 then
        begin
          CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ReLoadNpc.sCmd) = 0 then
        begin
          CmdReloadNpc(sParam1);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMANAGE.sCmd) = 0 then
        begin
          CmdReloadManage(@g_GameCommand.RELOADMANAGE, sParam1);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then
        begin
          CmdReloadRobotManage();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADROBOT.sCmd) = 0 then
        begin
          CmdReloadRobot();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONITEMS.sCmd) = 0 then
        begin
          CmdReloadMonItems();
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADDIARY.sCmd) = 0 then
        begin
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADITEMDB.sCmd) = 0 then
        begin
          FrmDB.LoadItemsDB();
          SysMsg('ÎïÆ·Êý¾Ý¿âÖØÐÂ¼ÓÔØÍê³É', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMAGICDB.sCmd) = 0 then
        begin
          FrmDB.LoadMagicDB();
          SysMsg('Ä§·¨Êý¾Ý¿âÖØÐÂ¼ÓÔØÍê³É', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then
        begin
          FrmDB.LoadMonsterDB();
          SysMsg('¹ÖÎïÊý¾Ý¿âÖØÐÂ¼ÓÔØÍê³É', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.RELOADMINMAP.sCmd) = 0 then
        begin
          FrmDB.LoadMinMap();
          g_MapManager.ReSetMinMap();
          SysMsg('Ð¡µØÍ¼ÅäÖÃÖØÐÂ¼ÓÔØÍê³É', c_Green, t_Hint);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then
        begin
          CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL, sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
        if CompareText(sCmd, 'IPLevel') = 0 then
        begin
          CmdAdjuestIPLevel(sParam1, Str_ToInt(sParam2, 1));
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.ADJUESTEXP.sCmd) = 0 then
        begin
          CmdAdjuestExp(@g_GameCommand.ADJUESTEXP, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.AddGuild.sCmd) = 0 then
        begin
          CmdAddGuild(@g_GameCommand.AddGuild, sParam1, sParam2);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.INITSABUK.sCmd) = 0 then
        begin
          CmdInitSabuk(@g_GameCommand.INITSABUK);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.DelGuild.sCmd) = 0 then
        begin
          CmdDelGuild(@g_GameCommand.DelGuild, sParam1);
          Exit;
        end;
        if (CompareText(sCmd, g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then
        begin
          CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD, sParam1, sParam2, True);
          Exit;
        end;
        if CompareText(sCmd, g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0 then
        begin
          CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR, sParam1);
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.SPIRIT.sCmd) = 0 then
        begin
          CmdSpirtStart(g_GameCommand.SPIRIT.sCmd, sParam1);
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.SPIRITSTOP.sCmd) = 0 then
        begin
          CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd, sParam1);
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.TESTSERVERCONFIG.sCmd) = 0 then
        begin
          SendServerConfig();
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.TESTGETBAGITEM.sCmd) = 0 then
        begin
          CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM, sParam1);
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.MOBFIREBURN.sCmd) = 0 then
        begin
          CmdMobFireBurn(@g_GameCommand.MOBFIREBURN, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6);
          Exit;
        end
        else if CompareText(sCmd, g_GameCommand.TESTSPEEDMODE.sCmd) = 0 then
        begin
          CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
          Exit;
        end
        else if CompareText(sCmd, 'msg') = 0 then
        begin
          m_DefMsg := MakeDefaultMsg(Str_ToInt(sParam1, 0), //Ident
            Str_ToInt(sParam2, 0), //Recog
            Str_ToInt(sParam3, 0), //Param
            Str_ToInt(sParam4, 0), //Tag
            Str_ToInt(sParam5, 0)); //Series
          SendSocket(@m_DefMsg, sParam6);
          Exit;
        end
        else if CompareText(sCmd, 'StallLooks') = 0 then
        begin
          nValue := Str_ToInt(sParam1, 0);
          if not (nValue in [0..2]) then
            nValue := 0;
          if m_StallMgr.StallType <> nValue then
          begin
            m_StallMgr.StallType := nValue;
            if m_StallMgr.OnSale then
            begin
              StallInfo.open := True;
              StallInfo.Name := m_StallMgr.mBlock.StallName;
              StallInfo.Looks := nValue;
              m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
              SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));
              SendRefMsg(RM_STALLSTATUS, m_StallMgr.mBlock.ItemCount, m_nCurrX, m_nCurrY, m_btDirection, '');
            end;
            SysMsg('ÄãµÄÌ¯Î»ÀàÐÍÒÑ¸Ä±ä£¡', c_Red, t_Hint);
          end;
          Exit;
        end
        else if CompareText(sCmd, 'mag') = 0 then
        begin
          if sParam5 = '' then
            SendRefMsg(RM_JOINTATTACK, Str_ToInt(sParam1, 0), m_nCurrX, m_nCurrY, m_btDirection, '')
          else
            SendRefMsg(RM_JOINTATTACK, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), '');
          Exit;
        end
        else if CompareText(sCmd, 'efe') = 0 then
        begin
          SendRefMsg(RM_STRUCKEFFECTEX, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), '');
          Exit;
        end
        else if CompareText(sCmd, 'ShowEffect') = 0 then
        begin
          SendRefMsg(RM_FIREWORKS, 0, Str_ToInt(sParam1, 0), m_nCurrX, m_nCurrY, '');
          Exit;
        end
        else if CompareText(sCmd, 'Appr') = 0 then
        begin
          m_wAppr := Str_ToInt(sParam1, 0);
          FeatureChanged();
          Exit;
        end
        else if CompareText(sCmd, 'Mageff') = 0 then
        begin
          //PlayObject := UserEngine.GetPlayObject('blue01');
          //if PlayObject = nil then
          //  SendRefMsg(RM_HEROSPELL, m_btDirection, m_nCurrX, m_nCurrY, 0, '')
          //else
          SendRefMsg(RM_HEROSPELL, 0, Str_ToInt(sParam1, m_nCurrX), Str_ToInt(sParam2, m_nCurrY), 0, '');
          Exit;
        end
        else if CompareText(sCmd, 'HeroState') = 0 then
        begin
          QueryHeroHeroState();
          Exit;
        end
        else if CompareText(sCmd, 'refbag') = 0 then
        begin
          ClientQueryBagItems();
          Exit;
        end
        else if CompareText(sCmd, 'Eva') = 0 then
        begin
          CmdSetEvaItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
          Exit;
        end

      end;
    end;
    SysMsg('@' + sCmd + ' ´ËÃüÁî²»ÕýÈ·£¬»òÃ»ÓÐ×ã¹»µÄÈ¨ÏÞ£¡', c_Red, t_Hint);
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [sData]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TPlayObject.ProcessSayMsg(sData: string);
var
  n: Integer;
  boDisableSayMsg: Boolean;
  SC, sCryCryMsg, sParam1: string;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject.ProcessSayMsg Msg = %s';
  sTheSafeZoneDisableSyaMsg = '¶Ô²»Æð£¬±¾°²È«Çø²»ÔÊÐíËµ»°ÁÄÌì£¡';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited ProcessSayMsg(sData);
    Exit;
  end;
  try
    if m_PEnvir.m_MapFlag.nSecret and $01 <> 0 then
    begin
      SysMsg('±¾µØÍ¼½ûÖ¹Ëµ»°ÁÄÌì£¡', c_Red, t_Hint);
      Exit;
    end;

    if Length(sData) > g_Config.nSayMsgMaxLen then
      sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);

    if ((GetTickCount - m_dwSayMsgTick) < g_Config.dwSayMsgTime) and (m_btPermission < 5) then
    begin
      Inc(m_nSayMsgCount);
      if m_nSayMsgCount >= g_Config.nSayMsgCount {2} then
      begin
        m_boDisableSayMsg := True;
        m_dwDisableSayMsgTick := GetTickCount + g_Config.dwDisableSayMsgTime {60 * 1000};
        SysMsg(Format(g_sDisableSayMsg, [g_Config.dwDisableSayMsgTime div (60 * 1000)]), c_Red, t_Hint);
      end;
    end
    else
    begin
      m_dwSayMsgTick := GetTickCount();
      m_nSayMsgCount := 0;
    end;
    if GetTickCount >= m_dwDisableSayMsgTick then
      m_boDisableSayMsg := False;
    boDisableSayMsg := m_boDisableSayMsg;

    g_DenySayMsgList.Lock;
    try
      if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then
        boDisableSayMsg := True;
    finally
      g_DenySayMsgList.UnLock;
    end;

    if not boDisableSayMsg then
    begin
      //m_sOldSayMsg := sData;
      if sData[1] = '/' then
      begin
        SC := Copy(sData, 2, Length(sData) - 1);
        if CompareText(Trim(SC), Trim(g_GameCommand.WHO.sCmd)) = 0 then
        begin
          if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then
          begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          n := UserEngine.OfflinePlayCount;
          HearMsg(Format(g_sOnlineCountMsg, [UserEngine.PlayObjectCount, n, (UserEngine.PlayObjectCount - n)]));
          Exit;
        end;
        if CompareText(Trim(SC), Trim(g_GameCommand.TOTAL.sCmd)) = 0 then
        begin
          if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then
          begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            Exit;
          end;
          HearMsg(Format(g_sTotalOnlineCountMsg, [g_nTotalHumCount]));
          Exit;
        end;
        SC := GetValidStr3(SC, sParam1, [' ']);
        if not m_boFilterSendMsg then
          Whisper(sParam1, SC);
        Exit;
      end;
      if sData[1] = '!' then
      begin
        if Length(sData) >= 2 then
        begin
          if sData[2] = '!' then
          begin
            SC := Copy(sData, 3, Length(sData) - 2);
            SendGroupText(m_sCharName + ': ' + SC);
            Exit;
          end;
          if sData[2] = '~' then
          begin
            if m_MyGuild <> nil then
            begin
              SC := Copy(sData, 3, Length(sData) - 2);
              TGuild(m_MyGuild).SendGuildMsg(m_sCharName + ': ' + SC);
              UserEngine.SendInterMsg(ISM_GUILDMSG, g_nServerIndex, TGuild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' + SC);
            end;
            Exit;
          end;
        end;
        if not m_PEnvir.m_MapFlag.boQUIZ then
        begin
          if (GetTickCount - m_dwShoutMsgTick) > 10 * 1000 then
          begin
            if m_Abil.Level <= g_Config.nCanShoutMsgLevel then
            begin
              SysMsg(Format(g_sYouNeedLevelMsg, [g_Config.nCanShoutMsgLevel + 1]), c_Red, t_Hint);
              Exit;
            end;
            m_dwShoutMsgTick := GetTickCount();
            SC := Copy(sData, 2, Length(sData) - 1);
            sCryCryMsg := '(!)' + m_sCharName + ': ' + SC;
            if m_boFilterSendMsg then
              SendMsg(nil, RM_CRY, 0, 0, $FFFF, 0, sCryCryMsg)
            else
              UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, sCryCryMsg);
            Exit;
          end;
          SysMsg(Format(g_sYouCanSendCyCyLaterMsg, [10 - (GetTickCount - m_dwShoutMsgTick) div 1000]), c_Red, t_Hint);
          Exit;
        end;
        SysMsg(g_sThisMapDisableSendCyCyMsg {'±¾µØÍ¼²»ÔÊÐíº°»°'}, c_Red, t_Hint);
        Exit;
      end;
      if m_boFilterSendMsg then //Èç¹û½ûÖ¹·¢ÐÅÏ¢£¬ÔòÖ»Ïò×Ô¼º·¢ÐÅÏ¢ Ä§·¨×ÖÌå
        SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, {MakeWord(m_btChatColor, m_btChatFont)} 0, m_sCharName + ':' + sData)
      else
        inherited;
      Exit;
    end;
    SysMsg(g_sYouIsDisableSendMsg {'½ûÖ¹ÁÄÌì'}, c_Red, t_Hint);
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [sData]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean; //004CB7F8
var
  n14, n18: Integer;
  StdItem: pTStdItem;
  dwAttackTime, dwCheckTime: LongWord;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ClientHitXY';
begin
  Result := False;
  dwDelayTime := 0;
  try
    if not m_boCanHit or m_StallMgr.OnSale or m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanHit) then
      Exit;
{$IF SERIESSKILL}
    if GetTickCount() - m_dwCanNextMoveTick < 100 then
      Exit; //750
{$IFEND SERIESSKILL}
    if not g_Config.boSpeedHackCheck then
      if not boLateDelivery then
      begin
        if (wIdent <> CM_SMITEHIT) and
          (wIdent <> CM_SMITELONGHIT) and
          (wIdent <> CM_SMITELONGHIT2) and
          (wIdent <> CM_SMITELONGHIT3) and
          (wIdent <> CM_SMITEWIDEHIT) and
          (wIdent <> CM_SMITEWIDEHIT2) then
        begin
          if not CheckActionStatus(wIdent, dwDelayTime) then
          begin
            m_boFilterAction := False;
            Exit;
          end;
          m_boFilterAction := True;
          dwAttackTime := _MAX(0, Integer(g_Config.dwHitIntervalTime) - m_nHitSpeed * g_Config.ClientConf.btItemSpeed); //·ÀÖ¹¸ºÊý³ö´í
          dwCheckTime := GetTickCount - m_dwAttackTick;
          if g_Config.boDisableDoubleAttack and (dwCheckTime < g_Config.nDoubleAttackCheck) then
            Exit;
          if dwCheckTime < dwAttackTime then
          begin
            Inc(m_dwAttackCount);
            dwDelayTime := dwAttackTime - dwCheckTime;
            if dwDelayTime > g_Config.dwDropOverSpeed then
            begin
              if m_dwAttackCount >= 4 then
              begin
                m_dwAttackTick := GetTickCount();
                m_dwAttackCount := 0;
                dwDelayTime := g_Config.dwDropOverSpeed;
                if m_boTestSpeedMode then
                  SysMsg('¹¥»÷Ã¦¸´Î»' + IntToStr(dwDelayTime), c_Red, t_Hint);
              end
              else
                m_dwAttackCount := 0;
              Exit;
            end
            else
            begin
              if m_boTestSpeedMode then
                SysMsg('¹¥»÷²½Ã¦' + IntToStr(dwDelayTime), c_Red, t_Hint);
              Exit;
            end;
          end;
        end;
      end;
    if (nX = m_nCurrX) and (nY = m_nCurrY) then
    begin
      Result := True;
      m_dwAttackTick := GetTickCount();

      if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then
      begin
        if GetFrontPosition(n14, n18) and not m_PEnvir.CanWalk(n14, n18, False) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if (StdItem <> nil) and (StdItem.Shape = 19) then
          begin
            if PileStones(n14, n18) then
            begin
{$IF VER_ClientType_45}
              if m_wClientType in [45, 46] then
{$IFEND VER_ClientType_45}
                SendSocket(nil, '+DIG')
{$IF VER_ClientType_45}
              else
                SendSocket(nil, '=DIG');
{$IFEND VER_ClientType_45}
            end;
            Dec(m_nHealthTick, 30);
            Dec(m_nSpellTick, 50);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth, 2);
            Dec(m_nPerSpell, 2);
            Exit;
          end;
        end;
      end;

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
      if (UserEngine.m_PlayObjectList.Count > 10) then
      begin
        m_boEmergencyClose := True;
        Exit;
      end;
{$IFEND}
      if wIdent = CM_HIT then
        AttackDir(nil, 0, nDir)
      else if wIdent = CM_HEAVYHIT then
        AttackDir(nil, 1, nDir)
      else if wIdent = CM_BIGHIT then
        AttackDir(nil, 2, nDir)
      else if wIdent = CM_POWERHIT then
        AttackDir(nil, 3, nDir)
      else if wIdent = CM_LONGHIT then
        AttackDir(nil, 4, nDir)
      else if wIdent = CM_WIDEHIT then
        AttackDir(nil, 5, nDir)
      else if wIdent = CM_FIREHIT then
      begin
          AttackDir(nil, 7, nDir);
      end
      else if wIdent = CM_CRSHIT then
        AttackDir(nil, 8, nDir)
      else if wIdent = CM_TWNHIT then
        AttackDir(nil, 9, nDir)
      else if wIdent = CM_SQUHIT then
        AttackDir(nil, 10, nDir)
      else if wIdent = CM_HERO_LONGHIT2 then
        AttackDir(nil, 12, nDir)
      else
      begin
        if wIdent = CM_PURSUEHIT then
          AttackDir(nil, 13, nDir)
        else if wIdent = CM_SMITEHIT then
          AttackDir(nil, 20, nDir)
        else if wIdent = CM_SMITELONGHIT then
          AttackDir(nil, 21, nDir)
        else if wIdent = CM_SMITELONGHIT2 then
          AttackDir(nil, 24, nDir)
        else if wIdent = CM_SMITEWIDEHIT then
          AttackDir(nil, 22, nDir)
        else if wIdent = CM_SMITEWIDEHIT2 then
          AttackDir(nil, 23, nDir)
        else if wIdent = CM_SMITELONGHIT3 then
          AttackDir(nil, 25, nDir);
      end;

      if (m_MagicArr[0][SKILL_YEDO] <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then
      begin
        Dec(m_btAttackSkillCount);
        if m_btAttackSkillPointCount = m_btAttackSkillCount then
        begin
          m_boPowerHit := True;
          SendSocket(nil, '+PWR');
        end;
        if m_btAttackSkillCount <= 0 then
        begin
          m_btAttackSkillCount := 7 - m_MagicArr[0][SKILL_YEDO].btLevel mod 4;
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
        end;
      end;
      Dec(m_nHealthTick, 30);
      Dec(m_nSpellTick, 100);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth, 2);
      Dec(m_nPerSpell, 2);
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanRun or m_StallMgr.OnSale or m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not g_Config.ClientConf.boParalyCanRun) then
    Exit;

{$IF SERIESSKILL}
  if GetTickCount() - m_dwCanNextMoveTick < 100 then
    Exit;
{$IFEND SERIESSKILL}
  if not g_Config.boSpeedHackCheck then
    if not boLateDelivery then
    begin
      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMoveTick;
      if dwCheckTime < g_Config.dwRunIntervalTime then
      begin
        Inc(m_dwMoveCount);
        dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
        if dwDelayTime > g_Config.dwDropOverSpeed then
        begin
          if m_dwMoveCount >= 4 then
          begin
            m_dwMoveTick := GetTickCount();
            m_dwMoveCount := 0;
            dwDelayTime := g_Config.dwDropOverSpeed;
            if m_boTestSpeedMode then
              SysMsg('ÂíÅÜ²½Ã¦¸´Î»' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end
          else
            m_dwMoveCount := 0;
          Exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('ÂíÅÜ²½Ã¦' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;

  m_dwMoveTick := GetTickCount();
  m_boHealthCrc := False;
{$IF DEBUG = 1}
  //SysMsg(format('µ±Ç°X:%d µ±Ç°Y:%d Ä¿±êX:%d Ä¿±êY:%d', [m_nCurrX, m_nCurrY, nX, nY]), c_Green, t_Hint);
{$IFEND}
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if HorseRunTo(n14, False) then
  begin
    if m_boTransparent and (m_boHideMode) then
      m_wStatusTimeArr[STATE_TRANSPARENT {0 0x70}] := 1; //004CB212

    if m_boHealthCrc or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end
  else
    m_dwMoveCount := 0;
end;

function TPlayObject.ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer;
  TargeTBaseObject: TBaseObject; boLateDelivery: Boolean;
  var dwDelayTime: LongWord; var IswarrSkill: Boolean): Boolean; //004CBCEC

  function IsNotAllowUseMag(PlayObject: TPlayObject; cMag: pTMagic): Boolean;
  var
    i: Integer;
  resourcestring
    sNotAllowUseMag = '±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃ%s';
  begin
    Result := False;
    if (PlayObject.m_PEnvir <> nil) and (PlayObject.m_PEnvir.m_MapFlag.boNotAllowUseMag) then
    begin
      if PlayObject.m_PEnvir.m_MapFlag.sNotAllowUseMag <> nil then
      begin
        for i := 0 to PlayObject.m_PEnvir.m_MapFlag.sNotAllowUseMag.Count - 1 do
        begin
          if cMag.wMagicId = Integer(PlayObject.m_PEnvir.m_MapFlag.sNotAllowUseMag[i]) then
          begin
            PlayObject.SysMsg(Format(sNotAllowUseMag, [cMag.sMagicName]), c_Purple, t_Hint);
            Result := True;
            Break;
          end;
        end;
      end;
    end;
  end;

var
  UserMagic: pTUserMagic;
  nSpellPoint: Integer;
  n14: Integer;
  BaseObject: TBaseObject;
  dwCheckTime: LongWord;
  boTrainOk, boIsWarrSkill: Boolean;
label
  labmagic;
begin
  Result := False;
  dwDelayTime := 0;

  IswarrSkill := True;

  if not (nKey in [1..255]) then
    Exit;
  UserMagic := m_MagicArr[0][nKey];
  if UserMagic = nil then
    Exit;

  if UserMagic.wMagIdx in [68, 78] then
  begin
    //Âé±Ô×´Ì¬¿ÉÒÔÊ¹ÓÃ
    if not m_boCanSpell or m_StallMgr.OnSale or m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) then
      Exit;
  end
  else if m_boTDBeffect or
    not m_boCanSpell or
    m_StallMgr.OnSale or
    m_boDeath or
    (m_wStatusTimeArr[POISON_PURPLE] <> 0) or
    ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanSpell) then
    Exit;

{$IF SERIESSKILL}
  if nKey in [100..111] then
  begin
    if (m_btReadySeriesSkill <> 2) or (m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax) then
    begin
      //
      Exit;
    end;
  end;
{$IFEND SERIESSKILL}

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
  if (UserEngine.m_PlayObjectList.Count > 10) then
  begin
    m_boEmergencyClose := True;
    Exit;
  end;
{$IFEND}

  if IsNotAllowUseMag(Self, UserMagic.MagicInfo) then
  begin
    SendMsg(Self, RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
    Exit;
  end;

  boIsWarrSkill := MagicManager.IsWarrSkill(UserMagic.wMagIdx);
  IswarrSkill := boIsWarrSkill;
  if not boLateDelivery and not boIsWarrSkill and not g_Config.boSpeedHackCheck then
  begin
    if not (nKey in [100..111]) then
    begin
      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        Exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMagicAttackTick;
      if dwCheckTime < m_dwMagicAttackInterval then
      begin
        Inc(m_dwMagicAttackCount);
        dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
        if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then
        begin
          if m_dwMagicAttackCount >= 4 then
          begin
            m_dwMagicAttackTick := GetTickCount();
            m_dwMagicAttackCount := 0;
            dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
            if m_boTestSpeedMode then
              SysMsg('Ä§·¨Ã¦¸´Î»' + IntToStr(dwDelayTime), c_Red, t_Hint);
          end
          else
            m_dwMagicAttackCount := 0;
          Exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('Ä§·¨Ã¦' + IntToStr(dwDelayTime), c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
  end;

  Dec(m_nSpellTick, 450);
  m_nSpellTick := _MAX(0, m_nSpellTick);

  if not boIsWarrSkill then
    m_dwMagicAttackInterval := UserMagic.MagicInfo.dwDelayTime + g_Config.dwMagicHitIntervalTime;

  m_dwMagicAttackTick := GetTickCount();
  case UserMagic.wMagIdx of
    SKILL_ERGUM {12}:
      begin //´ÌÉ±½£·¨
        if m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil then
        begin
          if not m_boUseThrusting then
          begin
            ThrustingOnOff(True);
            SendSocket(nil, '+LNG');
          end
          else
          begin
            ThrustingOnOff(False);
            SendSocket(nil, '+ULNG');
          end;
        end;
        Result := True;
      end;
    SKILL_BANWOL {25}:
      begin //°ëÔÂÍäµ¶
        if m_MagicArr[0][SKILL_BANWOL] <> nil then
        begin
          if not m_boUseHalfMoon then
          begin
            HalfMoonOnOff(True);
            SendSocket(nil, '+WID');
          end
          else
          begin
            HalfMoonOnOff(False);
            SendSocket(nil, '+UWID');
          end;
        end;
        Result := True;
      end;
    SKILL_FIRESWORD {26}:
      begin //ÁÒ»ð½£·¨
        if m_MagicArr[0][SKILL_FIRESWORD] {m_MagicFireSwordSkill} <> nil then
        begin
          if AllowFireHitSkill() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+FIR');
            end;
          end;
        end;
        Result := True;
      end;
    SKILL_MOOTEBO {27}:
      begin //Ò°Âù³å×²
        Result := True;
        if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then
        begin
          m_dwDoMotaeboTick := GetTickCount();
          if not (nTargetX in [0..7]) then
            Exit;
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_WAbil.MP >= nSpellPoint then
          begin
            if nSpellPoint > 0 then
            begin
              DamageSpell(nSpellPoint);
              HealthSpellChanged();
            end;
            if DoMotaebo(m_btDirection, _MIN(4, UserMagic.btLevel)) then
            begin
              if UserMagic.btLevel < UserMagic.MagicInfo.btTrainLv then
              begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= m_Abil.Level then
                begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then
                  begin
                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end; //004CC1B5
      end;
    66:
      begin //¿ªÌìÕ¶
        if m_MagicArr[0][66] <> nil then
        begin
          if AllowSquHitSkill() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+SLON');
            end;
          end;
        end;
        Result := True;
      end;

    113:
      begin
        if m_MagicArr[0][113] <> nil then
        begin
          if AllowSmiteLongSkill2() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+SMIL2');
            end;
          end;
        end;
        Result := True;
      end;
    114:
      begin
        if m_MagicArr[0][114] <> nil then
        begin
          if AllowSmiteWideSkill2() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            //0821
            if g_Config.boSkill_114_MP then
            begin
              if m_WAbil.MP >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil, '+SMIW2');
              end;
            end
            else
            begin
              if m_nInPowerPoint >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  Dec(m_nInPowerPoint, nSpellPoint);
                  TPlayObject(Self).InternalPowerPointChanged(True);
                end;
                SendSocket(nil, '+SMIW2');
              end;
            end;
          end;
        end;
        Result := True;
      end;
    115:
      begin
        if m_MagicArr[0][115] <> nil then
        begin
          if AllowSmiteLongSkill3() then
          begin
            //nSpellPoint := GetSpellPoint(UserMagic);
            //if m_WAbil.MP >= nSpellPoint then begin
            //if nSpellPoint > 0 then begin
            //  DamageSpell(nSpellPoint);
            //  HealthSpellChanged();
            //end;
            SendSocket(nil, '+SMIL3');
            //end;
          end;
        end;
        Result := True;
      end;
    68, 78:
      begin
        if not AllowSuperSkill68() then
          Exit
        else
        begin
          goto labmagic;
        end;
      end;
    116, 117: if not AllowSuperSkill3() then
        Exit
      else
        goto labmagic;
    76: if not AllowSkill_MedusaEye() then
        Exit
      else
        goto labmagic;
    77: if not AllowSuperSkill77() then
        Exit
      else
        goto labmagic;
{$IF SERIESSKILL}
    ///////////////////////////////////////////////////////////////////////////
    100: if m_nInPowerLevel > 0 then
      begin
        Result := True;
        if m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId = UserMagic.wMagIdx then
        begin
          //m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId := 0;

          //if (GetTickCount - m_dwDoMotaeboTick) > 1 * 1000 then begin
          m_dwDoMotaeboTick := GetTickCount();
          if not (nTargetX in [0..7]) then
            Exit;
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_nInPowerPoint >= nSpellPoint then
          begin
            if nSpellPoint > 0 then
            begin
              Dec(m_nInPowerPoint, nSpellPoint);
              TPlayObject(Self).InternalPowerPointChanged(True);
            end;
            if DoMotaeboEx(m_btDirection, _MIN(5, UserMagic.btLevel)) then
            begin
              if UserMagic.btLevel < MagicMaxTrainLevel(UserMagic) then
              begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= m_nInPowerLevel then
                begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then
                  begin
                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
            Inc(m_btSeriesSkillSetpCur);
            if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
            begin
              m_btReadySeriesSkill := 0;
            end;
          end;
          //end;
        end;
      end;
    101:
      begin
        if m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId = UserMagic.wMagIdx then
        begin
          //m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId := 0;
          if m_MagicArr[0][101] <> nil then
          begin
            if AllowSmiteSkill() then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_nInPowerPoint >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  Dec(m_nInPowerPoint, nSpellPoint);
                  TPlayObject(Self).InternalPowerPointChanged(True);
                end;
                SendSocket(nil, '+SMI');
                Inc(m_btSeriesSkillSetpCur);
                if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                begin
                  m_btReadySeriesSkill := 0;
                end;
              end;
            end;
          end;
        end;
        Result := True;
      end;
    102:
      begin
        if m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId = UserMagic.wMagIdx then
        begin
          //m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId := 0;
          if m_MagicArr[0][102] <> nil then
          begin
            if AllowSmiteLongSkill() then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_nInPowerPoint >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  Dec(m_nInPowerPoint, nSpellPoint);
                  TPlayObject(Self).InternalPowerPointChanged(True);
                end;
                SendSocket(nil, '+SMIL');
                Inc(m_btSeriesSkillSetpCur);
                if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                begin
                  m_btReadySeriesSkill := 0;
                end;
              end;
            end;
          end;
        end;
        Result := True;
      end;
    103: 
      begin
        if m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId = UserMagic.wMagIdx then
        begin
          //m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId := 0;
          if m_MagicArr[0][103] <> nil then
          begin
            if AllowSmiteWideSkill() then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_nInPowerPoint >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  Dec(m_nInPowerPoint, nSpellPoint);
                  TPlayObject(Self).InternalPowerPointChanged(True);
                end;
                SendSocket(nil, '+SMIW');
                Inc(m_btSeriesSkillSetpCur);
                if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                begin
                  m_btReadySeriesSkill := 0;
                end;
              end;
            end;
          end;
        end;
        Result := True;
      end;
{$IFEND SERIESSKILL}
    SKILL_40:
      begin //Ë«ÁúÕ¶
        if m_MagicArr[0][SKILL_40] {m_MagicCrsSkill} <> nil then
        begin
          if not m_boCrsHitkill then
          begin
            SkillCrsOnOff(True);
            SendSocket(nil, '+CRS');
          end
          else
          begin
            SkillCrsOnOff(False);
            SendSocket(nil, '+UCRS');
          end;
        end;
        Result := True;
      end;
    SKILL_42: 
      begin //ÁúÓ°½£·¨
        if m_MagicArr[0][42] <> nil then
        begin
          if not m_boSquareHit then
          begin
            SkillSquOnOff(True);
            SendSocket(nil, '+SQU');
          end
          else
          begin
            SkillSquOnOff(False);
            SendSocket(nil, '+USQU');
          end;
        end;
        Result := True;
      end;
    SKILL_43: 
      begin //À×öª½£·¨
        if m_MagicArr[0][43] <> nil then
        begin
          if AllowTwinHitSkill() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+TWN');
            end;
          end;
        end;
        Result := True;
      end;
    SKILL_56: 
      begin //ÖðÈÕ½£·¨
        if m_MagicArr[0][56] <> nil then
        begin
          if AllowPursueHitSkill() then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              SendSocket(nil, '+PUR');
            end;
          end;
        end;
        Result := True;
      end;
  else
    begin
      labmagic:
      boIsWarrSkill := (UserMagic.wMagIdx in [104..111]);
      m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
      BaseObject := nil;
      if g_Config.LargeMagicRange or boIsWarrSkill or (Random(3) = 0) then
        n14 := 2
      else
        n14 := 1;
      if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY, n14) then
      begin
        BaseObject := TargeTBaseObject;
        nTargetX := BaseObject.m_nCurrX;
        nTargetY := BaseObject.m_nCurrY;
      end;

      if boIsWarrSkill then
      begin
        if m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId = UserMagic.wMagIdx then
        begin
          //m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId := 0;
          if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject, boTrainOk) then
            SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
          Inc(m_btSeriesSkillSetpCur);
          if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
          begin
            m_btReadySeriesSkill := 0;
          end;
          Result := True;
        end;
        Exit;
      end;

      if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject, boTrainOk) then
        SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
      Result := True;

    end;
  end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
end;

function TPlayObject.ReportEscortPos(): Boolean;
begin
  Result := False;
  if (m_Escort <> nil) and not m_Escort.m_boGhost and not m_Escort.m_boDeath then
  begin
    if (m_PEnvir = m_Escort.m_PEnvir) then
    begin
      if ((abs(m_nCurrX - m_Escort.m_nCurrX) in [1..8]) and (abs(m_nCurrY - m_Escort.m_nCurrY) in [1..8])) then
      begin
        m_dwReportEscortPosTick := 0;
        Exit;
      end;
      if ((abs(m_nCurrX - m_Escort.m_nCurrX) in [12..32]) or (abs(m_nCurrY - m_Escort.m_nCurrY) in [12..32])) then
      begin
        if GetTickCount - m_dwReportEscortPosTick > 60 * 1000 then
        begin
          m_dwReportEscortPosTick := GetTickCount;
          SysMsg(Format('ÄãºÍÑºÔËÖÐµÄ%s¾àÀëÌ«Ô¶ÁË£¡%sÔÚ(%d/%d)', [m_Escort.m_sFCharName, m_Escort.m_sFCharName, m_Escort.m_nCurrX, m_Escort.m_nCurrY]), c_Red, t_Hint);
        end;
      end;
    end;
  end;
end;

function TPlayObject.RunTo(btDir: Byte; boFlag: Boolean; nDestX, nDestY: Integer): Boolean;
var
  nOldX, nOldY: Integer;
  boInSafeZone: Boolean;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::RunTo';
begin
  Result := False;
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    if not (btDir in [0..7]) then
      Exit;
    m_btDirection := btDir;
    boInSafeZone := m_boInSafeZone;

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
    if (UserEngine.m_PlayObjectList.Count > 10) then
    begin
      m_boEmergencyClose := True;
      Exit;
    end;
{$IFEND}
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, True) > 0) then
          begin

            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or (boInSafeZone and
            g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or (boInSafeZone and
            g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, True) > 0) then
          begin

            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True}, Self) or
            (boInSafeZone and g_Config.boSafeZoneRunAll)) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))} then
    begin
      if Walk(RM_RUN) then
      begin
        if m_boTransparent and m_boHideMode then
          m_wStatusTimeArr[STATE_TRANSPARENT] := 1;
        Result := True;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          CheckMapEvent(5, '');
          ReportEscortPos();
        end;
        if g_Config.boHeroRecalcWalkTick and (m_TargetCret <> nil) and m_TargetCret.IsHero and IsProperTarget(m_TargetCret) then
          m_TargetCret.m_dwWalkTick := GetTickCount - m_nWalkSpeed div 2; //m_TargetCret.m_dwWalkTick := 0;
        UpdateViewRange();
      end
      else
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nOldX, nOldY, True) > 0 then
        begin
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
        end
        else
        begin
          MainOutMessageAPI('[Error] TPlayObject::RunTo MovingOBject :' + m_PEnvir.m_sMapFileName + ':' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
        end;

      end;
    end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

function TPlayObject.HorseRunTo(btDir: Byte; boFlag: Boolean): Boolean;
var
  prex, prey: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::HorseRunTo';
begin
  Result := False;

  try
    prex := m_nCurrX;
    prey := m_nCurrY;
    if not (btDir in [0..7]) then
      Exit;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 3, True) > 0) then
          begin

            Dec(m_nCurrY, 3);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 3) and (m_nCurrY > 2) and (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY - 3, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 3) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY + 3, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 3, True) > 0) then
          begin

            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 2) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY + 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY + 3, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 2) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY - 3, g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY - 3, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
    end;
    if (m_nCurrX <> prex) or (m_nCurrY <> prey) then
    begin
      if Walk(RM_HORSERUN) then
      begin
        Result := True;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          TPlayObject(Self).ReportEscortPos();
        end;
        if g_Config.boHeroRecalcWalkTick and (m_TargetCret <> nil) and m_TargetCret.IsHero and IsProperTarget(m_TargetCret) then
          m_TargetCret.m_dwWalkTick := GetTickCount - m_nWalkSpeed div 2; //m_TargetCret.m_dwWalkTick := 0;
        UpdateViewRange();
      end
      else
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, prex, prey, True) > 0 then
        begin
          m_nCurrX := prex;
          m_nCurrY := prey;
        end
        else
        begin
          MainOutMessageAPI('[Error] TPlayObject::HorseRunTo MovingOBject :' + m_PEnvir.m_sMapFileName + ':' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
        end;

      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

function TPlayObject.ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime: LongWord): Boolean; //004CB11C
var
  nDir: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanRun or m_StallMgr.OnSale or m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanRun) then
    Exit;
{$IF SERIESSKILL}
  if GetTickCount() - m_dwCanNextMoveTick < 100 then
    Exit;
{$IFEND SERIESSKILL}
  if (nFlag <> wIdent) and not g_Config.boSpeedHackCheck then
  begin
    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then
    begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwRunIntervalTime div 3 then
      begin
        if m_dwMoveCount >= 4 then
        begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwRunIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('ÅÜ²½Ã¦¸´Î»' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMoveCount := 0;
        Exit;
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('ÅÜ²½Ã¦' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
  if (UserEngine.m_PlayObjectList.Count > 10) then
  begin
    m_boEmergencyClose := True;
    Exit;
  end;
{$IFEND}
  m_dwWalkTick := 0;
  m_dwMoveTick := GetTickCount();
  m_boHealthCrc := False;
  nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if RunTo(nDir, False, nX, nY) then
  begin
    if m_boTransparent and (m_boHideMode) then
      m_wStatusTimeArr[STATE_TRANSPARENT] := 1;
    if m_boHealthCrc or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end
  else
    m_dwMoveCount := 0;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
end;

function TPlayObject.ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean;
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanWalk or m_StallMgr.OnSale then
    Exit;
  if m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not g_Config.ClientConf.boParalyCanWalk) then
    Exit;
{$IF SERIESSKILL}
  if GetTickCount() - m_dwCanNextMoveTick < 100 then
    Exit;
{$IFEND SERIESSKILL}
  if not boLateDelivery and not g_Config.boSpeedHackCheck then
  begin
    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      Exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwWalkIntervalTime then
    begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwWalkIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwWalkIntervalTime div 3 then
      begin
        if m_dwMoveCount >= 4 then
        begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwWalkIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('×ßÂ·Ã¦¸´Î»' + IntToStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMoveCount := 0;
        Exit;
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('×ßÂ·Ã¦' + IntToStr(dwDelayTime), c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
  m_dwWalkTick := 0;
  m_dwMoveTick := GetTickCount();
  m_boHealthCrc := False;
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);

  if WalkTo(n14, False) then
  begin
    if m_boHealthCrc or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 10);
  end
  else
  begin
    m_dwMoveCount := 0;
    //m_dwMoveCountA := 0;
  end;
end;

procedure TPlayObject.ThrustingOnOff(boSwitch: Boolean);
begin
  m_boUseThrusting := boSwitch;
  if m_boUseThrusting then
    SysMsg(sThrustingOn, c_Green, t_Hint)
  else
    SysMsg(sThrustingOff, c_Green, t_Hint);
end;

procedure TPlayObject.HalfMoonOnOff(boSwitch: Boolean);
begin
  m_boUseHalfMoon := boSwitch;
  if m_boUseHalfMoon then
    SysMsg(sHalfMoonOn, c_Green, t_Hint)
  else
    SysMsg(sHalfMoonOff, c_Green, t_Hint);
end;

procedure TPlayObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  m_boCrsHitkill := boSwitch;
  //if m_boCrsHitkill then
  //  SysMsg(sCrsHitOn, c_Green, t_Hint)
  //else
  //  SysMsg(sCrsHitOff, c_Green, t_Hint);
end;

procedure TPlayObject.SkillSquOnOff(boSwitch: Boolean);
begin
  m_boSquareHit := boSwitch;
  {if m_bo42kill then
    SysMsg('¿ªÆô¿ñ·çÕ¶', c_Green, t_Hint)
  else
    SysMsg('¹Ø±Õ¿ñ·çÕ¶', c_Green, t_Hint);}
end;

function TPlayObject.AllowFireHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestFireHitTick) > 10 * 1000 then
  begin
    m_dwLatestFireHitTick := GetTickCount();
    m_boFireHitSkill := True;
    SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
    Result := True;
  end
  else
    //SysMsg(sFireSpiritsFail, c_Red, t_Hint);
end;

function TPlayObject.AllowSquHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestHeroLongHitTick) > 8 * 1000 then
  begin
    m_dwLatestHeroLongHitTick := GetTickCount();
    m_btSquareHit := 2;
    Result := True;
  end
  else
    //SysMsg(sFireSpiritsFail, c_Red, t_Hint);
end;

function TPlayObject.AllowTwinHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestTwinHitTick) > 15 * 1000 then
  begin
    m_dwLatestTwinHitTick := GetTickCount();
    m_boTwinHitSkill := True;
    //SysMsg(sTwinSpiritsSummoned, c_Green, t_Hint);
    Result := True;
  end
  else
    //SysMsg(sTwinSpiritsFail, c_Red, t_Hint);
end;

function TPlayObject.AllowPursueHitSkill(): Boolean;
begin
  Result := False;
  if (GetTickCount - m_dwLatestPursueHitTick) > 10 * 1000 then
  begin
    m_dwLatestPursueHitTick := GetTickCount();
    m_boPursueHitSkill := True;
    SysMsg(sPursueSpiritsSummoned, c_Green, t_Hint);
    Result := True;
  end;
end;
{$IF SERIESSKILL}

function TPlayObject.AllowSmiteSkill(): Boolean;
begin
  Result := False;
  if not m_boSmiteSkill and (GetTickCount - m_dwLatestSmiteTick > 10 * 1000) then
  begin
    m_dwLatestSmiteTick := GetTickCount();
    m_boSmiteSkill := True;
    Result := True;
  end;
end;

function TPlayObject.AllowRushHitSkill(): Boolean;
begin
  Result := False;
  //m_SeriesSkillArr2
  if not m_boRushhitSkill and (m_btReadySeriesSkill = 2) and (GetTickCount - m_dwLatestRushHitTick > 8 * 1000) then
  begin
    m_dwLatestRushHitTick := GetTickCount();
    m_boRushhitSkill := True;
    Result := True;
  end;
end;

function TPlayObject.AllowSmiteLongSkill(): Boolean;
begin
  Result := False;
  if not m_boSmiteLongSkill and (m_btReadySeriesSkill = 2) and ((GetTickCount - m_dwLatestSmiteLongTick) > 8 * 1000) then
  begin
    m_dwLatestSmiteLongTick := GetTickCount();
    m_boSmiteLongSkill := True;
    Result := True;
  end;
end;

function TPlayObject.AllowSmiteLongSkill2(): Boolean;
begin
  Result := False;
  if not m_boSmiteLongSkill2 {and (m_btReadySeriesSkill = 2)} and ((GetTickCount - m_dwLatestSmiteLongTick2) > 10 * 1000) then
  begin
    m_dwLatestSmiteLongTick2 := GetTickCount();
    m_boSmiteLongSkill2 := True;
    Result := True;
  end;
end;

function TPlayObject.AllowSmiteLongSkill3(): Boolean;
var
  HPper: Integer;
begin
  Result := False;
  if not m_boSmiteLongSkill3 then
  begin
    if (GetTickCount - m_dwLatestSmiteLongTick3) >= g_Config.SuperSkillInvTime * 1000 then
    begin
      m_dwLatestSmiteDamageTick := GetTickCount();
      m_dwLatestSmiteLongTick3 := GetTickCount();
      m_boSmiteLongSkill3 := True;
      Result := True;
      Exit;
    end;
    HPper := Round(m_WAbil.HP / m_WAbil.MaxHP * 100);
    if (HPper <= 60) and (HPper >= 10) and (GetTickCount - m_dwLatestSmiteDamageTick >= _MAX(8, (g_Config.SuperSkillInvTime div 2)) * 1000) then
    begin
      m_dwLatestSmiteDamageTick := GetTickCount();
      m_dwLatestSmiteLongTick3 := GetTickCount();
      m_boSmiteLongSkill3 := True;
      m_WAbil.HP := _MAX(1, m_WAbil.HP - Round(m_WAbil.MaxHP / 10));
      HealthSpellChanged();
      Result := True;
      Exit;
    end;
    if m_btRaceServer = RC_PLAYOBJECT then
      SysMsg(Format('%dÃë²ÅÄÜÔÙ´ÎÊ©Õ¹ [Ñª»ê¼¼ÄÜ(Õ½)]', [(g_Config.SuperSkillInvTime * 1000 - GetTickCount + m_dwLatestSmiteLongTick3) div 1000 + 1]), c_Green, t_Hint);
  end;
end;

function TPlayObject.AllowSuperSkill3(): Boolean;
var
  HPper: Integer;
begin
  Result := False;
  if (GetTickCount - m_dwLatestSmiteLongTick3) >= g_Config.SuperSkillInvTime * 1000 then
  begin
    m_dwLatestSmiteDamageTick := GetTickCount();
    m_dwLatestSmiteLongTick3 := GetTickCount();
    Result := True;
    Exit;
  end;
  HPper := Round(m_WAbil.HP / m_WAbil.MaxHP * 100);
  if (HPper <= 60) and (HPper >= 10) and (GetTickCount - m_dwLatestSmiteDamageTick >= _MAX(8, (g_Config.SuperSkillInvTime div 2)) * 1000) then
  begin
    m_dwLatestSmiteDamageTick := GetTickCount();
    m_dwLatestSmiteLongTick3 := GetTickCount();
    m_WAbil.HP := _MAX(1, m_WAbil.HP - Round(m_WAbil.MaxHP / 10));
    HealthSpellChanged();
    Result := True;
    Exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
    SysMsg(Format('%dÃë²ÅÄÜÔÙ´ÎÊ©Õ¹ [Ñª»ê¼¼ÄÜ]', [(g_Config.SuperSkillInvTime * 1000 - GetTickCount + m_dwLatestSmiteLongTick3) div 1000 + 1]), c_Green, t_Hint);
end;

function TPlayObject.AllowSuperSkill68(): Boolean;
var
  dwtime: Integer;
begin
  Result := False;
  //if m_btPermission > 9 then
  //  dwtime := 3 * 1000
  //else
  dwtime := g_Config.nSuperSkill68InvTime * 1000;
  if (GetTickCount - m_dwLatestSkill68Tick) >= dwtime then
  begin
    m_dwLatestSkill68Tick := GetTickCount();
    Result := True;
    Exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
    SysMsg(Format('%dÃë²ÅÄÜÔÙ´ÎÊ©Õ¹¸Ã¼¼ÄÜ', [(dwtime - GetTickCount + m_dwLatestSkill68Tick) div 1000 + 1]), c_Green, t_Hint);
end;

function TPlayObject.AllowSuperSkill77(): Boolean;
var
  dwtime: Integer;
begin
  Result := False;
  //if m_btPermission > 9 then
  //  dwtime := 3 * 1000
  //else
  dwtime := g_Config.Skill77Inv * 1000;
  if (GetTickCount - m_dwLatestSkill77Tick) >= dwtime then
  begin
    m_dwLatestSkill77Tick := GetTickCount();
    Result := True;
    Exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
    SysMsg(Format('%dÃë²ÅÄÜÔÙ´ÎÊ©Õ¹ [ÉñÁú¸½Ìå] ¼¼ÄÜ', [(dwtime - GetTickCount + m_dwLatestSkill77Tick) div 1000 + 1]), c_Green, t_Hint);
end;

function TPlayObject.AllowSkill_MedusaEye(): Boolean;
var
  Castle: TUserCastle;
begin
  Result := False;
  Castle := g_CastleManager.InCastleWarArea(Self);
  if (Castle <> nil) and Castle.m_boUnderWar then
  begin
    SysMsg('¹¥³ÇÇøÓò²»ÔÊÐíÊ¹ÓÃ [ÃÀ¶ÅÉ¯Ö®Í«] ¼¼ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  if (GetTickCount - m_dwLatestMedusaEyeTick) >= 45 * 1000 then
  begin
    m_dwLatestMedusaEyeTick := GetTickCount();
    m_boMedusaEyeHint := False;
    Result := True;
    Exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
    SysMsg(Format('%dÃë²ÅÄÜÔÙ´ÎÊ©Õ¹ [ÃÀ¶ÅÉ¯Ö®Í«] ¼¼ÄÜ', [(45 * 1000 - GetTickCount + m_dwLatestMedusaEyeTick) div 1000 + 1]), c_Green, t_Hint);
end;

function TPlayObject.AllowSmiteWideSkill(): Boolean;
begin
  Result := False;
  if not m_boSmiteWideSkill and (m_btReadySeriesSkill = 2) and ((GetTickCount - m_dwLatestSmiteWideTick) > 8 * 1000) then
  begin
    m_dwLatestSmiteWideTick := GetTickCount();
    m_boSmiteWideSkill := True;
    Result := True;
  end;
end;

function TPlayObject.AllowSmiteWideSkill2(): Boolean;
begin
  Result := False;
  if m_boSmiteWideSkill2 then
  begin
    if GetTickCount - m_dwLatestSmiteWideTick2 < _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000) then
      SysMsg(Format('[ÒÐÌì±ÙµØ] ¼¼ÄÜÀäÈ´Ê±¼ä»¹ÓÐ%dÃë', [((_MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000) - GetTickCount + m_dwLatestSmiteWideTick2) div 1000) + 1]), c_Green, t_Hint);
    Exit;
  end;
  if ((GetTickCount - m_dwLatestSmiteWideTick2) > _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000)) then
  begin
    m_dwLatestSmiteWideTick2 := GetTickCount();
    m_boSmiteWideSkill2 := True;
    Result := True;
  end
  else
  begin
    SysMsg(Format('[ÒÐÌì±ÙµØ] ¼¼ÄÜÀäÈ´Ê±¼ä»¹ÓÐ%dÃë', [((_MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000) - GetTickCount + m_dwLatestSmiteWideTick2) div 1000) + 1]), c_Green, t_Hint);
  end;
end;
{$IFEND SERIESSKILL}

procedure TBaseObject.MapRandomMove(sMapName: string; nInt: Integer);
var
  Envir: TEnvirnoment;
  n10, n14, n18: Integer;
begin
  Envir := g_MapManager.FindMap(sMapName);
  if Envir <> nil then
  begin
    if Envir.m_MapHeader.wHeight < 150 then
    begin
      if Envir.m_MapHeader.wHeight < 30 then
      begin
        n18 := 2;
      end
      else
        n18 := 20;
    end
    else
      n18 := 50;
    n10 := Random(Envir.m_MapHeader.wWidth - n18 - 1) + n18;
    n14 := Random(Envir.m_MapHeader.wHeight - n18 - 1) + n18;
    SpaceMove(sMapName, n10, n14, nInt);
  end;
end;

procedure TPlayObject.ClientClickNPC(Npc: Integer);
var
  i: Integer;
  NormNpc: TNormNpc;
  VisibleBaseObject: pTVisibleBaseObject;
  PlayObject: TPlayObject;
begin
  if GetTickCount - m_dwClickNPCTick <= 500 then
    Exit;
  m_dwClickNPCTick := GetTickCount;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
  if (UserEngine.m_PlayObjectList.Count > 10) then
  begin
    m_boEmergencyClose := True;
    Exit;
  end;
{$IFEND}
  if not m_boCanDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;

  if m_boDeath or m_boGhost or m_StallMgr.OnSale then
    Exit;

  if Npc = 0 then
    Exit;

  if TObject(Npc) = m_LastNPC then
  begin
    NormNpc := TNormNpc(m_LastNPC);
  end
  else
  begin
    NormNpc := UserEngine.FindMerchant(TObject(Npc));
    if NormNpc = nil then
      NormNpc := UserEngine.FindNPC(TObject(Npc));
  end;
  if NormNpc <> nil then
  begin
    m_LastNPC := NormNpc;
    if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and
      (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then
      NormNpc.Click(Self);
    Exit;
  end;

  PlayObject := nil;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    VisibleBaseObject := m_VisibleActors.Items[i];
    if VisibleBaseObject.BaseObject = TObject(Npc) then
    begin
      PlayObject := TPlayObject(VisibleBaseObject.BaseObject);
      Break;
    end;
  end;
  if (PlayObject <> nil) and (PlayObject <> Self) then
  begin
    if ((PlayObject.m_PEnvir = m_PEnvir) and (abs(PlayObject.m_nCurrX - m_nCurrX) <= 15) and (abs(PlayObject.m_nCurrY - m_nCurrY) <= 15)) then
    begin
      if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) and PlayObject.m_StallMgr.OnSale then
      begin
        if (PlayObject.m_boDeath) or (PlayObject.m_boGhost) then
          Exit;
        PlayObject.SendStallItems(Self);
      end;
    end;
  end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPE.inc'}
{$IFEND}
end;

function TBaseObject.AddItemToStorage(UserItem: pTUserItem): Boolean;
var
  nStorageCount: Integer;
begin
  Result := False;
  if g_Config.boExtendStorage then
    nStorageCount := High(TStorageItems) + High(TStorageItemsEx)
  else
    nStorageCount := High(TStorageItems);
  if m_StorageItemList.Count < nStorageCount then
  begin
    m_StorageItemList.Add(UserItem);
    Result := True;
  end;
end;

function TBaseObject.AddItemToBag(UserItem: pTUserItem): Boolean;
begin
  Result := False;
  if m_ItemList.Count < GetMaxBagItem then
  begin
    m_ItemList.Add(UserItem);
    WeightChanged();
    Result := True;
  end;
end;

function TPlayObject.GetRangeHumanCount: Integer;
begin
  Result := UserEngine.GetMapOfRangeHumanCount(m_PEnvir, m_nCurrX, m_nCurrY, 10);
end;

procedure TBaseObject.CheckSkillShowHP(Magic: pTUserMagic);
begin
  if Magic.MagicInfo.wMagicId = 28 then
    if Magic.btLevel >= 2 then
      m_boAbilSeeHealGauge := True;
end;

procedure TPlayObject.GetHomePoint;
var
  i: Integer;
  StartPointInfo: pTStartPointInfo;
begin
  if IsHero then
  begin
    m_sHomeMap := m_Master.m_sHomeMap;
    m_nHomeX := TPlayObject(m_Master).m_nHomeX;
    m_nHomeY := TPlayObject(m_Master).m_nHomeY;
    Exit;
  end;
  if PKLevel >= 2 then
  begin
    m_sHomeMap := g_Config.sRedHomeMap;
    m_nHomeX := g_Config.nRedHomeX;
    m_nHomeY := g_Config.nRedHomeY;
  end
  else
  begin
    for i := 0 to m_CurSafeZoneList.Count - 1 do
    begin
      StartPointInfo := m_CurSafeZoneList[i];
      if (StartPointInfo.Envir = m_PEnvir) then
      begin
        if (abs(m_nCurrX - StartPointInfo.nX) < 50) and (abs(m_nCurrY - StartPointInfo.nY) < 50) then
        begin
          m_sHomeMap := StartPointInfo.sMapName;
          m_nHomeX := StartPointInfo.nX;
          m_nHomeY := StartPointInfo.nY;
          Break;
        end;
      end;
    end;
  end;
end;

function TPlayObject.GetQuestFalgStatus(nFlag: Integer): Integer;
var
  n10, n14: Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TPlayObject.SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
var
  n10, n14: Integer;
  bt15: Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then
  begin
    bt15 := m_QuestFlag[n10];
    if nValue = 0 then
      m_QuestFlag[n10] := (not (128 shr n14)) and (bt15)
    else
      m_QuestFlag[n10] := (128 shr n14) or (bt15);
  end;
end;

function TPlayObject.GetQuestUnitOpenStatus(nFlag: Integer): Integer; //004C159C
var
  n10, n14: Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestUnitOpen[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TPlayObject.SetQuestUnitOpenStatus(nFlag: Integer; nValue: Integer); //004C1614
var
  n10, n14: Integer;
  bt15: Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    bt15 := m_QuestUnitOpen[n10];
    if nValue = 0 then
      m_QuestUnitOpen[n10] := (not (128 shr n14)) and (bt15)
    else
      m_QuestUnitOpen[n10] := (128 shr n14) or (bt15);
  end;
end;

function TPlayObject.GetQuestUnitStatus(nFlag: Integer): Integer; //004C16A8
var
  n10, n14: Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestUnit[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TPlayObject.SetQuestUnitStatus(nFlag: Integer; nValue: Integer); //004C1720
var
  n10, n14: Integer;
  bt15: Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    Exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    bt15 := m_QuestUnit[n10];
    if nValue = 0 then
      m_QuestUnit[n10] := (not (128 shr n14)) and (bt15)
    else
      m_QuestUnit[n10] := (128 shr n14) or (bt15);
  end;
end;

procedure TPlayObject.CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or (sSkillName = '') or (nLevel < 0) or not (nLevel in [0..15]) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ  ¼¼ÄÜÃû³Æ ÐÞÁ¶µÈ¼¶(0-15)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  Magic := UserEngine.FindMagic(sSkillName);
  if Magic = nil then
  begin
    SysMsg(Format('%s ¼¼ÄÜÃû³Æ²»ÕýÈ·', [sSkillName]), c_Red, t_Hint);
    Exit;
  end;

  if PlayObject.IsTrainingSkill(Magic.wMagicId, Magic.btClass) then
  begin
    SysMsg(Format('%s ¼¼ÄÜÒÑÐÞÁ¶¹ýÁË', [sSkillName]), c_Red, t_Hint);
    Exit;
  end;

  Case Magic.wMagicId  of
   114:
    begin
      if (m_btWeaponSkill <> 2) and (m_btSpSkill4 < 100) then
      begin
        SysMsg(Format('´Ë×°±¸²»ÄÜÑ§Ï°%s', [sSkillName]),c_Red, t_Hint);
        Exit;
      end;
    end;
   118:
     begin
        SysMsg(Format('´Ë×°±¸²»ÄÜÑ§Ï°%s', [sSkillName]),c_Red, t_Hint);
        Exit;
     end;
     69:
     begin
       if m_btSpSkill2 < 2 then
       begin
         SysMsg(Format('´Ë×°±¸²»ÄÜÑ§Ï°%s', [sSkillName]),c_Red, t_Hint);
         Exit;
       end;
     end;
     77:
     begin
       if (m_btSkill77 <= 0) and (m_btSpSkill3 < 100) then
       begin
         SysMsg(Format('´Ë×°±¸²»ÄÜÑ§Ï°%s', [sSkillName]),c_Red, t_Hint);
         Exit;
       end;
     end;
     78:
     begin
       if (m_btWeaponSkill <> 3) and (m_btSpSkill1 < 100) then
       begin
         SysMsg(Format('´Ë×°±¸²»ÄÜÑ§Ï°%s', [sSkillName]),c_Red, t_Hint);
         Exit;
       end;
     end;
  end;

  New(UserMagic);
  UserMagic.MagicInfo := Magic;
  UserMagic.wMagIdx := Magic.wMagicId;
  UserMagic.btLevel := _MIN(15, nLevel);
  UserMagic.btKey := 0;
  UserMagic.nTranPoint := 0;
  PlayObject.m_MagicList.Add(UserMagic);
  PlayObject.SendAddMagic(UserMagic);
  PlayObject.RecalcAbilitys;
  SysMsg(Format('%s µÄ %s ¼¼ÄÜÐÞÁ¶³É¹¦', [sHumanName, sSkillName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel: Integer);
var
  i: Integer;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ  ¼¼ÄÜÃû³Æ ÐÞÁ¶µÈ¼¶(0-15)', c_Red, t_Hint);
    Exit;
  end;
  nLevel := _MIN(15, nLevel);
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format('%s²»ÔÚÏß£¬»òÔÚÆäËü·þÎñÆ÷ÉÏ', [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  for i := 0 to PlayObject.m_MagicList.Count - 1 do
  begin
    UserMagic := PlayObject.m_MagicList.Items[i];
    if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
    begin
      UserMagic.btLevel := _MIN(15, nLevel);
      PlayObject.SendMsg(PlayObject, RM_MAGIC_LVEXP, UserMagic.MagicInfo.btClass, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '');
      PlayObject.SysMsg(Format('%sµÄÐÞ¸ÄÁ¶µÈ¼¶Îª%d', [sSkillName, nLevel]), c_Green, t_Hint);
      SysMsg(Format('%sµÄ¼¼ÄÜ%sÐÞÁ¶µÈ¼¶Îª%d', [sHumanName, sSkillName, nLevel]), c_Green, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sHumName = '') or (nPoint <= 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÈËÎïÃû³Æ  ½ð±ÒÊýÁ¿', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if (PlayObject.m_nGameGold + nPoint) < High(Integer) then
      Inc(PlayObject.m_nGameGold, nPoint)
    else
    begin
      nPoint := High(Integer) - PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := High(Integer);
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + 'µÄÓÎÏ·±ÒÒÑÔö¼Ó' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('ÓÎÏ·µã±ÒÔö¼Ó' + IntToStr(nPoint) + '.', c_Green, t_Hint);

    if g_boGameLogGameGold then
      AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          nPoint,
          '+',
          m_sCharName]));
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sHumName = '') or (nPoint <= 0) then
    Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_nGameGold > nPoint then
      Dec(PlayObject.m_nGameGold, nPoint)
    else
    begin
      nPoint := PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + 'µÄÓÎÏ·µãÒÑ¼õÉÙ' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('ÓÎÏ·µãÒÑ¼õÉÙ' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    if g_boGameLogGameGold then
      AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          nPoint,
          '-',
          m_sCharName]));
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then
    Ctr := sCtr[1];
  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGold < 0) or (nGold > High(Integer)) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=':
      begin
        PlayObject.m_nGameGold := nGold;
        PlayObject.SysMsg(Format('ÄãµÄ%sµÈÓÚ%d£¬µ±Ç°ÓµÓÐ%d%s', [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
        SysMsg(Format('%sµÄ%sµÈÓÚ%d£¬µ±Ç°ÓµÓÐ%d%s', [sHumanName, g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
      end;
    '+':
      begin
        Inc(PlayObject.m_nGameGold, nGold);
        PlayObject.SysMsg(Format('ÄãµÄ%sÒÑÔö¼Ó%d£¬µ±Ç°ÓµÓÐ%d%s', [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
        SysMsg(Format('%sµÄ%sÒÑÔö¼Ó%d£¬µ±Ç°ÓµÓÐ%d%s', [sHumanName, g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
      end;
    '-':
      begin
        Dec(PlayObject.m_nGameGold, nGold);
        PlayObject.SysMsg(Format('ÄãµÄ%sÒÑ¼õÉÙ%d£¬µ±Ç°ÓµÓÐ%d%s', [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
        SysMsg(Format('%sµÄ%sÒÑ¼õÉÙ%d£¬µ±Ç°ÓµÓÐ%d%s', [sHumanName, g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
      end;
  end;
  if g_boGameLogGameGold then
  begin
    AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGoldName,
        nGold,
        sCtr[1],
        m_sCharName]));
  end;
  GameGoldChanged();
end;

procedure TPlayObject.CmdGamePoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then
    Ctr := sCtr[1];
  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGamePointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=': PlayObject.m_nGamePoint := nPoint;
    '+': Inc(PlayObject.m_nGamePoint, nPoint);
    '-': Dec(PlayObject.m_nGamePoint, nPoint);
  end;
  if g_boGameLogGamePoint then
  begin
    AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEPOINT,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGamePointName,
        nPoint,
        sCtr[1],
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(Format('(%s) ' + g_sGameCommandGamePointHumanMsg, [sCtr[1], nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
  SysMsg(Format('(%s) ' + g_sGameCommandGamePointGMMsg, [sCtr[1], sHumanName, nPoint, PlayObject.m_nGamePoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdCreditPoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
  nCreditPoint: Integer;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCtr <> '') then
    Ctr := sCtr[1];
  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint
    > High(Byte)) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandCreditPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  case sCtr[1] of
    '=':
      begin
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nPoint;
      end;
    '+':
      begin
        nCreditPoint := PlayObject.m_btCreditPoint + nPoint;
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nCreditPoint;
      end;
    '-':
      begin
        nCreditPoint := PlayObject.m_btCreditPoint - nPoint;
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nCreditPoint;
      end;
  end;
  PlayObject.SysMsg(Format('(%s) ' + g_sGameCommandCreditPointHumanMsg, [sCtr[1], nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
  SysMsg(Format('(%s) ' + g_sGameCommandCreditPointGMMsg, [sCtr[1], sHumanName, nPoint, PlayObject.m_btCreditPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer); //004CD550
var
  PlayObject: TPlayObject;
  nServerIndex: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sHumName = '') or (nCount <= 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ  ½ð±ÒÊýÁ¿', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then
      Inc(PlayObject.m_nGold, nCount)
    else
    begin
      nCount := PlayObject.m_nGoldMax - PlayObject.m_nGold;
      PlayObject.m_nGold := PlayObject.m_nGoldMax;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + 'µÄ½ð±ÒÒÑÔö¼Ó' + IntToStr(nCount) + '.', c_Green, t_Hint);
    if g_boGameLogGold then
      AddGameDataLogAPI('14' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end
  else
  begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
      SysMsg(sHumName + ' ÏÖÔÚ' + IntToStr(nServerIndex) + 'ºÅ·þÎñÆ÷ÉÏ', c_Green, t_Hint)
    else
      //FrontEngine.AddChangeGoldList(m_sCharName, sHumName, nCount);
    //SysMsg(sHumName + ' ÏÖÔÚ²»ÔÚÏß£¬µÈÆäÉÏÏßÊ±½ð±Ò½«×Ô¶¯Ôö¼Ó', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdInitSabuk(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  try
    g_CastleManager.ReInit();
    g_CastleManager.Initialize;
  finally
    MainOutMessageAPI('ÖØÐÂ¼ÓÔØÉ³°Í¿ËÊý¾ÝÍê³É...');
  end;
end;

procedure TPlayObject.CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string); //004CEBA0
var
  Human: TPlayObject;
  boAddState: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if g_nServerIndex <> 0 then
  begin
    SysMsg('Õâ¸öÃüÁîÖ»ÄÜÊ¹ÓÃÔÚÖ÷·þÎñÆ÷ÉÏ', c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or (sGuildChief = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÐÐ»áÃû³Æ ÕÆÃÅÈËÃû³Æ', c_Red, t_Hint);
    Exit;
  end;

  boAddState := False;
  Human := UserEngine.GetPlayObject(sGuildChief);
  if Human = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sGuildChief]), c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.MemberOfGuild(sGuildChief) = nil then
  begin
    if g_GuildManager.AddGuild(sGuildName, sGuildChief) then
    begin
      UserEngine.SendInterMsg(ISM_ADDGUILD, g_nServerIndex, sGuildName + '/' + sGuildChief);
      SysMsg('ÐÐ»áÃû³Æ: ' + sGuildName + ' ÕÆÃÅÈË: ' + sGuildChief, c_Green, t_Hint);
      boAddState := True;
    end
    else
    begin
      SysMsg('ÐÐ»áÃû³Æ: ' + sGuildName + 'Ãû³Æ°üº¬ÌØÊâ×Ö·û»òÕßÒÑ±»×¢²á' , c_Green, t_Hint);
    end;
  end;
  if boAddState then
  begin
    Human.m_MyGuild := TObject(g_GuildManager.MemberOfGuild(Human.m_sCharName));
    if Human.m_MyGuild <> nil then
    begin
      Human.m_sGuildRankName := TGuild(Human.m_MyGuild).GetRankName(Human, Human.m_nGuildRankNo);
      Human.RefShowName();
    end;
  end;
end;

procedure TPlayObject.CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
var
  PlayObject: TPlayObject;
  dwExp: LongWord;
  dwOExp: LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ¾­ÑéÖµ', c_Red, t_Hint);
    Exit;
  end;
  dwExp := Str_ToInt(sExp, 0);

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    dwOExp := PlayObject.m_Abil.Exp;
    PlayObject.m_Abil.Exp := dwExp;
    PlayObject.HasLevelUp();
    SysMsg(sHumanName + ' ¾­Ñéµ÷ÕûÍê³É', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessageAPI('[¾­Ñéµ÷Õû] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(dwOExp) + ' -> ' + IntToStr(PlayObject.m_Abil.Exp) + ')');
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint)
end;

procedure TPlayObject.CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string;
  nLevel: Integer);
var
  PlayObject: TPlayObject;
  nOLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ µÈ¼¶', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp();
    SysMsg(sHumanName + ' µÈ¼¶µ÷ÕûÍê³É', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessageAPI('[µÈ¼¶µ÷Õû] ' + m_sCharName + '(' + PlayObject.m_sCharName
        +
        ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) +
        ')');
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdAdjuestIPLevel(sHumanName: string; nLevel: Integer);
var
  PlayObject: TPlayObject;
  nOLevel: Integer;
begin
  if (m_btPermission < 10) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @IPLevel ÈËÎïÃû³Æ µÈ¼¶', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    nOLevel := PlayObject.m_nInPowerLevel;
    PlayObject.m_nInPowerLevel := _MAX(0, _MIN(MAX_IPLEVEL, nLevel));
    PlayObject.HasLevelUp(True);
    SysMsg(sHumanName + ' ÄÚ¹¦µÈ¼¶µ÷ÕûÍê³É', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessageAPI('[ÄÚ¹¦µÈ¼¶µ÷Õû] ' + m_sCharName + '(' + PlayObject.m_sCharName
        +
        ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_nInPowerLevel) +
        ')');
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer); //004CDDAC
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdBackStep(sCmd: string; nType, nCount: Integer);
begin
  if (m_btPermission < 6) then
    Exit;
  nType := _MIN(nType, 8);
  if nType = 0 then
    CharPushed(GetBackDir(m_btDirection), nCount)
  else
    CharPushed(Random(nType), nCount);
end;

procedure TPlayObject.CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount:
  Integer);
var
  PlayObject: TPlayObject;
  sMsg: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÊôÐÔµãÊý(²»ÊäÈëÎª²é¿´µãÊý)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount > 0) then
  begin
    PlayObject.m_nBonusPoint := nCount;
    PlayObject.SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    Exit;
  end;
  sMsg :=
    Format('Î´·ÖÅäµãÊý:%d ÒÑ·ÖÅäµãÊý:(DC:%d MC:%d SC:%d AC:%d MAC:%d HP:%d MP:%d HIT:%d SPEED:%d)',
    [PlayObject.m_nBonusPoint,
    PlayObject.m_BonusAbil.DC,
      PlayObject.m_BonusAbil.MC,
      PlayObject.m_BonusAbil.SC,
      PlayObject.m_BonusAbil.AC,
      PlayObject.m_BonusAbil.MAC,
      PlayObject.m_BonusAbil.HP,
      PlayObject.m_BonusAbil.MP,
      PlayObject.m_BonusAbil.HIT,
      PlayObject.m_BonusAbil.Speed
      ]);
  SysMsg(Format('%sµÄÊôÐÔµãÊýÎª:%s', [sHumName, sMsg]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd: string; nPermission: Integer;
  sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  m_boAdminMode := boFlag;
  if m_boAdminMode then
    SysMsg(sGameMasterMode, c_Green, t_Hint)
  else
    SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7: string);
begin
  if (m_PEnvir <> nil) and m_PEnvir.m_MapFlag.boNoSwitchAttackMode then
  begin
    SysMsg('µ±Ç°µØÍ¼²»ÄÜ¸ü¸Ä¹¥»÷Ä£Ê½£¡', c_Red, t_Hint);
    Exit;
  end;

  if (nMode >= 0) and (nMode <= 4) then
    m_btAttatckMode := nMode
  else
  begin
    if m_btAttatckMode < HAM_PKATTACK then
      Inc(m_btAttatckMode)
    else
      m_btAttatckMode := HAM_ALL;
  end;
  case m_btAttatckMode of
    HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: È«Ìå¹¥»÷]
    HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: ºÍÆ½¹¥»÷]
    HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: ºÍÆ½¹¥»÷]
    HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //
    HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: ±à×é¹¥»÷]
    HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: ÐÐ»á¹¥»÷]
    HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[¹¥»÷Ä£Ê½: ºìÃû¹¥»÷]
  end;
  SendMsg(Self, RM_ATTACKMODE, 0, 0, 0, 0, '');
end;

procedure TPlayObject.CmdChangeDearName(Cmd: pTGameCmd; sHumanName, sDearName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sDearName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÅäÅ¼Ãû³Æ(Èç¹ûÎª ÎÞ ÔòÇå³ý)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if CompareText(sDearName, 'ÎÞ') = 0 then
    begin
      PlayObject.m_sDearName := '';
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' µÄÅäÅ¼ÃûÇå³ý³É¹¦', c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_sDearName := sDearName;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' µÄÅäÅ¼Ãû¸ü¸Ä³É¹¦', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
var
  PlayObject: TPlayObject;
  nSex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nSex := -1;
  if (sSex = 'Man') or (sSex = 'ÄÐ') or (sSex = '0') then
    nSex := 0;
  if (sSex = 'WoMan') or (sSex = 'Å®') or (sSex = '1') then
    nSex := 1;
  if (sHumanName = '') or (nSex = -1) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÐÔ±ð(ÄÐ¡¢Å®)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_btGender <> nSex then
    begin
      PlayObject.m_btGender := nSex;
      PlayObject.FeatureChanged();
      SysMsg(PlayObject.m_sCharName + ' µÄÐÔ±ðÒÑ¸Ä±ä', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(PlayObject.m_sCharName + ' µÄÐÔ±ðÎ´¸Ä±ä', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg(sHumanName + 'Ã»ÓÐÔÚÏß', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
var
  nMakeIndex, nItemIndex: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÎïÆ·±àºÅ ÎïÆ·IDºÅ ÎïÆ·Ãû³Æ', c_Red, t_Hint);
    Exit;
  end;
  nMakeIndex := Str_ToInt(sMakeIndex, -1);
  nItemIndex := Str_ToInt(sItemIndex, -1);
  if (nMakeIndex <= 0) or (nItemIndex < 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÎïÆ·±àºÅ ÎïÆ·IDºÅ ÎïÆ·Ãû³Æ', c_Red, t_Hint);
    Exit;
  end;
  if ItemUnit.AddCustomItemName(nMakeIndex, nItemIndex, sItemName) then
  begin
    ItemUnit.SaveCustomItemName();
    SysMsg('ÎïÆ·Ãû³ÆÉèÖÃ³É¹¦', c_Green, t_Hint);
    Exit;
  end;
  SysMsg('´ËÎïÆ·£¬ÒÑ¾­ÉèÖÃÁËÆäËüµÄÃû³Æ', c_Red, t_Hint);
end;
// ¹ÜÀíÔ±ÃüÁî¸Ä±äÖ°Òµ
procedure TPlayObject.CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
var
  PlayObject: TPlayObject;
  Jobtemp: Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (sHumanName = '') or (sJobName = '') then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandChangeJobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);

  if PlayObject <> nil then
  begin
    Jobtemp := PlayObject.m_btJob;
    if CompareText(sJobName, 'Warr') = 0 then
      PlayObject.m_btJob := 0;
    if CompareText(sJobName, 'Wizard') = 0 then
      PlayObject.m_btJob := 1;
    if CompareText(sJobName, 'Taos') = 0 then
      PlayObject.m_btJob := 2;
    if Jobtemp = PlayObject.m_btJob then
    begin
      SysMsg('ÃüÁîÓÐÎó»òÓë±¾ÉíÖ°ÒµÏàÍ¬', c_Green, t_Hint);
      exit;
    end;
    PlayObject.HasLevelUp();
    PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg, c_Green, t_Hint);
    SysMsg(Format(g_sGameCommandChangeJobMsg, [sHumanName]), c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
var
  nOLevel: Integer;
  nLevel: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  nLevel := Str_ToInt(sParam1, 1);
  nOLevel := m_Abil.Level;
  m_Abil.Level := _MIN(MAXUPLEVEL, nLevel);
  HasLevelUp();
  if g_Config.boShowMakeItemMsg then
  begin
    MainOutMessageAPI(Format(g_sGameCommandLevelConsoleMsg, [m_sCharName, nOLevel, m_Abil.Level]));
  end;
end;

procedure TPlayObject.CmdChangeMasterName(Cmd: pTGameCmd; sHumanName,
  sMasterName, sIsMaster: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sMasterName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ Ê¦Í½Ãû³Æ(Èç¹ûÎª ÎÞ ÔòÇå³ý)', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if CompareText(sMasterName, 'ÎÞ') = 0 then
    begin
      PlayObject.m_sMasterName := '';
      PlayObject.RefShowName;
      PlayObject.m_boMaster := False;
      SysMsg(sHumanName + ' µÄÊ¦Í½ÃûÇå³ý³É¹¦', c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_sMasterName := sMasterName;
      if (sIsMaster <> '') and (sIsMaster[1] = '1') then
        PlayObject.m_boMaster := True
      else
        PlayObject.m_boMaster := False;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' µÄÊ¦Í½Ãû¸ü¸Ä³É¹¦', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if boFlag then
  begin
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
  end;
  m_boObMode := boFlag;
  if m_boObMode then
    SysMsg(sObserverMode, c_Green, t_Hint)
  else
    SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeSabukLord(Cmd: pTGameCmd; sCASTLENAME, sGuildName: string; boFlag: Boolean);
var
  Guild: TGuild;
  Castle: TUserCastle;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (sCASTLENAME = '') or (sGuildName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ³Ç±¤Ãû³Æ ÐÐ»áÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then
  begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red,
      t_Hint);
    Exit;
  end;

  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    AddGameDataLogAPI('27' + #9 +
      Castle.m_sOwnGuild + #9 +
      '0' + #9 +
      '1' + #9 +
      'sGuildName' + #9 +
      m_sCharName + #9 +
      '0' + #9 +
      '1' + #9 +
      '0');
    Castle.GetCastle(Guild);
    if boFlag then
      UserEngine.SendInterMsg(ISM_CHANGECASTLEOWNER, g_nServerIndex, sGuildName);
    SysMsg(Castle.m_sName + ' ËùÊôÐÐ»áÒÑ¾­¸ü¸ÄÎª ' + sGuildName, c_Green, t_Hint);
  end
  else
  begin
    SysMsg('ÐÐ»á ' + sGuildName + '»¹Ã»½¨Á¢', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeSalveStatus;
var
  b: Boolean;
  Hero: TBaseObject;
begin
  b := False;
  if m_SlaveList.Count > 0 then
  begin
    m_boSlaveRelax := not m_boSlaveRelax;
    if m_boSlaveRelax then
      SysMsg(sPetRest, c_Green, t_Hint)
    else
      SysMsg(sPetAttack, c_Green, t_Hint);
    b := True;
  end;

  Hero := GetHeroObjectA;
  if (Hero <> nil) and (Hero.m_SlaveList.Count > 0) then
  begin
    if b then
      Hero.m_boSlaveRelax := m_boSlaveRelax
    else
      Hero.m_boSlaveRelax := not Hero.m_boSlaveRelax;
    if Hero.m_boSlaveRelax then
      Hero.SysMsg(sPetRest, c_Green, t_Hint)
    else
      Hero.SysMsg(sPetAttack, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeHeroStatus;
var
  HeroObject: TBaseObject;
begin
  HeroObject := GetHeroObjectA;
  if GetHeroObjectA <> nil then
  begin
    if m_boHeroSearchTag then
    begin
      m_boHeroSearchTag := False;
      TAnimalObject(HeroObject).m_nTargetX2 := -1;
      TAnimalObject(HeroObject).m_nTargetY2 := -1;
      m_btHeroRelax := 0;
    end;
    Inc(m_btHeroRelax);
    if m_btHeroRelax > 2 then
      m_btHeroRelax := 0;
    case m_btHeroRelax of
      0: SysMsg(sHeroAttack, c_Blue, t_Hint);
      1: SysMsg(sHeroFolow, c_Blue, t_Hint);
      2: SysMsg(sHeroRest, c_Blue, t_Hint);
    end;

  end;
end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  m_boSuperMan := boFlag;
  if m_boSuperMan then
    SysMsg(sSupermanMode, c_Green, t_Hint)
  else
    SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: string);
var
  nCount: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  nCount := Str_ToInt(sUserCount, -1);
  if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and (sUserCount[1] = '?')) then
  begin
    SysMsg('ÉèÖÃ·þÎñÆ÷×î¸ßÉÏÏßÈËÊý', c_Red, t_Hint);
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÈËÊý', c_Red, t_Hint);
    Exit;
  end;
  g_Config.nUserFull := nCount;
  SysMsg(Format('·þÎñÆ÷ÉÏÏßÈËÊýÏÞÖÆ: %d', [nCount]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: string);
var
  nFastStep: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  nFastStep := Str_ToInt(sFastStep, -1);
  if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and (sFastStep[1] = '?')) then
  begin
    SysMsg('ÉèÖÃ¹ÖÎïÐÐ¶¯ËÙ¶È', c_Red, t_Hint);
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ËÙ¶È', c_Red, t_Hint);
    Exit;
  end;
  g_Config.nZenFastStep := nFastStep;
  SysMsg(Format('¹ÖÎïÐÐ¶¯ËÙ¶È: %d', [nFastStep]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
var
  i: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  DelList := nil;
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, 'ÈËÎïÃû³Æ']), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  for i := 0 to PlayObject.m_ItemList.Count - 1 do
  begin
    UserItem := PlayObject.m_ItemList.Items[i];
    if DelList = nil then
      DelList := TStringList.Create;
    DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
    Dispose(UserItem);
  end;
  PlayObject.m_ItemList.Clear;
  if DelList <> nil then
    PlayObject.SendMsg(PlayObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < nPermission) then
    Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg('Çå³ýÍæ¼ÒµÄ²Ö¿âÃÜÂë', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s ÈËÎïÃû³Æ', [sCmd]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    Exit;
  end;
  PlayObject.m_boPasswordLocked := False;
  PlayObject.m_boUnLockStoragePwd := False;
  PlayObject.m_sStoragePwd := '';
  PlayObject.SysMsg('ÄãµÄ±£»¤ÃÜÂëÒÑ±»Çå³ý', c_Green, t_Hint);
  SysMsg(Format('%sµÄ±£»¤ÃÜÂëÒÑ±»Çå³ý', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);
var
  i, ii: Integer;
  MonList: TList;
  Envir: TEnvirnoment;
  nMonCount: Integer;
  boKillAll: Boolean;
  boKillAllMap: Boolean;
  boNotItem: Boolean;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or (sMonName = '') or (sItems = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' µØÍ¼ºÅ(* ÎªËùÓÐ) ¹ÖÎïÃû³Æ(* ÎªËùÓÐ) µôÎïÆ·(0,1)', c_Red, t_Hint);
    Exit;
  end;
  boKillAll := False;
  boKillAllMap := False;
  boNotItem := True;
  nMonCount := 0;
  Envir := nil;
  if sMonName = '*' then
    boKillAll := True;
  if sMapName = '*' then
    boKillAllMap := True;
  if sItems = '1' then
    boNotItem := False;

  MonList := TList.Create;
  for i := 0 to g_MapManager.Count - 1 do
  begin
{$IF USEHASHLIST = 1}
    //Envir := TEnvirnoment(g_MapManager.Objects[i]);
    Envir := TEnvirnoment(g_MapManager.Values[g_MapManager.Keys[i]]);
{$ELSE}
    Envir := TEnvirnoment(g_MapManager[i]);
{$IFEND}
    if (Envir <> nil) and (boKillAllMap or (CompareText(Envir.m_sMapFileName, sMapName) = 0)) then
    begin
      UserEngine.GetMapMonster(Envir, MonList);
      for ii := 0 to MonList.Count - 1 do
      begin
        BaseObject := TBaseObject(MonList.Items[ii]);
        if BaseObject.m_Master <> nil then
          Continue;
        if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0) then
        begin
          BaseObject.m_boNoItem := boNotItem;
          BaseObject.m_WAbil.HP := 0;
          BaseObject.MakeGhost;
          Inc(nMonCount);
        end;
      end;
    end;
  end;
  MonList.Free;
  if Envir = nil then
  begin
    SysMsg('ÊäÈëµÄµØÍ¼²»´æÔÚ', c_Red, t_Hint);
    Exit;
  end;

  SysMsg('ÒÑÇå³ý¹ÖÎïÊý: ' + IntToStr(nMonCount), c_Red, t_Hint);
end;

procedure TPlayObject.CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ)', c_Red, t_Hint);
    Exit;
  end;
  if sHumanName[1] = '?' then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚÇå³ýÈËÎïµÄÈÎÎñ±êÖ¾', c_Blue, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format('%s²»ÔÚÏß£¬»òÔÚÆäËü·þÎñÆ÷ÉÏ', [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  FillChar(PlayObject.m_QuestFlag, SizeOf(TQuestFlag), #0);
  SysMsg(Format('%sµÄÈÎÎñ±êÖ¾ÒÑ¾­È«²¿ÇåÁã', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
var
  Guild: TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
  begin
    SysMsg('²é¿´ÐÐ»áÕ½µÄµÃ·ÖÊý', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s ÐÐ»áÃû³Æ', [Cmd.sCmd]), c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    SysMsg(Format('%s µÄµÃ·ÖÎª: %d', [sGuildName, Guild.m_nContestPoint]),
      c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format('ÐÐ»á: %s ²»´æÔÚ', [sGuildName]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdStartContest(Cmd: pTGameCmd; sParam1: string);
var
  i, ii: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  s20: string;
  Guild: TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg('¿ªÊ¼ÐÐ»áÕù°ÔÈü', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    Exit;
  end;

  if not m_PEnvir.m_MapFlag.boFIGHT3Zone then
  begin
    SysMsg('´ËÃüÁî²»ÄÜÔÚµ±Ç°µØÍ¼ÖÐÊ¹ÓÃ', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for i := 0 to List10.Count - 1 do
  begin
    PlayObject := TPlayObject(List10.Items[i]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
    begin
      PlayObject.m_nFightZoneDieCount := 0;
      if PlayObject.m_MyGuild = nil then
        Continue;
      bo19 := False;
      for ii := 0 to List14.Count - 1 do
      begin
        PlayObjectA := TPlayObject(List14.Items[ii]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19 := True;
      end;
      if not bo19 then
      begin
        List14.Add(PlayObject.m_MyGuild);
      end;
    end;
  end;
  SysMsg('ÐÐ»áÕù°ÔÈüÒÑ¾­¿ªÊ¼', c_Green, t_Hint);
  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
    g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ÐÐ»áÕ½ÕùÒÑ±¬·¢');
  s20 := '';
  for i := 0 to List14.Count - 1 do
  begin
    Guild := TGuild(List14.Items[i]);
    Guild.StartTeamFight();
    for ii := 0 to List10.Count - 1 do
    begin
      PlayObject := TPlayObject(List10.Items[i]);
      if PlayObject.m_MyGuild = Guild then
      begin
        Guild.AddTeamFightMember(PlayObject.m_sCharName);
      end;
    end;
    s20 := s20 + Guild.sGuildName + ' ';
  end;
  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
    g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, ' -²Î¼ÓµÄÃÅÅÉ:' + s20);
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdEndContest(Cmd: pTGameCmd; sParam1: string); //004CF364
var
  i, ii: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  Guild: TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg('½áÊøÐÐ»áÕù°ÔÈü', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    Exit;
  end;

  if not m_PEnvir.m_MapFlag.boFIGHT3Zone then
  begin
    SysMsg('´ËÃüÁî²»ÄÜÔÚµ±Ç°µØÍ¼ÖÐÊ¹ÓÃ', c_Red, t_Hint);
    Exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for i := 0 to List10.Count - 1 do
  begin
    PlayObject := TPlayObject(List10.Items[i]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
    begin
      if PlayObject.m_MyGuild = nil then
        Continue;
      bo19 := False;
      for ii := 0 to List14.Count - 1 do
      begin
        PlayObjectA := TPlayObject(List14.Items[ii]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19 := True;
      end;
      if not bo19 then
      begin
        List14.Add(PlayObject.m_MyGuild);
      end;
    end;
  end;
  for i := 0 to List14.Count - 1 do
  begin
    Guild := TGuild(List14.Items[i]);
    Guild.EndTeamFight();
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, Format(' - %s ÐÐ»áÕù°ÔÈüÒÑ½áÊø', [Guild.sGuildName]));
  end;
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdChangeHeroMakeSlave();
begin
  case m_btHeroMakeSlave of
    1: SysMsg('[ÔÊÐí·½Ê¿Ó¢ÐÛÕÙ»½÷¼÷Ã]', c_Green, t_Hint);
    2: SysMsg('[ÔÊÐí·½Ê¿Ó¢ÐÛÕÙ»½ÉñÊÞ]', c_Green, t_Hint);
    3: SysMsg('[ÔÊÐí·½Ê¿Ó¢ÐÛÕÙ»½ÔÂÁé]', c_Green, t_Hint);
    4: SysMsg('[ÔÊÐí·¨Ê¦Ó¢ÐÛ³ÖÐø¿ª¶Ü]', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeLongAttack();
var
  i: Integer;
  BaseObject: TBaseObject;
begin
  for i := 0 to m_SlaveList.Count - 1 do
  begin
    BaseObject := TBaseObject(m_SlaveList.Items[i]);
    if BaseObject.m_btRaceServer = RC_HERO then
    begin
      BaseObject.m_boLongAttack := not BaseObject.m_boLongAttack;
      if BaseObject.m_boLongAttack then
        SysMsg('(·ÖÉí ' + BaseObject.m_sCharName + ')ÔÊÐíÊ¹ÓÃ×Ô¶¯´ÌÉ±¡£', c_Green, t_Hint)
      else
        SysMsg('(·ÖÉí ' + BaseObject.m_sCharName + ')½ûÖ¹Ê¹ÓÃ×Ô¶¯´ÌÉ±¡£', c_Green, t_Hint)
    end;
  end;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚÔÊÐí»ò½ûÖ¹±à×é´«ËÍ¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  m_boAllowGroupReCall := not m_boAllowGroupReCall;
  if m_boAllowGroupReCall then
    SysMsg(g_sEnableGroupRecall {'[ÔÊÐíÌìµØºÏÒ»]'}, c_Green, t_Hint)
  else
    SysMsg(g_sDisableGroupRecall {'[½ûÖ¹ÌìµØºÏÒ»]'}, c_Green, t_Hint);
end;

procedure TPlayObject.CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
var
  i: Integer;
  Guild: TGuild;
  sHumanName: string;
  nPoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
  begin
    SysMsg('²é¿´ÐÐ»áÕù°ÔÈü½á¹û', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s ÐÐ»áÃû³Æ', [Cmd.sCmd]), c_Red, t_Hint);
    Exit;
  end;

  if not m_PEnvir.m_MapFlag.boFIGHT3Zone then
  begin
    SysMsg('´ËÃüÁî²»ÄÜÔÚµ±Ç°µØÍ¼ÖÐÊ¹ÓÃ', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
      g_Config.btCryMsgFColor, g_Config.btCryMsgBColor,
      Format(' - %s ÐÐ»áÕù°ÔÈü½á¹û: ', [Guild.sGuildName]));
    for i := 0 to Guild.TeamFightDeadList.Count - 1 do
    begin
      nPoint := Integer(Guild.TeamFightDeadList.Objects[i]);
      sHumanName := Guild.TeamFightDeadList.Strings[i];
      UserEngine.CryCry(RM_CRY,
        m_PEnvir,
        m_nCurrX,
        m_nCurrY,
        1000,
        g_Config.btCryMsgFColor,
        g_Config.btCryMsgBColor,
        Format(' - %s  : %d ·Ö/ËÀÍö%d´Î¡£ ', [sHumanName, HiWord(nPoint),
        LoWord(nPoint)]));
    end;
  end;
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    Format(' - [%s] : %d ·Ö', [Guild.sGuildName, Guild.m_nContestPoint]));
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    '------------------------------------');
end;

procedure TPlayObject.CmdDearRecall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd +
      ' (·òÆÞ´«ËÍ£¬½«¶Ô·½´«ËÍµ½×Ô¼ºÉí±ß£¬¶Ô·½±ØÐëÔÊÐí´«ËÍ¡£)', c_Green, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then
  begin
    SysMsg('ÄãÃ»ÓÐ½á»é', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_MapFlag.boNODEARRECALL then
  begin
    SysMsg('±¾µØÍ¼½ûÖ¹·òÆÞ´«ËÍ', c_Red, t_Hint);
    Exit;
  end;

  if (m_DearHuman = nil) or m_DearHuman.m_boDeath then
  begin
    if m_btGender = 0 then
    begin
      SysMsg('ÄãµÄÀÏÆÅ²»ÔÚÏß', c_Red, t_Hint);
    end
    else
    begin
      SysMsg('ÄãµÄÀÏ¹«²»ÔÚÏß', c_Red, t_Hint);
    end;
    Exit;
  end;
  if GetTickCount - m_dwDearRecallTick < 10000 then
  begin
    SysMsg('ÉÔµÈ»á²ÅÄÜÔÙ´ÎÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  m_dwDearRecallTick := GetTickCount();
  if m_DearHuman.m_boCanDearRecall then
    RecallHuman(m_DearHuman.m_sCharName)
  else
    SysMsg(m_DearHuman.m_sCharName + ' ²»ÔÊÐí´«ËÍ', c_Red, t_Hint);
end;

procedure TPlayObject.CmdMasterRecall(sCmd, sParam: string);
var
  i: Integer;
  MasterHuman: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd +
      ' (Ê¦Í½´«ËÍ£¬Ê¦¸¸¿ÉÒÔ½«Í½µÜ´«ËÍµ½×Ô¼ºÉí±ß£¬Í½µÜ±ØÐëÔÊÐí´«ËÍ¡£)', c_Green,
      t_Hint);
    Exit;
  end;
  if not m_boMaster then
  begin
    SysMsg('Ö»ÄÜÊ¦¸¸²ÅÄÜÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  if m_MasterList.Count = 0 then
  begin
    SysMsg('ÄãµÄÍ½µÜÒ»¸ö¶¼²»ÔÚÏß', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_MapFlag.boNOMASTERRECALL then
  begin
    SysMsg('±¾µØÍ¼½ûÖ¹Ê¦Í½´«ËÍ', c_Red, t_Hint);
    Exit;
  end;
  if GetTickCount - m_dwMasterRecallTick < 10000 then
  begin
    SysMsg('ÉÔµÈ»á²ÅÄÜÔÙ´ÎÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  for i := 0 to m_MasterList.Count - 1 do
  begin
    MasterHuman := TPlayObject(m_MasterList.Items[i]);
    if MasterHuman.m_boCanMasterRecall then
    begin
      RecallHuman(MasterHuman.m_sCharName);
    end
    else
    begin
      SysMsg(MasterHuman.m_sCharName + ' ²»ÔÊÐí´«ËÍ', c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
    PlayObject.m_nBonusPoint := 0;
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp();
    PlayObject.SysMsg('·ÖÅäµãÊýÒÑÇå³ý', c_Red, t_Hint);
    SysMsg(sHumName + ' µÄ·ÖÅäµãÊýÒÑÇå³ý.', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
var
  PlayObject: TPlayObject;
  nLevel: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ µãÊý(Îª¿ÕÔò²é¿´)', c_Red,
      t_Hint);
    Exit;
  end;
  nLevel := Str_ToInt(sLevel, -1);
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    if (nLevel >= 0) and (nLevel <= 255) then
    begin
      PlayObject.m_btReLevel := nLevel;
      PlayObject.RefShowName();
    end;
    SysMsg(sHumanName + ' µÄ×ªÉúµÈ¼¶Îª ' + IntToStr(PlayObject.m_btReLevel),
      c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sHumanName + ' Ã»ÔÚÏßÉÏ', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
  nTotleUsePoint: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    nTotleUsePoint := PlayObject.m_BonusAbil.DC +
      PlayObject.m_BonusAbil.MC +
      PlayObject.m_BonusAbil.SC +
      PlayObject.m_BonusAbil.AC +
      PlayObject.m_BonusAbil.MAC +
      PlayObject.m_BonusAbil.HP +
      PlayObject.m_BonusAbil.MP +
      PlayObject.m_BonusAbil.HIT +
      PlayObject.m_BonusAbil.Speed +
      PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);

    Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp();
    PlayObject.SysMsg('·ÖÅäµãÊýÒÑ¸´Î»', c_Red, t_Hint);
    SysMsg(sHumName + ' µÄ·ÖÅäµãÊýÒÑ¸´Î».', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdSbkDoorControl(sCmd, sParam: string);
begin

end;

procedure TPlayObject.CmdSearchDear(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚ²éÑ¯ÅäÅ¼µ±Ç°ËùÔÚÎ»ÖÃ', c_Red, t_Hint);
    Exit;
  end;
  if m_sDearName = '' then
  begin
    SysMsg(g_sYouAreNotMarryedMsg {'Äã¶¼Ã»½á»é²éÊ²Ã´£¿'}, c_Red, t_Hint);
    Exit;
  end;
  if m_DearHuman = nil then
  begin
    if m_btGender = 0 then
      SysMsg(g_sYourWifeNotOnlineMsg {'ÄãµÄÀÏÆÅ»¹Ã»ÓÐÉÏÏß'}, c_Red, t_Hint)
    else
      SysMsg(g_sYourHusbandNotOnlineMsg {'ÄãµÄÀÏ¹«»¹Ã»ÓÐÉÏÏß'}, c_Red, t_Hint);
    Exit;
  end;

  if m_btGender = 0 then
  begin
    SysMsg(g_sYourWifeNowLocateMsg {'ÄãµÄÀÏÆÅÏÖÔÚÎ»ÓÚ:'}, c_Green, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.m_sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_DearHuman.SysMsg(g_sYourHusbandSearchLocateMsg {'ÄãµÄÀÏ¹«ÕýÔÚÕÒÄã£¬ËûÏÖÔÚÎ»ÓÚ:'}, c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.m_sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(g_sYourHusbandNowLocateMsg {'ÄãµÄÀÏ¹«ÏÖÔÚÎ»ÓÚ:'}, c_Red, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.m_sMapDesc + '(' + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_DearHuman.SysMsg(g_sYourWifeSearchLocateMsg {'ÄãµÄÀÏÆÅÕýÔÚÕÒÄã£¬ËýÏÖÔÚÎ»ÓÚ:'}, c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.m_sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdSearchMaster(sCmd, sParam: string);
var
  i: Integer;
  Human: TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚ²éÑ¯Ê¦Í½µ±Ç°ËùÔÚÎ»ÖÃ', c_Red, t_Hint);
    Exit;
  end;
  if m_sMasterName = '' then
  begin
    SysMsg(g_sYouAreNotMasterMsg, c_Red, t_Hint);
    Exit;
  end;
  if m_boMaster then
  begin
    if m_MasterList.Count <= 0 then
    begin
      SysMsg(g_sYourMasterListNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    SysMsg(g_sYourMasterListNowLocateMsg, c_Green, t_Hint);
    for i := 0 to m_MasterList.Count - 1 do
    begin
      Human := TPlayObject(m_MasterList.Items[i]);
      SysMsg(Human.m_sCharName + ' ' + Human.m_PEnvir.m_sMapDesc + '(' + IntToStr(Human.m_nCurrX) + ':' + IntToStr(Human.m_nCurrY) + ')', c_Green, t_Hint);
      Human.SysMsg(g_sYourMasterSearchLocateMsg, c_Green, t_Hint);
      Human.SysMsg(m_sCharName + ' ' + m_PEnvir.m_sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end
  else
  begin
    if m_MasterHuman = nil then
    begin
      SysMsg(g_sYourMasterNotOnlineMsg, c_Red, t_Hint);
      Exit;
    end;
    SysMsg(g_sYourMasterNowLocateMsg, c_Red, t_Hint);
    SysMsg(m_MasterHuman.m_sCharName + ' ' + m_MasterHuman.m_PEnvir.m_sMapDesc + '(' + IntToStr(m_MasterHuman.m_nCurrX) + ':' + IntToStr(m_MasterHuman.m_nCurrY) + ')', c_Green, t_Hint);
    m_MasterHuman.SysMsg(g_sYourMasterListSearchLocateMsg, c_Green, t_Hint);
    m_MasterHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.m_sMapDesc + '(' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
var
  nPerission: Integer;
  PlayObject: TPlayObject;
resourcestring
  sOutFormatMsg = '[È¨ÏÞµ÷Õû] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nPerission := Str_ToInt(sPermission, 0);
  if (sHumanName = '') or not (nPerission in [0..10]) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ È¨ÏÞµÈ¼¶(0 - 10)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessageAPI(Format(sOutFormatMsg, [m_sCharName, PlayObject.m_sCharName, PlayObject.m_btPermission, nPerission]));
  PlayObject.m_btPermission := nPerission;
  SysMsg(sHumanName + ' µ±Ç°È¨ÏÞÎª: ' + IntToStr(PlayObject.m_btPermission), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShowHumanFlag(sCmd: string; nPermission: Integer;
  sHumanName, sFlag: string);
var
  PlayObject: TPlayObject;
  nFlag: Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandShowHumanFlagHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nFlag := Str_ToInt(sFlag, 0);
  if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
    SysMsg(Format(g_sGameCommandShowHumanFlagONMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint)
  else
    SysMsg(Format(g_sGameCommandShowHumanFlagOFFMsg, [PlayObject.m_sCharName, nFlag]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowHumanUnit(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject: TPlayObject;
  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitStatus(nUnit) = 1 then
  begin
    SysMsg(Format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName,
      nUnit]), c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName,
      nUnit]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject: TPlayObject;
  nUnit: Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitOpenStatus(nUnit) = 1 then
  begin
    SysMsg(Format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName,
      nUnit]), c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName,
      nUnit]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMapInfoMsg, [m_PEnvir.m_sMapFileName, m_PEnvir.m_sMapDesc]), c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandMapInfoSizeMsg, [m_PEnvir.m_MapHeader.wWidth, m_PEnvir.m_MapHeader.wHeight]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sMapName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' µØÍ¼ºÅ', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(sMapName + ' ²»´æÔÚ', c_Red, t_Hint);
    Exit;
  end;
  sMsg := 'µØÍ¼Ä£Ê½: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1,
  sParam2: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sMapName = '') or (sMapMode = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' µØÍ¼ºÅ Ä£Ê½', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(sMapName + ' ²»´æÔÚ', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sMapMode, 'SAFE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boSAFE := True;
    end
    else
    begin
      Envir.m_MapFlag.boSAFE := False;
    end;
  end
  else if CompareText(sMapMode, 'DARK') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boDARK := True;
    end
    else
    begin
      Envir.m_MapFlag.boDARK := False;
    end;
  end
  else if CompareText(sMapMode, 'DARK') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boDARK := True;
    end
    else
    begin
      Envir.m_MapFlag.boDARK := False;
    end;
  end
  else if CompareText(sMapMode, 'FIGHT') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boFIGHTZone := True;
    end
    else
    begin
      Envir.m_MapFlag.boFIGHTZone := False;
    end;
  end
  else if CompareText(sMapMode, 'FIGHT2') = 0 then
  begin
    if (sParam1 <> '') then
      Envir.m_MapFlag.boFIGHT2Zone := True
    else
      Envir.m_MapFlag.boFIGHT2Zone := False;
  end
  else if CompareText(sMapMode, 'FIGHT3') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boFIGHT3Zone := True;
    end
    else
    begin
      Envir.m_MapFlag.boFIGHT3Zone := False;
    end;
  end
  else if CompareText(sMapMode, 'DAY') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boDAY := True;
    end
    else
    begin
      Envir.m_MapFlag.boDAY := False;
    end;
  end
  else if CompareText(sMapMode, 'QUIZ') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boQUIZ := True;
    end
    else
    begin
      Envir.m_MapFlag.boQUIZ := False;
    end;
  end
  else if CompareText(sMapMode, 'NORECONNECT') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNORECONNECT := True;
      Envir.m_MapFlag.sReConnectMap := sParam1;
    end
    else
    begin
      Envir.m_MapFlag.boNORECONNECT := False;
    end;
  end
  else if CompareText(sMapMode, 'MUSIC') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boMUSIC := True;
      Envir.m_MapFlag.nMUSICID := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boMUSIC := False;
    end;
  end
  else if CompareText(sMapMode, 'EXPRATE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boEXPRATE := True;
      Envir.m_MapFlag.nEXPRATE := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boEXPRATE := False;
    end;
  end
  else if CompareText(sMapMode, 'PKWINLEVEL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boPKWINLEVEL := True;
      Envir.m_MapFlag.nPKWINLEVEL := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boPKWINLEVEL := False;
    end;
  end
  else if CompareText(sMapMode, 'PKWINEXP') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boPKWINEXP := True;
      Envir.m_MapFlag.nPKWINEXP := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boPKWINEXP := False;
    end;
  end
  else if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boPKLOSTLEVEL := True;
      Envir.m_MapFlag.nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boPKLOSTLEVEL := False;
    end;
  end
  else if CompareText(sMapMode, 'PKLOSTEXP') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boPKLOSTEXP := True;
      Envir.m_MapFlag.nPKLOSTEXP := Str_ToInt(sParam1, -1);
    end
    else
    begin
      Envir.m_MapFlag.boPKLOSTEXP := False;
    end;
  end
  else if CompareText(sMapMode, 'DECHP') = 0 then
  begin
    if (sParam1 <> '') and (sParam2 <> '') then
    begin
      Envir.m_MapFlag.boDECHP := True;
      Envir.m_MapFlag.nDECHPTIME := Str_ToInt(sParam1, -1);
      Envir.m_MapFlag.nDECHPPOINT := Str_ToInt(sParam2, -1);
    end
    else
    begin
      Envir.m_MapFlag.boDECHP := False;
    end;
  end
  else if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then
  begin
    if (sParam1 <> '') and (sParam2 <> '') then
    begin
      Envir.m_MapFlag.boDECGAMEGOLD := True;
      Envir.m_MapFlag.nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
      Envir.m_MapFlag.nDECGAMEGOLD := Str_ToInt(sParam2, -1);
    end
    else
    begin
      Envir.m_MapFlag.boDECGAMEGOLD := False;
    end;
  end
  else if CompareText(sMapMode, 'INCGAMEGOLD') = 0 then
  begin
    if (sParam1 <> '') and (sParam2 <> '') then
    begin
      Envir.m_MapFlag.boINCGAMEGOLD := True;
      Envir.m_MapFlag.nINCGAMEGOLDTIME := Str_ToInt(sParam1, -1);
      Envir.m_MapFlag.nINCGAMEGOLD := Str_ToInt(sParam2, -1);
    end
    else
    begin
      Envir.m_MapFlag.boINCGAMEGOLD := False;
    end;
  end
  else if CompareText(sMapMode, 'INCGAMEPOINT') = 0 then
  begin
    if (sParam1 <> '') and (sParam2 <> '') then
    begin
      Envir.m_MapFlag.boINCGAMEPOINT := True;
      Envir.m_MapFlag.nINCGAMEPOINTTIME := Str_ToInt(sParam1, -1);
      Envir.m_MapFlag.nINCGAMEPOINT := Str_ToInt(sParam2, -1);
    end
    else
    begin
      Envir.m_MapFlag.boINCGAMEGOLD := False;
    end;
  end
  else if CompareText(sMapMode, 'RUNHUMAN') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boRUNHUMAN := True;
    end
    else
    begin
      Envir.m_MapFlag.boRUNHUMAN := False;
    end;
  end
  else if CompareText(sMapMode, 'RUNMON') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boRUNMON := True;
    end
    else
    begin
      Envir.m_MapFlag.boRUNMON := False;
    end;
  end
  else if CompareText(sMapMode, 'NEEDHOLE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNEEDHOLE := True;
    end
    else
    begin
      Envir.m_MapFlag.boNEEDHOLE := False;
    end;
  end
  else if CompareText(sMapMode, 'NORECALL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNORECALL := True;
    end
    else
    begin
      Envir.m_MapFlag.boNORECALL := False;
    end;
  end
  else if CompareText(sMapMode, 'NOGUILDRECALL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNOGUILDRECALL := True;
    end
    else
    begin
      Envir.m_MapFlag.boNOGUILDRECALL := False;
    end;
  end
  else if CompareText(sMapMode, 'NODEARRECALL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNODEARRECALL := True;
    end
    else
    begin
      Envir.m_MapFlag.boNODEARRECALL := False;
    end;
  end
  else if CompareText(sMapMode, 'NOMASTERRECALL') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNOMASTERRECALL := True;
    end
    else
    begin
      Envir.m_MapFlag.boNOMASTERRECALL := False;
    end;
  end
  else if CompareText(sMapMode, 'NORANDOMMOVE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNORANDOMMOVE := True;
    end
    else
    begin
      Envir.m_MapFlag.boNORANDOMMOVE := False;
    end;
  end
  else if CompareText(sMapMode, 'NODRUG') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNODRUG := True;
    end
    else
    begin
      Envir.m_MapFlag.boNODRUG := False;
    end;
  end
  else if CompareText(sMapMode, 'MINE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boMINE := True;
    end
    else
    begin
      Envir.m_MapFlag.boMINE := False;
    end;
  end
  else if CompareText(sMapMode, 'NOPOSITIONMOVE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_MapFlag.boNOPOSITIONMOVE := True;
    end
    else
    begin
      Envir.m_MapFlag.boNOPOSITIONMOVE := False;
    end;
  end;
  sMsg := 'µØÍ¼Ä£Ê½: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
var
  i: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÎïÆ·Ãû³Æ ÊýÁ¿)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nItemCount := 0;
  for i := PlayObject.m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := PlayObject.m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
    begin
      if StdItem.Overlap >= 1 then
      begin
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('10' + #9 +
            PlayObject.m_sMapName + #9 +
            IntToStr(PlayObject.m_nCurrX) + #9 +
            IntToStr(PlayObject.m_nCurrY) + #9 +
            PlayObject.m_sCharName + #9 +
            sItemName + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            IntToStr(nItemCount) + #9 +
            m_sCharName);

        if UserItem.Dura >= nItemCount then
        begin
          UserItem.Dura := UserItem.Dura - nItemCount;

          if UserItem.Dura <= 0 then
          begin
            PlayObject.SendDelItems(UserItem);
            Dispose(UserItem);
            PlayObject.m_ItemList.Delete(i);
          end
          else
          begin
            PlayObject.SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, StdItem.Name);
          end;
        end
        else
        begin
          PlayObject.SendDelItems(UserItem);
          Dispose(UserItem);
          PlayObject.m_ItemList.Delete(i);
        end;
        Break;

      end
      else
      begin
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('10' + #9 +
            PlayObject.m_sMapName + #9 +
            IntToStr(PlayObject.m_nCurrX) + #9 +
            IntToStr(PlayObject.m_nCurrY) + #9 +
            PlayObject.m_sCharName + #9 +
            sItemName + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            m_sCharName);

        PlayObject.SendDelItems(UserItem);
        Dispose(UserItem);
        PlayObject.m_ItemList.Delete(i);
        Inc(nItemCount);
        if nItemCount >= nCount then
          Break;
      end;

    end;
  end;
end;

procedure TPlayObject.CmdTakeUserItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);
var
  i: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÎïÆ·Ãû³Æ ÊýÁ¿)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  //È¡±³°üÎïÆ·
  nItemCount := 0;
  for i := PlayObject.m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := PlayObject.m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
    begin
      PlayObject.SendDelItems(UserItem);
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
      PlayObject.m_ItemList.Delete(i);
      Inc(nItemCount);
      if nItemCount >= nCount then
        Break;
    end;
  end;

  nItemCount := 0;
  for i := PlayObject.m_StorageItemList.Count - 1 downto 0 do
  begin
    UserItem := PlayObject.m_StorageItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
    begin
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
      PlayObject.m_StorageItemList.Delete(i);
      Inc(nItemCount);
      if nItemCount >= nCount then
        Exit;
    end;
  end;
  //È¡ÉíÉÏ×°±¸
  nItemCount := 0;
  for i := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do
  begin
    if PlayObject.m_UseItems[i].wIndex = 0 then
      Continue;
    StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
    begin
      PlayObject.SendDelItems(@PlayObject.m_UseItems[i]);
      New(UserItem);
      UserItem^ := PlayObject.m_UseItems[i];
      PlayObject.m_UseItems[i].wIndex := 0;
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
      Inc(nItemCount);
      if nItemCount >= nCount then
        Exit;
    end;
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount:
  Integer); //004CD27C
var
  PlayObject: TPlayObject;
  nServerIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or (nCount <= 0) then
    Exit;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_nGold > nCount then
    begin
      Dec(PlayObject.m_nGold, nCount);
    end
    else
    begin
      nCount := PlayObject.m_nGold;
      PlayObject.m_nGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + 'µÄ½ð±ÒÒÑ¼õÉÙ' + IntToStr(nCount) + '.', c_Green, t_Hint);
    //004CD409
    if g_boGameLogGold then
      AddGameDataLogAPI('13' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end
  else
  begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
    begin
      SysMsg(sHumName + 'ÏÖÔÚ' + IntToStr(nServerIndex) + 'ºÅ·þÎñÆ÷ÉÏ', c_Green, t_Hint);
    end
    else
    begin
      //FrontEngine.AddChangeGoldList(m_sCharName, sHumName, -nCount);
      //SysMsg(sHumName + 'ÏÖÔÚ²»ÔÚÏß£¬µÈÆäÉÏÏßÊ±½ð±Ò½«×Ô¶¯¼õÉÙ', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdDelGuild(Cmd: pTGameCmd; sGuildName: string); //004CEDEC
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if g_nServerIndex <> 0 then
  begin
    SysMsg('Ö»ÄÜÔÚÖ÷·þÎñÆ÷ÉÏ²Å¿ÉÒÔÊ¹ÓÃ´ËÃüÁîÉ¾³ýÐÐ»á', c_Red, t_Hint);
    Exit;
  end;
  if sGuildName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÐÐ»áÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  if g_GuildManager.DelGuild(sGuildName) then
  begin
    UserEngine.SendInterMsg(ISM_DELGUILD, g_nServerIndex, sGuildName);
  end
  else
  begin
    SysMsg('Ã»ÕÒµ½' + sGuildName + 'Õâ¸öÐÐ»á', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelNpc(sCmd: string; nPermission: Integer; sParam1:
  string);
var
  BaseObject: TBaseObject;
  i: Integer;
resourcestring
  sDelOK = 'É¾³ýNPC³É¹¦..';
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  BaseObject := GetPoseCreateB();
  if BaseObject <> nil then
  begin
    for i := 0 to UserEngine.m_MerchantList.Count - 1 do
    begin
      if TBaseObject(UserEngine.m_MerchantList.Items[i]) = BaseObject then
      begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.DisappearA();
        SysMsg(sDelOK, c_Red, t_Hint);
        Exit;
      end;
    end;
    for i := 0 to UserEngine.QuestNPCList.Count - 1 do
    begin
      if TBaseObject(UserEngine.QuestNPCList.Items[i]) = BaseObject then
      begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.DisappearA();
        SysMsg(sDelOK, c_Red, t_Hint);
        Exit;
      end;
    end;
  end;
  SysMsg(g_sGameCommandDelNpcMsg, c_Red, t_Hint);
end;

procedure TPlayObject.CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName:
  string);
var
  i: Integer;
  PlayObject: TPlayObject;
  boDelAll: Boolean;
  UserMagic: pTUserMagic;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sSkillName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ¼¼ÄÜÃû³Æ)', c_Red, t_Hint);
    Exit;
  end;
  if CompareText(sSkillName, 'All') = 0 then
    boDelAll := True
  else
    boDelAll := False;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  for i := PlayObject.m_MagicList.Count - 1 downto 0 do
  begin
    UserMagic := PlayObject.m_MagicList.Items[i];
    if boDelAll then
    begin
      Dispose(UserMagic);
      PlayObject.m_MagicList.Delete(i);
    end
    else
    begin
      if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
      begin
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(i);
        PlayObject.SysMsg(Format('¼¼ÄÜ%sÒÑÉ¾³ý', [sSkillName]), c_Green, t_Hint);
        SysMsg(Format('%sµÄ¼¼ÄÜ%sÒÑÉ¾³ý', [sHumanName, sSkillName]), c_Green, t_Hint);
        PlayObject.RecalcAbilitys();
        Break;
      end;
    end;
  end;
  if boDelAll then
    PlayObject.RecalcAbilitys();
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny:
  string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' µÇÂ¼ÕÊºÅ ÊÇ·ñÓÀ¾Ã·â(0,1)', c_Red,
      t_Hint);
    Exit;
  end;
  g_DenyAccountList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyAccountList.AddObject(sAccount, TObject(1));
      SaveDenyAccountList();
      SysMsg(sAccount + 'ÒÑ¼ÓÈë½ûÖ¹µÇÂ¼ÕÊºÅÁÐ±í', c_Green, t_Hint);
    end
    else
    begin
      g_DenyAccountList.AddObject(sAccount, TObject(0));
      SysMsg(sAccount + 'ÒÑ¼ÓÈëÁÙÊ±½ûÖ¹µÇÂ¼ÕÊºÅÁÐ±í', c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny:
  string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÊÇ·ñÓÀ¾Ã·â(0,1)', c_Red,
      t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyChrNameList.AddObject(sCharName, TObject(1));
      SaveDenyChrNameList();
      SysMsg(sCharName + 'ÒÑ¼ÓÈë½ûÖ¹ÈËÎïÁÐ±í', c_Green, t_Hint);
    end
    else
    begin
      g_DenyChrNameList.AddObject(sCharName, TObject(0));
      SysMsg(sCharName + 'ÒÑ¼ÓÈëÁÙÊ±½ûÖ¹ÈËÎïÁÐ±í', c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny:
  string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' IPµØÖ· ÊÇ·ñÓÀ¾Ã·â(0,1)', c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(1));
      SaveDenyIPAddrList();
      SysMsg(sIPaddr + 'ÒÑ¼ÓÈë½ûÖ¹µÇÂ¼IPÁÐ±í', c_Green, t_Hint);
    end
    else
    begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(0));
      SysMsg(sIPaddr + 'ÒÑ¼ÓÈëÁÙÊ±½ûÖ¹µÇÂ¼IPÁÐ±í', c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableFilter(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then
    Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('ÆôÓÃ/½ûÖ¹ÎÄ×Ö¹ýÂË¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  boFilterWord := not boFilterWord;
  if boFilterWord then
  begin
    SysMsg('ÒÑÆôÓÃÎÄ×Ö¹ýÂË', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('ÒÑ½ûÖ¹ÎÄ×Ö¹ýÂË', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  i: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sAccount = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' µÇÂ¼ÕÊºÅ', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyAccountList.Lock;
  try
    for i := 0 to g_DenyAccountList.Count - 1 do
    begin
      if CompareText(sAccount, g_DenyAccountList.Strings[i]) = 0 then
      begin
        if Integer(g_DenyAccountList.Objects[i]) <> 0 then
          SaveDenyAccountList;
        g_DenyAccountList.Delete(i);
        SysMsg(sAccount + 'ÒÑ´Ó½ûÖ¹µÇÂ¼ÕÊºÅÁÐ±íÖÐÉ¾³ý', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
  if not boDelete then
    SysMsg(sAccount + 'Ã»ÓÐ±»½ûÖ¹µÇÂ¼', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  i: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sCharName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyChrNameList.Lock;
  try
    for i := 0 to g_DenyChrNameList.Count - 1 do
    begin
      if CompareText(sCharName, g_DenyChrNameList.Strings[i]) = 0 then
      begin
        if Integer(g_DenyChrNameList.Objects[i]) <> 0 then
          SaveDenyChrNameList;
        g_DenyChrNameList.Delete(i);
        SysMsg(sCharName + 'ÒÑ´Ó½ûÖ¹µÇÂ¼ÈËÎïÁÐ±íÖÐÉ¾³ý', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
  if not boDelete then
    SysMsg(sCharName + 'Ã»ÓÐ±»½ûÖ¹µÇÂ¼', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  i: Integer;
  boDelete: Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sIPaddr = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' IPµØÖ·', c_Red, t_Hint);
    Exit;
  end;
  boDelete := False;
  g_DenyIPAddrList.Lock;
  try
    for i := 0 to g_DenyIPAddrList.Count - 1 do
    begin
      if CompareText(sIPaddr, g_DenyIPAddrList.Strings[i]) = 0 then
      begin
        if Integer(g_DenyIPAddrList.Objects[i]) <> 0 then
          SaveDenyIPAddrList;
        g_DenyIPAddrList.Delete(i);
        SysMsg(sIPaddr + 'ÒÑ´Ó½ûÖ¹µÇÂ¼IPÁÐ±íÖÐÉ¾³ý', c_Green, t_Hint);
        boDelete := True;
        Break;
      end;
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
  if not boDelete then
    SysMsg(sIPaddr + 'Ã»ÓÐ±»½ûÖ¹µÇÂ¼', c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  i: Integer;
begin
  if (m_btPermission < 6) then
    Exit;
  g_DenyAccountList.Lock;
  try
    if g_DenyAccountList.Count <= 0 then
    begin
      SysMsg('½ûÖ¹µÇÂ¼ÕÊºÅÁÐ±íÎª¿Õ', c_Green, t_Hint);
      Exit;
    end;
    for i := 0 to g_DenyAccountList.Count - 1 do
    begin
      SysMsg(g_DenyAccountList.Strings[i], c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
var
  i: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if g_DenyChrNameList.Count <= 0 then
    begin
      SysMsg('½ûÖ¹µÇÂ¼½ÇÉ«ÁÐ±íÎª¿Õ', c_Green, t_Hint);
      Exit;
    end;
    for i := 0 to g_DenyChrNameList.Count - 1 do
    begin
      SysMsg(g_DenyChrNameList.Strings[i], c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  i: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if g_DenyIPAddrList.Count <= 0 then
    begin
      SysMsg('½ûÖ¹µÇÂ¼½ÇÉ«ÁÐ±íÎª¿Õ', c_Green, t_Hint);
      Exit;
    end;
    for i := 0 to g_DenyIPAddrList.Count - 1 do
    begin
      SysMsg(g_DenyIPAddrList.Strings[i], c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_boFilterSendMsg := True;
  end;
  g_DisableSendMsgList.Add(sHumanName);
  SaveDisableSendMsgList();
  SysMsg(sHumanName + ' ÒÑ¼ÓÈë½ûÑÔÁÐ±í', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd: pTGameCmd);
var
  i: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if g_DisableSendMsgList.Count <= 0 then
  begin
    SysMsg('½ûÑÔÁÐ±íÎª¿Õ', c_Red, t_Hint);
    Exit;
  end;

  SysMsg('½ûÑÔÁÐ±í:', c_Blue, t_Hint);
  for i := 0 to g_DisableSendMsgList.Count - 1 do
  begin
    SysMsg(g_DisableSendMsgList.Strings[i], c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  for i := 0 to g_DisableSendMsgList.Count - 1 do
  begin
    if CompareText(sHumanName, g_DisableSendMsgList.Strings[i]) = 0 then
    begin
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        PlayObject.m_boFilterSendMsg := False;
      end;
      g_DisableSendMsgList.Delete(i);
      SaveDisableSendMsgList();
      SysMsg(sHumanName + ' ÒÑ´Ó½ûÑÔÁÐ±íÖÐÉ¾³ý', c_Green, t_Hint);
      Exit;
    end;
  end;
  SysMsg(sHumanName + ' Ã»ÓÐ±»½ûÑÔ', c_Red, t_Hint);
end;

procedure TPlayObject.CmdAddToCastleWarList(param1, param2: string);

  function IsInAttackList(CurCastle: TUserCastle; AddingInfo: pTAttackerInfo): Boolean;
  var
    i: Integer;
    AttackerInfo: pTAttackerInfo;
    wYear, wMonth, wDay: Word;
    sYear, sMonth, sDay: Word;
  begin
    Result := False;
    for i := 0 to CurCastle.m_AttackWarList.Count - 1 do
    begin
      AttackerInfo := pTAttackerInfo(CurCastle.m_AttackWarList.Values[CurCastle.m_AttackWarList.Keys[i]]);
      //AttackerInfo := pTAttackerInfo(CurCastle.m_AttackWarList[i]);
      if (CompareText(AddingInfo^.sGuildName, AttackerInfo^.sGuildName) = 0) or (AddingInfo^.Guild = AttackerInfo^.Guild) then
      begin
        DecodeDate(AddingInfo^.AttackDate, wYear, wMonth, wDay);
        DecodeDate(AttackerInfo^.AttackDate, sYear, sMonth, sDay);
        if (wYear = sYear) and (wMonth = wMonth) and (wDay = sDay) then
        begin
          Result := True;
          Break;
        end;
      end;
    end;
  end;

var
  i, idx: Integer;
  AttackerInfo: pTAttackerInfo;
  AddInfo: pTAttackerInfo;
  Guild: TGuild;
  boAddAll: Boolean;
  CurCastle: TUserCastle;
begin
  if (m_btPermission < 6) then
    Exit;
  idx := Str_ToInt(param1, -1);
  if (idx < 0) or (idx >= g_CastleManager.m_CastleList.Count) or (param2 = '') then
  begin
    SysMsg(Format('ÃüÁî¸ñÊ½: @AddToCastleWarList + ³Ç±¤±àºÅ(0~%d) + ÐÐ»áÃû(*±íÊ¾ËùÓÐÐÐ»á)', [g_CastleManager.m_CastleList.Count]), c_Red, t_Hint);
    Exit;
  end;
  CurCastle := g_CastleManager.m_CastleList[idx];
  if CurCastle = nil then
    Exit;
  boAddAll := param2 = '*';
  if boAddAll then
  begin
    for i := CurCastle.m_AttackWarList.Count - 1 downto 0 do
    begin
      AttackerInfo := pTAttackerInfo(CurCastle.m_AttackWarList.Values[CurCastle.m_AttackWarList.Keys[i]]);
      Dispose(AttackerInfo);
    end;
    CurCastle.m_AttackWarList.Clear;

    for i := 0 to g_GuildManager.GuildList.Count - 1 do
    begin
      //Guild := TGuild(g_GuildManager.GuildList.Items[i]);
      Guild := TGuild(g_GuildManager.GuildList.Values[g_GuildManager.GuildList.Keys[i]]);
      if not CurCastle.m_AttackWarList.Exists(Guild.sGuildName) then
      begin
        New(AttackerInfo);
        AttackerInfo^.sGuildName := Guild.sGuildName;
        AttackerInfo^.Guild := Guild;
        AttackerInfo^.AttackDate := Now;
        //CurCastle.m_AttackWarList.Add(AttackerInfo);
        CurCastle.m_AttackWarList.Put(Guild.sGuildName, TObject(AttackerInfo));
      end;
    end;
  end
  else
  begin
    Guild := g_GuildManager.FindGuild(param2);
    if Guild = nil then
    begin
      SysMsg(Format('ÐÐ»á %s ²»´æÔÚ£¡', [param2]), c_Red, t_Hint);
      Exit;
    end;
    if CurCastle.m_AttackWarList.Exists(param2) then
    begin
      SysMsg(Format('ÐÐ»á %s ÒÑ¾­ÔÚ¹¥³ÇÁÐ±íÖÐ£¡', [param2]), c_Red, t_Hint);
      Exit;
    end;

    New(AddInfo);
    AddInfo.AttackDate := Now();
    AddInfo.sGuildName := param2;
    AddInfo.Guild := Guild;
    if IsInAttackList(CurCastle, AddInfo) then
    begin
      SysMsg(Format('ÐÐ»á %s ÒÑ¾­ÔÚ¹¥³ÇÁÐ±íÖÐ£¡', [param2]), c_Red, t_Hint);
      Dispose(AddInfo);
      Exit;
    end;
    //CurCastle.m_AttackWarList.Add(AddInfo);
    CurCastle.m_AttackWarList.Put(AddInfo.sGuildName, TObject(AddInfo));
  end;
end;

procedure TPlayObject.CmdEndGuild;
begin
  if (m_MyGuild <> nil) then
  begin
    if (m_nGuildRankNo > 1) then
    begin
      if TGuild(m_MyGuild).IsMember(m_sCharName) and
        TGuild(m_MyGuild).DelMember(m_sCharName) then
      begin
        UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
        m_MyGuild := nil;
        RefRankInfo(0, '');
        RefShowName();
        SysMsg('ÄãÒÑ¾­ÍË³öÐÐ»á', c_Green, t_Hint);
      end;
    end
    else
    begin
      SysMsg('ÐÐ»áÕÆÃÅÈË²»ÄÜÕâÑùÍË³öÐÐ»á', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('Äã¶¼Ã»¼ÓÈëÐÐ»á', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent: TFireBurnEvent;
begin
  if (m_btPermission < 6) then
    Exit;
  if (nInt = 0) or (nTime = 0) or (nN = 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN', c_Red, t_Hint);
    Exit;
  end;
  FireBurnEvent := TFireBurnEvent.Create(Self, m_nCurrX, m_nCurrY, nInt, nTime, nN, 0);
  g_EventManager.AddEvent(FireBurnEvent);
end;

procedure TPlayObject.CmdForcedWallconquestWar(Cmd: pTGameCmd; sCASTLENAME: string);
var
  Castle: TUserCastle;
  s20: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if sCASTLENAME = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ³Ç±¤Ãû³Æ', c_Red, t_Hint);
    Exit;
  end;

  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle <> nil then
  begin
    Castle.m_boUnderWar := not Castle.m_boUnderWar;
    if Castle.m_boUnderWar then
    begin
      Castle.m_dwStartCastleWarTick := GetTickCount();
      Castle.StartWallconquestWar();

      UserEngine.SendInterMsg(ISM_RELOADCASTLEINFO, g_nServerIndex, '');
      s20 := '[' + Castle.m_sName + '¹¥³ÇÕ½ÒÑ¾­¿ªÊ¼]';
      UserEngine.SendBroadCastMsg(s20, t_System);
      UserEngine.SendInterMsg(ISM_SYSOPMSG, g_nServerIndex, s20);
      Castle.MainDoorControl(True);
    end
    else
    begin
      Castle.StopWallconquestWar();
    end;
  end
  else
  begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandFreePKHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject.m_nPkPoint := 0;
  PlayObject.RefNameColor();
  PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg, c_Green, t_Hint);
  SysMsg(Format(g_sGameCommandFreePKMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGroupRecall(sCmd: string);
var
  i: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
begin

  if (m_boRecallSuite or (m_btPermission >= 6)) and not m_StallMgr.OnSale then
  begin
    if not m_PEnvir.m_MapFlag.boNORECALL then
    begin
      dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
      m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
      if m_btPermission >= 6 then
        m_wGroupRcallTime := 0;

      if m_wGroupRcallTime > dwValue then
        Dec(m_wGroupRcallTime, dwValue)
      else
        m_wGroupRcallTime := 0;
      if m_wGroupRcallTime = 0 then
      begin
        if m_GroupOwner = Self then
        begin
          for i := 1 to m_GroupMembers.Count - 1 do
          begin
            PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
            if PlayObject.m_boAllowGroupReCall then
            begin
              if PlayObject.m_PEnvir.m_MapFlag.boNORECALL then
                SysMsg(Format('%s ËùÔÚµÄµØÍ¼²»ÔÊÐí´«ËÍ', [PlayObject.m_sCharName]), c_Red, t_Hint)
              else
                RecallHuman(PlayObject.m_sCharName);
            end
            else
              SysMsg(Format('%s ²»ÔÊÐíÌìµØºÏÒ»', [PlayObject.m_sCharName]), c_Red, t_Hint);
          end;
          m_dwGroupRcallTick := GetTickCount();
          m_wGroupRcallTime := g_Config.nGroupRecallTime;
        end;
      end
      else
        SysMsg(Format('%d ÃëÖ®ºó²Å¿ÉÒÔÔÙÊ¹ÓÃ´Ë¹¦ÄÜ', [m_wGroupRcallTime]), c_Red, t_Hint);
    end
    else
      SysMsg('´ËµØÍ¼½ûÖ¹Ê¹ÓÃ´ËÃüÁî', c_Red, t_Hint);
  end
  else
    SysMsg('ÄúÏÖÔÚ»¹ÎÞ·¨Ê¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
end;

procedure TPlayObject.CmdGuildRecall(sCmd, sParam: string);
var
  i, ii: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
  GuildRank: pTGuildRank;
  nRecallCount, nNoRecallCount: Integer;
  Castle: TUserCastle;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('ÃüÁî¹¦ÄÜ: ÐÐ»á´«ËÍ£¬ÐÐ»áÕÆÃÅÈË¿ÉÒÔ½«Õû¸öÐÐ»á³ÉÔ±È«²¿¼¯ÖÐ', c_Red, t_Hint);
    Exit;
  end;
  if not m_boGuildMove and (m_btPermission < 6) then
  begin
    SysMsg('ÄúÏÖÔÚ»¹ÎÞ·¨Ê¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  if not IsGuildMaster then
  begin
    SysMsg('ÐÐ»áÕÆÃÅÈË²Å¿ÉÒÔÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  if m_PEnvir.m_MapFlag.boNOGUILDRECALL then
  begin
    SysMsg('±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;

  Castle := g_CastleManager.InCastleWarArea(Self);
  if (Castle <> nil) and Castle.m_boUnderWar then
  begin
    SysMsg('¹¥³ÇÇøÓò²»ÔÊÐíÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;

  nRecallCount := 0;
  nNoRecallCount := 0;
  dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
  if m_btPermission >= 6 then
    m_wGroupRcallTime := 0;
  if m_wGroupRcallTime > dwValue then
    Dec(m_wGroupRcallTime, dwValue)
  else
    m_wGroupRcallTime := 0;
  if m_wGroupRcallTime > 0 then
  begin
    SysMsg(Format('%d ÃëÖ®ºó²Å¿ÉÒÔÔÙÊ¹ÓÃ´Ë¹¦ÄÜ', [m_wGroupRcallTime]), c_Red, t_Hint);
    Exit;
  end;
  for i := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
  begin
    GuildRank := TGuild(m_MyGuild).m_RankList.Items[i];
    for ii := 0 to GuildRank.MemberList.Count - 1 do
    begin
      PlayObject := TPlayObject(GuildRank.MemberList.Values[GuildRank.MemberList.Keys[ii]]);
      if PlayObject <> nil then
      begin
        if PlayObject = Self then
          Continue;
        if PlayObject.m_boAllowGuildReCall then
        begin
          if PlayObject.m_PEnvir.m_MapFlag.boNORECALL then
            SysMsg(Format('%s ËùÔÚµÄµØÍ¼²»ÔÊÐí´«ËÍ', [PlayObject.m_sCharName]), c_Red, t_Hint)
          else
          begin
            RecallHuman(PlayObject.m_sCharName);
            Inc(nRecallCount);
          end;
        end
        else
        begin
          Inc(nNoRecallCount);
          SysMsg(Format('%s ²»ÔÊÐíÐÐ»áºÏÒ»', [PlayObject.m_sCharName]), c_Red, t_Hint);
        end;
      end;
    end;
  end;
  SysMsg(Format('ÒÑ´«ËÍ%d¸ö³ÉÔ±£¬%d¸ö³ÉÔ±Î´±»´«ËÍ', [nRecallCount, nNoRecallCount]), c_Green, t_Hint);
  m_dwGroupRcallTick := GetTickCount();
  m_wGroupRcallTime := g_Config.nGuildRecallTime;
end;

procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: string); //004CE9F0
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair:
  Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (nHair < 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÈËÎïÃû³Æ ÀàÐÍÖµ', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_btHair := nHair;
    PlayObject.FeatureChanged();
    SysMsg(sHumanName + ' µÄÍ··¢ÒÑ¸Ä±ä', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(PlayObject.GetPlayObjectInfo(), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandHumanLocalHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
{$IF EXPIPLOCAL=1}
  SysMsg(Format(g_sGameCommandHumanLocalMsg, [sHumanName, GetIPLocal(PlayObject.m_sIPaddr)]), c_Green, t_Hint);
{$ELSE}
  SysMsg(Format(g_sGameCommandHumanLocalMsg, [sHumanName, m_sIPLocal]), c_Green, t_Hint);
{$IFEND}
end;

procedure TPlayObject.CmdHunger(sCmd, sHumanName: string; nHungerPoint:
  Integer);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sHumanName = '') or (nHungerPoint < 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÈËÎïÃû³Æ ÄÜÁ¿Öµ', c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_nHungerStatus := nHungerPoint;
    PlayObject.SendMsg(PlayObject, RM_MYSTATUS, 0, 0, 0, 0, '');
    PlayObject.RefMyStatus();
    SysMsg(sHumanName + ' µÄÄÜÁ¿ÖµÒÑ¸Ä±ä', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sHumanName + 'Ã»ÓÐÔÚÏß', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer); //004BF4D4
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandIncPkPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  Inc(PlayObject.m_nPkPoint, nPoint);
  PlayObject.RefNameColor();
  if nPoint > 0 then
    SysMsg(Format(g_sGameCommandIncPkPointAddPointMsg, [sHumanName, nPoint]), c_Green, t_Hint)
  else
    SysMsg(Format(g_sGameCommandIncPkPointDecPointMsg, [sHumanName, -nPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandKickHumanHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumName);
  if PlayObject <> nil then
  begin
    PlayObject.m_boKickFlag := True;
    PlayObject.m_boEmergencyClose := True;
    if PlayObject.IsHero then
      PlayObject.MakeGhost;
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdKill(Cmd: pTGameCmd; sHumanName: string);
var
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if sHumanName <> '' then
  begin
    BaseObject := UserEngine.GetPlayObject(sHumanName);
    if BaseObject = nil then
      BaseObject := UserEngine.GetHeroObject(sHumanName);
    if BaseObject = nil then
    begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end
  else
  begin
    BaseObject := GetPoseCreate();
    if BaseObject = nil then
    begin
      SysMsg('ÃüÁîÊ¹ÓÃ·½·¨²»ÕýÈ·£¬±ØÐëÓë½ÇÉ«Ãæ¶ÔÃæÕ¾ºÃ', c_Red, t_Hint);
      Exit;
    end;
  end;
  BaseObject.Die;
end;

procedure TPlayObject.CmdUnLockLogin(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if not g_Config.boLockHumanLogin then
  begin
    SysMsg('±¾·þÎñÆ÷»¹Ã»ÓÐÆôÓÃµÇÂ¼Ëø¹¦ÄÜ', c_Red, t_Hint);
    Exit;
  end;
  if m_sStoragePwd = '' then
  begin
    SysMsg(Format('¶Ô²»Æð,Ã»ÓÐÉèÖÃ²Ö¿âÃÜÂë´Ë¹¦ÄÜÎÞ·¨Ê¹ÓÃ,ÉèÖÃ²Ö¿âÃÜÂëÊäÈëÖ¸Áî:@%s', [g_GameCommand.PASSWORDLOCK.sCmd]), c_Red, t_Hint);
    Exit;
  end;
  if m_boLockLogon and not m_boLockLogoned then
  begin
    SysMsg(Format('ÇëÊäÈëÕýÈ·µÄ²Ö¿âÃÜÂë,ÔÙÊäÈëÖ¸Áî:@%s', [g_GameCommand.UNLOCKLOGON.sCmd]), c_Red, t_Hint);
    SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
    SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
    m_boUnLockStoragePwd := True;
    m_boUnLockPwd := True;
    Exit;
  end;
  if not m_boLockLogon then
  begin
    SysMsg('´ËÃüÁîÖ»ÄÜÔÚ±£»¤Ä£Ê½ÏÂÊ¹ÓÃ', c_Red, t_Hint);
    Exit;
  end;
  m_boLockLogon := False;
  SysMsg(Format('ÄãÕý´¦ÓÚ·Ç±£»¤Ä£Ê½,Èç¹ûÏëÄãµÄ×°±¸¸ü¼Ó°²È«,ÇëÊäÈëÖ¸Áî:@%s', [g_GameCommand.LOCKLOGON.sCmd]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdRemoteMsg(Cmd: pTGameCmd);
begin
  m_boRemoteMsg := not m_boRemoteMsg;
  if m_boRemoteMsg then
    SysMsg('[ÔÊÐí½ÓÊÕÏûÏ¢]', c_Green, t_Hint)
  else
    SysMsg('[½ûÖ¹½ÓÊÕÏûÏ¢]', c_Green, t_Hint);
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
resourcestring
  IsCastlePalaceEnvirMsg = '»Ê¹¬ÄÚ½ûÖ¹½øÈë±£»¤Ä£Ê½';
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if not g_Config.boLockHumanLogin then
  begin
    SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
    Exit;
  end;
  //{$IF VEROWNER = WL}
  if m_sStoragePwd = '' then
  begin
    SysMsg(Format(g_sPasswordNotSetMsg, [g_GameCommand.PASSWORDLOCK.sCmd]), c_Red, t_Hint);
    Exit;
  end;
  if g_CastleManager.IsCastlePalaceEnvir(m_PEnvir) <> nil then
  begin
    SysMsg(IsCastlePalaceEnvirMsg, c_Red, t_Hint);
    Exit;
  end;
  if m_boLockLogon and not m_boLockLogoned then
  begin
    SysMsg(Format(g_sPasswordProtectMode, [g_GameCommand.UNLOCKLOGON.sCmd]), c_Red, t_Hint);
    Exit;
  end;
  m_boLockLogon := True;
  SysMsg(Format(g_sPasswordProtectMode, [g_GameCommand.UNLOCKLOGON.sCmd]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdLotteryTicket(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandLotteryTicketMsg, [g_Config.nWinLotteryCount,
    g_Config.nNoWinLotteryCount,
      g_Config.nWinLotteryLevel1,
      g_Config.nWinLotteryLevel2,
      g_Config.nWinLotteryLevel3,
      g_Config.nWinLotteryLevel4,
      g_Config.nWinLotteryLevel5,
      g_Config.nWinLotteryLevel6]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdLuckPoint(sCmd: string; nPermission: Integer;
  sHumanName, sCtr, sPoint: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandLuckPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;

  if sCtr = '' then
  begin
    SysMsg(Format(g_sGameCommandLuckPointMsg, [sHumanName, PlayObject.m_nBodyLuckLevel, PlayObject.m_dBodyLuck, PlayObject.m_nLuck]), c_Green, t_Hint);
    Exit;
  end;

end;

procedure TPlayObject.CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount, nDura: Integer);
var
  i: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  StdItemIndex: Integer;
  boCanMake: Boolean;
begin
  boCanMake := True;
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sItemName = '') then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount <= 0) then
    nCount := 1;
  if (nCount > MAX_OVERLAPITEM) then
    nCount := MAX_OVERLAPITEM;
  if (m_btPermission < Cmd.nPermissionMax) then
  begin
    if InLimitItemList(sItemName, -1, t_dMake) then
      boCanMake := False;
    if InLimitItemList(sItemName, -1, t_aMake) then //ÔÊÐíÓÅÏÈ
      boCanMake := True;
    if not boCanMake then
    begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
      Exit;
    end;
    if g_CastleManager.InCastleWarArea(Self) <> nil then
    begin
      SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
      Exit;
    end;
    if not InSafeZone then
    begin
      SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
      Exit;
    end;
    nCount := 1;  //·Ç×î´óÈ¨ÏÞÊ±£¬Ä¬ÈÏÖ»ÔÊÐíÖÆÔìµ¥¸öÎïÆ·
  end;

  StdItemIndex := UserEngine.GetStdItemIdx(sItemName);
  StdItem := UserEngine.GetStdItem(StdItemIndex);

  if StdItem = nil then Exit;

  while nCount > 0 do
  begin
    UserItem := GetOverlapItemFromBag(m_ItemList, StdItem, StdItemIndex);
    if UserItem <> nil then
    begin
      if UserItem.DuraMax - UserItem.Dura > nCount then
      begin
        UserItem.Dura := UserItem.Dura + nCount;
        nCount := 0;
      end
      else
      begin
        nCount := nCount - (UserItem.DuraMax - UserItem.Dura);
        UserItem.Dura := UserItem.DuraMax;
      end;
      SendChangeBagItemDura(UserItem.MakeIndex, UserItem.Dura, False);
      Continue;
    end;

    if not IsEnoughBag then
    begin
      SysMsg('±³°üÃ»ÓÐ×ã¹»µÄ¿ÕÎ»', c_Red, t_Hint);
      Break;
    end;

    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
    begin
      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5) then
      begin
        Dispose(UserItem);
        Break; //0412
      end;

      if Random(g_Config.nMakeRandomAddValue) = 0 then
        UserEngine.RandomUpgradeItem(UserItem);

      if StdItem.StdMode in [15..24, 26] then
      begin
        if StdItem.Shape in [130, 131, 132] then
          UserEngine.GetUnknowItemValue(UserItem);
      end;

      if (StdItem.StdMode = 56) and (StdItem.Shape = 0) then
      begin
        if (nDura in [1..10]) then
          UserItem.btValue[0] := nDura
        else
          UserItem.btValue[0] := 1;
        PWord(@UserItem.btValue[1])^ := 1000 + Random(2000);
      end;

      if (nDura > 0) and (StdItem.StdMode = 40) and (StdItem.Shape > 0) then
        UserItem.Dura := _MIN(UserItem.DuraMax, nDura * 1000);

      if m_btPermission >= Cmd.nPermissionMax then
        UserItem.MakeIndex := GetItemNumberEx();

      if CheckIsOverlapItem(StdItem) then
      begin
        if UserItem.DuraMax <= nCount then
        begin
          UserItem.Dura := UserItem.DuraMax;
          Dec(nCount, UserItem.Dura);
        end
        else
        begin
          UserItem.Dura := nCount;
          nCount := 0;
        end;
      end
      else
      begin
        Dec(nCount, 1);
      end;
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);

      SysMsg('[ÖÆÔìÎïÆ·] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')', c_Red, t_Hint);

      if g_Config.boShowMakeItemMsg and (m_btPermission >= 6) then
        MainOutMessageAPI('[ÖÆÔìÎïÆ·] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')');

      if StdItem.NeedIdentify = 1 then
        AddGameDataLogAPI('5' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
    begin
      Dispose(UserItem);
      SysMsg(Format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.MakeItem(sItemName: string; nCount, nDura: Integer);
var
  i: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if (nCount <= 0) then
    nCount := 1;

  if (nCount > MAX_OVERLAPITEM) then
    nCount := MAX_OVERLAPITEM;

  for i := 0 to nCount - 1 do
  begin
    if IsEnoughBag then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        if (StdItem.StdMode = 56) and (StdItem.Shape = 0) then
        begin
          if (nDura in [1..10]) then
            UserItem.btValue[0] := nDura
          else
            UserItem.btValue[0] := 1;
          PWord(@UserItem.btValue[1])^ := 1000 + Random(2000);
        end;

        if StdItem.Overlap >= 1 then
        begin
          UserItem.Dura := nCount;
          m_ItemList.Add(UserItem);
          SendAddItem(UserItem);
        end
        else
        begin
          m_ItemList.Add(UserItem);
          SendAddItem(UserItem);
        end;

        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('5' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        if StdItem.Overlap >= 1 then
          Break;
      end
      else
      begin
        Dispose(UserItem);
        Break;
      end;
    end
    else
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        if StdItem.Overlap >= 1 then
          UserItem.Dura := nCount;

        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('5' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            '0');

        DropItemDown(UserItem, 3, False, Self, nil);

        if StdItem.Overlap >= 1 then
          Break;
      end;
      Dispose(UserItem);
    end;
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(Format(g_sTheMapNotFound, [sMapName]) { + ' ´ËµØÍ¼ºÅ²»´æÔÚ'}, c_Red, t_Hint);
    Exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
  begin
    SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
    MapRandomMove(sMapName, 0);
  end
  else
    SysMsg(Format(g_sTheMapDisableMove, [sMapName, Envir.m_sMapDesc]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      Exit;
    end;
    if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
    begin
      SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPositionMoveHelpMsg]), c_Red, t_Hint);
      Exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
    begin
      Envir := g_MapManager.FindMap(sMapName);
      if Envir <> nil then
      begin
        nX := Str_ToInt(sX, 0);
        nY := Str_ToInt(sY, 0);
        if Envir.CanWalk(nX, nY, True) then
          SpaceMove(sMapName, nX, nY, 0)
        else
          SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap, [sMapName, sX, sY]), c_Green, t_Hint);
      end;
    end
    else
      SysMsg(Format(g_sTheMapDisableMove, [sMapName, Envir.m_sMapDesc]), c_Red, t_Hint);
  except
    on E: Exception do
    begin
      MainOutMessageAPI('[Exceptioin] TPlayObject.CmdPositionMove');
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TPlayObject.CmdSignMove(Cmd: pTGameCmd);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if m_sMarkerMap = '' then
  begin
    SysMsg('µ±Ç°Ã»ÓÐËÀÍöµØÍ¼±ê¼Ç¡£', c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(m_sMarkerMap);
  if Envir <> nil then
    TPlayObject(Self).SpaceMove(m_sMarkerMap, m_wMarkerX, m_wMarkerY, 0);
  m_sMarkerMap := '';
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
var
  SrcEnvir, DenEnvir: TEnvirnoment;
  HumanList: TList;
  i: Integer;
  MoveHuman: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMapMoveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  SrcEnvir := g_MapManager.FindMap(sSrcMap);
  DenEnvir := g_MapManager.FindMap(sDenMap);
  if (SrcEnvir = nil) then
  begin
    SysMsg(Format(g_sGameCommandMapMoveMapNotFound, [sSrcMap]), c_Red, t_Hint);
    Exit;
  end;
  if (DenEnvir = nil) then
  begin
    SysMsg(Format(g_sGameCommandMapMoveMapNotFound, [sDenMap]), c_Red, t_Hint);
    Exit;
  end;

  HumanList := TList.Create;
  UserEngine.GetMapRageHuman(SrcEnvir, SrcEnvir.m_MapHeader.wWidth div 2, SrcEnvir.m_MapHeader.wHeight div 2, 1000, HumanList);
  for i := 0 to HumanList.Count - 1 do
  begin
    MoveHuman := TPlayObject(HumanList.Items[i]);
    if MoveHuman <> Self then
      MoveHuman.MapRandomMove(sDenMap, 0);
  end;
  HumanList.Free;
end;

procedure TPlayObject.CmdMemberFunction(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('´ò¿ª»áÔ±¹¦ÄÜ´°¿Ú.', c_Red, t_Hint);
    Exit;
  end;
  if g_ManageNPC <> nil then
  begin
    g_ManageNPC.m_OprCount := 0;
    g_ManageNPC.GotoLable(Self, '@Member', False);
  end;
end;

procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('´ò¿ª»áÔ±¹¦ÄÜ´°¿Ú.', c_Red, t_Hint);
    Exit;
  end;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(Self, '@Member', False);
  end;
end;

procedure TPlayObject.CmdMission(Cmd: pTGameCmd; sX, sY: string); //004CCA08
var
  nX, nY: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sX = '') or (sY = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' X  Y', c_Red, t_Hint);
    Exit;
  end;
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  g_boMission := True;
  g_sMissionMap := m_sMapName;
  g_nMissionX := nX;
  g_nMissionY := nY;
  SysMsg('¹ÖÎï¼¯ÖÐÄ¿±êÒÑÉè¶¨Îª: ' + m_sMapName + '(' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ')', c_Green, t_Hint);
end;

procedure TPlayObject.CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel: Integer);
var
  i: Integer;
  nX, nY: Integer;
  Monster: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nCount <= 0 then
    nCount := 1;
  if not (nLevel in [0..10]) then
    nLevel := 0;
  nCount := _MIN(3000, nCount);
  GetFrontPosition(nX, nY);
  for i := 0 to nCount - 1 do
  begin
    Monster := UserEngine.RegenMonsterByName(m_PEnvir.m_sMapFileName, nX, nY, sMonName);
    if Monster <> nil then
    begin
      Monster.m_btSlaveMakeLevel := nLevel;
      Monster.m_btSlaveExpLevel := nLevel;
      Monster.RecalcAbilitys();
      Monster.RefNameColor;
    end
    else
    begin
      SysMsg(g_sGameCommandMobMsg, c_Red, t_Hint);
      Break;
    end;
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandMobCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then
  begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapMonster(Envir, nil)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandHumanCountHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then
  begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandMobCountMonsterCount,
    [UserEngine.GetMapHuman(sMapName)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMAP, sX, sY, sType,
  sTime, sPoint: string);
var
  nX, nY, nType, nTime, nPoint: Integer;
  FireBurnEvent: TFireBurnEvent;
  Envir: TEnvirnoment;
  OldEnvir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMAP = '') or ((sMAP <> '') and (sMAP[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY, sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;

  nX := Str_ToInt(sX, -1);
  nY := Str_ToInt(sY, -1);
  nType := Str_ToInt(sType, -1);
  nTime := Str_ToInt(sTime, -1);
  nPoint := Str_ToInt(sPoint, -1);
  if nPoint < 0 then
    nPoint := 1;

  if (sMAP = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint
    < 0) then
  begin
    SysMsg(Format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMAP, sX, sY,
      sType, sTime, sPoint]), c_Red, t_Hint);
    Exit;
  end;
  Envir := g_MapManager.FindMap(sMAP);
  if Envir <> nil then
  begin
    OldEnvir := m_PEnvir;
    m_PEnvir := Envir;
    try
      FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint, 0);
      g_EventManager.AddEvent(FireBurnEvent);
    finally
      m_PEnvir := OldEnvir;
    end;
  end;
  //SysMsg(Format(g_sGameCommandMobFireBurnMapNotFountMsg, [Cmd.sCmd, sMAP]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdMobLevel(Cmd: pTGameCmd; Param: string); //004CFD5C
var
  i: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((Param <> '') and (Param[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  BaseObjectList := TList.Create;
  m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, 2, True, BaseObjectList);
  for i := 0 to BaseObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(BaseObjectList.Items[i]);
    SysMsg(BaseObject.GeTBaseObjectInfo(), c_Green, t_Hint);
  end;
  BaseObjectList.Free;
end;

procedure TPlayObject.CmdMobNpc(sCmd: string; nPermission: Integer; sParam1,
  sParam2, sParam3, sParam4: string);
var
  nAppr: Integer;
  boIsCastle: Boolean;
  Merchant: TMerchant;
  nX, nY: Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandMobNpcHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  nAppr := Str_ToInt(sParam3, 0);
  boIsCastle := (Str_ToInt(sParam4, 0) = 1);
  if sParam1 = '' then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' NPCÃû³Æ ½Å±¾ÎÄ¼þÃû ÍâÐÎ(Êý×Ö) ÊôÉ³³Ç(0,1)', c_Red, t_Hint);
    Exit;
  end;
  Merchant := TMerchant.Create;
  Merchant.m_sCharName := sParam1;
  Merchant.m_sFCharName := FilterCharName(Merchant.m_sCharName);
  Merchant.m_sMapName := m_sMapName;
  Merchant.m_PEnvir := g_MapManager.FindMap(Merchant.m_sMapName);
  Merchant.m_wAppr := nAppr;
  Merchant.m_nFlag := 0;
  Merchant.m_boCastle := boIsCastle;
  Merchant.m_sScript := sParam2;
  GetFrontPosition(nX, nY);
  Merchant.m_nCurrX := nX;
  Merchant.m_nCurrY := nY;
  Merchant.Initialize();
  Merchant.OnEnvirnomentChanged();
  UserEngine.AddMerchant(Merchant);
end;

procedure TPlayObject.CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount:
  string); //004CCBB4
var
  i: Integer;
  nCount, nX, nY: Integer;
  MEnvir: TEnvirnoment;
  Mon: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nCount := _MIN(500, Str_ToInt(sCount, 0));
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  MEnvir := g_MapManager.FindMap(g_sMissionMap);
  if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' X  Y ¹ÖÎïÃû³Æ ¹ÖÎïÊýÁ¿', c_Red, t_Hint);
    Exit;
  end;
  if not g_boMission or (MEnvir = nil) then
  begin
    SysMsg('»¹Ã»ÓÐÉè¶¨¹ÖÎï¼¯ÖÐµã', c_Red, t_Hint);
    SysMsg('ÇëÏÈÓÃÃüÁî' + g_GameCommand.Mission.sCmd + 'ÉèÖÃ¹ÖÎïµÄ¼¯ÖÐµã', c_Red, t_Hint);
    Exit;
  end;

  for i := 0 to nCount - 1 do
  begin
    Mon := UserEngine.RegenMonsterByName(g_sMissionMap, nX, nY, sMonName);
    if Mon <> nil then
    begin
      Mon.m_boMission := True;
      Mon.m_nMissionX := g_nMissionX;
      Mon.m_nMissionY := g_nMissionY;
    end
    else
      Break;
  end;
  SysMsg(IntToStr(nCount) + ' Ö» ' + sMonName + ' ÒÑÕýÔÚÍùµØÍ¼ ' + g_sMissionMap + ' ' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ' ¼¯ÖÐ', c_Green, t_Hint);
end;

procedure TPlayObject.CmdNpcScript(sCmd: string; nPermission: Integer; sParam1,
  sParam2, sParam3: string);
var
  BaseObject: TBaseObject;
  nNPCType: Integer;
  i: Integer;
  sScriptFileName: string;
  Merchant: TMerchant;
  NormNpc: TNormNpc;
  LoadList: TStringList;
  sScriptLine: string;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandNpcScriptHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  nNPCType := -1;
  BaseObject := GetPoseCreateB();
  if BaseObject <> nil then
  begin
    for i := 0 to UserEngine.m_MerchantList.Count - 1 do
    begin
      if TBaseObject(UserEngine.m_MerchantList.Items[i]) = BaseObject then
      begin
        nNPCType := 0;
        Break;
      end;
    end;
    for i := 0 to UserEngine.QuestNPCList.Count - 1 do
    begin
      if TBaseObject(UserEngine.QuestNPCList.Items[i]) = BaseObject then
      begin
        nNPCType := 1;
        Break;
      end;
    end;
  end;
  if nNPCType < 0 then
  begin
    SysMsg('ÃüÁîÊ¹ÓÃ·½·¨²»ÕýÈ·£¬±ØÐëÓëNPCÃæ¶ÔÃæ£¬²ÅÄÜÊ¹ÓÃ´ËÃüÁî', c_Red, t_Hint);
    Exit;
  end;

  if sParam1 = '' then
  begin
    if nNPCType = 0 then
    begin
      Merchant := TMerchant(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript + '-' + Merchant.m_sMapName + '.txt';
    end;
    if nNPCType = 1 then
    begin
      NormNpc := TNormNpc(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName +
        '-' + NormNpc.m_sMapName + '.txt';
    end;
    if FileExists(sScriptFileName) then
    begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sScriptFileName);
      except
        SysMsg('¶ÁÈ¡½Å±¾ÎÄ¼þ´íÎó: ' + sScriptFileName, c_Red, t_Hint);
      end;
      for i := 0 to LoadList.Count - 1 do
      begin
        sScriptLine := Trim(LoadList.Strings[i]);
        sScriptLine := ReplaceChar(sScriptLine, ' ', ',');
        SysMsg(IntToStr(i) + ',' + sScriptLine, c_Blue, t_Hint);
      end;
      LoadList.Free;
    end;
  end;
end;

procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: string);
//004CE938
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: string;
  nLevel: Integer); //004CC468
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdPKpoint(Cmd: pTGameCmd; sHumanName: string); //004CC61C
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandPKPointHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SysMsg(Format(g_sGameCommandPKPointMsg, [sHumanName, PlayObject.m_nPkPoint]),
    c_Green, t_Hint);
end;

procedure TPlayObject.CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
var
  i: Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandPrvMsgHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  i := m_BlockWhisperList.IndexOf(sHumanName);
  if i > -1 then
  begin
    m_BlockWhisperList.Delete(i);
    SysMsg(Format(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green, t_Hint);
    Exit;
  end;
  {for i := 0 to m_BlockWhisperList.Count - 1 do begin
    if CompareText(m_BlockWhisperList.Strings[i], sHumanName) = 0 then begin
      m_BlockWhisperList.Delete(i);
      SysMsg(Format(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green, t_Hint);
      Exit;
    end;
  end;}
  m_BlockWhisperList.Add(sHumanName);
  SysMsg(Format(g_sGameCommandPrvMsgLimitMsg, [sHumanName]), c_Green, t_Hint);

end;

procedure TPlayObject.CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandReAliveHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject.ReAlive;
  PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
  PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');

  SysMsg(Format(g_sGameCommandReAliveMsg, [sHumanName]), c_Green, t_Hint);
  SysMsg(sHumanName + ' ÒÑ»ñÖØÉú', c_Green, t_Hint);
end;

procedure TPlayObject.CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  RecallHuman(sHumanName);
end;

procedure TPlayObject.CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel, nAutoChangeColor, nFixColor, nType: Integer);
var
  i: Integer;
  n10, n14: Integer;
  Mon: TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  if nLevel >= 10 then
    nLevel := 0;
  if nCount <= 0 then
    nCount := 1;
  for i := 0 to nCount - 1 do
  begin
    if m_SlaveList.Count >= 20 then
      Break;
    GetFrontPosition(n10, n14);
    Mon := UserEngine.RegenMonsterByName(m_PEnvir.m_sMapFileName, n10, n14, sMonName);
    if Mon <> nil then
    begin
      Mon.m_Master := Self;
      Mon.m_dwMasterRoyaltyTick := GetTickCount + Round(24 * 60 * 60 / 10 * g_Config.dwMasterRoyaltyRate) * 1000;
      Mon.m_btSlaveMakeLevel := 3;
      Mon.m_btSlaveExpLevel := nLevel;
      if nAutoChangeColor = 1 then
        Mon.m_boAutoChangeColor := True
      else if nFixColor > 0 then
      begin
        Mon.m_boFixColor := True;
        Mon.m_nFixColorIdx := nFixColor - 1;
      end;
      if nType <> 0 then
        //Mon.m_boAttackTarget := True;
        Mon.RecalcAbilitys();
      Mon.RefNameColor();
      m_SlaveList.Add(Mon);
    end;
  end;
end;

procedure TPlayObject.CmdReconnection(sCmd, sIPaddr, sPort: string);
begin
  if (m_btPermission < 6) then
    Exit;
  if (sIPaddr <> '') and (sIPaddr[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚ¸Ä±ä¿Í»§¶ËÁ¬½ÓÍø¹ØµÄIP¼°¶Ë¿Ú', c_Blue, t_Hint);
    Exit;
  end;

  if (sIPaddr = '') or (sPort = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' IPµØÖ· ¶Ë¿Ú', c_Red, t_Hint);
    Exit;
  end;
  if (sIPaddr <> '') and (sPort <> '') then
  begin
    SendMsg(Self, RM_RECONNECTION, 0, 0, 0, 0, sIPaddr + '/' + sPort);
  end;
end;

procedure TPlayObject.CmdRefineWeapon(Cmd: pTGameCmd; nDc, nMc, nSc, nHit:
  Integer); //004CD1C4
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (nDc + nMc + nSc) > 10 then
    Exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    Exit;
  m_UseItems[U_WEAPON].btValue[0] := nDc;
  m_UseItems[U_WEAPON].btValue[1] := nMc;
  m_UseItems[U_WEAPON].btValue[2] := nSc;
  m_UseItems[U_WEAPON].btValue[5] := nHit;
  SendUpdateItem(@m_UseItems[U_WEAPON]);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  MainOutMessageAPI('[ÎäÆ÷µ÷Õû]' + m_sCharName + ' DC:' + IntToStr(nDc) + ' MC' + IntToStr(nMc) + ' SC' + IntToStr(nSc) + ' HIT:' + IntToStr(nHit));
end;

procedure TPlayObject.CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandReGotoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  SpaceMove(PlayObject.m_PEnvir.m_sMapFileName, PlayObject.m_nCurrX, PlayObject.m_nCurrY, 0);
end;

procedure TPlayObject.CmdReloadAbuse(sCmd: string; nPermission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: string);
begin
  if (m_btPermission < 6) then
    Exit;
  FrmDB.LoadAdminList();
  UserEngine.SendInterMsg(213, g_nServerIndex, '');
  SysMsg('¹ÜÀíÔ±ÁÐ±íÖØÐÂ¼ÓÔØ³É¹¦...', c_Green, t_Hint);
end;

procedure TPlayObject.CmdReloadGuild(sCmd: string; nPermission: Integer;
  sParam1: string);
var
  Guild: TGuild;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd,
      g_sGameCommandReloadGuildHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  if g_nServerIndex <> 0 then
  begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver, c_Red, t_Hint);
    Exit;
  end;

  Guild := g_GuildManager.FindGuild(sParam1);
  if Guild = nil then
  begin
    SysMsg(Format(g_sGameCommandReloadGuildNotFoundGuildMsg, [sParam1]), c_Red,
      t_Hint);
    Exit;
  end;
  Guild.LoadGuild();
  SysMsg(Format(g_sGameCommandReloadGuildSuccessMsg, [sParam1]), c_Red, t_Hint);
  UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, sParam1);
end;

procedure TPlayObject.CmdReloadGuildAll; //004CE530
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdReloadLineNotice(sCmd: string;
  nPermission: Integer; sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then
  begin
    SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg, c_Green, t_Hint);
  end
  else
  begin
    SysMsg(g_sGameCommandReloadLineNoticeFailMsg, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd: pTGameCmd; sParam: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam <> '') and (sParam[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sParam = '' then
  begin
    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.ClearScript();
      g_ManageNPC.LoadNpcScript();
      SysMsg('ÖØÐÂ¼ÓÔØµÇÂ¼½Å±¾Íê³É...', c_Green, t_Hint);
    end
    else
      SysMsg('ÖØÐÂ¼ÓÔØµÇÂ¼½Å±¾Ê§°Ü...', c_Green, t_Hint);
  end
  else
  begin
    if g_FunctionNPC <> nil then
    begin
      g_FunctionNPC.ClearScript();
      g_FunctionNPC.LoadNpcScript();
      SysMsg('ÖØÐÂ¼ÓÔØ¹¦ÄÜ½Å±¾Íê³É...', c_Green, t_Hint);
    end
    else
      SysMsg('ÖØÐÂ¼ÓÔØ¹¦ÄÜ½Å±¾Ê§°Ü...', c_Green, t_Hint);
    if g_MapEventNPC <> nil then
    begin
      g_MapEventNPC.ClearScript();
      g_MapEventNPC.LoadNpcScript();
      SysMsg('ÖØÐÂ¼ÓÔØÊÂ¼þ½Å±¾Íê³É...', c_Green, t_Hint);
    end
    else
      SysMsg('ÖØÐÂ¼ÓÔØÊÂ¼þ½Å±¾Ê§°Ü...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadRobot;
begin
  if g_RobotManage <> nil then
  begin
    g_RobotManage.RELOADROBOT();
    SysMsg('ÖØÐÂ¼ÓÔØ»úÆ÷ÈËÅäÖÃÍê³É...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadRobotManage;
begin
  if (m_btPermission < 6) then
    Exit;
  if g_RobotNPC <> nil then
  begin
    g_RobotNPC.ClearScript();
    g_RobotNPC.LoadNpcScript();
    SysMsg('ÖØÐÂ¼ÓÔØ»úÆ÷ÈË×¨ÓÃ½Å±¾Íê³É...', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('ÖØÐÂ¼ÓÔØ»úÆ÷ÈË×¨ÓÃ½Å±¾Ê§°Ü...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadMonItems;
var
  i: Integer;
  Monster: pTMonInfo;
begin
  if (m_btPermission < 6) then
    Exit;
  EnterCriticalSection(ProcessHumanCriticalSection);
  try
    for i := 0 to UserEngine.MonsterList.Count - 1 do
    begin
{$IF USEHASHLIST = 1}
      Monster := pTMonInfo(UserEngine.MonsterList.Values[UserEngine.MonsterList.Keys[i]]);
      FrmDB.LoadMonitems(UserEngine.MonsterList.Keys[i], Monster.ItemList);
{$ELSE}
      Monster := UserEngine.MonsterList.Items[i];
      FrmDB.LoadMonitems(Monster.sName, Monster.ItemList);
{$IFEND}

    end;
    SysMsg('¹ÖÎï±¬ÎïÆ·ÁÐ±íÖØ¼ÓÔØÍê³É...', c_Green, t_Hint);
  finally
    LeaveCriticalSection(ProcessHumanCriticalSection);
  end;
end;

procedure TPlayObject.CmdReloadNpc(sParam: string); //004CFFF8
var
  i: Integer;
  TmpList: TList;
  Merchant: TMerchant;
  Npc: TNormNpc;
begin
  if (m_btPermission < 6) then
    Exit;
  if CompareText('all', sParam) = 0 then
  begin
    FrmDB.ReLoadMerchants();
    UserEngine.ReloadMerchantList();
    SysMsg('½»Ò×NPCÖØÐÂ¼ÓÔØÍê³É', c_Red, t_Hint);
    UserEngine.ReloadNpcList();
    SysMsg('¹ÜÀíNPCÖØÐÂ¼ÓÔØÍê³É', c_Red, t_Hint);
    Exit;
  end;
  TmpList := TList.Create;
  if UserEngine.GetMerchantList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then
  begin
    for i := 0 to TmpList.Count - 1 do
    begin
      Merchant := TMerchant(TmpList.Items[i]);
      Merchant.ClearScript;
      Merchant.LoadNpcScript;
      SysMsg(Merchant.m_sCharName + 'ÖØÐÂ¼ÓÔØ³É¹¦...', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg('¸½½üÎ´·¢ÏÖÈÎºÎ½»Ò×NPC', c_Red, t_Hint);
  end;
  TmpList.Clear;
  if UserEngine.GetNpcList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then
  begin
    for i := 0 to TmpList.Count - 1 do
    begin
      Npc := TNormNpc(TmpList.Items[i]);
      Npc.ClearScript;
      Npc.LoadNpcScript;
      SysMsg(Npc.m_sCharName + 'ÖØÐÂ¼ÓÔØ³É¹¦...', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg('¸½½üÎ´·¢ÏÖÈÎºÎ¹ÜÀíNPC', c_Red, t_Hint);
  end;
  TmpList.Free;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if m_boProbeNecklace or (m_btPermission >= 6) then
  begin
    if (sHumanName = '') then
    begin
      SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÈËÎïÃû³Æ', c_Red, t_Hint);
      Exit;
    end;
    if m_boProbeNecklace and g_Config.boSearchHumanOutSafeZone then
    begin
      if InSafeZone() then
      begin
        SysMsg('°²È«Çø½ûÖ¹Ê¹ÓÃ', c_Red, t_Hint);
        Exit;
      end;
    end;
    if ((GetTickCount - m_dwProbeTick) > 10000) or (m_btPermission >= 3) then
    begin
      m_dwProbeTick := GetTickCount();
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        SysMsg(sHumanName + ' ÏÖÔÚÎ»ÓÚ ' + PlayObject.m_PEnvir.m_sMapDesc + ' ' + IntToStr(PlayObject.m_nCurrX) + ':' + IntToStr(PlayObject.m_nCurrY), c_Blue, t_Hint);
      end
      else
      begin
        SysMsg(sHumanName + ' ÏÖÔÚ²»ÔÚÏß»òÎ»ÓÚÆäËü·þÎñÆ÷ÉÏ', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg(IntToStr((GetTickCount - m_dwProbeTick) div 1000 - 10) + ' ÃëÖ®ºó²Å¿ÉÒÔÔÙÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('ÄúÏÖÔÚ»¹ÎÞ·¨Ê¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowSbkGold(Cmd: pTGameCmd; sCASTLENAME, sCtr, sGold:
  string);
var
  i: Integer;
  Ctr: Char;
  nGold: Integer;
  Castle: TUserCastle;
  List: TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sCASTLENAME <> '') and (sCASTLENAME[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;
  if sCASTLENAME = '' then
  begin
    List := TStringList.Create;
    g_CastleManager.GetCastleGoldInfo(List);
    for i := 0 to List.Count - 1 do
    begin
      SysMsg(List.Strings[i], c_Green, t_Hint);
    end;
    List.Free;
    Exit;
  end;
  Castle := g_CastleManager.Find(sCASTLENAME);
  if Castle = nil then
  begin
    SysMsg(Format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCASTLENAME]), c_Red, t_Hint);
    Exit;
  end;

  Ctr := sCtr[1];
  nGold := Str_ToInt(sGold, -1);
  if not (Ctr in ['=', '-', '+']) or (nGold < 0) or (nGold > 100000000) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSbkGoldHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  case Ctr of
    '=': Castle.m_nTotalGold := nGold;
    '-': Dec(Castle.m_nTotalGold);
    '+': Inc(Castle.m_nTotalGold, nGold);
  end;
  if Castle.m_nTotalGold < 0 then
    Castle.m_nTotalGold := 0;
end;

procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);
var
  i: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShowUseItemInfoHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  for i := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do
  begin
    UserItem := @PlayObject.m_UseItems[i];
    if UserItem.wIndex = 0 then
      Continue;
    SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]',
      [GetUseItemName(i),
      UserEngine.GetStdItemName(UserItem.wIndex),
        UserItem.wIndex,
        UserItem.MakeIndex,
        UserItem.Dura,
        UserItem.DuraMax]),
        c_Blue, t_Hint);
  end;
end;

procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
var
  i: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, 'ÕÊºÅ') = 0 then
    nBind := 0;
  if CompareText(sType, 'ÈËÎï') = 0 then
    nBind := 1;
  if CompareText(sType, 'IP') = 0 then
    nBind := 2;

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and
    (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then
  begin
    SysMsg(Format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of
    0:
      begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          for i := 0 to g_ItemBindAccount.Count - 1 do
          begin
            ItemBind := g_ItemBindAccount.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1:
      begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          for i := 0 to g_ItemBindCharName.Count - 1 do
          begin
            ItemBind := g_ItemBindCharName.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2:
      begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          for i := 0 to g_ItemBindIPaddr.Count - 1 do
          begin
            ItemBind := g_ItemBindIPaddr.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
              nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName,
                sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
  end;
end;

procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  i: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, 'ÕÊºÅ') = 0 then
    nBind := 0;
  if CompareText(sType, 'ÈËÎï') = 0 then
    nBind := 1;
  if CompareText(sType, 'IP') = 0 then
    nBind := 2;

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and
    (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
    PlayObject := UserEngine.GetHeroObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then
  begin
    SysMsg(Format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]),
      c_Red, t_Hint);
    Exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of //
    0:
      begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          for i := 0 to g_ItemBindAccount.Count - 1 do
          begin
            ItemBind := g_ItemBindAccount.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
              nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName,
                sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1:
      begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          for i := 0 to g_ItemBindCharName.Count - 1 do
          begin
            ItemBind := g_ItemBindCharName.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
              nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName,
                sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2:
      begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          for i := 0 to g_ItemBindIPaddr.Count - 1 do
          begin
            ItemBind := g_ItemBindIPaddr.Items[i];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
              nMakeIdex) then
            begin
              SysMsg(Format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName,
                sItem]), c_Red, t_Hint);
              Exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(Format('%s[%s]IDX[%d]ÏµÁÐºÅ[%d]³Ö¾Ã[%d-%d]£¬°ó¶¨µ½%s³É¹¦',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(Format('ÄãµÄ%s[%s]ÒÑ¾­°ó¶¨µ½%s[%s]ÉÏÁË',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
  end;
end;

procedure TPlayObject.CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
var
  dwtime: LongWord;
  nIndex: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  dwtime := Str_ToInt(sTime, 5);
  g_DenySayMsgList.Lock;
  try
    nIndex := g_DenySayMsgList.GetIndex(sHumanName);
    if nIndex >= 0 then
      g_DenySayMsgList.Objects[nIndex] := TObject(GetTickCount + dwtime * 60 * 1000)
    else
      g_DenySayMsgList.AddRecord(sHumanName, GetTickCount + dwtime * 60 * 1000);
  finally
    g_DenySayMsgList.UnLock;
  end;
  SysMsg(Format(g_sGameCommandShutupHumanMsg, [sHumanName, dwtime]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShutupList(Cmd: pTGameCmd; sParam1: string);
var
  i: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    Exit;
  end;

  if (m_btPermission < 6) then
    Exit;
  g_DenySayMsgList.Lock;
  try
    if g_DenySayMsgList.Count <= 0 then
    begin
      SysMsg(g_sGameCommandShutupListIsNullMsg, c_Green, t_Hint);
      Exit;
    end;
    for i := 0 to g_DenySayMsgList.Count - 1 do
    begin
      SysMsg(g_DenySayMsgList.Strings[i] + ' ' +
        IntToStr((LongWord(g_DenySayMsgList.Objects[i]) - GetTickCount) div
        60000), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupReleaseHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  g_DenySayMsgList.Lock;
  try
    i := g_DenySayMsgList.GetIndex(sHumanName);
    if i >= 0 then
    begin
      g_DenySayMsgList.Delete(i);
      PlayObject := UserEngine.GetPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg, c_Red, t_Hint);
      end;
      if boAll then
      begin
        UserEngine.SendInterMsg(ISM_CHATPROHIBITIONCANCEL, g_nServerIndex, sHumanName);
      end;
      SysMsg(Format(g_sGameCommandShutupReleaseHumanCanSendMsg, [sHumanName]), c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdSetEvaItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
var
  StdItem: pTStdItem;
  Abil: array[0..3] of TEvaAbil;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (nWhere in [Low(THumanUseItems)..High(THumanUseItems)]) and (nValueType in [0..(27 + 3)]) and (nValue in [0..255]) then
  begin
    if m_UseItems[nWhere].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then
        Exit;
      if (StdItem.Eva.EvaTimesMax > 0) then
      begin
        SetItemEvaInfo(@m_UseItems[nWhere], t_EvaTimes, 2, Abil);

        SetItemEvaInfo(@m_UseItems[nWhere], t_Spirit, 85, Abil);
        SetItemEvaInfo(@m_UseItems[nWhere], t_SpiritMax, 125, Abil);

        SetItemEvaInfo(@m_UseItems[nWhere], t_AdvAbil, 5, Abil);

        SetItemEvaInfo(@m_UseItems[nWhere], t_AdvAbilMax, 4, Abil);

        SetItemEvaInfo(@m_UseItems[nWhere], t_Quality, 250, Abil);

        RecalcAbilitys();
        SendUpdateItem(@m_UseItems[nWhere]);
      end;
    end
    else
    begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
var
  sShowMsg: string;
  StdItem: pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;

  if (nWhere in [Low(THumanUseItems)..High(THumanUseItems)]) and (nValueType in [0..(27 + 3)]) and (nValue in [0..255]) then
  begin
    if m_UseItems[nWhere].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then
        Exit;

      if nValueType > 13 then
      begin
        if nValueType = 14 then
        begin
          nValue := _MIN(65, nValue);
          m_UseItems[nWhere].Dura := nValue * 1000;
        end
        else if nValueType = 15 then
        begin
          nValue := _MIN(65, nValue);
          m_UseItems[nWhere].DuraMax := nValue * 1000;
        end
        else if nValueType = 16 then
        begin
          m_UseItems[nWhere].btValue[14] := nValue;
        end
        else if nValueType = 17 then
        begin
          m_UseItems[nWhere].btValue[15] := _MIN(15, nValue) * 16 + m_UseItems[nWhere].btValue[15] mod 16;
        end
        else if nValueType = 18 then
        begin
          m_UseItems[nWhere].btValue[15] := m_UseItems[nWhere].btValue[15] div 16 * 16 + _MIN(15, nValue);
        end
        else if nValueType = 19 then
        begin
          m_UseItems[nWhere].btValue[16] := _MIN(15, nValue) * 16 + m_UseItems[nWhere].btValue[16] mod 16;
        end
        else if nValueType = 20 then
        begin
          m_UseItems[nWhere].btValue[16] := m_UseItems[nWhere].btValue[16] div 16 * 16 + _MIN(15, nValue);
        end
        else if nValueType = 21 then
        begin
          m_UseItems[nWhere].btValue[17] := _MIN(15, nValue) * 16 + m_UseItems[nWhere].btValue[17] mod 16;
        end
        else if nValueType = 22 then
        begin
          m_UseItems[nWhere].btValue[17] := m_UseItems[nWhere].btValue[17] div 16 * 16 + _MIN(15, nValue);
        end
        else
          m_UseItems[nWhere].btValue[nValueType - (2 + 3)] := nValue;
      end
      else
      begin
        m_UseItems[nWhere].btValue[nValueType] := nValue;
      end;
      RecalcAbilitys();
      SendUpdateItem(@m_UseItems[nWhere]);
      sShowMsg := IntToStr(m_UseItems[nWhere].wIndex) + '-' +
        IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
        IntToStr(m_UseItems[nWhere].Dura) + '/' +
        IntToStr(m_UseItems[nWhere].DuraMax) + ' ' +
        IntToStr(m_UseItems[nWhere].btValue[0]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[1]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[2]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[3]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[4]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[5]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[6]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[7]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[8]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[9]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[10]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[11]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[12]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[13]);
      //SysMsg(sShowMsg, c_Blue, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessageAPI('[ÎïÆ·µ÷Õû] ' + m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');
    end
    else
    begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: string);
var
  nTime: Integer;
  dwtime: LongWord;
begin
  if (m_btPermission < 6) then
    Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚ¿ªÊ¼Æíµ»ÉúÐ§±¦±¦ÅÑ±ä', c_Red, t_Hint);
    Exit;
  end;
  nTime := Str_ToInt(sParam1, -1);
  if nTime > 0 then
  begin
    dwtime := LongWord(nTime) * 1000;
  end
  else
  begin
    dwtime := g_Config.dwSpiritMutinyTime;
  end;

  g_dwSpiritMutinyTick := GetTickCount + dwtime;
  SysMsg('Æíµ»ÅÑ±äÒÑ¿ªÊ¼¡£³ÖÐøÊ±³¤ ' + IntToStr(dwtime div 1000) + ' Ãë',
    c_Green, t_Hint);
end;

procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then
    Exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('´ËÃüÁîÓÃÓÚÍ£Ö¹Æíµ»ÉúÐ§µ¼ÖÂ±¦±¦ÅÑ±ä', c_Red, t_Hint);
    Exit;
  end;
  g_dwSpiritMutinyTick := 0;
  SysMsg('Æíµ»ÅÑ±äÒÑÍ£Ö¹', c_Green, t_Hint);

end;

procedure TPlayObject.CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sQuestName = '') then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + Cmd.sCmd + ' ÎÊ´ðÃû³Æ', c_Red, t_Hint);
    Exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TPlayObject.CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
var
  i: Integer;
  PlayObject: TPlayObject;
  MoveHuman: TPlayObject;
  nRange: Integer;
  HumanList: TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1]
    = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandSuperTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  nRange := _MAX(10, Str_ToInt(sRange, 2));
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    HumanList := TList.Create;
    UserEngine.GetMapRageHuman(PlayObject.m_PEnvir, PlayObject.m_nCurrX,
      PlayObject.m_nCurrY, nRange, HumanList);
    for i := 0 to HumanList.Count - 1 do
    begin
      MoveHuman := TPlayObject(HumanList.Items[i]);
      if MoveHuman <> Self then
        MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap, 0);
    end;
    HumanList.Free;
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;

end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('ÏÂÂíÃüÁî£¬ÔÚÆïÂí×´Ì¬ÊäÈë´ËÃüÁîÏÂÂí', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s', [sCmd]), c_Red, t_Hint);
    Exit;
  end;
  if not m_boOnHorse then
    Exit;

  m_boOnHorse := False;
  FeatureChanged();
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: string);
begin
  if m_StallMgr.OnSale then
  begin
    SysMsg('°ÚÌ¯×´Ì¬²»ÄÜÆïÂí£¡', c_Red, t_Hint);
    Exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('ÉÏÂíÃüÁî£¬ÔÚ´÷ºÃÂíÅÆºóÊäÈë´ËÃüÁî¾Í¿ÉÒÔÆïÉÏÂí', c_Red, t_Hint);
    SysMsg(Format('ÃüÁî¸ñÊ½: @%s', [sCmd]), c_Red, t_Hint);
    Exit;
  end;
  if m_boOnHorse then
    Exit;

  if (m_btHorseType = 0) then
  begin
    SysMsg('ÆïÂí±ØÐëÏÈ´÷ÉÏÂíÅÆ', c_Red, t_Hint);
    Exit;
  end;
  m_boOnHorse := True;
  FeatureChanged();
end;

procedure TPlayObject.CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
var
  nX, nY: Integer;
  FireBurnEvent: TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY: Integer;
begin
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do
  begin
    for nY := nMinY to nMaxY do
    begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then
      begin
        FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint, 0);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
var
  btDc, btSc, btMc, btDura: Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandTestGetBagItemsHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  btDc := 0;
  btSc := 0;
  btMc := 0;
  btDura := 0;
  GetBagUseItems(btDc, btSc, btMc, btDura);
  SysMsg(Format('DC:%d SC:%d MC:%d DURA:%d', [btDc, btSc, btMc, btDura]),
    c_Blue, t_Hint);
end;

procedure TPlayObject.CmdHWID(sCmd, sParam1: string; nInt: Integer);
var
  szHWID: string;
  PlayObject: TPlayObject;
begin
  if (m_btPermission < 10) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if nInt <> 2 then
  begin
    if (sParam1 = '') then
    begin
      SysMsg(Format(g_sGameCommandParamUnKnow, [sCmd, 'ÈËÎïÃû']), c_Red, t_Hint);
      Exit;
    end;
    PlayObject := UserEngine.GetPlayObject(sParam1);
    if PlayObject = nil then
    begin
      SysMsg(Format('%s ²»ÔÚÏß£¡', [sParam1]), c_Red, t_Hint);
      Exit;
    end;
  end;
  case nInt of
    0:
      begin
        SysMsg(Format('»ñÈ¡»úÆ÷Âë: %s %s', [sParam1, MD5.MD5Print(PlayObject.m_xHWID)]), c_Red, t_Hint);
      end;
    1:
      begin
        szHWID := MD5.MD5Print(PlayObject.m_xHWID);
        m_DefMsg := MakeDefaultMsg(SM_HWID, Integer(Self), 0, 0, nInt);
        SendSocketAll(@m_DefMsg, szHWID);
      end;
    2:
      begin
        m_DefMsg := MakeDefaultMsg(SM_HWID, Integer(Self), 0, 0, nInt);
        SendSocketAll(@m_DefMsg, sParam1);
      end;
  end;
end;

procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  m_boTestSpeedMode := not m_boTestSpeedMode;
  if m_boTestSpeedMode then
  begin
    SysMsg('¿ªÆôËÙ¶È²âÊÔÄ£Ê½', c_Red, t_Hint);
  end
  else
  begin
    SysMsg('¹Ø±ÕËÙ¶È²âÊÔÄ£Ê½', c_Red, t_Hint);
  end;

end;

procedure TPlayObject.CmdTestStatus(sCmd: string; nType, nTime: Integer);
begin
  if (m_btPermission < 6) then
    Exit;
  if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0) then
  begin
    SysMsg('ÃüÁî¸ñÊ½: @' + sCmd + ' ÀàÐÍ(0..11) Ê±³¤', c_Red, t_Hint);
    Exit;
  end;
  m_wStatusTimeArr[nType] := nTime;
  m_dwStatusArrTick[nType] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  StatusChanged();
  SysMsg(Format('×´Ì¬±àºÅ:%d Ê±¼ä³¤¶È: %d Ãë', [nType, nTime]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdTing(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandTingHelpMsg]), c_Red, t_Hint);
    Exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.MapRandomMove(m_sHomeMap, 0);
  end
  else
  begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTraining(sSkillName: string; nLevel: Integer);
begin
  if (m_btPermission < 6) then
    Exit;
end;

procedure TPlayObject.CmdUserMoveXY(sCmd, sX, sY: string);
var
  nX, nY: Integer;
  boUseAmulet: Boolean;
  nAmuletIdx: Integer;
begin
  if m_boTeleport then
    boUseAmulet := True
  else
    boUseAmulet := CheckAmulet(1, 3, nAmuletIdx);
  if boUseAmulet then
  begin
    nX := Str_ToInt(sX, -1);
    nY := Str_ToInt(sY, -1);
    if not m_PEnvir.m_MapFlag.boNOPOSITIONMOVE then
    begin
      if not m_PEnvir.CanWalk(nX, nY, True) then
      begin
        SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName, sX, sY]), c_Green, t_Hint);
        Exit;
      end;
      
      if m_PEnvir.CanWalkOfItem(nX, nY, g_Config.boUserMoveCanDupObj, g_Config.boUserMoveCanOnItem) then
      begin
        if (GetTickCount - m_dwTeleportTick) > g_Config.dwUserMoveTime * 1000 then
        begin
          m_dwTeleportTick := GetTickCount();
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          SpaceMove(m_sMapName, nX, nY, 0);
          if not m_boTeleport and boUseAmulet then
            UseAmulet(1, 3, nAmuletIdx);
        end
        else
          SysMsg(IntToStr(g_Config.dwUserMoveTime - (GetTickCount - m_dwTeleportTick) div 1000) + 'ÃëÖ®ºó²Å¿ÉÒÔÔÙÊ¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
      end
      else
        SysMsg(Format(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName, sX, sY]), c_Green, t_Hint);
    end
    else
      SysMsg('´ËµØÍ¼½ûÖ¹Ê¹ÓÃ´ËÃüÁî', c_Red, t_Hint);
  end
  else
    SysMsg('Î´Åå´÷´«ËÍ×°±¸£¬ÎÞ·¨Ê¹ÓÃ´Ë¹¦ÄÜ', c_Red, t_Hint);
end;

procedure TPlayObject.CmdViewDiary(sCmd: string; nFlag: Integer); //004D1B70
begin

end;

procedure TPlayObject.CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2:
  string);
var
  PlayObject: TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then
  begin
    SysMsg(Format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandViewWhisperHelpMsg]), c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sCharName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_GetWhisperHuman = Self then
    begin
      PlayObject.m_GetWhisperHuman := nil;
      SysMsg(Format(g_sGameCommandViewWhisperMsg1, [sCharName]), c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_GetWhisperHuman := Self;
      SysMsg(Format(g_sGameCommandViewWhisperMsg2, [sCharName]), c_Green, t_Hint);
    end;
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sCharName]), c_Red, t_Hint);
end;

constructor TPlayObject.Create;
var
  dwTick: LongWord;
begin
  inherited;

  FillChar(m_xHWID, SizeOf(m_xHWID), 0);
  FillChar(m_DetectItem, SizeOf(m_DetectItem), 0);
  m_dwDetectItemTick := 0;

  m_boGetHeros := False;
  m_boSendHeros := False;
  FillChar(m_Heros, SizeOf(THerosInfo), #0);

  m_boCanBind := False;
  m_boCanUnBind := False;
  m_wGroupRcallTime := 0;
  m_dwGroupRcallTick := GetTickCount();
  m_boAllowGroupReCall := False;
  FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);

  m_boAllowGroup := False;
  m_boAllowGuild := False;

  m_sMarkerMap := '';
  m_wMarkerX := 0;
  m_wMarkerY := 0;

  FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit), #0);
  FillChar(m_QuestUnit, SizeOf(TQuestUnit), #0);

  dwTick := GetTickCount();
  m_btRaceServer := RC_PLAYOBJECT;
  m_boNameChangeColor := False;
  m_boEmergencyClose := False;
  m_boSwitchData := False;
  m_boReconnection := False;
  m_boKickFlag := False;
  m_boSoftClose := False;
  m_boOffLineFlag := False;
  m_boOffLinePlay := False;
  m_boOffLineLogin := False;
  m_boSetOffLine := False;
  m_sOffLineLeaveword := '';
  m_boReadyRun := False;
  m_dwSaveRcdTick := dwTick;
  m_boWantRefMsg := True;
  m_boRcdSaved := False;
  m_nNewHeroOK := 88;
  m_boDieInFight3Zone := False;
  m_Script := nil;
  m_LastNPC := nil;
  m_sGotoNpcLabel := '';
  //m_nDelayCall := 0;
  //m_sDelayCallLabel := '';
  m_DelayCallList := TList.Create;
  FillChar(m_aScriptTimers, SizeOf(TScriptTimers), #0);
  //m_boDelayCall := False;
  //m_DelayCallNPC := 0;
  m_boTimeRecall := False;
  m_sMoveMap := '';
  m_nMoveX := 0;
  m_nMoveY := 0;
  m_dwRunTick := 0;
  m_nRunTime := 250;
  m_dwSearchTime := 1200;
  m_dwSearchTick := dwTick;
  m_nViewRangeX := 12; //4
  m_nViewRangeY := 12; //3
  m_boNewHuman := False;
  m_boLoginNoticeOK := False;
  m_boTryPlayMode := False;
  m_boExpire := False;
  m_boSendNotice := False;
  m_boSendImageFileCustom := False;
  m_boSendSafeZoneEffectCustom := False;
  m_boSendNpcCustom := False;
  m_dwCheckDupObjTick := dwTick;
  m_dwLogonTimcCostTick := dwTick;
  m_dwSafeZoneCheckTick := dwTick;
  m_boInSafeArea := False;
  //m_nStatusGoodCount := 0;
  m_dwMagicAttackTick := dwTick;
  m_dwMagicAttackInterval := 0;
  m_dwAttackTick := dwTick;
  m_dwMoveTick := dwTick;
  m_dwTurnTick := dwTick;
  m_dwActionTick := dwTick;
  m_dwAttackCount := 0;
  m_dwAttackCountA := 0;
  m_dwMagicAttackCount := 0;
  m_dwMoveCount := 0;
  m_nOverSpeedCount := 0;
  //m_sOldSayMsg := '';
  m_LastNimbusCount := 0;
  m_nTagDropPlus := 0;
  m_nPreventDrop := 0;
  //m_boHideSendSayMsg := False;
  m_dwRefNimbusStateTick := dwTick;
  m_dwSayMsgTick := dwTick;
  m_boDisableSayMsg := False;
  m_dwDisableSayMsgTick := dwTick;
  m_dLogonTime := Now();
  m_dwLogonTick := dwTick;
  m_boSwitchData := False;
  m_boSwitchDataNeedDelay := False;
  m_nWriteChgDataErrCount := 0;
  m_dwShowLineNoticeTick := dwTick;
  m_nShowLineNoticeIdx := 0;
{$IF VER_ClientType_45}
  m_nSoftVersionDateEx := 0;
{$IFEND VER_ClientType_45}
  m_CanJmpScriptLableList := TStringList.Create;
  m_nKillMonExpMultiple := 1;
  m_nKillMonExpRate := 100;
  m_dwRateTick := dwTick;
  m_nPowerRate := 100;
  m_boSetItemCode := False;
  m_boSetStoragePwd := False;
  m_boReConfigPwd := False;
  m_boCheckOldPwd := False;
  m_boUnLockPwd := False;
  m_boUnLockStoragePwd := False;
  m_btPwdFailCount := 0;
  m_sTempPwd := '';
  m_sStoragePwd := '';
  m_boFilterSendMsg := False;
  m_boCanRecallHero := True;
  m_boCanDeal := True;
  m_boCanDrop := True;
  m_boCanGetBackItem := True;
  m_boCanWalk := True;
  m_boCanRun := True;
  m_boCanHit := True;
  m_boCanSpell := True;
  m_boCanUseItem := True;
  m_nMemberType := 0;
  m_nMemberLevel := 0;

  m_nGameGold := 0;
  m_boDecGameGold := False;
  m_nDecGameGold := 1;
  m_dwDecGameGoldTick := dwTick;
  m_dwDecGameGoldTime := 60 * 1000;

  m_boIncGameGold := False;
  m_nIncGameGold := 1;
  m_dwIncGameGoldTick := dwTick;
  m_dwIncGameGoldTime := 60 * 1000;

  m_nGamePoint := 0;
  m_dwIncGamePointTick := dwTick;
  m_dwDecGamePointTick := dwTick;

  m_DearHuman := nil;
  m_MasterHuman := nil;
  m_MasterList := TList.Create;
  m_boSendMsgFlag := False;
  m_boChangeItemNameFlag := False;

  m_boCanMasterRecall := False;
  m_boCanDearRecall := False;
  m_dwDearRecallTick := dwTick;
  m_dwMasterRecallTick := dwTick;
  m_btReColorIdx := 0;
  m_GetWhisperHuman := nil;
  m_boOnHorse := False;
  m_sRankLevelName := g_sRankLevelName;
  m_boFixedHideMode := True;
  FillChar(m_nMval, SizeOf(m_nMval), #0);
  FillChar(m_DyVal, SizeOf(m_DyVal), #0);
  FillChar(m_nSval, SizeOf(m_nSval), #0);
  m_dwAutoClearEctypeTick := GetTickCount;
  m_dwAutoGetExpTick := GetTickCount;
  m_nAutoGetExpPoint := 0;
  m_AutoGetExpEnvir := nil;
  m_dwHitIntervalTime := g_Config.dwHitIntervalTime; //¹¥»÷¼ä¸ô
  m_dwMagicHitIntervalTime := g_Config.dwMagicHitIntervalTime; //Ä§·¨¼ä¸ô
  m_dwRunIntervalTime := g_Config.dwRunIntervalTime; //×ßÂ·¼ä¸ô
  m_dwWalkIntervalTime := g_Config.dwWalkIntervalTime; //×ßÂ·¼ä¸ô
  m_dwTurnIntervalTime := g_Config.dwTurnIntervalTime; //»»·½Ïò¼ä¸ô
  m_dwActionIntervalTime := g_Config.dwActionIntervalTime; //×éºÏ²Ù×÷¼ä¸ô
  m_dwRunLongHitIntervalTime := g_Config.dwRunLongHitIntervalTime; //×éºÏ²Ù×÷¼ä¸ô
  m_dwRunHitIntervalTime := g_Config.dwRunHitIntervalTime; //×éºÏ²Ù×÷¼ä¸ô
  m_dwWalkHitIntervalTime := g_Config.dwWalkHitIntervalTime; //×éºÏ²Ù×÷¼ä¸ô
  m_dwRunMagicIntervalTime := g_Config.dwRunMagicIntervalTime; //ÅÜÎ»Ä§·¨¼ä¸ô
  m_DynamicVarList := TList.Create;
  m_boTestSpeedMode := False;
  m_boLockLogoned := False;
  m_boRemoteMsg := False;
  //New(m_PowerBlock);
  //Move(g_PowerBlock, m_PowerBlock^, SizeOf(TPowerBlock));

  m_dwSendWhisperTick := dwTick;
  m_boClientVerOK := False;
  Randomize();
  m_sRandomNo := IntToStr(Random(9999));

  m_dwDoFlyTick := GetTickCount;
  m_dwMagicIceRainTick := GetTickCount;
  m_dwMagicDeadEyeTick := GetTickCount;

  m_nCanRun := -1;
  m_dwCanRunTime := 0;
  m_sOffLineLabel := '';
  FillChar(m_btGetShopItem, 6, #0);
  m_btHeroMakeSlave := 4;
  m_dwRecallHeroTick := 0;
{$IF SERIESSKILL}
  m_btReadySeriesSkill := 0;
  m_btSeriesSkillSetpCur := 8;
  m_btSeriesSkillSetpMax := 0;
  m_dwReadySeriesSkillTick := GetTickCount();
  m_dwCanNextMoveTick := 0;
{$IFEND SERIESSKILL}

  m_dwQueryBagItemsTick := 0;
  m_HeroObject := nil;
  m_Escort := nil;
  m_HeroRcd := nil;
  FillChar(m_MakerMapInfo, SizeOf(TMakerMapInfo), #0);
  FillChar(m_aBoxItems, SizeOf(TBoxItems), #0);
  m_nBoxIndex := 9;
  m_boCanGetRareBoxItem := False;
  m_dwLatestDropTime := GetTickCount;

  m_GroupOwner := nil;
  m_GroupMembers := TStringList.Create;
  m_boDealing := False;
  m_DealCreat := nil;
  m_DealGoldCreat := nil;

  m_UserMarket := TMarketItemManager.Create;
  m_MarketNpc := nil;
  m_boFlagUserMarket := False;
  m_boFlagReadyToSellCheck := False;
  m_dwGatherExp := 0;
  m_dwGatherIPExp := 0;
  m_dwGatherNimbus := 0;
  m_dwGatherExpTick := GetTickCount;
  m_dwGatherIPExpTick := GetTickCount;
  m_dwGatherNimbusTick := GetTickCount;
  m_dwGatherNimbusTick2 := GetTickCount;
  m_boTakeDlgItem := False;
  m_nDlgItemIndex := 0;
  m_nPerInPower := 1;
  m_dwIncInPowerTick := GetTickCount;
  m_boHeroSidestep := False;
  m_boHeroTargetFilter := False;
  m_nHeroSidestepHP := 0;
  m_BlockWhisperList := TStringList.Create;
  m_MissionList := TStringList.Create;
  m_VisibleEvents := TList.Create;
  m_VisibleItems := TList.Create;

  m_boQueryRankOK := False;
  m_nLvRankType := 0;
  m_nLvRankResult := 0;
  m_sSendRankData := '';
{$IF SERIESSKILL}
  FillChar(m_SeriesSkillArr, SizeOf(m_SeriesSkillArr), 0);
  FillChar(m_SeriesSkillArr2, SizeOf(m_SeriesSkillArr2), 0);
  FillChar(m_VenationInfos, SizeOf(m_VenationInfos), 0);
{$IFEND SERIESSKILL}
  m_boInSafeArea := False;

  m_boInSafeZone := False;
  m_boSendInSafeZone := False;

  m_btValNPCType := 0;
  m_btValType := 0;
  m_btValLabel := 0;

  m_btCollectExpLv := 0;
  m_dwCollectExp := 0;
  m_dwCollectIPExp := 0;

  m_StallMgr := TStallMgr.Create;

  m_btHitPowerAddOn := 0;
  m_status := 0;
end;

procedure TPlayObject.DealCancel();
var
  pu: pTUserItem;
  ps: pTStdItem;
  i: Integer;
begin
  if not m_boDealing then
    Exit;
  m_boDealing := False;
  SendDefMessage(SM_DEALCANCEL, 0, 0, 0, 0, '');

  if m_DealItemList.Count > 0 then
  begin
    for i := m_DealItemList.Count - 1 downto 0 do
    begin
      pu := pTUserItem(m_DealItemList[i]);
      ps := UserEngine.GetStdItem(pu.wIndex);
      if ps = nil then
        Continue;

      if (ps.Overlap >= 1) then
      begin

        if UserCounterItemAdd(ps.StdMode, ps.Looks, pu.Dura, ps.Name, True) then
        begin

        end
        else
        begin
          m_ItemList.Add(m_DealItemList[i]);
          SendAddItem(pTUserItem(m_DealItemList[i]));
        end;
      end;
    end;
  end;

  if m_DealCreat <> nil then
    TPlayObject(m_DealCreat).DealCancel;
  m_DealCreat := nil;
  GetBackDealItems();
  SysMsg(g_sDealActionCancelMsg, c_Green, t_Hint);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.DealCancelA();
begin
  m_Abil.HP := m_WAbil.HP;
  DealCancel();
end;

function TPlayObject.DecGold(nGold: Integer): Boolean;
begin
  Result := False;
  if m_nGold >= nGold then
  begin
    Dec(m_nGold, nGold);
    Result := True;
  end;
end;

destructor TPlayObject.Destroy;
var
  i, code: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::Destroy %s(%s/%d/%d) Code: %d';
begin
  code := 0;
  try
    code := 1; ////////////////////
    m_BlockWhisperList.Free;

    code := 2;
    m_MasterList.Free;

    code := 3;
    for i := 0 to m_DynamicVarList.Count - 1 do
      Dispose(pTDynamicVar(m_DynamicVarList[i]));
    m_DynamicVarList.Free;

    code := 4;
    m_MissionList.Free;

    //for i := 0 to m_CustomDataList.Count - 1 do
    //  Dispose(pTCustomData(m_CustomDataList.Items[i]));
    //m_CustomDataList.Free;

    code := 5;
    m_CanJmpScriptLableList.Free;

    //code := 6;
    //Dispose(m_PowerBlock);

    code := 7;
    m_GroupMembers.Free;

    code := 8;
    if m_ChgSlaveList <> nil then
      m_ChgSlaveList.Free;

    code := 9;
    if m_HeroRcd <> nil then
      Dispose(m_HeroRcd);

    code := 10;
    m_UserMarket.Free;

    code := 11;
{$IF NewVisibleEvent = 1}
    for i := 0 to m_VisibleEvents.Count - 1 do
      Dispose(pTVisibleEvent(m_VisibleEvents[i]));
{$IFEND}
    m_VisibleEvents.Free;

    code := 12;
    for i := 0 to m_VisibleItems.Count - 1 do
      Dispose(pTVisibleMapItem(m_VisibleItems[i]));
    m_VisibleItems.Free;

    code := 13;
    for i := 0 to m_DelayCallList.Count - 1 do
      Dispose(PTDelayCallNPC(m_DelayCallList[i]));
    m_DelayCallList.Free;

    m_StallMgr.Free; //120806
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, code]));
      MainOutMessageAPI(E.Message);
    end;
  end;
  inherited;
end;

procedure TPlayObject.Disappear();
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if m_boReadyRun then
      DisappearA;
    if m_boTransparent and m_boHideMode then
      m_wStatusTimeArr[STATE_TRANSPARENT] := 0;
    if m_GroupOwner <> nil then
      m_GroupOwner.DelMember(Self);
    if m_MyGuild <> nil then
      TGuild(m_MyGuild).DelHumanObj(Self);
    LogonTimcCost();
  end;
  inherited;
end;

procedure TPlayObject.DropUseItems(BaseObject: TBaseObject);
var
  i, nPKLevel: Integer;
  nRate, nRate2: Integer;
  StdItem: pTStdItem;
  DelList: TStringList;
  nTagDropPlus, nPreventDrop: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::DropUseItems';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited DropUseItems(BaseObject);
    Exit;
  end;

  if m_boNoDropUseItemEx then
    Exit;
  if (m_btRaceServer = RC_PLAYOBJECT) and g_Config.boNoDropItemOfGameGold and (m_nGameGold > g_Config.nNoDropItemGamegold) then
    Exit;
  DelList := nil;
  try
    if (m_boAngryRing or m_boNoDropUseItem)
{$IF CustomBuild = 1}
    and ((m_ExpHitter <> nil) and not m_ExpHitter.m_boUnAngryRing)
{$IFEND} then
      Exit;

    if g_Config.boDieDropUseItemRateSingle then
    begin
      nPKLevel := PKLevel;

      for i := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if m_UseItems[i].wIndex <= 0 then
          Continue;

        if (PCardinal(@m_UseItems[i].btValue[22])^ > 0) and (PCardinal(@m_UseItems[i].btValue[22])^ = m_dwIdCRC) then
        begin
          if g_Config.boBindNoScatter then
            Continue;
        end;

        if nPKLevel > 2 then
          nRate := Round(g_Config.aDieDropUseItemRate[i] / 10 * g_Config.nDieRedDropUseItemRateSingle)
        else
          nRate := g_Config.aDieDropUseItemRate[i];

        if nRate <= 0 then
          nRate := 1;
        nRate2 := Round(1 * 10000 / nRate);

        nPreventDrop := 0;
        if m_nPreventDrop > 0 then
          nPreventDrop := m_nPreventDrop;

        nTagDropPlus := 0;
        if (m_LastHiter <> nil) then
        begin
          if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
          begin
            nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
          end;
        end;

        nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);

        //nRate := _MAX(1, nRate + nPreventDrop - nTagDropPlus);

        if (nRate2 <= Random(10000)) or InLimitItemList('', m_UseItems[i].wIndex, t_dTakeOff) or InLimitItemList('', m_UseItems[i].wIndex, t_nsc) then
          Continue;
        if DropItemDown(@m_UseItems[i], g_Config.nScatterRange, True, BaseObject, Self) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
          if StdItem <> nil then
          begin
            //if StdItem.Reserved and 10 = 0 then begin
            if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[i].wIndex), TObject(m_UseItems[i].MakeIndex));
            end;
            m_UseItems[i].wIndex := 0;
            SysMsg(Format('[ÉíÉÏµôÂä] %s', [StdItem.Name]), c_Purple, t_Hint);
            //end;
          end;
        end;
      end;
      if DelList <> nil then
      begin
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
        RecalcAbilitys();
      end;

      Exit;
    end;

    if PKLevel > 2 then
      nRate := g_Config.nDieRedDropUseItemRate {15}
    else
      nRate := g_Config.nDieDropUseItemRate {30};

    if nRate <= 0 then
      nRate := 1;
    nRate2 := Round(1 * 10000 / nRate);

    nPreventDrop := 0;
    if m_nPreventDrop > 0 then
      nPreventDrop := m_nPreventDrop;

    nTagDropPlus := 0;
    if (m_LastHiter <> nil) then
    begin
      if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
      begin
        nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
      end;
    end;

    nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);

    //nRate := _MAX(1, nRate + nPreventDrop - nTagDropPlus);

    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex <= 0 then
        Continue;

      if (PCardinal(@m_UseItems[i].btValue[22])^ > 0) and (PCardinal(@m_UseItems[i].btValue[22])^ = m_dwIdCRC) then
      begin
        if g_Config.boBindNoScatter then
          Continue;
      end;

      if (nRate2 <= Random(10000)) or InLimitItemList('', m_UseItems[i].wIndex, t_dTakeOff) or InLimitItemList('', m_UseItems[i].wIndex, t_nsc) then
        Continue;
      if DropItemDown(@m_UseItems[i], g_Config.nScatterRange, True, BaseObject, Self) then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if StdItem <> nil then
        begin
          //if StdItem.Reserved and 10 = 0 then begin
          if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          begin
            if DelList = nil then
              DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[i].wIndex), TObject(m_UseItems[i].MakeIndex));
          end;
          m_UseItems[i].wIndex := 0;
          SysMsg(Format('[ÉíÉÏµôÂä] %s', [StdItem.Name]), c_Purple, t_Hint);
          //end;
        end;
      end;
    end;
    if DelList <> nil then
    begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      RecalcAbilitys();
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
  DropUseItemsWithoutFail(nil);
end;

procedure TPlayObject.DropUseItemsWithoutFail(BaseObject: TBaseObject);
var
  i: Integer;
  StdItem: pTStdItem;
  DelList: TStringList;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::DropUseItems_WithoutFail';
begin
  DelList := nil;
  try
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex <= 0 then
        Continue;
      if InLimitItemList('', m_UseItems[i].wIndex, t_sDrop) then
      begin
        if DropItemDown(@m_UseItems[i], g_Config.nScatterRange, True, BaseObject, Self) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
          if StdItem <> nil then
          begin
            //if StdItem.Reserved and 10 = 0 then begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[i].wIndex), TObject(m_UseItems[i].MakeIndex));
            end;
            m_UseItems[i].wIndex := 0;
            SysMsg(Format('[Ç¿ÖÆµôÂä] %s', [StdItem.Name]), c_Purple, t_Hint);
            //end;
          end;
        end;
      end;
    end;
    if DelList <> nil then
    begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      RecalcAbilitys();
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.GainExp(dwExp: LongWord; nMonLevel: Integer; bipexp: Boolean);
var
  i, nGroupCount, nSumLevel: Integer;
  dwGroupExp, dwPlayExp: LongWord;
  PlayObject: TPlayObject;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::GainExp %d';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  if m_GroupOwner = nil then
  begin
    WinExp(dwExp, bipexp);
    Exit;
  end;
  nSumLevel := 0;
  nGroupCount := 0;
  for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
    if not PlayObject.m_boDeath and not PlayObject.m_boGhost and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrY - PlayObject.m_nCurrY) <= 12) then
    begin
      nSumLevel := nSumLevel + PlayObject.m_Abil.Level;
      Inc(nGroupCount);
    end;
  end;

  if (nSumLevel > 0) and (nGroupCount > 1) then
  begin
    dwGroupExp := 0;
    if nGroupCount in [2..GROUPMAX] then
      dwGroupExp := Round(dwExp / 100 * g_Config.GroupExpHumRate[nGroupCount - 2])
    else if nGroupCount > GROUPMAX then
      dwGroupExp := Round(dwExp / 100 * g_Config.GroupExpHumRate[High(g_Config.GroupExpHumRate)]);
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrY - PlayObject.m_nCurrY) <= 12) then
      begin
        if g_Config.boHighLevelKillMonFixExp and g_Config.boHighLevelGroupFixExp then
          dwPlayExp := Round(dwGroupExp / nGroupCount)
        else
          dwPlayExp := Round(dwGroupExp / nSumLevel * PlayObject.m_Abil.Level);

        if dwPlayExp > dwExp then  dwPlayExp := dwExp;
        
        if g_Config.boHighLevelGroupFixExp then
        begin
          PlayObject.WinExp(dwPlayExp, bipexp);
        end
        else
        begin
          PlayObject.WinExp(PlayObject.CalcGetExp(nMonLevel, dwPlayExp), bipexp);
        end;
      end;
    end;
  end
  else
  begin
    //
    WinExp(dwExp, bipexp);
  end;
  {except
    on E: Exception do begin
      MainOutMessageAPI(Format(sExceptionMsg, [nC]));
      MainOutMessageAPI(E.Message);
    end;
  end;}
end;

procedure TPlayObject.GameTimeChanged;
begin
  if (m_nBright <> g_nGameTime) or (m_Time <> g_Time) then
  begin
    m_Time := g_Time;
    m_nBright := g_nGameTime;
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.GetBackDealItems;
var
  i: Integer;
  ps: pTStdItem;
begin
  if m_DealItemList.Count > 0 then
  begin
    for i := 0 to m_DealItemList.Count - 1 do
    begin
      ps := UserEngine.GetStdItem(pTUserItem(m_DealItemList[i]).wIndex);
      if ps = nil then
        Continue;
      if ps.Overlap <= 0 then
      begin
        m_ItemList.Add(m_DealItemList.Items[i]);
        CheckDelBagCopyed();
      end;
    end;
    m_DealItemList.Clear;
  end;
  Inc(m_nGold, m_nDealGolds);
  m_nDealGolds := 0;
  m_boDealOK := False;
end;

procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
var
  i, ii: Integer;
  DuraList: TList;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  DelItemList: TStringList;
  nDc, nSc, nMc, nDcMin, nDcMax, nScMin, nScMax, nMcMin, nMcMax, nDura, nItemCount: Integer;
begin
  nDcMin := 0;
  nDcMax := 0;
  nScMin := 0;
  nScMax := 0;
  nMcMin := 0;
  nMcMax := 0;
  nDura := 0;
  nItemCount := 0;
  DelItemList := nil;
  DuraList := TList.Create;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
      begin
        Continue;
      end;
    end;
    if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then
    begin
      DuraList.Add(Pointer(Round(UserItem.Dura / 1.0E3)));
      if DelItemList = nil then
        DelItemList := TStringList.Create;
      DelItemList.AddObject(g_Config.sBlackStone, TObject(UserItem.MakeIndex));
      Dispose(UserItem);
      m_ItemList.Delete(i);
    end
    else
    begin
      if IsUseItem(UserItem.wIndex) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          StdItem80 := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, StdItem80);
          nDc := 0;
          nSc := 0;
          nMc := 0;
          case StdItem80.StdMode of
            19, 20, 21:
              begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            22, 23:
              begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            24, 26:
              begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
              end;
          end;
          if nDcMin < nDc then
          begin
            nDcMax := nDcMin;
            nDcMin := nDc;
          end
          else
          begin
            if nDcMax < nDc then
              nDcMax := nDc;
          end;
          if nScMin < nSc then
          begin
            nScMax := nScMin;
            nScMin := nSc;
          end
          else
          begin
            if nScMax < nSc then
              nScMax := nSc;
          end;
          if nMcMin < nMc then
          begin
            nMcMax := nMcMin;
            nMcMin := nMc;
          end
          else
          begin
            if nMcMax < nMc then
              nMcMax := nMc;
          end;
          if DelItemList = nil then
            DelItemList := TStringList.Create;
          DelItemList.AddObject(StdItem.Name, TObject(UserItem.MakeIndex));
          if StdItem.NeedIdentify = 1 then
            AddGameDataLogAPI('26' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '1' + #9 +
              '0');
          Dispose(UserItem);
          m_ItemList.Delete(i);
        end;
      end;
    end;
  end;
  for i := 0 to DuraList.Count - 1 do
  begin
    for ii := DuraList.Count - 1 downto i + 1 do
    begin
      if Integer(DuraList.Items[ii]) > Integer(DuraList.Items[ii - 1]) then
        DuraList.Exchange(ii, ii - 1);
    end;
  end;
  for i := 0 to DuraList.Count - 1 do
  begin
    nDura := nDura + Integer(DuraList.Items[i]);
    Inc(nItemCount);
    if nItemCount >= 5 then
      Break;
  end;
  btDura := Round(_MIN(5, nItemCount) + _MIN(5, nItemCount) * ((nDura / _MAX(1, nItemCount)) / 5.0));
  btDc := nDcMin div 5 + nDcMax div 3;
  btSc := nScMin div 5 + nScMax div 3;
  btMc := nMcMin div 5 + nMcMax div 3;
  if DelItemList <> nil then
    SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelItemList), 0, 0, '');
  if DuraList <> nil then
    DuraList.Free;
end;

function TPlayObject.GetPlayObjectInfo: string;
var
  sHeroName: string;
begin
  sHeroName := '';
  if m_sHeroName <> '' then
    sHeroName := Format(' (Ó¢ÐÛ: %s)', [m_sHeroName]);
  Result := m_sCharName + sHeroName +
    ' ±êÊ¶:' + IntToHex(Integer(Self), 2) +
    ' È¨ÏÞµÈ¼¶: ' + IntToStr(m_btPermission) +
    ' ¹ÜÀíÄ£Ê½: ' + BoolToCStr(m_boAdminMode) +
    ' ÒþÉíÄ£Ê½: ' + BoolToCStr(m_boObMode) +
    ' ÎÞµÐÄ£Ê½: ' + BoolToCStr(m_boSuperMan) +
    ' µØÍ¼:' + m_sMapName + '(' + m_PEnvir.m_sMapDesc + ')' +
    ' ×ù±ê:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
    ' µÈ¼¶:' + IntToStr(m_Abil.Level) +
    ' ×ªÉúµÈ¼¶:' + IntToStr(m_btReLevel) +
    ' ¾­Ñé:' + IntToStr(m_Abil.Exp) +
    ' ÉúÃüÖµ: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
    ' Ä§·¨Öµ: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
    ' ¹¥»÷Á¦: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) +
    ' Ä§·¨Á¦: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) +
    ' µÀÊõ: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) +
    ' ·ÀÓùÁ¦: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) +
    ' Ä§·ÀÁ¦: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) +
    ' ×¼È·:' + IntToStr(m_btHitPoint) +
    ' Ãô½Ý:' + IntToStr(m_btSpeedPoint) +
    ' ËÙ¶È:' + IntToStr(m_nHitSpeed) +
    ' ²Ö¿âÃÜÂë:' + m_sStoragePwd +
{$IF EXPIPLOCAL=1}
  ' µÇÂ¼IP:' + m_sIPaddr + '(' + GetIPLocal(m_sIPaddr) + ')' +
{$ELSE}
  ' µÇÂ¼IP:' + m_sIPaddr + '(' + m_sIPLocal + ')' +
{$IFEND}
  ' µÇÂ¼ÕÊºÅ:' + m_sUserID +
    ' µÇÂ¼Ê±¼ä:' + DateTimeToStr(m_dLogonTime) +
    ' ÔÚÏßÊ±³¤(·ÖÖÓ):' + IntToStr((GetTickCount - m_dwLogonTick) div 60000) +
    ' µÇÂ¼Ä£Ê½:' + IntToStr(m_nPayMent) +
    ' ' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
    ' ' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
    ' ' + g_Config.sPayMentPointName + ':' + IntToStr(m_nPayMentPoint) +
    ' »áÔ±ÀàÐÍ:' + IntToStr(m_nMemberType) +
    ' »áÔ±µÈ¼¶:' + IntToStr(m_nMemberLevel) +
    ' ¾­Ñé±¶Êý:' + CurrToStr(m_nKillMonExpRate / 100) +
    ' ¹¥»÷±¶Êý:' + CurrToStr(m_nPowerRate / 100) +
    ' ÉùÍûÖµ:' + IntToStr(m_btCreditPoint) +
    ' Ïß³ÌID:' + IntToStr(m_nSessionID);
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_BUTCH) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.UseLamp;
var
  nOldDura: Integer;
  nDura: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::UseLamp';
begin
  try
    if m_UseItems[U_RIGHTHAND].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
      if (StdItem = nil) or (StdItem.Source <> 0) then
        Exit;
      nOldDura := Round(m_UseItems[U_RIGHTHAND].Dura / 1000);
      if g_Config.boDecLampDura then
        nDura := m_UseItems[U_RIGHTHAND].Dura - 1
      else
        nDura := m_UseItems[U_RIGHTHAND].Dura;
      if nDura <= 0 then
      begin
        nDura := 0;
        m_UseItems[U_RIGHTHAND].Dura := nDura;
        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        begin
          PlayObject := TPlayObject(Self);
          if (PCardinal(@m_UseItems[U_RIGHTHAND].btValue[22])^ > 0) and (PCardinal(@m_UseItems[U_RIGHTHAND].btValue[22])^ = PlayObject.m_dwIdCRC) and g_Config.boBindNoMelt then
          begin
            if nOldDura <> Round(nDura / 1000) then
            begin
              SendMsg(Self, RM_LAMPCHANGEDURA, U_RIGHTHAND, nDura, m_UseItems[U_RIGHTHAND].DuraMax, 0, '');
              SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÊôÐÔÊ§Ð§£¬Çë¼°Ê±ÐÞÀí', [StdItem.Name]), c_Red, t_Hint);
            end;
          end
          else
          begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('3' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                StdItem.Name + #9 +
                IntToStr(m_UseItems[U_RIGHTHAND].MakeIndex) + #9 +
                BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                '0');
            PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
            m_UseItems[U_RIGHTHAND].wIndex := 0;
          end;
        end
        else
          m_UseItems[U_RIGHTHAND].wIndex := 0;
        m_nLight := 0;
        SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
        //SendMsg(self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');   //0905
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        Exit;
      end
      else
        m_UseItems[U_RIGHTHAND].Dura := nDura;
      if nOldDura <> Round(nDura / 1000) then
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

function TBaseObject.GetPoseCreate(): TBaseObject;
var
  nX, nY: Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then
    Result := m_PEnvir.GetMovingObject(nX, nY, True);
end;

function TBaseObject.GetPoseCreateA(): TBaseObject;
var
  nX, nY: Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then
  begin
    Result := m_PEnvir.GetMovingObjectA(nX, nY, True);
  end;
end;

function TBaseObject.GetPoseCreateB(): TBaseObject;
var
  nX, nY: Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then
  begin
    Result := m_PEnvir.GetMovingObject(nX, nY, True);
  end;
end;

{procedure TPlayObject.SetHeroOprateCMD(Value: Boolean);
begin
  if FHeroOprateCMD <> Value then
    FHeroOprateCMD := Value;
end; }

procedure TPlayObject.ClientQueryBagItems();
var
  i, nIDt, nDt: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
resourcestring
  sItemExpiresMsg = 'ÄãµÄÎïÆ·£º¡¼%s¡½´ïµ½Ê¹ÓÃÆÚÏÞ£¬ÒÑ±»ÏµÍ³×Ô¶¯»ØÊÕ£¡';
label
  lOutCheck, lOutCheckA;
begin
  m_boSendInSafeZone := True;
  m_dwSafeZoneCheckTick := 0;
{$IF VER_ClientType_45}
  if m_nSoftVersionDateEx = 0 then
  begin
    sSENDMSG := '';
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;

        {CheckItemExpires}
        if StdItem.StdMode = 2 then
        begin
          case StdItem.Shape of
            18:
              begin
                CopyMemory(@nIDt, @UserItem.btValue, SizeOf(Integer));
                if nIDt = 0 then
                  goto lOutCheck;
                nDt := GetItemFormatDate();
                nIDt := Round((nDt - nIDt) / (24 * 60 * 60));
                if OClientItem.s.DuraMax - nIDt > 0 then
                  Dec(OClientItem.s.DuraMax, nIDt)
                else
                begin
                  //SendDelItems(UserItem);
                  Dispose(UserItem);
                  m_ItemList.Delete(i);
                  SysMsg(Format(sItemExpiresMsg, [OClientItem.s.Name]), c_Purple, t_Hint);
                  Continue;
                end;
              end;
          end;
        end;
        lOutCheck:
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        if StdItem.StdMode = 50 then
          OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
        sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
      end;
    end;
    if (m_ItemList.Count > 0) and (sSENDMSG <> '') then
    begin
      m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end
  else
  begin
{$IFEND VER_ClientType_45}
    sSENDMSG := '';
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        {CheckItemExpires}
        if StdItem.StdMode = 2 then
        begin
          case StdItem.Shape of
            18:
              begin
                CopyMemory(@nIDt, @UserItem.btValue, SizeOf(Integer));
                if nIDt = 0 then
                  goto lOutCheckA;
                nDt := GetItemFormatDate();
                nIDt := Round((nDt - nIDt) / (24 * 60 * 60));
                if OClientItem.s.DuraMax - nIDt > 0 then
                  Dec(OClientItem.s.DuraMax, nIDt)
                else
                begin
                  //SendDelItems(UserItem);
                  Dispose(UserItem);
                  m_ItemList.Delete(i);
                  SysMsg(Format(sItemExpiresMsg, [OClientItem.s.Name]), c_Purple, t_Hint);
                  Continue;
                end;
              end;
          end;
        end;
        lOutCheckA:
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;

        ClientItem.s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, Self, ClientItem);

        if StdItem.StdMode = 50 then
          ClientItem.s.Name := ClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
        sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
      end;
    end;
    if (m_ItemList.Count > 0) and (sSENDMSG <> '') then
    begin
      m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0, m_ItemList.Count);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.ClientQueryHeroBagItems();
var
  i, nBig: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
  sSENDMSG := '';
{$IF VER_ClientType_45}
  if m_wClientType = 45 then
  begin
    for i := HeroObject.m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := HeroObject.m_ItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
      end;
    end;
    nBig := GetLevelBagSize(HeroObject.m_Abil.Level);
    m_DefMsg := MakeDefaultMsg(SM_HEROBAGITEMS, Integer(Self) {Integer(HeroObject)}, 0, HeroObject.m_ItemList.Count, nBig);
    SendSocket(@m_DefMsg, sSENDMSG);
  end
  else if m_wClientType = 46 then
  begin
{$IFEND VER_ClientType_45}
    for i := HeroObject.m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := HeroObject.m_ItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;

        ClientItem.s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, TPlayObject(HeroObject), ClientItem);

        sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
      end;
    end;
    nBig := GetLevelBagSize(HeroObject.m_Abil.Level);
    m_DefMsg := MakeDefaultMsg(SM_HEROBAGITEMS, Integer(Self), 0, HeroObject.m_ItemList.Count, nBig);
    SendSocket(@m_DefMsg, sSENDMSG);
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.ClientQueryUserSet(ProcessMsg: pTProcessMessage);
//var
//  sPassword: string;
begin
  {sPassword := MD5.HashString(ProcessMsg.sMsg);
  if sPassword <> DecodeString('NbA_VsaSTRucMbAjUl') then  //JackyWangFang
  begin
    MainOutMessageAPI('Fail');
    exit;
  end;
  m_nClientFlagMode := ProcessMsg.wParam;
  MainOutMessageAPI(format('OK:%d', [m_nClientFlagMode]));
  //'JackyWangFang'
  //'8988e0804091579a2fd8a0db75e9c17a';
  //'NbA_VsaSTRucMbAjUl'
  }
end;

procedure TPlayObject.ClientQueryUserState(PlayObject: TPlayObject; nX, nY: Integer); //004DE654
var
  i, ii, Len: Integer;
  UserState: TUserStateInfo;
  StdItem: pTStdItem;
  StdItem24: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
  UserItem: pTUserItem;
  SendTitle: THumTitle;
  Buffer: array[0..255] of Byte;
begin
{$IF VER_ClientType_45}
  if m_wClientType = 45 then
  begin
    if not CretInNearXY(PlayObject, nX, nY) then
      Exit;
    FillChar(OUserState, SizeOf(TOUserStateInfo), #0);
    // OUserState.Feature
    Len := PlayObject.GetFeature(Self, @Buffer[0]);
    if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) or PlayObject.IsHero or ((PlayObject.m_btRaceServer = RC_HERO) and (PlayObject.m_Master <> nil)) then
      OUserState.UserName := PlayObject.m_sCharName
    else
      OUserState.UserName := PlayObject.m_sFCharName;
    OUserState.NameColor := GetCharColor(PlayObject);
    if (PlayObject.m_btRaceServer = RC_HERO) and (PlayObject.m_dwCloneDispearTick > 0) and (PlayObject.m_Master <> nil) then
    begin
      OUserState.GuildName := PlayObject.m_Master.m_sCharName;
      OUserState.GuildRankName := 'µÄÔªÉñ';
    end
    else if PlayObject.IsHero then
    begin
      OUserState.GuildName := PlayObject.m_sHeroMasterName;
      OUserState.GuildRankName := 'µÄÓ¢ÐÛ';
    end
    else if PlayObject.m_MyGuild <> nil then
    begin
      OUserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
      OUserState.GuildRankName := PlayObject.m_sGuildRankName;
    end;
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      UserItem := @PlayObject.m_UseItems[i];
      if UserItem.wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
        if StdItem = nil then
          Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@PlayObject.m_UseItems[i], StdItem24);
        CopyStdItemToOStdItem(@StdItem24, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;
        OClientItem.MakeIndex := PlayObject.m_UseItems[i].MakeIndex;
        OClientItem.Dura := PlayObject.m_UseItems[i].Dura;
        OClientItem.DuraMax := PlayObject.m_UseItems[i].DuraMax;
        OUserState.UseItems[i] := OClientItem;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OUserState, SizeOf(TOUserStateInfo)) + EncodeBuffer(@Buffer[0], Len));
    Exit;
  end;
  if m_wClientType <> 46 then
  begin
    if not CretInNearXY(PlayObject, nX, nY) then
      Exit;
    FillChar(OUserState, SizeOf(TOUserStateInfo), #0);
    OUserState.Feature := PlayObject.GetFeature(Self);
    OUserState.UserName := PlayObject.m_sCharName;
    OUserState.NameColor := GetCharColor(PlayObject);
    if PlayObject.m_MyGuild <> nil then
      OUserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
    OUserState.GuildRankName := PlayObject.m_sGuildRankName;

    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      UserItem := @PlayObject.m_UseItems[i];
      if UserItem.wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
        if StdItem = nil then
          Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@PlayObject.m_UseItems[i], StdItem24);
        CopyStdItemToOStdItem(@StdItem24, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;
        OClientItem.MakeIndex := PlayObject.m_UseItems[i].MakeIndex;
        OClientItem.Dura := PlayObject.m_UseItems[i].Dura;
        OClientItem.DuraMax := PlayObject.m_UseItems[i].DuraMax;
        OUserState.UseItems[i] := OClientItem;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@OUserState, SizeOf(TOUserStateInfo)) + EncodeBuffer(@Buffer[0], Len));
  end
  else
  begin
{$IFEND VER_ClientType_45}
    if m_PEnvir.m_MapFlag.nSecret and $04 <> 0 then
    begin
      SysMsg('±¾µØÍ¼½ûÖ¹²é¿´TaÈËÐÅÏ¢£¡', c_Red, t_Hint);
      Exit;
    end;

    if not CretInNearXY(PlayObject, nX, nY) then
      Exit;
    FillChar(UserState, SizeOf(TUserStateInfo), #0);
    Len := PlayObject.GetFeature(Self, @Buffer[0]);
    move(Buffer[0],UserState.Feature,Len);
    // UserState.Feature := PlayObject.GetFeature(Self, @Buffer[0]);
    UserState.btResver1 := PlayObject.m_btWeaponSkill;
    UserState.btGender := PlayObject.m_btGender;
    UserState.ActiveTitle := PlayObject.GetTitleIndex();
    ii := 0;
    for i := Low(PlayObject.m_Titles) to High(PlayObject.m_Titles) do
    begin
      if PlayObject.m_Titles[i].Index > 0 then
      begin
        SendTitle.Index := PlayObject.m_Titles[i].Index;
        SendTitle.Time := M2Share.GetTitleTime(PlayObject.m_Titles[i]);
        UserState.Titles[ii] := SendTitle;
        Inc(ii);
      end;
    end;

    if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) or PlayObject.IsHero or ((PlayObject.m_btRaceServer = RC_HERO) and (PlayObject.m_Master <> nil)) then
      UserState.UserName := PlayObject.m_sCharName
    else
      UserState.UserName := PlayObject.m_sFCharName;
    UserState.NameColor := GetCharColor(PlayObject);
    if (PlayObject.m_btRaceServer = RC_HERO) and (PlayObject.m_dwCloneDispearTick > 0) and (PlayObject.m_Master <> nil) then
    begin
      UserState.GuildName := PlayObject.m_Master.m_sCharName;
      UserState.GuildRankName := 'µÄÔªÉñ';
    end
    else if PlayObject.IsHero then
    begin
      UserState.GuildName := PlayObject.m_sHeroMasterName;
      UserState.GuildRankName := 'µÄÓ¢ÐÛ';
    end
    else if PlayObject.m_MyGuild <> nil then
    begin
      UserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
      UserState.GuildRankName := PlayObject.m_sGuildRankName;
    end;
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      UserItem := @PlayObject.m_UseItems[i];
      if UserItem.wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
        if StdItem = nil then
          Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@PlayObject.m_UseItems[i], StdItem24);
        Move(StdItem24, ClientItem.s, SizeOf(TClientStdItem));

        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;

        ClientItem.MakeIndex := PlayObject.m_UseItems[i].MakeIndex;
        ClientItem.Dura := PlayObject.m_UseItems[i].Dura;
        ClientItem.DuraMax := PlayObject.m_UseItems[i].DuraMax;

        ClientItem.s.ItemType := PlayObject.m_UseItems[i].btValue[14];
        GetSendClientItem(@PlayObject.m_UseItems[i], Self, ClientItem);

        UserState.UseItems[i] := ClientItem;
      end;
    end;
    if g_Config.boHumanAttribute and (PlayObject.m_btAttribute in [1..5]) then
      UserState.btHumAttr := PlayObject.m_btAttribute;
    m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStateInfo)));
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
var
  Npc: TNormNpc;
begin
  if m_boDeath or m_boGhost then
    Exit;

  if nParam1 = 0 then
    Exit;

  if TObject(nParam1) = m_LastNPC then
  begin
    Npc := TNormNpc(m_LastNPC);
  end
  else
  begin
    Npc := UserEngine.FindMerchant(TObject(nParam1));
    if Npc = nil then
      Npc := UserEngine.FindNPC(TObject(nParam1));
  end;

  //NPC := UserEngine.FindMerchant(TObject(nParam1));
  //if NPC = nil then NPC := UserEngine.FindNPC(TObject(nParam1));
  if Npc = nil then
    Exit;

  m_LastNPC := Npc;

  if ((Npc.m_PEnvir = m_PEnvir) and
    (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
    (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
    Npc.UserSelect(Self, Trim(sMsg));
end;

procedure TPlayObject.ClientMerchantQueryExchgBook(nParam1, nMakeIndex: Integer; sMsg: string);
var
  i: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem18 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then
    begin
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        UserItem18 := UserItem;
        Break;
      end;
    end;
  end;
  if UserItem18 = nil then
    Exit;

  if nParam1 = 0 then
    Exit;
  if TObject(nParam1) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
  end;

  //Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then
    Exit;

  m_LastNPC := Merchant;

  if ((Merchant.m_PEnvir = m_PEnvir) {and (Merchant.m_boSell)} and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryExchgBook(Self, UserItem18);
end;

procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg: string);
var
  i: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem18 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then
    begin
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        UserItem18 := UserItem;
        Break;
      end;
    end;
  end;
  if UserItem18 = nil then Exit;

  if nParam1 = 0 then Exit;

  if TObject(nParam1) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
  end;

  //Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then Exit;

  m_LastNPC := Merchant;

  if ((Merchant.m_PEnvir = m_PEnvir) and (Merchant.m_boSell) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQuerySellPrice(Self, UserItem18);
end;

procedure TPlayObject.ClientUserExchgItem(nParam1, nMakeIndex, sellcnt: Integer; sMsg: string);
var
  i, temp: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  pstd: pTStdItem;
begin
  if m_StallMgr.OnSale or m_boDeath then
  begin
    SendDefMessage(SM_USEREXCHGITEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    pstd := UserEngine.GetStdItem(UserItem.wIndex);
    if (pstd <> nil) and (UserItem.MakeIndex = nMakeIndex) then
    begin

      if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
      begin
        if g_Config.boBindNoSell then
        begin
          SendDefMessage(SM_USEREXCHGITEM_FAIL, -2, 0, 0, 0, '');
          Exit;
        end;
      end;

      if InLimitItemList('', UserItem.wIndex, t_dSell) then
      begin
        SendDefMessage(SM_USEREXCHGITEM_FAIL, -3, 0, 0, 0, '');
        Break;
      end;

      if CompareText(pstd.Name, sMsg) = 0 then
      begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) {and (Merchant.m_boSell)} and ((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
        begin
          temp := Merchant.GetExchgItemBookCnt(UserItem);
          if temp > 0 then
          begin
            Dispose(UserItem);
            m_ItemList.Delete(i);
            MakeItem('¾íÖáËéÆ¬', temp, 0);
            WeightChanged();
          end
          else
          begin
            SendDefMessage(SM_USEREXCHGITEM_FAIL, -4 + temp, 0, 0, 0, '');
          end;
        end;
        Break;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientSellItemList(IntMerchant: Integer; sMsg: String);
var
  TLen, Strlen,I, SeccessItem: Integer;
  Item: TClientItem;
begin
  if sMsg = '' then Exit;
  TLen :=  GetCodeMsgSize(SizeOf(TClientItem) * 4 / 3);
  Strlen := 1;
  I := 0;
  SeccessItem := 0;
  while  Strlen < Length(sMsg) do
  begin
    DecodeBuffer(copy(sMsg, Strlen, TLen), @Item, SizeOf(TClientItem));
    if ClientUserSellItem(IntMerchant, Item.MakeIndex, Item.Dura, Item.s.Name) then
    begin
      SeccessItem := SeccessItem  or  (1 shl I);
    end;
    Inc(Strlen, TLen);
    Inc(I);
  end;
  SendDefMessage(SM_SELLSECCESSITEM, 0, SeccessItem, 0, 0, '');
end;

function TPlayObject.ClientUserSellItem(nParam1, nMakeIndex, sellcnt: Integer; sMsg: string): Boolean;
var
  i, temp: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  pstd: pTStdItem;
  ItemList: TStringList;
begin
  Result := false;
  if m_StallMgr.OnSale or m_boDeath then
  begin
    SendDefMessage(SM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;

  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    pstd := UserEngine.GetStdItem(UserItem.wIndex);
    if (pstd <> nil) and (UserItem.MakeIndex = nMakeIndex) then
    begin

      if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
      begin
        if g_Config.boBindNoSell then
        begin
          SendDefMessage(SM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
          Exit;
        end;
      end;

      if InLimitItemList('', UserItem.wIndex, t_dSell) then
      begin
        SendDefMessage(SM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
        Break;
      end;

      sUserItemName := '';
      if UserItem.btValue[13] = 1 then sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);

      if sUserItemName = '' then sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and (Merchant.m_boSell) and ((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
        begin
          if pstd.Overlap >= 1 then
          begin
            temp := UserItem.Dura;
            if (sellcnt > 0) and (temp >= sellcnt) then
            begin
              Result := True;
              if Merchant.ClientSellCountItem(Self, UserItem, sellcnt) then
              begin
                if temp - sellcnt <= 0 then
                begin
                  Dispose(pTUserItem(m_ItemList[i]));
                  m_ItemList.Delete(i);
                end
                else
                begin
                  pTUserItem(m_ItemList[i]).Dura := temp - sellcnt;
                end;
              end;
              WeightChanged;
            end;
          end
          else
          begin
            if Merchant.ClientSellItem(Self, UserItem) then
            begin
              Result := True;
              if UserItem.btValue[13] = 1 then
              begin
                ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                UserItem.btValue[13] := 0;
              end;
              m_ItemList.Delete(i);
              WeightChanged();
            end;
          end;
        end;
        Break;
      end;
    end;
  end;
end;

var
  g_DealGoldType: array[4..5] of string = ('½ð±Ò', 'Ôª±¦');

procedure TPlayObject.ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
var
  Merchant: TMerchant;
  PlayObject: TPlayObject;
  i, ii, nPrice, nPriceType: Integer;
  maxGold: LongWord;
  pstd: pTStdItem;
  UserItem: pTUserItem;
  VisibleBaseObject: pTVisibleBaseObject;
  StallInfo: TStallInfo;
label
  labNpc;
begin
  try
    if m_boDealing or m_StallMgr.OnSale or m_boDeath then
      Exit;

    if nParam1 = 0 then
      Exit;

    if TObject(nParam1) = m_LastNPC then
    begin
      goto labNpc;
    end;

    PlayObject := nil;
    for i := 0 to m_VisibleActors.Count - 1 do
    begin
      VisibleBaseObject := m_VisibleActors.Items[i];
      if VisibleBaseObject.BaseObject = TObject(nParam1) then
      begin
        PlayObject := TPlayObject(VisibleBaseObject.BaseObject);
        Break;
      end;
    end;

    if (PlayObject <> nil) and (PlayObject.m_btRaceServer = RC_PLAYOBJECT) and PlayObject.m_StallMgr.OnSale then
    begin
      if (PlayObject = Self) or
        (PlayObject.m_boDeath) or
        (PlayObject.m_boGhost) or
        (abs(PlayObject.m_nCurrX - m_nCurrX) > 15) or
        (abs(PlayObject.m_nCurrY - m_nCurrY) > 15) then
        Exit;

      if nIdent = CM_USERBUYITEM then
      begin

        if nInt = 0 then
          Exit;

        nPrice := -1;
        for i := Low(PlayObject.m_StallMgr.mBlock.Items) to High(PlayObject.m_StallMgr.mBlock.Items) do
        begin
          if PlayObject.m_StallMgr.mBlock.Items[i].s.Name = '' then
            Continue;
          if PlayObject.m_StallMgr.mBlock.Items[i].MakeIndex = nInt then
          begin
            nPrice := PlayObject.m_StallMgr.mBlock.Items[i].s.Price;
            nPriceType := PlayObject.m_StallMgr.mBlock.Items[i].s.NeedIdentify;
            Break;
          end;
        end;

        if nPrice = -1 then
        begin
          SendDefMessage(SM_BUYSTALLITEM, -1, 0, 0, 0, '');
          Exit;
        end;

        case nPriceType of
          4:
            begin
              maxGold := LongWord(PlayObject.m_nGold + nPrice);
              if maxGold > g_Config.nHumanMaxGold then
              begin
                SendDefMessage(SM_BUYSTALLITEM, -2, 0, 0, 0, PlayObject.m_sCharName);
                Exit;
              end;
              if m_nGold < nPrice then
              begin
                SendDefMessage(SM_BUYSTALLITEM, -3, 0, 0, 0, PlayObject.m_StallMgr.mBlock.Items[i].s.Name);
                Exit;
              end;
            end;
          5:
            begin
              maxGold := LongWord(PlayObject.m_nGameGold + nPrice);
              if maxGold > High(Integer) then
              begin
                SendDefMessage(SM_BUYSTALLITEM, -4, 0, 0, 0, PlayObject.m_sCharName);
                Exit;
              end;
              if m_nGameGold < nPrice then
              begin
                SendDefMessage(SM_BUYSTALLITEM, -5, 0, 0, 0, PlayObject.m_StallMgr.mBlock.Items[i].s.Name);
                Exit;
              end;
            end;
        else
          Exit;
        end;

        for i := 0 to PlayObject.m_ItemList.Count - 1 do
        begin
          UserItem := PlayObject.m_ItemList[i];
          if (UserItem.MakeIndex = nInt) then
          begin
            pstd := UserEngine.GetStdItem(UserItem.wIndex);
            if pstd = nil then
            begin
              SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');
              Exit;
            end;
            if CompareText(pstd.Name, sMsg) <> 0 then
            begin
              SendDefMessage(SM_BUYSTALLITEM, -6, 0, 0, 0, '');
              Exit;
            end;

            if IsEnoughBag and IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex, UserItem.Dura)) then
            begin
              if nPriceType = 4 then
              begin
                DecGold(nPrice);
                GoldChanged;
                if g_boGameLogGold then
                  AddGameDataLogAPI('10' + #9 +
                    m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 +
                    IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 +
                    sSTRING_GOLDNAME + #9 +
                    IntToStr(nPrice) + #9 +
                    '1' + #9 +
                    PlayObject.m_sCharName);

                PlayObject.m_nGold := _MIN(g_Config.nHumanMaxGold, (PlayObject.m_nGold + nPrice));
                PlayObject.GoldChanged();
                if g_boGameLogGold then
                  AddGameDataLogAPI('9' + #9 +
                    PlayObject.m_sMapName + #9 +
                    IntToStr(PlayObject.m_nCurrX) + #9 +
                    IntToStr(PlayObject.m_nCurrY) + #9 +
                    PlayObject.m_sCharName + #9 +
                    sSTRING_GOLDNAME + #9 +
                    IntToStr(nPrice) + #9 +
                    '1' + #9 +
                    m_sCharName);
              end
              else
              begin
                Dec(m_nGameGold, nPrice);
                GameGoldChanged;
                if g_boGameLogGameGold then
                begin
                  AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
                    m_sMapName,
                      m_nCurrX,
                      m_nCurrY,
                      m_sCharName,
                      g_Config.sGameGoldName,
                      nPrice,
                      '-',
                      PlayObject.m_sCharName]));
                end;

                PlayObject.m_nGameGold := _MIN(High(Integer), (PlayObject.m_nGameGold + nPrice));
                PlayObject.GameGoldChanged();
                if g_boGameLogGameGold then
                begin
                  AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
                    PlayObject.m_sMapName,
                      PlayObject.m_nCurrX,
                      PlayObject.m_nCurrY,
                      PlayObject.m_sCharName,
                      g_Config.sGameGoldName,
                      nPrice,
                      '+',
                      m_sCharName]));
                end;
              end;

              if pstd.NeedIdentify = 1 then
              begin
                AddGameDataLogAPI('9' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  pstd.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  PlayObject.m_sCharName + ' (' + IntToStr(nPrice) + g_DealGoldType[nPriceType] + ')');

                AddGameDataLogAPI('10' + #9 +
                  PlayObject.m_sMapName + #9 +
                  IntToStr(PlayObject.m_nCurrX) + #9 +
                  IntToStr(PlayObject.m_nCurrY) + #9 +
                  PlayObject.m_sCharName + #9 +
                  pstd.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  m_sCharName + ' (' + IntToStr(nPrice) + g_DealGoldType[nPriceType] + ')');
              end;

              AddItemToBag(UserItem);
              SendAddItem(UserItem);
              //m_dwSaveRcdTick := 0;    //0720
              WeightChanged();

              PlayObject.SendDelItems(UserItem);
              PlayObject.m_ItemList.Delete(i);
              PlayObject.WeightChanged();
              PlayObject.m_dwSaveRcdTick := 0; //0720

              PlayObject.SysMsg(Format('%s»¨·Ñ%d%s¹ºÂòÁËÄãµÄ%s', [m_sCharName, nPrice, g_DealGoldType[nPriceType], pstd.Name]), c_Blue, t_Hint);
              SysMsg(Format('Äã»¨·Ñ%d%s¹ºÂòÁË%sµÄ%s', [nPrice, g_DealGoldType[nPriceType], PlayObject.m_sCharName, pstd.Name]), c_Blue, t_Hint);

              for ii := Low(PlayObject.m_StallMgr.mBlock.Items) to High(PlayObject.m_StallMgr.mBlock.Items) do
              begin
                if PlayObject.m_StallMgr.mBlock.Items[ii].MakeIndex = nInt then
                begin
                  PlayObject.m_StallMgr.mBlock.Items[ii].MakeIndex := 0;
                  PlayObject.m_StallMgr.mBlock.Items[ii].s.Name := '';
                  Break;
                end;
              end;
              Dec(PlayObject.m_StallMgr.mBlock.ItemCount);

              if PlayObject.m_StallMgr.mBlock.ItemCount <= 0 then
              begin
                PlayObject.m_StallMgr.OnSale := False;
                PlayObject.m_StallMgr.mBlock.StallName := '';
                PlayObject.m_StallMgr.mBlock.ItemCount := 0;
                FillChar(PlayObject.m_StallMgr.mBlock.Items, SizeOf(PlayObject.m_StallMgr.mBlock.Items), #0);

                StallInfo.open := False;
                StallInfo.Name := PlayObject.m_StallMgr.mBlock.StallName;
                StallInfo.Looks := PlayObject.m_StallMgr.StallType;
                PlayObject.m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(PlayObject), PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_btDirection);
                PlayObject.SendSocket(@PlayObject.m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

                PlayObject.SendRefMsg(RM_STALLSTATUS, 0, PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_btDirection, '');
                if (g_FunctionNPC <> nil) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(Self, '@StoreClosed', False);
                end;
                Exit;
              end
              else
              begin
                //StallInfo.open := PlayObject.m_StallMgr.OnSale;
                //StallInfo.Looks := PlayObject.m_StallMgr.StallType;
                //StallInfo.Name := PlayObject.m_StallMgr.mBlock.StallName;
                //m_DefMsg := MakeDefaultMsg(SM_OPENStall, Integer(PlayObject), PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_btDirection);
                //SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

                PlayObject.SendStallItems(Self);
              end;

            end
            else
            begin
              SendDefMessage(SM_BUYSTALLITEM, -7, 0, 0, 0, '');
              Exit;
            end;
            Break;
          end;
        end;

        Exit;
      end
      else
        Exit;
      Exit;
    end;

    labNpc:
    if TObject(nParam1) = m_LastNPC then
    begin
      Merchant := TMerchant(m_LastNPC);
    end
    else
    begin
      Merchant := UserEngine.FindMerchant(TObject(nParam1));
      if Merchant <> nil then
        m_LastNPC := Merchant;
    end;
    //Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or (not Merchant.m_boBuy) or (Merchant.m_PEnvir <> m_PEnvir) or (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then
      Exit;

    if nIdent = CM_USERBUYITEM then
    begin
      if nZz > 0 then
        Merchant.ClientBuyItem(Self, sMsg, nInt, nZz)
      else
        Merchant.ClientBuyItem(Self, sMsg, nInt, 1);
    end
    else if nIdent = CM_BUYSELLOFFITEM then
    begin
      Merchant.ClientBuySaleItem(Self, sMsg, nInt);
    end
    else if (nIdent = CM_USERGETDETAILITEM) or (nIdent = CM_GETMERCHANDISEMSG) then
      Merchant.ClientGetDetailGoodsList(Self, sMsg, nZz, nInt)
    else if nIdent = CM_GETSALEDETAILITEM then
      Merchant.ClientGetSaleItemList(Self, sMsg, nZz);

  except
    on E: Exception do
    begin
      MainOutMessageAPI('TUserHuman.ClientUserBuyItem wIdent = ' + IntToStr(nIdent));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.ClientDropGold(nGold: Integer): Boolean;
var
  nTemp: Integer;
begin
  Result := False;

  if (m_btRaceServer <> RC_PLAYOBJECT) or (m_sHeroMasterName <> '') then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '·Ç·¨²Ù×÷£¡');
    Exit;
  end;

  if g_Config.boInSafeDisableDrop and InSafeZone then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    Exit;
  end;

  if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropGoldMsg);
    Exit;
  end;

  if not m_boCanDrop or m_StallMgr.OnSale then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;

  if (nGold > m_nGold) or (nGold <= 0) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, 'ÄãÃ»ÓÐÄÇÃ´¶àµÄ' + sSTRING_GOLDNAME);
    Exit;
  end;

  nTemp := m_nGold;
  Dec(m_nGold, nGold);
  if not DropGoldDown(nGold, False, nil, Self) then
    Inc(m_nGold, nGold);

  if nTemp <> m_nGold then
    GoldChanged();

  Result := True;
end;

function TPlayObject.ClientDropItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
var
  i, remain, t: Integer;
  newpu, UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
resourcestring
  sCanotDropItemMsg = 'µ±Ç°ÎïÆ·½ûÖ¹¶ªÆú';
begin
  Result := False;

  if (m_btRaceServer <> RC_PLAYOBJECT) or (m_sHeroMasterName <> '') then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '·Ç·¨²Ù×÷£¡');
    Exit;
  end;
  //if m_StallMgr.OnSale then Exit;
  if (m_PEnvir <> nil) and m_PEnvir.m_MapFlag.boNOTHROWITEM then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[ÌáÊ¾]£º±¾µØÍ¼½ûÖ¹¶ªÎïÆ·');
    Exit;
  end;
  if g_Config.boInSafeDisableDrop and InSafeZone and (not InLimitItemList(sItemName, -1, t_ADrop)) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    Exit;
  end;
  if not m_boCanDrop then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;
  {ÕÛ·ÖÎïÆ·Ãû³Æ(ÐÅ¼þÎïÆ·µÄÃû³ÆºóÃæ¼ÓÁËÊ¹ÓÃ´ÎÊý)}
  if Pos(' ', sItemName) > 0 then
    GetValidStr3(sItemName, sItemName, [' ']);
  if (GetTickCount - m_DealLastTick) > g_Config.dwTryDealTime then
  begin
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        //
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
          begin
            Exit;
          end;
        end;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;
        {LimitItem by Blue}

        if InLimitItemList('', UserItem.wIndex, t_dDrop) then
        begin
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sCanotDropItemMsg);
          Break;
        end;
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          if (StdItem.Overlap >= 1) and (dropcnt >= 1) then
          begin
            t := UserItem.Dura;
            if dropcnt > t then
              dropcnt := UserItem.Dura;
            remain := t - dropcnt;
            if dropcnt > 0 then
            begin
              if remain > 0 then
              begin
                New(newpu);
                if UserEngine.CopyToUserItemFromName(sItemName, newpu) then
                begin
                  newpu.Dura := dropcnt;
                  if DropItemDown(newpu, g_Config.nScatterRange, False, nil, Self) then
                  begin
                    UserItem.Dura := remain;
                    SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, remain, 0, sItemName);
                    Dispose(newpu);
                    Result := True;
                    Break;
                  end
                  else
                  begin
                    Dispose(newpu);
                    Break;
                  end;
                end
                else
                begin
                  Dispose(newpu);
                  Break;
                end;
              end
              else
              begin
                if DropItemDown(UserItem, g_Config.nScatterRange, False, nil, Self) then
                begin
                  Dispose(pTUserItem(m_ItemList[i]));
                  m_ItemList.Delete(i);
                  //~m_dwSaveRcdTick := 0;
                  if m_btRaceServer = RC_PLAYOBJECT then
                    CheckMapEvent(1, sItemName);
                  Result := True;
                  Break;
                end;
              end;
            end;
          end
          else
          begin
            if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice) then
            begin
              Dispose(UserItem);
              m_ItemList.Delete(i);
              //~m_dwSaveRcdTick := 0;
              if m_btRaceServer = RC_PLAYOBJECT then
                CheckMapEvent(1, sItemName);
              Result := True;
              Break;
            end;
            if DropItemDown(UserItem, g_Config.nScatterRange, False, nil, Self) then
            begin
              Dispose(UserItem);
              m_ItemList.Delete(i);
              //~m_dwSaveRcdTick := 0;
              if m_btRaceServer = RC_PLAYOBJECT then
                CheckMapEvent(1, sItemName);
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
    if Result then
      WeightChanged();
  end;
end;

function TPlayObject.ClientDismantleItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
var
  i,remain, t: Integer;
  newpu, UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
begin
  Result := False;
  if m_StallMgr.OnSale then
    Exit;
  if m_ItemList.Count >= GetMaxBagItem - 6 then
  begin
    SysMsg('±³°üÃ»ÓÐ×ã¹»µÄ¿ÕÎ»,Çë±£Áô6¸öÒÔÉÏµÄ¿ÕÎ»', c_Red, t_Hint);
    Exit;
  end;
  if (GetTickCount - m_DealLastTick) > g_Config.dwTryDealTime then
  begin
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
          if CompareText(sUserItemName, sItemName) = 0 then
          begin
            if (StdItem.Overlap >= 1) and (dropcnt >= 1) and (UserItem.Dura > 1) then
            begin
              t := UserItem.Dura;
              if dropcnt >= t then
                dropcnt := UserItem.Dura - 1;
              remain := t - dropcnt;
              if (dropcnt > 0) and (remain > 0) then
              begin
                if remain > 0 then
                begin
                  New(newpu);
                  if UserEngine.CopyToUserItemFromName(sItemName, newpu) then
                  begin
                    newpu.Dura := dropcnt;
                    if AddItemToBag(newpu) then
                    begin
                      SendAddItem(newpu);
                      UserItem.Dura := remain;
                      SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, remain, 0, sItemName);
                      Result := True;
                    end
                    else
                    begin
                      Dispose(newpu);
                    end;
                  end
                  else
                  begin
                    Dispose(newpu);
                  end;
                end;
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
    if Result then
      WeightChanged();
  end;
end;

function TPlayObject.ClientHeroDropItem(sItemName: string; nItemIdx, dropcnt: Integer): Boolean;
var
  i, remain, t: Integer;
  newpu, UserItem: pTUserItem;
  StdItem: pTStdItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
resourcestring
  sCanotDropItemMsg = 'µ±Ç°ÎïÆ·½ûÖ¹¶ªÆú';
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
  Result := False;
  if (HeroObject.m_PEnvir <> nil) and HeroObject.m_PEnvir.m_MapFlag.boNOTHROWITEM then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[ÌáÊ¾]£º±¾µØÍ¼½ûÖ¹¶ªÎïÆ·');
    Exit;
  end;
  if g_Config.boInSafeDisableDrop and HeroObject.InSafeZone and (not InLimitItemList(sItemName, -1, t_ADrop)) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    Exit;
  end;
  if not m_boCanDrop then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    Exit;
  end;

  if Pos(' ', sItemName) > 0 then
    GetValidStr3(sItemName, sItemName, [' ']);
  if (GetTickCount - m_DealLastTick) > g_Config.dwTryDealTime then
  begin
    for i := HeroObject.m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := HeroObject.m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;

        {LimitItem by Blue}
        if InLimitItemList('', UserItem.wIndex, t_dDrop) then
        begin
          HeroObject.SysMsg(sCanotDropItemMsg, c_Red, t_Hint);
          Break;
        end;
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          if (StdItem.Overlap >= 1) and (dropcnt >= 1) then
          begin
            t := UserItem.Dura;
            if dropcnt > t then
              dropcnt := UserItem.Dura;
            remain := t - dropcnt;
            if dropcnt > 0 then
            begin
              if remain > 0 then
              begin
                New(newpu);
                if UserEngine.CopyToUserItemFromName(sItemName, newpu) then
                begin
                  newpu.Dura := dropcnt;
                  if HeroObject.DropItemDown(newpu, g_Config.nScatterRange, False, nil, Self) then
                  begin
                    UserItem.Dura := remain;
                    HeroObject.SendMsg(HeroObject, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, remain, 0, sItemName);
                    Result := True;
                    Dispose(newpu);
                    Break;
                  end
                  else
                  begin
                    Dispose(newpu);
                    Break;
                  end;
                end
                else
                begin
                  Dispose(newpu);
                  Break;
                end;
              end
              else
              begin
                if HeroObject.DropItemDown(UserItem, g_Config.nScatterRange, False, nil, Self) then
                begin
                  Dispose(pTUserItem(HeroObject.m_ItemList[i]));
                  HeroObject.m_ItemList.Delete(i);
                  //~HeroObject.m_dwHeroSaveRcdTick := 0;
                  Result := True;
                  Break;
                end;
              end;
            end;
          end
          else
          begin
            if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice) then
            begin
              Dispose(UserItem);
              HeroObject.m_ItemList.Delete(i);
              //~HeroObject.m_dwHeroSaveRcdTick := 0; //0408_1
              //if m_btRaceServer = RC_PLAYOBJECT then CheckMapEvent(1, sItemName);
              Result := True;
              Break;
            end;
            if HeroObject.HeroDropItemDown(UserItem, g_Config.nScatterRange, False, nil, Self) then
            begin
              Dispose(UserItem);
              HeroObject.m_ItemList.Delete(i);
              //~HeroObject.m_dwHeroSaveRcdTick := 0; //0408_1
              //if m_btRaceServer = RC_PLAYOBJECT then CheckMapEvent(1, sItemName);
              Result := True;
              Break;
            end;
          end;
        end;
      end;
    end;
    if Result then
      HeroObject.WeightChanged();
  end;
end;

procedure TPlayObject.GoldChange(sChrName: string; nGold: Integer); //004CD844
var
  s10, s14: string;
begin
  if nGold > 0 then
  begin
    s10 := '14';
    s14 := 'Ôö¼ÓÍê³É';
  end
  else
  begin
    s10 := '13';
    s14 := 'ÒÔÉ¾¼õ';
  end;
  SysMsg(sChrName + ' µÄ½ð±Ò ' + IntToStr(nGold) + ' ½ð±Ò' + s14, c_Green, t_Hint);
  if g_boGameLogGold then
    AddGameDataLogAPI(s10 + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      sSTRING_GOLDNAME + #9 +
      IntToStr(nGold) + #9 +
      '1' + #9 +
      sChrName);
end;

procedure TBaseObject.ClearStatusTime;
begin
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
  FillChar(m_wStatusTimeArrEx, SizeOf(m_wStatusTimeArrEx), #0);
end;

function TBaseObject.IsMoveAble: Boolean;
begin
  if not m_boGhost and
    not m_boDeath and
    not m_boFixedHideMode and
    not m_boStoneMode and
    (m_wStatusTimeArr[POISON_STONE] = 0) and
    (m_wStatusTimeArr[POISON_PURPLE] = 0) then
    Result := True
  else
    Result := False;
end;

procedure TBaseObject.RandomSpaceMoveInRange(mtype, inrange, OutRange: Integer);
var
  ran, signX, signY, nX, nY: Integer;
begin
  signX := 1;
  signY := 1;

  if m_PEnvir <> nil then
  begin
    ran := Random(100);
    ran := ran mod 4;

    case ran of
      0:
        begin
          signX := 1;
          signY := 1;
        end;
      1:
        begin
          signX := -1;
          signY := 1;
        end;
      2:
        begin
          signX := -1;
          signY := -1;
        end;
      3:
        begin
          signX := 1;
          signY := -1;
        end;
    end;

    nX := m_nCurrX + signX * (inrange + Random(OutRange - inrange) + 1);
    if nX >= m_PEnvir.m_MapHeader.wWidth then
    begin
      nX := m_PEnvir.m_MapHeader.wWidth - 1;
    end
    else if nX < 0 then
    begin
      nX := 0;
    end;

    nY := m_nCurrY + signY * (inrange + Random(OutRange - inrange) + 1);
    if nY >= m_PEnvir.m_MapHeader.wHeight then
    begin
      nY := m_PEnvir.m_MapHeader.wHeight - 1;
    end
    else if nY < 0 then
    begin
      nY := 0;
    end;

    SpaceMove(m_PEnvir.m_sMapFileName, nX, nY, mtype);
  end;
end;

procedure TPlayObject.SendMapDescription;
var
  nMUSICID: Integer;
begin
  nMUSICID := -1;
  if m_PEnvir.m_MapFlag.boMUSIC then
    nMUSICID := m_PEnvir.m_MapFlag.nMUSICID;
  SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.m_sMapDesc);
end;

procedure TPlayObject.SendImageFileListCustom;
var
  i: Integer;
  sImageFileListCustomMsg: String;
begin
  sImageFileListCustomMsg := '';     //½ô½Ó×ÅÍ¨Öª·¢ËÍÖ®ºó´«ËÍ×Ô¶¨ÒåÎÄ¼þÁÐ±í2019-12-04
  for i := 0 to g_FileCustomList_Server.Count - 1 do
  begin
    sImageFileListCustomMsg := sImageFileListCustomMsg + g_FileCustomList_Server.Strings[i] + '/';
  end;
  SendDefMessage(SM_IMAGEFILELISTCUSTOM, 0, 0, 0, 0, sImageFileListCustomMsg);
end;

procedure TPlayObject.SendSafeZoneEffectCustom;
var
  i: Integer;
  sSafeZoneEffectCustomMsg: String;
  P:pTStartPointCustom;
begin
  sSafeZoneEffectCustomMsg := '';     // 2019-12-04
  for i := 0 to g_StartPointCustomList_Server.Count - 1 do
  begin
     P := g_StartPointCustomList_Server.items[i];
     sSafeZoneEffectCustomMsg := sSafeZoneEffectCustomMsg + EncodeBuffer(pchar(P), SizeOf(TStartPointCustom)) + '/';
  end;

  if (g_StartPointCustomList_Server.Count > 0) and (sSafeZoneEffectCustomMsg <> '') then
  begin
    m_DefMsg := MakeDefaultMsg(SM_SAFEZONEEFFECTCUSTOM, 0, 0, 0, g_StartPointCustomList_Server.Count);
    SendSocket(@m_DefMsg, sSafeZoneEffectCustomMsg);
  end;
  
end;

procedure TPlayObject.SendNpcCustom;
var
  i: Integer;
  sNpcCustomMsg: String;
  P:pTNpcCustom;
begin
  sNpcCustomMsg := '';     // 2019-12-07
  for i := 0 to g_NpcCustomList_Server.Count - 1 do
  begin
     P := g_NpcCustomList_Server.items[i];
     sNpcCustomMsg := sNpcCustomMsg + EncodeBuffer(pchar(P), SizeOf(TNpcCustom)) + '/';
  end;

  if (g_NpcCustomList_Server.Count > 0) and (sNpcCustomMsg <> '') then
  begin
    m_DefMsg := MakeDefaultMsg(SM_NPCCUSTOM, 0, 0, 0, g_NpcCustomList_Server.Count);
    SendSocket(@m_DefMsg, sNpcCustomMsg);
  end;
end;

procedure TPlayObject.SendNotice;
var
  LoadList: TStringList;
  i: Integer;
  sNoticeMsg: string;
begin
  LoadList := TStringList.Create;
  NoticeManager.GetNoticeMsg('Notice', LoadList);
  sNoticeMsg := '';
  for i := 0 to LoadList.Count - 1 do
    sNoticeMsg := sNoticeMsg + LoadList.Strings[i] + #$20#$1B;
  LoadList.Free;
  SendDefMessage(SM_SENDNOTICE, 2000, 0, 0, 0, sNoticeMsg);
end;

procedure TPlayObject.SendMissions();
var
  i, nstep, nC: Integer;
  sid, sDesc: string;
begin
  for i := 0 to m_MissionList.Count - 1 do
  begin
    sid := m_MissionList[i];
    nstep := Integer(m_MissionList.Objects[i]);
    if nstep <= 0 then
      Continue;
    sDesc := M2Share.GetMissionSendMsg(sid, nstep, nC);
    if g_FunctionNPC <> nil then
      sDesc := g_FunctionNPC.GetLineVariableText(Self, sDesc); //'title=%s desc=%s';
    if sDesc <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SETMISSION, Str_ToInt(sid, 0), nC, 0, 1);
      SendSocket(@m_DefMsg, EncodeString(sDesc));
    end;
  end;
end;

procedure TPlayObject.UserResumeLogon();
var
  i, ii: Integer;
  sIPaddr: string;
begin
  m_VisibleHumanList.Clear;

  for ii := m_VisibleItems.Count - 1 downto 0 do
    Dispose(pTVisibleMapItem(m_VisibleItems[ii]));
  m_VisibleItems.Clear;

  for i := 0 to m_VisibleActors.Count - 1 do
    Dispose(pTVisibleBaseObject(m_VisibleActors[i]));
  m_VisibleActors.Clear;

{$IF NewVisibleEvent = 1}
  for ii := m_VisibleEvents.Count - 1 downto 0 do
    Dispose(pTVisibleEvent(m_VisibleEvents[ii]));
{$IFEND}
  m_VisibleEvents.Clear;

  m_dwMapMoveTick := GetTickCount();
  SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');

  UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission);
  GetHomePoint();

  for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
  begin
    if m_wStatusTimeArr[i] > 0 then
      m_dwStatusArrTick[i] := GetTickCount();
  end;
  RecalcLevelAbilitys();
  RecalcAbilitys();
  if m_btClPkPoint = 0 then
  begin
    m_nPkPoint := 0;
    Inc(m_btClPkPoint);
  end;
  if (m_nGold > g_Config.nHumanMaxGold) and (g_Config.nHumanMaxGold > 0) then
    m_nGold := g_Config.nHumanMaxGold;
  if not m_boTryPlayMode then
  begin
    if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then
    begin
      SysMsg(sClientSoftVersionError, c_Red, t_Hint);
      SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
      SysMsg(sForceDisConnect, c_Red, t_Hint);
      m_boEmergencyClose := True;
      Exit;
    end;
{$IF VER_ClientType_45}
    if (m_nSoftVersionDateEx = 0) and g_Config.boOldClientShowHiLevel then
    begin
      SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
      SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
      if (not g_Config.boCanOldClientLogon) then
      begin
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        Exit;
      end;
    end;
{$IFEND VER_ClientType_45}
    case m_btAttatckMode of
      HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);
      HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);
      HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);
      HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint);
      HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint);
      HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint);
      HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);
    end;
    SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint);
    SendMsg(Self, RM_ATTACKMODE, 0, 0, 0, 0, '');

    if g_Config.boTestServer then
      SysMsg(sStartNoticeMsg, c_Green, t_Hint);
    if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then
    begin
      if m_btPermission < 2 then
      begin
        SysMsg(sOnlineUserFull, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    end;
  end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
  if (UserEngine.m_PlayObjectList.Count <= 10) then
  begin
    m_nBright := g_nGameTime;
    m_Time := g_Time;
    if g_TitlesBuffLen > 0 then
      SendMsg(Self, RM_SENDTITLES, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_WINIPEXP, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
    SendMsg(Self, RM_PLAYERCONFIG, 0, 0, 0, 0, '');

    if g_pcsiLen > 0 then
      SendMsg(Self, RM_SUITESTR, 0, 0, 0, 0, '');

    if g_Config.cbMutiHero then
      FrontEngine.AddToLoadRcdList(m_sUserID,
        m_sCharName,
        m_sIPaddr,
        5,
        m_nSessionID,
        m_nPayMent,
        m_nPayMode,
        m_nSoftVersionDate,
        m_nSocket,
        m_nGSocketIdx,
        m_nGateIdx,
        '',
        nil);

    if m_nInPowerLevel > 0 then
      SendMsg(Self, RM_SERIESSKILLARR, 0, 0, 0, 0, '');
    SendMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
    GameGoldChanged();
    InternalPowerPointChanged();
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then
    begin
      m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      for i := 0 to TGuild(m_MyGuild).m_GuildWarList.Count - 1 do
        SysMsg(TGuild(m_MyGuild).m_GuildWarList.Keys[i] + ' ÕýÔÚÓë±¾ÐÐ»á½øÐÐÐÐ»áÕ½', c_Green, t_Hint);
    end;
    RefShowName();
  end;
{$I '..\Common\Macros\VMPE.inc'}

  if (m_nPayMent = 1) then
  begin
    if not m_boTryPlayMode then
      SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
    m_nGoldMax := g_Config.nHumanTryModeMaxGold;
    if m_Abil.Level > g_Config.nTryModeLevel then
    begin
      SysMsg('²âÊÔ×´Ì¬¿ÉÒÔÊ¹ÓÃµ½µÚ ' + IntToStr(g_Config.nTryModeLevel) + ' ¼¶', c_Red, t_Hint);
      SysMsg('Á´½ÓÖÐ¶Ï£¬Çëµ½ÒÔÏÂµØÖ·»ñµÃÊÕ·ÑÏà¹ØÐÅÏ¢¡£(http://www.98km2.com)', c_Red, t_Hint);
      m_boEmergencyClose := True;
    end;
  end;
  if (m_nPayMent = 3) and not m_boTryPlayMode then
    SysMsg(g_sNowIsFreePlayMode {'µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ²âÊÔÄ£Ê½.'}, c_Green, t_Hint);
  if g_Config.boVentureServer then
    SysMsg('µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ£º[Ã°ÏÕÄ£Ê½]', c_Green, t_Hint);
  if (m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil) and (not m_boUseThrusting) then
  begin
    m_boUseThrusting := True;
    SendSocket(nil, '+LNG');
  end;
  if m_PEnvir.m_MapFlag.boNORECONNECT then
    MapRandomMove(m_PEnvir.m_MapFlag.sReConnectMap, 0);

  CancelDoStall;

{$I '..\Common\Macros\VMPB.inc'}
  if CheckDenyLogon() then
    Exit;

  if m_boOffLineLogin then
  begin
    m_boOffLineLogin := False;
    m_dwQueryBagItemsTick := 0;
    FillChar(m_btGetShopItem, 6, #0);
    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.m_OprCount := 0;
      g_ManageNPC.GotoLable(Self, '@Resume', False);
    end;
  end;

  if m_MagicArr[0][42] <> nil then
  begin
    m_nVigour := _MIN((m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour);
    SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
  end;

  m_boFixedHideMode := False;

  if m_sDearName <> '' then
    CheckMarry();
  CheckMaster();
  m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

  if (UserEngine.m_PlayObjectList.Count > 10) then
    m_boEmergencyClose := True;

  if g_Config.boPasswordLockSystem then
  begin
    if m_boPasswordLocked then
      m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
    if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then
    begin
      m_boCanDeal := not g_Config.boLockDealAction;
      m_boCanRecallHero := not g_Config.boLockRecallAction;
      m_boCanDrop := not g_Config.boLockDropAction;
      m_boCanUseItem := not g_Config.boLockUserItemAction;
      m_boCanWalk := not g_Config.boLockWalkAction;
      m_boCanRun := not g_Config.boLockRunAction;
      m_boCanHit := not g_Config.boLockHitAction;
      m_boCanSpell := not g_Config.boLockSpellAction;
      m_boCanSendMsg := not g_Config.boLockSendMsgAction;
      m_boObMode := g_Config.boLockInObModeAction;
      m_boAdminMode := g_Config.boLockInObModeAction;
      SysMsg(g_sActionIsLockedMsg + ' ¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sActionIsLockedMsg + '\ \'
        + '¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd + '\'
        + '¼ÓËøÃüÁî: @' + g_GameCommand.Lock.sCmd + '\'
        + 'ÉèÖÃÃÜÂëÃüÁî: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + 'ÐÞ¸ÄÃÜÂëÃüÁî: @' + g_GameCommand.CHGPASSWORD.sCmd);
    end;
  end;

  if (m_ChgSlaveList <> nil) and (m_ChgSlaveList.Count > 0) then
  begin
    for i := m_ChgSlaveList.Count - 1 downto 0 do
    begin
      ChangeServerMakeSlave(pTSlaveInfo(m_ChgSlaveList[i]));
      Dispose(pTSlaveInfo(m_ChgSlaveList[i]));
    end;
    m_ChgSlaveList.Clear;
  end;
{$I '..\Common\Macros\VMPE.inc'}
  m_boSendInSafeZone := True;
  m_dwSafeZoneCheckTick := 0;
  m_dwSearchTick := 0;
  m_dwIncGamePointTick := GetTickCount();
  m_dwIncGameGoldTick := GetTickCount();
  m_dwAutoGetExpTick := GetTickCount();

{$ELSE}
  m_nBright := g_nGameTime;
  m_Time := g_Time;
  if g_TitlesBuffLen > 0 then
    SendMsg(Self, RM_SENDTITLES, 0, 0, 0, 0, '');
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_WINIPEXP, 0, 0, 0, 0, '');
  SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
  SendMsg(Self, RM_PLAYERCONFIG, 0, 0, 0, 0, '');
  if g_pcsiLen > 0 then
    SendMsg(Self, RM_SUITESTR, 0, 0, 0, 0, '');

  if g_Config.cbMutiHero then
    FrontEngine.AddToLoadRcdList(m_sUserID,
      m_sCharName,
      m_sIPaddr,
      5,
      m_nSessionID,
      m_nPayMent,
      m_nPayMode,
      m_nSoftVersionDate,
      m_nSocket,
      m_nGSocketIdx,
      m_nGateIdx,
      '',
      nil);

  if m_nInPowerLevel > 0 then
    SendMsg(Self, RM_SERIESSKILLARR, 0, 0, 0, 0, '');
  SendMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
  GameGoldChanged();
  InternalPowerPointChanged();
  m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
  if m_MyGuild <> nil then
  begin
    m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
    for i := 0 to TGuild(m_MyGuild).m_GuildWarList.Count - 1 do
      SysMsg(TGuild(m_MyGuild).m_GuildWarList.Keys[i] + ' ÕýÔÚÓë±¾ÐÐ»á½øÐÐÐÐ»áÕ½', c_Green, t_Hint);
  end;
  RefShowName();

  if (m_nPayMent = 1) then
  begin
    if not m_boTryPlayMode then
      SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
    m_nGoldMax := g_Config.nHumanTryModeMaxGold;
    if m_Abil.Level > g_Config.nTryModeLevel then
    begin
      SysMsg('²âÊÔ×´Ì¬¿ÉÒÔÊ¹ÓÃµ½µÚ ' + IntToStr(g_Config.nTryModeLevel) + ' ¼¶', c_Red, t_Hint);
      SysMsg('Á´½ÓÖÐ¶Ï£¬Çëµ½ÒÔÏÂµØÖ·»ñµÃÊÕ·ÑÏà¹ØÐÅÏ¢¡£(http://www.98km2.com)', c_Red, t_Hint);
      m_boEmergencyClose := True;
    end;
  end;
  if (m_nPayMent = 3) and not m_boTryPlayMode then
    SysMsg(g_sNowIsFreePlayMode {'µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ²âÊÔÄ£Ê½.'}, c_Green, t_Hint);
  if g_Config.boVentureServer then
    SysMsg('µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ£º[Ã°ÏÕÄ£Ê½]', c_Green, t_Hint);
  if (m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil) and (not m_boUseThrusting) then
  begin
    m_boUseThrusting := True;
    SendSocket(nil, '+LNG');
  end;
  if m_PEnvir.m_MapFlag.boNORECONNECT then
    MapRandomMove(m_PEnvir.m_MapFlag.sReConnectMap, 0);

  CancelDoStall;

  if CheckDenyLogon() then
    Exit;

  if m_boOffLineLogin then
  begin
    m_boOffLineLogin := False;
    m_dwQueryBagItemsTick := 0;
    FillChar(m_btGetShopItem, 6, #0);
    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.m_OprCount := 0;
      g_ManageNPC.GotoLable(Self, '@Resume', False);
    end;
  end;

  if m_MagicArr[0][42] <> nil then
  begin
    m_nVigour := _MIN((m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour);
    SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
  end;

  m_boFixedHideMode := False;

  if m_sDearName <> '' then
    CheckMarry();
  CheckMaster();
  m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

  if g_Config.boPasswordLockSystem then
  begin
    if m_boPasswordLocked then
      m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
    if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then
    begin
      m_boCanDeal := not g_Config.boLockDealAction;
      m_boCanRecallHero := not g_Config.boLockRecallAction;
      m_boCanDrop := not g_Config.boLockDropAction;
      m_boCanUseItem := not g_Config.boLockUserItemAction;
      m_boCanWalk := not g_Config.boLockWalkAction;
      m_boCanRun := not g_Config.boLockRunAction;
      m_boCanHit := not g_Config.boLockHitAction;
      m_boCanSpell := not g_Config.boLockSpellAction;
      m_boCanSendMsg := not g_Config.boLockSendMsgAction;
      m_boObMode := g_Config.boLockInObModeAction;
      m_boAdminMode := g_Config.boLockInObModeAction;
      SysMsg(g_sActionIsLockedMsg + ' ¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sActionIsLockedMsg + '\ \'
        + '¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd + '\'
        + '¼ÓËøÃüÁî: @' + g_GameCommand.Lock.sCmd + '\'
        + 'ÉèÖÃÃÜÂëÃüÁî: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + 'ÐÞ¸ÄÃÜÂëÃüÁî: @' + g_GameCommand.CHGPASSWORD.sCmd);
    end;
  end;

  if (m_ChgSlaveList <> nil) and (m_ChgSlaveList.Count > 0) then
  begin
    for i := m_ChgSlaveList.Count - 1 downto 0 do
    begin
      ChangeServerMakeSlave(pTSlaveInfo(m_ChgSlaveList[i]));
      Dispose(pTSlaveInfo(m_ChgSlaveList[i]));
    end;
    m_ChgSlaveList.Clear;
  end;

  m_boSendInSafeZone := True;
  m_dwSafeZoneCheckTick := 0;
  m_dwSearchTick := 0;
  m_dwIncGamePointTick := GetTickCount();
  m_dwIncGameGoldTick := GetTickCount();
  m_dwAutoGetExpTick := GetTickCount();
{$IFEND V_TEST}
end;

procedure TPlayObject.UserLogon();
var
  i: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  sItem, sIPaddr: string;
  HeroObject: TBaseObject;
  pSlaveInfo: pTSlaveInfo;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::UserLogon';
  sCheckIPaddrFail = 'µÇÂ¼IPµØÖ·²»Æ¥Åä';
  sUserFullMsg = '¶Ô²»Æð£¬µ±Ç°·þÎñÆ÷ÔÚÏßÈËÊýÒÑÂú£¡';
begin
  sIPaddr := '';
  try
    if g_Config.boTestServer then
    begin
      if m_Abil.Level < g_Config.nTestLevel then
        m_Abil.Level := g_Config.nTestLevel;
      if m_nGold < g_Config.nTestGold then
        m_nGold := g_Config.nTestGold;
    end;
    if g_Config.boTestServer or g_Config.boServiceMode then
      m_nPayMent := 3;
    m_dwMapMoveTick := GetTickCount();
    m_dLogonTime := Now();
    m_dwLogonTick := GetTickCount();
    Initialize();
    SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');

    if m_Abil.Level <= 7 then
    begin
      if GetRangeHumanCount >= 80 then
        MapRandomMove(m_PEnvir.m_sMapFileName, 0);
      if m_boDieInFight3Zone then
        MapRandomMove(m_PEnvir.m_sMapFileName, 0);
    end;
    if UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission) then
    begin
{$IF VEROWNER = WL}
      if not CompareIPaddr(m_sIPaddr, sIPaddr) then
      begin
        SysMsg(sCheckIPaddrFail, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
{$IFEND}
    end;
    GetHomePoint();
    //for i := 0 to m_MagicList.Count - 1 do CheckSkillShowHP(pTUserMagic(m_MagicList.Items[i]));
    if m_MagicArr[0][28] <> nil then
      CheckSkillShowHP(m_MagicArr[0][28]);
    if m_boNewHuman then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);

      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);

      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);

      New(UserItem);
      if m_btGender = 0 then
        sItem := g_Config.sClothsMan
      else
        sItem := g_Config.sClothsWoman;
      if UserEngine.CopyToUserItemFromName(sItem, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);
    end;

    {¼ì²é±³°üÖÐµÄÎïÆ·ÊÇ·ñºÏ·¨ and ÉÏÏßÉ¾³ýÖ¸¶¨LIMITÎïÆ·  By blue}
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem = nil) or (StdItem.Name = '') or
        InLimitItemList('', UserItem.wIndex, t_pOnLogon) or
        ((StdItem.Overlap >= 1) and (UserItem.Dura = 0)) then
      begin
        Dispose(pTUserItem(m_ItemList.Items[i]));
        m_ItemList.Delete(i);
      end;
    end;

    {¼ì²é²Ö¿âÖÐµÄÎïÆ·ÊÇ·ñºÏ·¨ and ÉÏÏßÉ¾³ýÖ¸¶¨LIMITÎïÆ·  By blue}
    for i := m_StorageItemList.Count - 1 downto 0 do
    begin
      UserItem := m_StorageItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem = nil) or (StdItem.Name = '') or
        InLimitItemList('', UserItem.wIndex, t_pOnLogon) or
        ((StdItem.Overlap >= 1) and (UserItem.Dura = 0)) then
      begin
        Dispose(pTUserItem(m_StorageItemList.Items[i]));
        m_StorageItemList.Delete(i);
      end;
    end;

    {¼ì²éÈËÎïÉíÉÏµÄÎïÆ·ÊÇ·ñ·ûºÏÊ¹ÓÃ¹æÔò}
    if g_Config.boCheckUserItemPlace then
    begin
      for i := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if m_UseItems[i].wIndex > 0 then
        begin
          if InLimitItemList('', m_UseItems[i].wIndex, t_pOnLogon) then
          begin //ÉÏÏßÉ¾³ýÖ¸¶¨LIMITÎïÆ·  By blue
            m_UseItems[i].wIndex := 0;
            Continue;
          end;
          StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
          if StdItem <> nil then
          begin
            if not CheckUserItems(i, {$IF VER_ClientType_45}m_wClientType, {$IFEND VER_ClientType_45}StdItem) then
            begin
              New(UserItem);
              UserItem^ := m_UseItems[i];
              if not AddItemToBag(UserItem) then
                m_ItemList.Insert(0, UserItem);
              m_UseItems[i].wIndex := 0;
            end;
          end
          else
            m_UseItems[i].wIndex := 0;
        end;
      end;
    end;

    {¸´ÖÆÆ·¼ì²é}
    //DeleteBagEctype();
    //DeleteStorageEctype();

{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
    for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
    begin
      if m_wStatusTimeArr[i] > 0 then
        m_dwStatusArrTick[i] := GetTickCount();
    end;
    m_nCharStatus := GetCharStatus();
    RecalcLevelAbilitys();
    RecalcAbilitys();
    if m_btClPkPoint = 0 then
    begin
      m_nPkPoint := 0;
      Inc(m_btClPkPoint);
    end;
    if m_PEnvir.HumCount < 10 + 10 then
      m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
    if (UserEngine.m_PlayObjectList.Count > 10) then
      m_boEmergencyClose := True;
{$I '..\Common\Macros\VMPE.inc'}
{$ELSE}
    for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
    begin
      if m_wStatusTimeArr[i] > 0 then
        m_dwStatusArrTick[i] := GetTickCount();
    end;
    m_nCharStatus := GetCharStatus();
    RecalcLevelAbilitys();
    RecalcAbilitys();
    if m_btClPkPoint = 0 then
    begin
      m_nPkPoint := 0;
      Inc(m_btClPkPoint);
    end;
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
{$IFEND V_TEST}

    if (m_nGold > g_Config.nHumanMaxGold) and (g_Config.nHumanMaxGold > 0) then
      m_nGold := g_Config.nHumanMaxGold;
    if not m_boTryPlayMode then
    begin
      if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then
      begin
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        Exit;
      end;
{$IF VER_ClientType_45}
      if (m_nSoftVersionDateEx = 0) and g_Config.boOldClientShowHiLevel then
      begin
        SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
        SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
        if (not g_Config.boCanOldClientLogon) then
        begin
          SysMsg(sClientSoftVersionError, c_Red, t_Hint);
          SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          Exit;
        end;
      end;
{$IFEND VER_ClientType_45}
      case m_btAttatckMode of
        HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);
        HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);
        HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);
        HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint);
        HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint);
        HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint);
        HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);
      end;
      SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint);
      SendMsg(Self, RM_ATTACKMODE, 0, 0, 0, 0, '');

      if g_Config.boTestServer then
        SysMsg(sStartNoticeMsg, c_Green, t_Hint);
      if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then
      begin
        if m_btPermission < 2 then
        begin
          SysMsg(sOnlineUserFull, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          if m_boOffLineFlag then
            m_boOffLineFlag := False;
          if m_boOffLinePlay then
            m_boOffLinePlay := False;
        end;
      end;
    end;
{$IF V_TEST = 1}
{$I '..\Common\Macros\VMPB.inc'}
    if (UserEngine.m_PlayObjectList.Count <= 10) then
    begin
      m_nBright := g_nGameTime;
      m_Time := g_Time;
      if g_TitlesBuffLen > 0 then
        SendMsg(Self, RM_SENDTITLES, 0, 0, 0, 0, '');
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_WINIPEXP, 0, 0, 0, 0, '');
      SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
      SendMsg(Self, RM_PLAYERCONFIG, 0, 0, 0, 0, '');
      if g_pcsiLen > 0 then
        SendMsg(Self, RM_SUITESTR, 0, 0, 0, 0, '');

    end;

    if g_Config.cbMutiHero then
      FrontEngine.AddToLoadRcdList(m_sUserID,
        m_sCharName,
        m_sIPaddr,
        5,
        m_nSessionID,
        m_nPayMent,
        m_nPayMode,
        m_nSoftVersionDate,
        m_nSocket,
        m_nGSocketIdx,
        m_nGateIdx,
        '',
        nil);

    if m_nInPowerLevel > 0 then
      SendMsg(Self, RM_SERIESSKILLARR, 0, 0, 0, 0, '');
    SendMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
    GameGoldChanged();
    InternalPowerPointChanged();
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then
    begin
      m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      for i := 0 to TGuild(m_MyGuild).m_GuildWarList.Count - 1 do
        SysMsg(TGuild(m_MyGuild).m_GuildWarList.Keys[i] + ' ÕýÔÚÓë±¾ÐÐ»á½øÐÐÐÐ»áÕ½', c_Green, t_Hint);
    end;
    RefShowName();
{$I '..\Common\Macros\VMPE.inc'}
    if (m_nPayMent = 1) then
    begin
      if not m_boTryPlayMode then
        SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
      m_nGoldMax := g_Config.nHumanTryModeMaxGold;
      if m_Abil.Level > g_Config.nTryModeLevel then
      begin
        SysMsg('²âÊÔ×´Ì¬¿ÉÒÔÊ¹ÓÃµ½µÚ ' + IntToStr(g_Config.nTryModeLevel) + ' ¼¶', c_Red, t_Hint);
        SysMsg('Á´½ÓÖÐ¶Ï£¬Çëµ½ÒÔÏÂµØÖ·»ñµÃÊÕ·ÑÏà¹ØÐÅÏ¢¡£(http://www.98km2.com)', c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    end;
    if (m_nPayMent = 3) and not m_boTryPlayMode then
      SysMsg(g_sNowIsFreePlayMode {'µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ²âÊÔÄ£Ê½.'}, c_Green, t_Hint);
    if g_Config.boVentureServer then
      SysMsg('µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ£º[Ã°ÏÕÄ£Ê½]', c_Green, t_Hint);
    if (m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil) and (not m_boUseThrusting) then
    begin
      m_boUseThrusting := True;
      SendSocket(nil, '+LNG');
    end;
    if m_PEnvir.m_MapFlag.boNORECONNECT then
      MapRandomMove(m_PEnvir.m_MapFlag.sReConnectMap, 0);
    //CheckItemExpires();

    CancelDoStall;

    if CheckDenyLogon() then
      Exit;

    HeroObject := UserEngine.GetEscort(m_sCharName);
    if HeroObject <> nil then
    begin
      HeroObject.m_Master := Self;
      m_Escort := HeroObject;
      //HeroObject.RefShowName();
      if (HeroObject.m_PEnvir <> nil) and ((abs(m_nCurrX - HeroObject.m_nCurrX) > 8) or (abs(m_nCurrY - HeroObject.m_nCurrY) > 8)) then
        SysMsg(Format('ÄãµÄ%sÔÚ£º%s(%d/%d)', [HeroObject.m_sFCharName, HeroObject.m_PEnvir.m_sMapDesc, HeroObject.m_nCurrX, HeroObject.m_nCurrY]), c_Red, t_Hint);
    end;

{$I '..\Common\Macros\VMPB.inc'}
    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.m_OprCount := 0;
      g_ManageNPC.GotoLable(Self, '@Login', False);
    end;

    if m_MagicArr[0][42] <> nil then
    begin
      m_nVigour := _MIN((m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour);
      SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
    end;

    m_boFixedHideMode := False;

    if m_sDearName <> '' then
      CheckMarry();
    CheckMaster();
    m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

    if (UserEngine.m_PlayObjectList.Count > 10) then
      m_boEmergencyClose := True;
{$I '..\Common\Macros\VMPE.inc'}

    if g_Config.boPasswordLockSystem then
    begin
      if m_boPasswordLocked then
        m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then
      begin
        m_boCanDeal := not g_Config.boLockDealAction;
        m_boCanRecallHero := not g_Config.boLockRecallAction;
        m_boCanDrop := not g_Config.boLockDropAction;
        m_boCanUseItem := not g_Config.boLockUserItemAction;
        m_boCanWalk := not g_Config.boLockWalkAction;
        m_boCanRun := not g_Config.boLockRunAction;
        m_boCanHit := not g_Config.boLockHitAction;
        m_boCanSpell := not g_Config.boLockSpellAction;
        m_boCanSendMsg := not g_Config.boLockSendMsgAction;
        m_boObMode := g_Config.boLockInObModeAction;
        m_boAdminMode := g_Config.boLockInObModeAction;
        SysMsg(g_sActionIsLockedMsg + ' ¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sActionIsLockedMsg + '\ \'
          + '¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd + '\'
          + '¼ÓËøÃüÁî: @' + g_GameCommand.Lock.sCmd + '\'
          + 'ÉèÖÃÃÜÂëÃüÁî: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
          + 'ÐÞ¸ÄÃÜÂëÃüÁî: @' + g_GameCommand.CHGPASSWORD.sCmd);
      end;
    end;

    if (m_ChgSlaveList <> nil) and (m_ChgSlaveList.Count > 0) then
    begin
      for i := 0 to m_ChgSlaveList.Count - 1 do
      begin
        pSlaveInfo := pTSlaveInfo(m_ChgSlaveList[i]);
        ChangeServerMakeSlave(pSlaveInfo);
        Dispose(pSlaveInfo);
      end;
      m_ChgSlaveList.Clear;
    end;

    if m_boChgRecallHero then
    begin
      m_boChgRecallHero := False;
      SendMsg(Self, CM_RECALLHERO, 0, 0, 0, 0, '');
    end;

    m_boSendInSafeZone := True;
    m_dwSafeZoneCheckTick := 0;
    m_dwSearchTick := 0;
    m_dwIncGamePointTick := GetTickCount();
    m_dwIncGameGoldTick := GetTickCount();
    m_dwAutoGetExpTick := GetTickCount();
{$ELSE}
    m_nBright := g_nGameTime;
    m_Time := g_Time;
    if g_TitlesBuffLen > 0 then
      SendMsg(Self, RM_SENDTITLES, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_WINIPEXP, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
    SendMsg(Self, RM_PLAYERCONFIG, 0, 0, 0, 0, '');
    if g_pcsiLen > 0 then
      SendMsg(Self, RM_SUITESTR, 0, 0, 0, 0, '');

    if g_Config.cbMutiHero then
      FrontEngine.AddToLoadRcdList(m_sUserID,
        m_sCharName,
        m_sIPaddr,
        5,
        m_nSessionID,
        m_nPayMent,
        m_nPayMode,
        m_nSoftVersionDate,
        m_nSocket,
        m_nGSocketIdx,
        m_nGateIdx,
        '',
        nil);

    if m_nInPowerLevel > 0 then
      SendMsg(Self, RM_SERIESSKILLARR, 0, 0, 0, 0, '');
    SendMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
    GameGoldChanged();
    InternalPowerPointChanged();
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then
    begin
      m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      for i := 0 to TGuild(m_MyGuild).m_GuildWarList.Count - 1 do
        SysMsg(TGuild(m_MyGuild).m_GuildWarList.Keys[i] + ' ÕýÔÚÓë±¾ÐÐ»á½øÐÐÐÐ»áÕ½', c_Green, t_Hint);
    end;
    RefShowName();
    if (m_nPayMent = 1) then
    begin
      if not m_boTryPlayMode then
        SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
      m_nGoldMax := g_Config.nHumanTryModeMaxGold;
      if m_Abil.Level > g_Config.nTryModeLevel then
      begin
        SysMsg('²âÊÔ×´Ì¬¿ÉÒÔÊ¹ÓÃµ½µÚ ' + IntToStr(g_Config.nTryModeLevel) + ' ¼¶', c_Red, t_Hint);
        SysMsg('Á´½ÓÖÐ¶Ï£¬Çëµ½ÒÔÏÂµØÖ·»ñµÃÊÕ·ÑÏà¹ØÐÅÏ¢¡£(http://www.98km2.com)', c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    end;
    if (m_nPayMent = 3) and not m_boTryPlayMode then
      SysMsg(g_sNowIsFreePlayMode {'µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ²âÊÔÄ£Ê½.'}, c_Green, t_Hint);
    if g_Config.boVentureServer then
      SysMsg('µ±Ç°·þÎñÆ÷ÔËÐÐÓÚ£º[Ã°ÏÕÄ£Ê½]', c_Green, t_Hint);
    if (m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil) and (not m_boUseThrusting) then
    begin
      m_boUseThrusting := True;
      SendSocket(nil, '+LNG');
    end;
    if m_PEnvir.m_MapFlag.boNORECONNECT then
      MapRandomMove(m_PEnvir.m_MapFlag.sReConnectMap, 0);
    //CheckItemExpires();

    CancelDoStall;

    if CheckDenyLogon() then
      Exit;

    HeroObject := UserEngine.GetEscort(m_sCharName);
    if HeroObject <> nil then
    begin
      HeroObject.m_Master := Self;
      m_Escort := HeroObject;
      //HeroObject.RefShowName();
      if (HeroObject.m_PEnvir <> nil) and ((abs(m_nCurrX - HeroObject.m_nCurrX) > 8) or (abs(m_nCurrY - HeroObject.m_nCurrY) > 8)) then
        SysMsg(Format('ÄãµÄ%sÔÚ£º%s(%d/%d)', [HeroObject.m_sFCharName, HeroObject.m_PEnvir.m_sMapDesc, HeroObject.m_nCurrX, HeroObject.m_nCurrY]), c_Red, t_Hint);
    end;

    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.m_OprCount := 0;
      g_ManageNPC.GotoLable(Self, '@Login', False);
    end;

    if m_MagicArr[0][42] <> nil then
    begin
      m_nVigour := _MIN((m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour);
      SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
    end;

    m_boFixedHideMode := False;

    if m_sDearName <> '' then
      CheckMarry();
    CheckMaster();
    m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

    if g_Config.boPasswordLockSystem then
    begin
      if m_boPasswordLocked then
        m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
      if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then
      begin
        m_boCanDeal := not g_Config.boLockDealAction;
        m_boCanRecallHero := not g_Config.boLockRecallAction;
        m_boCanDrop := not g_Config.boLockDropAction;
        m_boCanUseItem := not g_Config.boLockUserItemAction;
        m_boCanWalk := not g_Config.boLockWalkAction;
        m_boCanRun := not g_Config.boLockRunAction;
        m_boCanHit := not g_Config.boLockHitAction;
        m_boCanSpell := not g_Config.boLockSpellAction;
        m_boCanSendMsg := not g_Config.boLockSendMsgAction;
        m_boObMode := g_Config.boLockInObModeAction;
        m_boAdminMode := g_Config.boLockInObModeAction;
        SysMsg(g_sActionIsLockedMsg + ' ¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd, c_Red, t_Hint);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sActionIsLockedMsg + '\ \'
          + '¿ªËøÃüÁî: @' + g_GameCommand.UnLock.sCmd + '\'
          + '¼ÓËøÃüÁî: @' + g_GameCommand.Lock.sCmd + '\'
          + 'ÉèÖÃÃÜÂëÃüÁî: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
          + 'ÐÞ¸ÄÃÜÂëÃüÁî: @' + g_GameCommand.CHGPASSWORD.sCmd);
      end;
    end;

    if (m_ChgSlaveList <> nil) and (m_ChgSlaveList.Count > 0) then
    begin
      for i := 0 to m_ChgSlaveList.Count - 1 do
      begin
        pSlaveInfo := pTSlaveInfo(m_ChgSlaveList[i]);
        ChangeServerMakeSlave(pSlaveInfo);
        Dispose(pSlaveInfo);
      end;
      m_ChgSlaveList.Clear;
    end;

    if m_boChgRecallHero then
    begin
      m_boChgRecallHero := False;
      SendMsg(Self, CM_RECALLHERO, 0, 0, 0, 0, '');
    end;

    m_boSendInSafeZone := True;
    m_dwSafeZoneCheckTick := 0;
    m_dwSearchTick := 0;
    m_dwIncGamePointTick := GetTickCount();
    m_dwIncGameGoldTick := GetTickCount();
    m_dwAutoGetExpTick := GetTickCount();
{$IFEND V_TEST}
  except
    on E: Exception do
    begin
      m_boFixedHideMode := False;
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.ClientGetBuyOff(Npc: TBaseObject; var sMsg: string): Integer;
var
  NPC1: TMerchant;
  sUserItemName: string;
  SellOff: pSellOff;
  nPrice: Integer;
  i, ii: Integer;
  List: TList;
begin
  if m_boDeath or m_boGhost then
    Exit;
  Result := 0;
  if Npc = nil then
    Exit;
  NPC1 := TMerchant(Npc);
  sMsg := '';
  if ((NPC1.m_PEnvir = m_PEnvir) and (abs(NPC1.m_nCurrX - m_nCurrX) < 15) and (abs(NPC1.m_nCurrY - m_nCurrY) < 15)) or (NPC1.m_boIsHide) then
  begin
    if NPC1.m_SellOffList = nil then
      Exit;
    for i := 0 to NPC1.m_SellOffList.Count - 1 do
    begin
      List := NPC1.m_SellOffList[i];
      for ii := 0 to List.Count - 1 do
      begin
        SellOff := pSellOff(List[ii]);
        nPrice := SellOff^.Price;
        if SellOff^.sCharName = m_sCharName then
        begin
          nPrice := -SellOff^.Price;
          Break;
        end;
      end;
      sUserItemName := '';
      if SellOff^.item.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(SellOff^.item.MakeIndex, SellOff^.item.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(SellOff^.item.wIndex);
      sMsg := sMsg + sUserItemName + '/1/' + IntToStr(nPrice) + '/' + IntToStr(List.Count) + '/';
      Inc(Result);
    end;
  end;
end;

procedure TPlayObject.ClientGetSellOff(nParam1, nMakeIndex: Integer; sMsg: string);
var
  i, ii: Integer;
  sPrice: string;
  nPrice: Integer;
  UserItem: pTUserItem;
  OjnectNPC: TMerchant;
  sUserItemName: string;
  SellOff, temp: pSellOff;
  List: TList;
begin
  if m_boDealing or m_boDeath or m_boGhost then
    Exit;
  OjnectNPC := UserEngine.FindMerchant(TObject(nParam1));
  if OjnectNPC = nil then
    Exit;
  sMsg := GetValidStr3(sMsg, sPrice, ['/']);
  sMsg := Trim(sMsg);
  nPrice := Str_ToInt(sPrice, -1);
  if sMsg = '' then
  begin
    SendDefMessage(SM_SELLOFFERROR, -1, 0, 0, 0, '');
    Exit;
  end;
  if nPrice < 0 then
  begin
    SendDefMessage(SM_SELLOFFERROR, -2, 0, 0, 0, '');
    Exit;
  end;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then
    begin
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        if ((OjnectNPC.m_PEnvir = m_PEnvir) and (abs(OjnectNPC.m_nCurrX - m_nCurrX) < 15) and (abs(OjnectNPC.m_nCurrY - m_nCurrY) < 15)) or (OjnectNPC.m_boIsHide) then
        begin
          if not InLimitItemList('', UserItem.wIndex, t_aSellOff) then
          begin
            SendDefMessage(SM_SELLOFFERROR, -4, 0, 0, 0, '');
            Break;
          end;
          if OjnectNPC.GetSellOffItemCount(Self) > g_Config.SellCount then
          begin
            SendDefMessage(SM_SELLOFFERROR, -3, 0, 0, 0, '');
            Break;
          end;
          if UserItem.btValue[13] = 1 then
          begin
            ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
            UserItem.btValue[13] := 0;
          end;
          New(SellOff);
          FillChar(SellOff^, SizeOf(TSellOff), #0);
          SellOff^.sCharName := m_sCharName;
          SellOff^.SellTime := Now();
          SellOff^.Price := nPrice;
          SellOff^.item := UserItem^;
          SellOff^.No2 := -1;
          List := nil;
          for ii := 0 to OjnectNPC.m_SellOffList.Count - 1 do
          begin
            List := OjnectNPC.m_SellOffList[ii];
            temp := pSellOff(List[0]);
            if (temp <> nil) and (temp.item.wIndex = SellOff.item.wIndex) {and (temp.sCharName = m_sCharName)} then
            begin
              List.Add(SellOff);
              OjnectNPC.SaveSellOff;
              Break;
            end;
            List := nil;
          end;
          if List = nil then
          begin
            List := TList.Create;
            List.Add(SellOff);
            OjnectNPC.m_SellOffList.Add(List);
            OjnectNPC.SaveSellOff;
          end;
          Dispose(UserItem); //0413
          m_ItemList.Delete(i);
          WeightChanged();
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.Die();
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited Die();
    Exit;
  end;

  DieFunc();
  inherited Die();
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    m_sMarkerMap := m_sMapName;
    m_wMarkerX := m_nCurrX;
    m_wMarkerY := m_nCurrY;
  end;
end;

(*procedure TPlayObject.SendWhisperMsg(PlayObject: TPlayObject);
var
  sMsg                      : string;
  //Year, Month, Day          : Word;
  StartPoint                : pTStartPointInfo;
begin
  //DecodeDate(Date, Year, Month, Day);
  if (g_nCheckLicense^ < 0) or (g_Config.nForceOffLineMsg >= 2) then begin
    if (PlayObject = self) or (PlayObject.m_btPermission >= 9) or (m_btPermission >= 9) then
      Exit;
    if {(g_Config.nForceOffLineMsg < 5) and}(UserEngine.PlayObjectCount < g_Config.nSendWhisperPlayCount + Random(5)) then
      Exit;
    if GetStartPoint(StartPoint) then begin
      if GetTickCount - StartPoint.dwWhisperTick < g_Config.dwSendWhisperTime then
        Exit;
      StartPoint.dwWhisperTick := GetTickCount();
    end else begin
      if (m_PEnvir <> nil) and (GetTickCount - m_PEnvir.m_MapFlag.dwWhisperTick < g_Config.dwSendWhisperTime) then
        Exit;
      m_PEnvir.m_MapFlag.dwWhisperTick := GetTickCount();
    end;
    sMsg := g_Config.sServerName + '[' + g_Config.sServerIPaddr + ']ÌáÊ¾Äú£¬' + GetResourceString(t_sAdvertisement);
    Whisper(PlayObject.m_sCharName, sMsg);
    {if g_SayMsgList.Count > 0 then begin
      Inc(g_nSayMsgIdx);
      if g_SayMsgList.Count <= g_nSayMsgIdx then
        g_nSayMsgIdx := 0;
      sMsg := g_SayMsgList.Strings[g_nSayMsgIdx];
      //Whisper(PlayObject.m_sCharName, sMsg);
      case Random(2) of
        0: Whisper(PlayObject.m_sCharName, sMsg);
        1: SendRefMsg(RM_HEAR, 1, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sMsg);
      end;
    end;}
  end;
end;*)

(*
function TPlayObject.GetAttackPower(nBasePower, nPower: Integer): Integer;
var
  nLuck                     : Integer;
  GetPower                  : function(nPower: Integer; var nLuck: Integer): real;
begin
  {if m_btRaceServer <> RC_PLAYOBJECT then begin
    Result := inherited GetAttackPower(nBasePower, nPower);
    Exit;
  end;}
  if nPower < 0 then
    nPower := 0;
  nLuck := m_nLuck;
  GetPower := Pointer(m_PowerBlock);
  nBasePower := Round(GetPower(nBasePower, nLuck));
  if nLuck > 0 then begin
    if Random(10 - _MIN(9, nLuck)) = 0 then
      Result := nBasePower + nPower
    else
      Result := nBasePower + Random(nPower + 1);
  end else begin
    Result := nBasePower + Random(nPower + 1);
    if nLuck < 0 then begin
      if Random(10 - _MAX(0, -nLuck)) = 0 then
        Result := nBasePower;
    end;
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero  then begin
    //InternalPower ???
    Result := Round(Result * (TPlayObject(self).m_nPowerRate / 100));
    if TPlayObject(self).m_boPowerItem then
      Result := Round(m_rPowerItem * Result);
  end;
  if m_boAutoChangeColor then
    Result := Result * m_nAutoChangeIdx + 1;
  if m_boFixColor then
    Result := Result * m_nFixColorIdx + 1;
end;
*)

procedure TBaseObject.ReadAllBook(); //0625
var
  i: Integer;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  UserMagic := nil;
  Magic := nil;
  for i := 0 to m_MagicList.Count - 1 do
    Dispose(pTUserMagic(m_MagicList[i]));
  m_MagicList.Clear;
  for i := 0 to UserEngine.m_MagicList.Count - 1 do
  begin
    Magic := UserEngine.m_MagicList.Items[i];
    if (m_btJob = Magic.btJob) {or (Magic.btJob = 99)} then
    begin
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      if Magic.wMagicId in [13, 26, 31, 45] then
        UserMagic.btLevel := _MAX(4, UserMagic.MagicInfo.btTrainLv)
      else
        UserMagic.btLevel := UserMagic.MagicInfo.btTrainLv;
      UserMagic.btKey := 0;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then //0625
        TPlayObject(Self).SendAddMagic(UserMagic);
    end;
  end;
  RecalcAbilitys();
end;

procedure TPlayObject.SendGoldInfo(boSendName: Boolean);
var
  sMsg: string;
begin
  if boSendName then
    sMsg := g_Config.sGameGoldName + #13 + g_Config.sGamePointName;
{$IF VER_ClientType_45}
  if (m_nClientVerNO = 11) and (m_wClientType = 900) then
    SendDefMessage(SM_GAMEGOLDNAME, m_nGameGold * 100, LoWord(m_nGamePoint), HiWord(m_nGamePoint), 0, sMsg)
  else
{$IFEND VER_ClientType_45}
    SendDefMessage(SM_GAMEGOLDNAME, m_nGameGold, LoWord(m_nGamePoint), HiWord(m_nGamePoint), 0, sMsg);
end;

procedure TPlayObject.SendLogon();
var
  sSENDMSG: string;
  MessageBodyWL: TMessageBodyWL;
  MessageBodyW: TMessageBodyW;
  Buffer: array[0..255] of Byte;
  nRecog: Integer;
begin
  m_DefMsg := MakeDefaultMsg(SM_LOGON, Integer(Self), m_nCurrX, m_nCurrY, MakeWord(m_btDirection, m_nLight));
  MessageBodyWL.lParam1 := GetFeatureToLong(@Buffer[0]);
  MessageBodyWL.lParam2 := m_nCharStatus;
  if m_boAllowGroup then
    MessageBodyWL.lTag1 := MakeLong(MakeWord(1, 0), GetFeatureEx)
  else
    MessageBodyWL.lTag1 := MakeLong(MakeWord(0, 0), GetFeatureEx); //1020
  MessageBodyWL.lTag2 := 0;
  SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)) + EncodeBuffer(@Buffer[0], MessageBodyWL.lParam1));

  nRecog := GetFeatureToLong(@Buffer[0]);

  sSENDMSG := '';
  MessageBodyW.param1 := MakeWord(GetTitleIndex, 0);
  MessageBodyW.param2 := 0;
  MessageBodyW.Tag1 := 0;
  MessageBodyW.Tag2 := 0;
  sSENDMSG := EncodeBuffer(@MessageBodyW, SizeOf(MessageBodyW));

  m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED,
    Integer(Self),
    LoWord(nRecog),
    HiWord(nRecog),
    GetFeatureEx);
  sSENDMSG := sSENDMSG + EncodeBuffer(@Buffer[0], nRecog);
  SendSocket(@m_DefMsg, sSENDMSG);
  
  InternalPowerPointChanged();
end;

procedure TPlayObject.SendServerConfig;
var
  nRecog, nParam: Integer;
  nRunHuman, nRunMon, nRunNpc, nWarRunAll: Integer;
  ClientConf: TClientConf;
  sMsg: string;
  svrcfg: TServerConfig;
begin
{$IF VER_ClientType_45}
  if m_nSoftVersionDateEx = 0 then
    Exit;
{$IFEND VER_ClientType_45}
  nRunHuman := 0;
  nRunMon := 0;
  nRunNpc := 0;
  nWarRunAll := 0;
  if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) then
  begin
    nRunHuman := 1;
    nRunMon := 1;
    nRunNpc := 1;
    nWarRunAll := 1;
  end
  else
  begin
    if g_Config.boRUNHUMAN or m_PEnvir.m_MapFlag.boRUNHUMAN then
      nRunHuman := 1;
    if g_Config.boRUNMON or m_PEnvir.m_MapFlag.boRUNMON then
      nRunMon := 1;
    if g_Config.boRunNpc then
      nRunNpc := 1;
    if g_Config.boWarDisHumRun then
      nWarRunAll := 1;
  end;
  ClientConf := g_Config.ClientConf;
  ClientConf.boRUNHUMAN := nRunHuman = 1;
  ClientConf.boRUNMON := nRunMon = 1;
  ClientConf.boRunNpc := nRunNpc = 1;
  ClientConf.boWarRunAll := g_Config.boLimitSquAttack;
  ClientConf.wSpellTime := g_Config.dwMagicHitIntervalTime + 300;
  ClientConf.wHitIime := g_Config.dwHitIntervalTime + 500;
  sMsg := EncodeBuffer(@ClientConf, SizeOf(ClientConf));
  nRecog := MakeLong(MakeWord(Integer(g_Config.boClientAutoPlay), nRunMon), MakeWord(nRunNpc, nWarRunAll));
  nParam := MakeWord(5, 0);
  SendDefMessage(SM_SERVERCONFIG, nRecog, nParam, _MIN(65000, g_Config.nEatItemTime), Word(g_Config.boSpeedCtrl), sMsg);

  FillChar(svrcfg, SizeOf(svrcfg), 0);
  svrcfg.AutoSay := g_Config.ClientAutoSay;
  svrcfg.Reserved[0] := Byte(g_Config.cbMutiHero);
  svrcfg.Reserved[1] := Byte(g_Config.boSkill_114_MP);
  svrcfg.Reserved[2] := Byte(g_Config.boSkill_68_MP);
  svrcfg.Reserved[3] := Byte(not  g_Config.boJointStrikeUI);
  svrcfg.Reserved[4] := Byte(g_Config.boOpenFindPathMyMap);
  sMsg := EncodeBuffer(@svrcfg, SizeOf(svrcfg));
  SendDefMessage(SM_SERVERCONFIG2,
    Integer(Self),
    MakeWord(Byte(g_Config.boStallSystem), Byte(g_Config.boClientNoFog)),
    MakeWord(Byte(g_Config.ClientAotoLongAttack), Byte(g_Config.boHeroSystem)),
    _MIN(65000, g_Config.nEatItemTime), sMsg);
  //g_Config.boStallSystem

end;
{
procedure TPlayObject.SendServerStatus;
begin
  if m_btPermission < 10 then
    Exit;
  SysMsg(IntToStr(CalcFileCRC(Application.ExeName)), c_Red, t_Hint);
end;
 }
function TPlayObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer; range: Integer): Boolean;
var
  i: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  //pListNode                 : PTWHNode;
begin
  Result := False;
  if m_PEnvir = nil then
  begin
    MainOutMessageAPI('CretInNearXY nil PEnvir');
    Exit;
  end;
  for nCX := nX - range to nX + range do
  begin
    for nCY := nY - range to nY + range do
    begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} then
      begin
        for i := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject <> nil then
          begin
            if OSObject.btType = OS_MOVINGOBJECT then
            begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if BaseObject <> nil then
              begin
                if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then
                begin
                  Result := True;
                  Exit;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.SendUseitems();
var
  i: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
begin
  sSENDMSG := '';
{$IF VER_ClientType_45}
  if m_wClientType = 45 then
  begin
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        item := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if item <> nil then
        begin
          StdItem := item^;
          ItemUnit.GetItemAddValue(@m_UseItems[i], StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          sUserItemName := '';
          if m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[i].MakeIndex, m_UseItems[i].wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;

          OClientItem.Dura := m_UseItems[i].Dura;
          OClientItem.DuraMax := m_UseItems[i].DuraMax;
          OClientItem.MakeIndex := m_UseItems[i].MakeIndex;
          sSENDMSG := sSENDMSG + IntToStr(i) + '/' + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
    Exit;
  end;
  sSENDMSG := '';
  if m_wClientType <> 46 then
  begin
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        item := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if item <> nil then
        begin
          StdItem := item^;
          ItemUnit.GetItemAddValue(@m_UseItems[i], StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          sUserItemName := '';
          if m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[i].MakeIndex, m_UseItems[i].wIndex);                                            
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;

          OClientItem.Dura := m_UseItems[i].Dura;
          OClientItem.DuraMax := m_UseItems[i].DuraMax;
          OClientItem.MakeIndex := m_UseItems[i].MakeIndex;
          sSENDMSG := sSENDMSG + IntToStr(i) + '/' + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end
  else
  begin
{$IFEND VER_ClientType_45}
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        item := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if item <> nil then
        begin
          StdItem := item^;
          ItemUnit.GetItemAddValue(@m_UseItems[i], StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
          sUserItemName := '';
          if m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[i].MakeIndex, m_UseItems[i].wIndex);
          if sUserItemName <> '' then
            ClientItem.s.Name := sUserItemName;
          ClientItem.Dura := m_UseItems[i].Dura;
          ClientItem.DuraMax := m_UseItems[i].DuraMax;
          ClientItem.MakeIndex := m_UseItems[i].MakeIndex;

          ClientItem.s.ItemType := m_UseItems[i].btValue[14];
          GetSendClientItem(@m_UseItems[i], Self, ClientItem);

          sSENDMSG := sSENDMSG + IntToStr(i) + '/' + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.SendHeroLoyalty();
var
  HeroObject: TBaseObject;
  d: Double;
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
  m_DefMsg := MakeDefaultMsg(SM_HEROLOYALTY, Integer(HeroObject), 0, 0, 0);
  if HeroObject.m_dBodyLuck = 0 then
    d := 1
  else
    d := HeroObject.m_dBodyLuck;
  SendSocket(@m_DefMsg, EncodeString(FormatFloat('###00.00%', d / 250)));
end;

procedure TPlayObject.SendHeroUseitems();
var
  i: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
{$IF VER_ClientType_45}
  if m_wClientType = 45 then
  begin
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if HeroObject.m_UseItems[i].wIndex > 0 then
      begin
        item := UserEngine.GetStdItem(HeroObject.m_UseItems[i].wIndex);
        if item <> nil then
        begin
          StdItem := item^;
          ItemUnit.GetItemAddValue(@HeroObject.m_UseItems[i], StdItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
          sUserItemName := '';
          if HeroObject.m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(HeroObject.m_UseItems[i].MakeIndex, HeroObject.m_UseItems[i].wIndex);
          if sUserItemName <> '' then
            OClientItem.s.Name := sUserItemName;

          OClientItem.Dura := HeroObject.m_UseItems[i].Dura;
          OClientItem.DuraMax := HeroObject.m_UseItems[i].DuraMax;
          OClientItem.MakeIndex := HeroObject.m_UseItems[i].MakeIndex;
          sSENDMSG := sSENDMSG + IntToStr(i) + '/' + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
        end;
      end;
    end;
    if sSENDMSG <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_HEROUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSENDMSG);
    end;
  end
  else
  begin
{$IFEND VER_ClientType_45}
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if HeroObject.m_UseItems[i].wIndex > 0 then
      begin
        item := UserEngine.GetStdItem(HeroObject.m_UseItems[i].wIndex);
        if item <> nil then
        begin
          StdItem := item^;
          ItemUnit.GetItemAddValue(@HeroObject.m_UseItems[i], StdItem);
          Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
          sUserItemName := '';
          if HeroObject.m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(HeroObject.m_UseItems[i].MakeIndex, HeroObject.m_UseItems[i].wIndex);
          if sUserItemName <> '' then
            ClientItem.s.Name := sUserItemName;
          ClientItem.Dura := HeroObject.m_UseItems[i].Dura;
          ClientItem.DuraMax := HeroObject.m_UseItems[i].DuraMax;
          ClientItem.MakeIndex := HeroObject.m_UseItems[i].MakeIndex;

          ClientItem.s.ItemType := HeroObject.m_UseItems[i].btValue[14];
          GetSendClientItem(@HeroObject.m_UseItems[i], TPlayObject(HeroObject), ClientItem);

          sSENDMSG := sSENDMSG + IntToStr(i) + '/' + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
        end;
      end;
    end;
    // if sSENDMSG <> '' then    
    //begin
    m_DefMsg := MakeDefaultMsg(SM_HEROUSEITEMS, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, sSENDMSG);
    //end;
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.SendHeroUseMagicDelay();
var
  i: Integer;
  sSENDMSG: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
  HeroObject: TBaseObject;
  //resourcestring
    //sExceptionMsg             = '[Exception] TPlayObject::SendHeroUseMagicDelay Code: %d';
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
  sSENDMSG := '';
  for i := 0 to HeroObject.m_MagicList.Count - 1 do
  begin
    UserMagic := HeroObject.m_MagicList.Items[i];
    ClientMagic.Key := Chr(UserMagic.btKey);
    ClientMagic.Level := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def := UserMagic.MagicInfo^;
    ClientMagic.Def.btTrainLv := MagicMaxTrainLevel(UserMagic);
    sSENDMSG := sSENDMSG + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) + '/';
  end;
  SendUpdateDelayMsg(Self, RM_HEROMAGIC_LVEXP, 0, 0, 0, HeroObject.m_MagicList.Count, sSENDMSG, 3 * 1000);
end;

procedure TPlayObject.SendHeroUseMagic();
var
  i: Integer;
  sSENDMSG: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
  HeroObject: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::SendHeroUseMagic Code: %d';
begin
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
    Exit;
  sSENDMSG := '';
  for i := 0 to HeroObject.m_MagicList.Count - 1 do
  begin
    UserMagic := HeroObject.m_MagicList.Items[i];
    ClientMagic.Key := Chr(UserMagic.btKey);
    ClientMagic.Level := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def := UserMagic.MagicInfo^;
    ClientMagic.Def.btTrainLv := MagicMaxTrainLevel(UserMagic);
    sSENDMSG := sSENDMSG + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) + '/';
  end;
  m_DefMsg := MakeDefaultMsg(SM_HEROMYMAGICS, 0, 0, 0, HeroObject.m_MagicList.Count);
  SendSocket(@m_DefMsg, sSENDMSG);

  TPlayObject(HeroObject).SendMyTitles(True);
end;

procedure TPlayObject.SendMyTitles(boReCount: Boolean);
var
  i, nInteger, tObjCount: Integer;
  sSENDMSG: string;
  SendTitle: THumTitle;
  StdItem: pTStdItem;
begin
  m_dwCheckTitleTick := GetTickCount();

  if boReCount then
  begin
    for i := Low(THumTitles) to High(THumTitles) do
    begin
      if m_Titles[i].Index > 0 then
      begin
        StdItem := UserEngine.GetTitle(m_Titles[i].Index);
        if StdItem <> nil then
        begin
          if (StdItem.DuraMax = 0) or (m_Titles[i].Time = 0) then
            Continue;
          nInteger := StdItem.DuraMax - Round((GetItemFormatDate - m_Titles[i].Time) / (60 * 60));
          if nInteger <= 0 then
          begin
            if (m_btActiveTitle in [1..6]) and (m_btActiveTitle - 1 = i) then
            begin
              ClientChangeTitle(0, 0);
            end;
            m_Titles[i].Index := 0;
          end;
        end;
      end;
    end;
  end;

  sSENDMSG := '';
  tObjCount := 0;
  for i := Low(m_Titles) to High(m_Titles) do
  begin
    if m_Titles[i].Index > 0 then
    begin
      SendTitle.Index := m_Titles[i].Index;
      SendTitle.Time := M2Share.GetTitleTime(m_Titles[i]);
      Inc(tObjCount);
      sSENDMSG := sSENDMSG + EncodeBuffer(@SendTitle, SizeOf(THumTitle)) + '/';
    end;
  end;

  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_MYTITLES, 1, 0, 0, tObjCount);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, sSENDMSG);
  end
  else
  begin
    m_DefMsg := MakeDefaultMsg(SM_MYTITLES, 0, 0, 0, tObjCount);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;

procedure TPlayObject.SendUseMagic();
var
  i: Integer;
  sSENDMSG: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
begin
  sSENDMSG := '';
  for i := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    ClientMagic.Key := Chr(UserMagic.btKey);
    ClientMagic.Level := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def := UserMagic.MagicInfo^;
    ClientMagic.Def.btTrainLv := MagicMaxTrainLevel(UserMagic);
    sSENDMSG := sSENDMSG + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) + '/';
  end;
  if sSENDMSG <> '' then
  begin
    m_DefMsg := MakeDefaultMsg(SM_SENDMYMAGIC, 0, 0, 0, m_MagicList.Count);
    SendSocket(@m_DefMsg, sSENDMSG);
  end;

  SendMyTitles(True);
end;

function TPlayObject.ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //4CAEB8
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if not (nDir in [0..7]) then
    Exit;
  if m_boDeath or m_StallMgr.OnSale or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
    Exit;
{$IF SERIESSKILL}
  if GetTickCount() - m_dwCanNextMoveTick < 100 then
    Exit;
{$IFEND SERIESSKILL}
  if not CheckActionStatus(wIdent, dwDelayTime) then
  begin
    m_boFilterAction := False;
    Exit;
  end;
  m_boFilterAction := True;

  if not g_Config.boSpeedHackCheck then
  begin
    dwCheckTime := GetTickCount - m_dwTurnTick;
    if dwCheckTime < g_Config.dwTurnIntervalTime then
    begin
      dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
      Exit;
    end;
  end;

  if (nX = m_nCurrX) and (nY = m_nCurrY) then
  begin
    m_btDirection := nDir;
    if Walk(RM_TURN) then
    begin
      m_dwTurnTick := GetTickCount();
      Result := True;
    end;
  end;
end;

function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean; //004CC248
var
  dwCheckTime: LongWord;
begin
  Result := False;
  if not (nDir in [0..7]) then
    Exit;
  if m_boDeath or (m_wStatusTimeArr[POISON_PURPLE] <> 0) or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
    Exit;
  if not g_Config.boSpeedHackCheck then
  begin
    dwCheckTime := GetTickCount - m_dwTurnTick;
    if dwCheckTime < g_Config.dwTurnIntervalTime then
    begin
      dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
      Exit;
    end;
    m_dwTurnTick := GetTickCount;
    //SendRefMsg(RM_POWERHIT, 0, 0, 0, 0, '');
  end;
  m_btDirection := nDir;
  SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  Result := True;
end;

procedure TPlayObject.ClientOpenDoor(nX, nY: Integer); //004DABD4
var
  Door: pTDoorInfo;
  Castle: TUserCastle;
begin
  Door := m_PEnvir.GetDoor(nX, nY);
  if Door = nil then
    Exit;
  Castle := g_CastleManager.IsCastleEnvir(m_PEnvir);
  if (Castle = nil) or
    (Castle.m_DoorStatus <> Door.Status) or
    (m_btRaceServer <> RC_PLAYOBJECT) or
    Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
  begin
    UserEngine.OpenDoor(m_PEnvir, nX, nY);
  end;
end;

function TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
var
  i, Source, n14: Integer;
  UserItem, TakeOffItem: pTUserItem;
  dStdItem, StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  boRecalcSuite: Boolean;
  Buffer: array[0..255] of Byte;
  FeatureMsg: string;
label
  FailExit, labExit;
begin
  n14 := -1;
  if m_boOffLineFlag then
    Exit;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
    begin
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (CompareText(sUserItemName, sItemName) = 0) then
      begin
        n14 := i;
        Break;
      end;
    end;
  end;
  Result := 0;
  if n14 >= 0 then
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
      begin
        SendDefMessage(SM_TAKEON_FAIL, Result, 0, 0, 0, '');
        Exit;
      end;
    end;

    if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
    begin
      if g_Config.boBindNoUse then
      begin
        SysMsg(Format('%sÒÑ°ó¶¨ÓÚÆäËûÕÊºÅ£¬Äã²»ÄÜÊ¹ÓÃ', [StdItem.Name]), c_Red, t_Hint);
        SendDefMessage(SM_TAKEON_FAIL, Result, 0, 0, 0, '');
        Exit;
      end;
    end;

    if InLimitItemList('', UserItem.wIndex, t_dTakeOn) then
    begin
      SysMsg(Format('Äã²»ÄÜÊ¹ÓÃ£º%s', [StdItem.Name]), c_Red, t_Hint);
      SendDefMessage(SM_TAKEON_FAIL, Result, 0, 0, 0, '');
      Exit;
    end;
    if (btWhere = 9) and (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura < m_UseItems[U_BUJUK].DuraMax) then
    begin
      dStdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
      if (dStdItem <> nil) then
      begin
        if (dStdItem.StdMode = 2) and (dStdItem.Source <> 0) then
        begin
          if dStdItem.Source < 0 then
            Source := 256 + dStdItem.Source
          else
            Source := dStdItem.Source;
          sUserItemName := GetUnbindItemName(Source);
          if sUserItemName <> '' then
          begin
            if CompareText(sUserItemName, StdItem.Name) = 0 then
            begin
              Inc(m_UseItems[U_BUJUK].Dura, 1000);
              goto labExit;
            end;
          end;
        end;

        if (((StdItem.StdMode = 41) and (StdItem.Shape = 1)) or
          ((StdItem.StdMode = 25) and (StdItem.Shape = 10) and (UserItem.Dura >= 100) and (UserItem.Dura < UserItem.DuraMax))) and
          ((dStdItem.StdMode = 25) and (dStdItem.Shape = 10) and (m_UseItems[U_BUJUK].Dura >= 500)) then
        begin
          case StdItem.StdMode of
            41: Inc(m_UseItems[U_BUJUK].Dura, 500);
            25: Inc(m_UseItems[U_BUJUK].Dura, UserItem.Dura);
          end;
          labExit:
          if m_UseItems[U_BUJUK].Dura > m_UseItems[U_BUJUK].DuraMax then
            m_UseItems[U_BUJUK].Dura := m_UseItems[U_BUJUK].DuraMax;
          SendDefMessage(SM_TAKEON_FAIL, 0, 0, 0, 0, '');
          SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0, '');
          SendDelItems(UserItem);
          DelBagItem(n14);
          Exit;
        end;
      end;
    end;

    boRecalcSuite := False;
    if CheckUserItems(btWhere, {$IF VER_ClientType_45}m_wClientType, {$IFEND VER_ClientType_45}StdItem) then
    begin
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if CheckTakeOnItems(btWhere, StdItem58) and CheckItemBindUse(UserItem) then
      begin
        TakeOffItem := nil;
        if btWhere in [Low(THumanUseItems)..High(THumanUseItems)] then
        begin
          if m_UseItems[btWhere].wIndex > 0 then
          begin
            StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
            if (StdItem20 <> nil) then
            begin
              if StdItem20.SvrSet.btRefSuiteCount > 0 then
                boRecalcSuite := True;
              if (StdItem20.StdMode in [15..24, 26]) then
              begin
                if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then
                begin
                  SysMsg(g_sCanotTakeOffItem {'ÎÞ·¨È¡ÏÂÎïÆ·'}, c_Red, t_Hint);
                  Result := -4;
                  goto FailExit;
                end;
              end;
              {if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then begin
                SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
                Result := -4;
                goto FailExit;
              end;
              if (StdItem20.Reserved and 4) <> 0 then begin
                SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
                Result := -4;
                goto FailExit;
              end;}
              if InLimitItemList('', m_UseItems[btWhere].wIndex, t_dTakeOff) then
              begin
                SysMsg(Format(g_sCanotTakeOffItem, [StdItem20.Name]), c_Red, t_Hint);
                goto FailExit;
              end;
            end;
            New(TakeOffItem);
            TakeOffItem^ := m_UseItems[btWhere];
          end;

          //×°±¸ºó°ó¶¨
          if g_Config.boBindTakeOn and (PCardinal(@UserItem.btValue[22])^ = 0) then
          begin
            if StdItem.SvrSet.nBind and $2 <> 0 then
              PCardinal(@UserItem.btValue[22])^ := m_dwIdCRC;
          end;

          m_UseItems[btWhere] := UserItem^;
          DelBagItem(n14);
          if TakeOffItem <> nil then
          begin
            TakeOffFunc(btWhere); //@TakeOff ´¥·¢
            AddItemToBag(TakeOffItem);
            SendAddItem(TakeOffItem);
            CheckDelBagCopyed();
          end;
          RecalcAbilitys((StdItem.SvrSet.btRefSuiteCount > 0) or boRecalcSuite);
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
          i := GetFeatureToLong(@Buffer[0]);
          SetLength(FeatureMsg,i);
          Move(Buffer[0], FeatureMsg[1],i);
          SendDefMessage(SM_TAKEON_OK, i, GetFeatureEx, 0, 0, FeatureMsg);
          FeatureChanged();
          TakeOnFunc(btWhere); //@TakeOn ´¥·¢
          Result := 1;
        end;
      end
      else
        Result := -1;
    end
    else
      Result := -1;
  end;
  FailExit:
  if Result <= 0 then
    SendDefMessage(SM_TAKEON_FAIL, Result, 0, 0, 0, '');
end;

procedure TPlayObject.ClientPlayerAddItemToHero(nItemIdx: Integer; sItemName: string);
var
  i: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
  stdItemIndex: Integer;
label
  FailExit;
begin
  if m_boOffLineFlag or m_boDeath then
  begin
    SendDefMessage(SM_HEROEXCHGBAGITEM_FAIL, 2, 0, 0, 0, '');
    Exit;
  end;

  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or (HeroObject.m_boDeath) then
  begin
    SendDefMessage(SM_HEROEXCHGBAGITEM_FAIL, 2, 0, 0, 0, '');
    Exit;
  end;


  if not TPlayObject(HeroObject).IsEnoughBag then
  begin
    SendDefMessage(SM_HEROEXCHGBAGITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if (GetTickCount - m_DealLastTick) > g_Config.dwTryDealTime then
  begin
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if TPlayObject(Self).IsOnSaleItem(nItemIdx) then
          begin
            Exit;
          end;
        end;
        if InLimitItemList('', UserItem.wIndex, t_dHeroUse) then
        begin
          SendDefMessage(SM_HEROEXCHGBAGITEM_FAIL, 2, 0, 0, 0, '');
          Exit;
        end;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Break;
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          if HeroObject.AddItemToBag(UserItem) then
          begin
            m_ItemList.Delete(i);
            SendDefMessage(SM_ADDITEMTOHEROBAG, 0, 0, 0, 0, '');
            WeightChanged();
            HeroObject.WeightChanged();

            m_dwSaveRcdTick := 0;
            HeroObject.m_dwHeroSaveRcdTick := 0;

            HeroObject.RecalcAbilitys();
            HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
            HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');
            //Break;
          end
        end;
        Break; //0805
      end;
    end;
  end;
end;

procedure TPlayObject.ClientHeroAddItemToPlayer(nItemIdx: Integer; sItemName: string);
var
  i: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
label
  FailExit;
begin
  if m_boOffLineFlag or m_boDeath then
    Exit;

  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or (HeroObject.m_boDeath) then
    Exit;

  if not IsEnoughBag then
  begin
    SendDefMessage(SM_HEROEXCHGBAGITEM_FAIL, 1, 0, 0, 0, '');
    Exit;
  end;
  if (GetTickCount - m_DealLastTick) > g_Config.dwTryDealTime then
  begin
    for i := 0 to HeroObject.m_ItemList.Count - 1 do
    begin
      UserItem := HeroObject.m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Break;
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          if AddItemToBag(UserItem) then
          begin
            HeroObject.m_ItemList.Delete(i);
            SendDefMessage(SM_GETITEMFROMHEROBAG, 0, 0, 0, 0, '');
            HeroObject.WeightChanged();

            m_dwSaveRcdTick := 0;
            HeroObject.m_dwHeroSaveRcdTick := 0;

            HeroObject.RecalcAbilitys();
            HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
            HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');

            //Break;
          end
        end;
        Break; //0805
      end;
    end;
  end;
end;

function TPlayObject.ClientHeroTakeOnItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
var
  i, n14: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: pTStdItem;
  StdItem58: TStdItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
  boRecalcSuite: Boolean;
label
  FailExit;
begin
  Result := 0;
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or (HeroObject.m_boDeath) then
  begin
    SendDefMessage(SM_HEROTAKEON_FAIL, Result, 0, 0, 0, '');
    Exit;
  end;
  n14 := -1;
  for i := 0 to HeroObject.m_ItemList.Count - 1 do
  begin
    UserItem := HeroObject.m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
    begin
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (CompareText(sUserItemName, sItemName) = 0) then
      begin
        n14 := i;
        Break;
      end;
    end;
  end;
  if n14 >= 0 then
  begin
    boRecalcSuite := False;
    if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> TPlayObject(HeroObject).m_dwIdCRC) then
    begin
      if g_Config.boBindNoUse then
      begin
        HeroObject.SysMsg(Format('%sÒÑ°ó¶¨ÓÚÆäËûÕÊºÅ£¬Äã²»ÄÜÊ¹ÓÃ', [StdItem.Name]), c_Red, t_Hint);
        SendDefMessage(SM_HEROTAKEON_FAIL, Result, 0, 0, 0, '');
        Exit;
      end;
    end;
    if InLimitItemList('', UserItem.wIndex, t_dHeroUse) then
    begin
      HeroObject.SysMsg(Format('Äã²»ÄÜÊ¹ÓÃ£º%s', [StdItem.Name]), c_Red, t_Hint);
      SendDefMessage(SM_HEROTAKEON_FAIL, Result, 0, 0, 0, '');
      Exit;
    end;
    if CheckUserItems(btWhere, {$IF VER_ClientType_45}HeroObject.m_wClientType, {$IFEND VER_ClientType_45}StdItem) then
    begin
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if TPlayObject(HeroObject).CheckTakeOnItems(btWhere, StdItem58) and TPlayObject(HeroObject).CheckItemBindUse(UserItem) then
      begin
        TakeOffItem := nil;
        if btWhere in [Low(THumanUseItems)..High(THumanUseItems)] then
        begin
          if HeroObject.m_UseItems[btWhere].wIndex > 0 then
          begin
            StdItem20 := UserEngine.GetStdItem(HeroObject.m_UseItems[btWhere].wIndex);
            if StdItem20 <> nil then
            begin
              if StdItem20.SvrSet.btRefSuiteCount > 0 then
                boRecalcSuite := True;
              if (StdItem20.StdMode in [15..24, 26]) then
              begin
                if (not HeroObject.m_boUserUnLockDurg) and (HeroObject.m_UseItems[btWhere].btValue[7] <> 0) then
                begin
                  HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
                  Result := -4;
                  goto FailExit;
                end;
              end;
              {if not HeroObject.m_boUserUnLockDurg then begin
                HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
                Result := -4;
                goto FailExit;
              end;
              if (StdItem20.Reserved and 4) <> 0 then begin
                HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
                Result := -4;
                goto FailExit;
              end;}
            end;
            if InLimitItemList('', HeroObject.m_UseItems[btWhere].wIndex, t_dTakeOff) then
            begin
              HeroObject.SysMsg(Format(g_sCanotTakeOffItem, [StdItem.Name]), c_Red, t_Hint);
              goto FailExit;
            end;
            New(TakeOffItem);
            TakeOffItem^ := HeroObject.m_UseItems[btWhere];
          end;

          //×°±¸ºó°ó¶¨
          if g_Config.boBindTakeOn and (PCardinal(@UserItem.btValue[22])^ = 0) then
          begin
            if StdItem.SvrSet.nBind and $2 <> 0 then
              PCardinal(@UserItem.btValue[22])^ := m_dwIdCRC;
          end;

          HeroObject.m_UseItems[btWhere] := UserItem^;
          HeroObject.DelBagItem(n14);
          if TakeOffItem <> nil then
          begin
            HeroObject.AddItemToBag(TakeOffItem);
            TPlayObject(HeroObject).SendAddItem(TakeOffItem);
          end;
          m_dwHeroSaveRcdTick := 0; //0408_1
          HeroObject.RecalcAbilitys((StdItem.SvrSet.btRefSuiteCount > 0) or boRecalcSuite);
          HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
          HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');
          SendDefMessage(SM_HEROTAKEON_OK, Integer(Self) {Integer(HeroObject)}, 0, 0, 0, '');
          HeroObject.FeatureChanged();
          Result := 1;
        end;
      end
      else
        Result := -1;
    end
    else
      Result := -1;
  end;
  FailExit:
  if Result <= 0 then
    SendDefMessage(SM_HEROTAKEON_FAIL, Result, 0, 0, 0, '');
end;

function TPlayObject.ClientHeroTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string): Integer;
var
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  HeroObject: TBaseObject;
label
  FailExit;
begin
  Result := 0;
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or (HeroObject.m_boDeath) then
  begin
    SendDefMessage(SM_HEROTAKEOFF_FAIL, Result, 0, 0, 0, '');
    Exit;
  end;
  if not m_boDealing and (btWhere in [Low(THumanUseItems)..High(THumanUseItems)]) then
  begin
    if HeroObject.m_UseItems[btWhere].wIndex > 0 then
    begin
      if HeroObject.m_UseItems[btWhere].MakeIndex = nItemIdx then
      begin
        StdItem := UserEngine.GetStdItem(HeroObject.m_UseItems[btWhere].wIndex);
        if StdItem = nil then
          goto FailExit;
        if (StdItem <> nil) and (StdItem.StdMode in [15..24, 26]) then
        begin
          if (not HeroObject.m_boUserUnLockDurg) and (HeroObject.m_UseItems[btWhere].btValue[7] <> 0) then
          begin
            HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
            Result := -4;
            goto FailExit;
          end;
        end;
        {if not HeroObject.m_boUserUnLockDurg then begin
          HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
          Result := -4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then begin
          HeroObject.SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
          Result := -4;
          goto FailExit;
        end;}
        if InLimitItemList('', HeroObject.m_UseItems[btWhere].wIndex, t_dTakeOff) then
        begin
          HeroObject.SysMsg(Format(g_sCanotTakeOffItem, [StdItem.Name]), c_Red, t_Hint);
          goto FailExit;
        end;
        sUserItemName := '';
        if HeroObject.m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(HeroObject.m_UseItems[btWhere].MakeIndex, HeroObject.m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(HeroObject.m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          New(UserItem);
          UserItem^ := HeroObject.m_UseItems[btWhere];
          if HeroObject.AddItemToBag(UserItem) then
          begin
            TPlayObject(HeroObject).SendDelItems(@HeroObject.m_UseItems[btWhere]);
            HeroObject.m_UseItems[btWhere].wIndex := 0;
            TPlayObject(HeroObject).SendAddItem(UserItem);
            HeroObject.RecalcAbilitys();
            HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
            HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');
            SendDefMessage(SM_HEROTAKEOFF_OK, Integer(Self) {Integer(HeroObject)}, 0, 0, 0, '');
            HeroObject.FeatureChanged();
            Result := 1;
          end
          else
          begin
            Dispose(UserItem);
            Result := -3;
          end;
        end;
      end;
    end
    else
      Result := -2;
  end
  else
    Result := -1;
  FailExit:
  if Result <= 0 then
    SendDefMessage(SM_HEROTAKEOFF_FAIL, Result, 0, 0, 0, '');
end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: Integer; sItemName: string);
var
  n10,Len: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
  Buffer: array[0..255] of Byte;
  FeatureMsg: string;
label
  FailExit;
begin
  n10 := 0;
  if not m_boDealing and (btWhere in [Low(THumanUseItems)..High(THumanUseItems)]) then
  begin
    if m_UseItems[btWhere].wIndex > 0 then
    begin
      TakeOffFunc(btWhere);
      if m_UseItems[btWhere].MakeIndex = nItemIdx then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
        if StdItem = nil then
          goto FailExit;
        if (StdItem <> nil) and (StdItem.StdMode in [15..24, 26]) then
        begin
          if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then
          begin
            SysMsg(g_sCanotTakeOffItem {'ÎÞ·¨È¡ÏÂÎïÆ·'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
        end;
        {if not m_boUserUnLockDurg then begin
          SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then begin
          SysMsg(g_sCanotTakeOffItem, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;}
        if InLimitItemList('', m_UseItems[btWhere].wIndex, t_dTakeOff) then
        begin
          SysMsg(Format(g_sCanotTakeOffItem, [StdItem.Name]), c_Red, t_Hint);
          goto FailExit;
        end;
        //È¡×Ô¶¨ÒåÎïÆ·Ãû³Æ
        sUserItemName := '';
        if m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          New(UserItem);
          UserItem^ := m_UseItems[btWhere];
          if AddItemToBag(UserItem) then
          begin
            m_UseItems[btWhere].wIndex := 0;
            SendAddItem(UserItem);
            CheckDelBagCopyed();
            RecalcLevelAbilitys();
            RecalcAbilitys();
          
            if m_WAbil.HP > m_WAbil.MaxHP then m_WAbil.HP := m_WAbil.MaxHP;
            if m_WAbil.MP > m_WAbil.MaxMP then m_WAbil.MP := m_WAbil.MaxMP;
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            Len := GetFeatureToLong(@Buffer[0]);
            SetLength(FeatureMsg, Len);
            Move(Buffer[0], FeatureMsg[1], Len);
            SendDefMessage(SM_TAKEOFF_OK, Len, GetFeatureEx, 0, 0, FeatureMsg);
            FeatureChanged();
            n10 := 1;
          end
          else
          begin
            Dispose(UserItem);
            n10 := -3;
          end;
        end;
      end;
    end
    else
      n10 := -2;
  end
  else
    n10 := -1;
  FailExit:
  if n10 <= 0 then
    SendDefMessage(SM_TAKEOFF_FAIL, n10, 0, 0, 0, '');
end;

procedure TPlayObject.ClientHeroSetTarget(nTarget, nTagX, nTagY: Integer);
var
  sTagName: string;
  nIdent: Integer;
  TagObject: TBaseObject;
  HeroObject: TBaseObject;
resourcestring
  sSetTagMsg = 'Ëø¶¨¹¥»÷Ä¿±ê:%s';
  sExceptionMsg = '[Exception] TPlayObject::ClientHeroSetTarget %d';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  nIdent := 0;
  try
    if nTarget <> 0 then
    begin
      nIdent := 1;
      if m_btHeroRelax <> 0 then
      begin
        m_btHeroRelax := 0;
        SysMsg(Format(sStartHeroAttackModeHelp, ['¹¥»÷']), c_Blue, t_Hint);
      end;
      if m_PEnvir = nil then
        Exit;
      nIdent := 2;

      TagObject := TBaseObject(nTarget);
      if not CretInNearXY(TagObject, nTagX, nTagY, 2) then
        Exit;

      if TagObject.m_boDeath or (TagObject.m_btRaceServer in [RC_NPC, RC_PEACENPC]) or not TagObject.m_boHoldPlace then
      begin
        Exit;
      end;

      if TagObject.IsHero then
      begin
        if TagObject.InSafeZone() then
          Exit;
      end;

      nIdent := 3;
      if (TagObject <> nil) and (Integer(TagObject) = nTarget) and (TagObject <> Self) then
      begin
        nIdent := 4;
        HeroObject := GetHeroObjectA;
        nIdent := 5;
        if (HeroObject <> nil) and not HeroObject.m_boDeath and (TagObject <> HeroObject) then
        begin
          nIdent := 6;
          if ((HeroObject.m_PEnvir = nil) or (m_PEnvir = HeroObject.m_PEnvir)) then
          begin
            if IsProperTarget(TagObject) then
            begin
              nIdent := 7;
              if m_boHeroSearchTag then
              begin
                m_boHeroSearchTag := False;
                TAnimalObject(HeroObject).m_nTargetX2 := -1;
                TAnimalObject(HeroObject).m_nTargetY2 := -1;
              end;
              HeroObject.m_LockTarget := TagObject;
              SetTargetCreat(TagObject);
              HeroObject.SetTargetCreat(TagObject);
              nIdent := 8;
              if (TagObject.m_btRaceServer = RC_PLAYOBJECT) or TagObject.IsHero or ((TagObject.m_btRaceServer = RC_HERO) and (TagObject.m_Master <> nil)) then
              begin
                if TagObject.m_PEnvir.m_MapFlag.nSecret and $08 <> 0 then
                begin
                  sTagName := TagObject.m_PEnvir.m_MapFlag.nSecretShowName;
                end
                else
                  sTagName := TagObject.m_sCharName
              end
              else
                sTagName := TagObject.m_sFCharName;
              nIdent := 9;
              HeroObject.SysMsg(Format(sSetTagMsg, [sTagName]), c_Red, t_Hint);
              m_dwHeroSetTargetTick := GetTickCount;
            end
            else
            begin
              if HeroObject.m_LockTarget = TagObject then
                HeroObject.m_LockTarget := nil;
              if HeroObject.m_TargetCret = TagObject then
                HeroObject.m_TargetCret := nil;
            end;
          end;
        end;
      end;
    end
    else
    begin
      nIdent := 10;
      HeroObject := GetHeroObjectA;
      if (HeroObject = nil) or HeroObject.m_boDeath then
        Exit;
      nIdent := 11;
      if (m_PEnvir = nil) or not m_PEnvir.CanWalk(nTagX, nTagY, False) then
      begin
        nIdent := 12;
        HeroObject.SysMsg('ÊØ»¤Î»ÖÃ²»¿Éµ½´ï£¡', c_Red, t_Hint);
        Exit;
      end;
      nIdent := 13;
      if not InSafeZone(m_PEnvir, nTagX, nTagY) then
      begin
        nIdent := 14;
        if not m_boHeroSearchTag then
          m_boHeroSearchTag := True;
        if m_btHeroRelax <> 0 then
          m_btHeroRelax := 0;
        nIdent := 15;
        TAnimalObject(HeroObject).m_nTargetX2 := nTagX;
        TAnimalObject(HeroObject).m_nTargetY2 := nTagY;
        SysMsg(Format(sHeroSearchTag, [nTagX, nTagY]), c_Blue, t_Hint);
      end
      else
        HeroObject.SysMsg('²»ÄÜÔÚ°²È«ÇøÄÚÊØ»¤£¡', c_Red, t_Hint);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [nIdent]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.GetUnBindItems(sItemName: string; nCount: Integer): Boolean;
var
  i: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  if sItemName <> '' then
    for i := 0 to nCount - 1 do
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        m_ItemList.Add(UserItem);
        SendAddItem(UserItem);
        Result := True;
      end
      else
      begin
        Dispose(UserItem);
        Break;
      end;
    end;
end;

function TPlayObject.InNotAllowUseItems(ItemIdx: Integer): Boolean;
var
  i: Integer;
begin
  Result := False;
  if (m_PEnvir <> nil) and (m_PEnvir.m_MapFlag.boNotAllowUseItems) then
  begin
    if m_PEnvir.m_MapFlag.sNotAllowUseItems <> nil then
    begin
      for i := 0 to m_PEnvir.m_MapFlag.sNotAllowUseItems.Count - 1 do
      begin
        if Integer(m_PEnvir.m_MapFlag.sNotAllowUseItems[i]) = ItemIdx then
        begin
          Result := True;
          Break;
        end;
      end;
      {sList := TStringList.Create;
      sString := m_PEnvir.m_MapFlag.sNotAllowUseItems;
      sList.Text := AnsiReplaceText(sString, '|', #13);
      for i := 0 to sList.Count - 1 do begin
        sString := sList.Strings[i];
        if sItemName = sString then begin
          Result := True;
          Break;
        end;
      end;
      sList.Free;}
    end;
  end;
end;

procedure TPlayObject.ClientHeroUseItems(nItemIdx, nType: Integer; sItemName: string);
var
  nDura: Integer;
  i, ii, nDateTime, nUsedDataTime, nOLevel, nSpareDateTime: Integer;
  b, boEatOK, boUseOK: Boolean;
  UserItem, dUserItem: pTUserItem;
  StdItem, dStdItem: pTStdItem;
  //UserItem34                : TUserItem;
  tIdx: Integer;
  dwInt: LongWord;
  sText: string;
  SlaveObject, HeroObject: TBaseObject;
resourcestring
  sStartUseLimitTimeItemMsg = '¡¼%s¡½ÒÑ¾­¿ªÆô,%s¿ªÊ¼Ê¹ÓÃ,ÓÐÐ§ÆÚÏÞ:%d%s';
  sStartUseLimitTimeItemMsg1 = '¡¼%s¡½ÒÑ¾­¿ªÆô,%s¿ªÊ¼Ê¹ÓÃ,ÓÐÐ§ÆÚÏÞ:%dÌì';
  sItemLimitDateTimeInfoMsg = '¡¼%s¡½ÓÚ%s¿ªÊ¼Ê¹ÓÃ,Ê£ÓàÓÐÐ§ÆÚÏÞ:%dÌì';
  sItemExpiresMsg = 'ÄãµÄÎïÆ·£º¡¼%s¡½´ïµ½Ê¹ÓÃÆÚÏÞ£¬ÒÑ±»ÏµÍ³×Ô¶¯»ØÊÕ£¡';
  sNotAllowUseItemsMsg = '±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃÎïÆ·£º%s';
  sDisallowUseItemsMsg = 'Äã²»ÄÜÊ¹ÓÃÎïÆ·: %s';
  sSlaveLevelUpMsg = 'ÔÚÉñÃØµÄÁ¦Á¿Ó°ÏìÏÂ£¬ÄãµÄ³èÎï:%s£¬³É³¤Îª%d¼¶';
begin
  boEatOK := False;
  StdItem := nil;
  HeroObject := GetHeroObjectA;
  if (HeroObject = nil) or HeroObject.m_boDeath then
  begin
    SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if m_boCanUseItem then
  begin
    if not HeroObject.m_boDeath then
    begin
      for i := 0 to HeroObject.m_ItemList.Count - 1 do
      begin
        UserItem := HeroObject.m_ItemList.Items[i];
        if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
        begin
          //UserItem34 := UserItem^;
          tIdx := UserItem.MakeIndex;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then
          begin
            if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> TPlayObject(HeroObject).m_dwIdCRC) then
            begin
              if g_Config.boBindNoUse then
              begin
                HeroObject.SysMsg(Format('%sÒÑ°ó¶¨ÓÚÆäËûÕÊºÅ£¬Äã²»ÄÜÊ¹ÓÃ', [StdItem.Name]), c_Red, t_Hint);
                SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
                Exit;
              end;
            end;

            if InLimitItemList('', UserItem.wIndex, t_dHeroUse) then
            begin
              HeroObject.SysMsg(Format(sDisallowUseItemsMsg, [StdItem.Name]), c_Red, t_Hint);
              SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
              Exit;
            end;
            if InNotAllowUseItems(UserItem.wIndex) then
            begin
              HeroObject.SysMsg(Format(sNotAllowUseItemsMsg, [StdItem.Name]), c_Red, t_Hint);
              SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
              Exit;
            end;
            case StdItem.StdMode of
              2: if nType = 0 then
                begin
                  case StdItem.Shape of
                    1: if HeroObject.m_SlaveList.Count > 0 then
                      begin
                        boUseOK := False;
                        for ii := HeroObject.m_SlaveList.Count - 1 downto 0 do
                        begin
                          SlaveObject := HeroObject.m_SlaveList.Items[ii];
                          with SlaveObject do
                          begin
                            if (m_btSlaveExpLevel < StdItem.AniCount) then
                            begin
                              m_btSlaveExpLevel := StdItem.AniCount;
                              m_btSlaveMakeLevel := StdItem.AniCount div 2;
                              RecalcAbilitys();
                              RefShowName();
                              SendRefMsg(RM_FIREWORKS, 0, 77, m_nCurrX, m_nCurrY, '');
                              m_WAbil.HP := m_WAbil.MaxHP;
                              SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
                              HeroObject.SysMsg(Format(sSlaveLevelUpMsg, [SlaveObject.m_sCharName, StdItem.AniCount]), c_Purple, t_Hint);
                              boUseOK := True;
                            end;
                          end;
                        end;
                        if boUseOK then
                        begin
                          nDura := UserItem.Dura;
                          Dec(nDura, 1000);
                          if nDura <= 0 then
                          begin
                            Dispose(UserItem);
                            HeroObject.m_ItemList.Delete(i);
                            boEatOK := True;
                          end
                          else
                          begin
                            UserItem.Dura := nDura;
                            SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
                            TPlayObject(HeroObject).SendUpdateItem(UserItem);
                            Break;
                          end;
                        end;
                      end;
                    10, 11:
                      begin
                        if (UserItem.Dura >= UserItem.DuraMax) then
                        begin
                          case StdItem.Need of
                            1: if m_nGold >= StdItem.Price then
                              begin
                                Dec(m_nGold, StdItem.Price);
                                GoldChanged();
                                b := True;
                              end
                              else
                              begin
                                SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 1, '');
                                Break;
                              end;
                            2: if m_nGameGold >= StdItem.Price then
                              begin
                                Dec(m_nGameGold, StdItem.Price);
                                GameGoldChanged();
                                b := True;
                              end
                              else
                              begin
                                SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 2, '');
                                Break;
                              end;
                            3: if m_nGameDiamond >= StdItem.Price then
                              begin
                                Dec(m_nGameDiamond, StdItem.Price);
                                SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
                                b := True;
                              end
                              else
                              begin
                                SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 3, '');
                                Break;
                              end;
                            4: if m_nGameGird >= StdItem.Price then
                              begin
                                Dec(m_nGameGird, StdItem.Price);
                                SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
                                b := True;
                              end
                              else
                              begin
                                SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 4, '');
                                Break;
                              end;
                          else
                            b := True;
                          end;
                          if b then
                          begin
                            dwInt := UserItem.Dura * 10000;
                            if StdItem.Shape = 10 then
                              TPlayObject(HeroObject).HeroGetExp(dwInt)
                            else if StdItem.Shape = 11 then
                              TPlayObject(HeroObject).HeroGetIPExp(dwInt); //GetExp(dwInt, True, False);
                            Dispose(UserItem);
                            HeroObject.m_ItemList.Delete(i);
                            boEatOK := True;
                            Break;
                          end;
                        end
                        else
                        begin
                          SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
                          Break;
                        end;
                      end;
                    13:
                      begin
                        nOLevel := HeroObject.m_nInPowerPoint;
                        Inc(HeroObject.m_nInPowerPoint, StdItem.DuraMax);
                        if HeroObject.m_nInPowerPoint > g_dwIPNeedInfo[HeroObject.m_nInPowerLevel].nPower then
                          HeroObject.m_nInPowerPoint := g_dwIPNeedInfo[HeroObject.m_nInPowerLevel].nPower;
                        if nOLevel <> HeroObject.m_nInPowerPoint then
                          TPlayObject(HeroObject).InternalPowerPointChanged(True);

                        if StdItem.Overlap >= 1 then
                        begin
                          nDura := UserItem.Dura;
                          Dec(nDura);
                          if nDura <= 0 then
                          begin
                            Dispose(UserItem);
                            HeroObject.m_ItemList.Delete(i);
                            boEatOK := True;
                          end
                          else
                          begin
                            UserItem.Dura := nDura;
                            SendDefMessage(SM_HEROEAT_FAIL, 0, 0, UserItem.Dura, 0, '');
                            //TPlayObject(HeroObject).SendUpdateItem(UserItem);
                            Break;
                          end;
                        end
                        else
                        begin
                          Dispose(UserItem);
                          HeroObject.m_ItemList.Delete(i);
                          boEatOK := True;
                        end;
                        HeroObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 23, 0, 0, '');
                      end;
                    9:
                      begin
                        boUseOK := False;
                        for ii := Low(THumanUseItems) to High(THumanUseItems) do
                        begin
                          if HeroObject.m_UseItems[ii].wIndex <= 0 then
                            Continue;
                          dStdItem := UserEngine.GetStdItem(HeroObject.m_UseItems[ii].wIndex);
                          if dStdItem <> nil then
                          begin
                            if dStdItem.StdMode in [7, 25, 40] then
                              Continue;
                            if InLimitItemList('', HeroObject.m_UseItems[ii].wIndex, t_dRepair) then
                            begin
                              HeroObject.SysMsg(dStdItem.Name + ' ²»ÔÊÐíÐÞÀí...', c_Red, t_Hint);
                              Continue;
                            end;
                            nOLevel := Round((HeroObject.m_UseItems[ii].DuraMax - HeroObject.m_UseItems[ii].Dura) / 10);
                            if nOLevel > 0 then
                            begin
                              if UserItem.Dura > nOLevel then
                              begin
                                HeroObject.m_UseItems[ii].Dura := HeroObject.m_UseItems[ii].DuraMax;
                                HeroObject.SendMsg(HeroObject, RM_DURACHANGE, ii, HeroObject.m_UseItems[ii].Dura, HeroObject.m_UseItems[ii].DuraMax, 0, '');
                                HeroObject.SysMsg(dStdItem.Name + ' ÐÞ¸´³É¹¦...', c_Green, t_Hint);
                                Dec(UserItem.Dura, nOLevel);
                                boUseOK := True;
                              end
                              else
                              begin
                                Inc(HeroObject.m_UseItems[ii].Dura, UserItem.Dura * 10);
                                HeroObject.SendMsg(HeroObject, RM_DURACHANGE, ii, HeroObject.m_UseItems[ii].Dura, HeroObject.m_UseItems[ii].DuraMax, 0, '');
                                Dispose(UserItem);
                                HeroObject.m_ItemList.Delete(i);
                                boEatOK := True;
                                Break;
                              end;
                            end;
                          end;
                        end;
                        if boUseOK then
                        begin
                          SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
                          TPlayObject(HeroObject).SendUpdateItem(UserItem);
                          Break;
                        end;
                      end;
                  end;
                end;
              0, 1, 3: if nType = 0 then
                begin
                  if TPlayObject(HeroObject).EatItems(StdItem) then
                  begin
                    if StdItem.Overlap >= 1 then
                    begin
                      nDura := UserItem.Dura;
                      Dec(nDura);
                      if nDura <= 0 then
                      begin
                        Dispose(UserItem);
                        HeroObject.m_ItemList.Delete(i);
                        boEatOK := True;
                      end
                      else
                      begin
                        UserItem.Dura := nDura;
                        SendDefMessage(SM_HEROEAT_FAIL, 0, 0, UserItem.Dura, 0, '');
                        //TPlayObject(HeroObject).SendUpdateItem(UserItem);
                        Break;
                      end;
                    end
                    else
                    begin
                      Dispose(UserItem);
                      HeroObject.m_ItemList.Delete(i);
                      boEatOK := True;
                    end;
                  end;
                  Break;
                end;
              4: if (nType = 0) and TPlayObject(HeroObject).ReadBook(StdItem) then
                begin
                  Dispose(UserItem);
                  HeroObject.m_ItemList.Delete(i);
                  boEatOK := True;
                  if (HeroObject.m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill} <> nil) and (not HeroObject.m_boUseThrusting) then
                    TPlayObject(HeroObject).ThrustingOnOff(True);
                  if (HeroObject.m_MagicArr[0][SKILL_BANWOL] <> nil) and (not HeroObject.m_boUseHalfMoon) then
                    TPlayObject(HeroObject).HalfMoonOnOff(True)
                  else if (HeroObject.m_MagicArr[0][40] {m_MagicCrsSkill} <> nil) and (not HeroObject.m_boCrsHitkill) then
                    TPlayObject(HeroObject).SkillCrsOnOff(True);
                end;
              31: if (nType = 0) then
                begin
                  if {(StdItem.AniCount = 0) or ((m_wClientType in [45, 46]) and}(StdItem.AniCount in [0..3]) {)} then
                  begin
                    if (HeroObject.m_ItemList.Count + 6 - 1) <= HeroObject.GetMaxBagItem then
                    begin

                      if StdItem.Overlap >= 1 then
                      begin
                        nDura := UserItem.Dura;
                        Dec(nDura);
                        if nDura <= 0 then
                        begin
                          Dispose(UserItem);
                          HeroObject.m_ItemList.Delete(i);
                          THeroObject(HeroObject).GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                          boEatOK := True;
                        end
                        else
                        begin
                          UserItem.Dura := nDura;
                          SendDefMessage(SM_HEROEAT_FAIL, 0, 0, UserItem.Dura, 0, '');
                          THeroObject(HeroObject).GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                          Break;
                        end;
                      end
                      else
                      begin
                        Dispose(UserItem);
                        HeroObject.m_ItemList.Delete(i);
                        THeroObject(HeroObject).GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                        boEatOK := True;
                      end;

                    end;
                  end;
                end;
              42: if (nType = 1) then
                begin
                  if HeroObject.m_UseItems[U_BUJUK].wIndex > 0 then
                  begin
                    dStdItem := UserEngine.GetStdItem(HeroObject.m_UseItems[U_BUJUK].wIndex);
                    if (dStdItem <> nil) and (dStdItem.Shape = 9) and (StdItem.DuraMax > 0) then
                    begin
                      if HeroObject.m_UseItems[U_BUJUK].Dura < HeroObject.m_UseItems[U_BUJUK].DuraMax then
                      begin
                        HeroObject.m_UseItems[U_BUJUK].Dura := _MIN(HeroObject.m_UseItems[U_BUJUK].DuraMax, HeroObject.m_UseItems[U_BUJUK].Dura + StdItem.DuraMax);
                        HeroObject.SendMsg(HeroObject, RM_DURACHANGE, U_BUJUK, HeroObject.m_UseItems[U_BUJUK].Dura, HeroObject.m_UseItems[U_BUJUK].DuraMax, 0, '');
                        HeroObject.m_boDrangonHeart := True;
                        Dispose(UserItem);
                        HeroObject.m_ItemList.Delete(i);
                        boEatOK := True;
                      end;
                    end;
                  end;
                end;
            end;
          end;
          Break;
        end;
      end;
    end;
  end
  else
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
  if boEatOK then
  begin
    HeroObject.WeightChanged();
    SendDefMessage(SM_HEROEAT_OK, 0, 0, 0, 0, '');
    HeroObject.RecalcAbilitys();
    HeroObject.SendMsg(HeroObject, RM_ABILITY, 0, 0, 0, 0, '');
    HeroObject.SendMsg(HeroObject, RM_SUBABILITY, 0, 0, 0, 0, '');
    if StdItem.NeedIdentify = 1 then
      AddGameDataLogAPI('11' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(tIdx {UserItem34.MakeIndex}) + #9 + '1' + #9 + '0');
  end
  else
    SendDefMessage(SM_HEROEAT_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientUseItems(nItemIdx: Integer; sItemName: string);
var
  nDura: Integer;
  i, ii, idx, nDateTime, nUsedDataTime, nOLevel, nSpareDateTime: Integer;
  b, boEatOK, boUseOK: Boolean;
  UserItem: pTUserItem;
  GetStdItem, StdItem: pTStdItem;
  dwInt: LongWord;
  //UserItem34                : TUserItem;
  tIdx: Integer;
  sText: string;
  SlaveObject: TBaseObject;
resourcestring
  sStartUseLimitTimeItemMsg = '¡¼%s¡½ÒÑ¾­¿ªÆô,%s¿ªÊ¼Ê¹ÓÃ,ÓÐÐ§ÆÚÏÞ:%d%s';
  sStartUseLimitTimeItemMsg1 = '¡¼%s¡½ÒÑ¾­¿ªÆô,%s¿ªÊ¼Ê¹ÓÃ,ÓÐÐ§ÆÚÏÞ:%dÌì';
  sItemLimitDateTimeInfoMsg = '¡¼%s¡½ÓÚ%s¿ªÊ¼Ê¹ÓÃ,Ê£ÓàÓÐÐ§ÆÚÏÞ:%dÌì';
  sItemExpiresMsg = 'ÄãµÄÎïÆ·£º¡¼%s¡½´ïµ½Ê¹ÓÃÆÚÏÞ£¬ÒÑ±»ÏµÍ³×Ô¶¯»ØÊÕ£¡';
  sNotAllowUseItemsMsg = '±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃÎïÆ·%s';
  sDisallowUseItemsMsg = 'Äã²»ÄÜÊ¹ÓÃÎïÆ·: %s';
  sSlaveLevelUpMsg = 'ÔÚÉñÃØµÄÁ¦Á¿Ó°ÏìÏÂ£¬ÄãµÄ³èÎï:%s£¬³É³¤Îª%d¼¶';
label
  DisPoseExit;
begin
  boEatOK := False;
  idx := 0;
  StdItem := nil;

  if (m_btRaceServer <> RC_PLAYOBJECT) or (m_sHeroMasterName <> '') then
  begin
    SendDefMessage(SM_EAT_FAIL, nItemIdx, 0, 0, 0, '');
    Exit;
  end;

  if m_boCanUseItem then
  begin
    if not m_boDeath then
    begin
      for i := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList.Items[i];
        if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
        begin
          //UserItem34 := UserItem^;
          tIdx := UserItem.MakeIndex;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then
          begin
            idx := UserItem.MakeIndex;
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if TPlayObject(Self).IsOnSaleItem(idx) then
              begin
                SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                Exit;
              end;
            end;
            {if m_StallMgr.OnSale then begin
              SysMsg(Format('°ÚÌ¯×´Ì¬²»ÄÜÊ¹ÓÃÎïÆ·%s', [StdItem.Name]), c_Red, t_Hint);
              SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
              Exit;
            end;}

            if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
            begin
              if g_Config.boBindNoUse then
              begin
                SysMsg(Format('%sÒÑ°ó¶¨ÓÚÆäËûÕÊºÅ£¬Äã²»ÄÜÊ¹ÓÃ', [StdItem.Name]), c_Red, t_Hint);
                SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                Exit;
              end;
            end;

            if InLimitItemList('', UserItem.wIndex, t_dTakeOn) then
            begin
              SysMsg(Format(sDisallowUseItemsMsg, [StdItem.Name]), c_Red, t_Hint);
              SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
              Exit;
            end;

            if InNotAllowUseItems(UserItem.wIndex) then
            begin
              if StdItem.Name <> '' then
                SysMsg(Format(sNotAllowUseItemsMsg, [StdItem.Name]), c_Red, t_Hint);
              SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
              Exit;
            end;
            case StdItem.StdMode of
              2:
                begin
                  if (StdItem.Source <> 0) then
                  begin
                    if (UserItem.Dura >= 1000) and (UserItem.DuraMax >= 1000) and (m_ItemList.Count < GetMaxBagItem) then
                    begin
                      if StdItem.Source < 0 then
                        nOLevel := 256 + StdItem.Source
                      else
                        nOLevel := StdItem.Source;
                      Dec(UserItem.Dura, 1000);
                      nDura := UserItem.DuraMax;
                      Dec(nDura, 1000);
                      if (nDura <= 0) then
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(i);
                        boEatOK := True;
                        GetUnBindItems(GetUnbindItemName(nOLevel), 1);
                      end
                      else
                      begin
                        UserItem.DuraMax := nDura;
                        SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                        SendUpdateItem(UserItem);
                        GetUnBindItems(GetUnbindItemName(nOLevel), 1);
                        Break;
                      end;
                    end;
                  end
                  else
                  begin
                    case StdItem.Shape of
                      0:
                        begin
                          nDura := UserItem.Dura;
                          Dec(nDura, 1000);
                          if nDura <= 0 then
                          begin
                            Dispose(UserItem);
                            m_ItemList.Delete(i);
                            boEatOK := True;
                            UseStdmodeFunItem(StdItem);
                          end
                          else
                          begin
                            UserItem.Dura := nDura;
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            SendUpdateItem(UserItem);
                            UseStdmodeFunItem(StdItem);
                            Break;
                          end;
                        end;
                      1: if m_SlaveList.Count > 0 then
                        begin
                          boUseOK := False;
                          for ii := m_SlaveList.Count - 1 downto 0 do
                          begin
                            SlaveObject := m_SlaveList.Items[ii];
                            with SlaveObject do
                            begin
                              if (m_btSlaveExpLevel < StdItem.AniCount) then
                              begin
                                m_btSlaveExpLevel := StdItem.AniCount;
                                m_btSlaveMakeLevel := StdItem.AniCount div 2;
                                RecalcAbilitys();
                                RefShowName();
                                SendRefMsg(RM_FIREWORKS, 0, 77, m_nCurrX, m_nCurrY, '');
                                m_WAbil.HP := m_WAbil.MaxHP;
                                SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
                                SysMsg(Format(sSlaveLevelUpMsg, [SlaveObject.m_sCharName, StdItem.AniCount]), c_Purple, t_Hint);
                                boUseOK := True;
                              end;
                            end;
                          end;
                          if boUseOK then
                          begin
                            nDura := UserItem.Dura;
                            Dec(nDura, 1000);
                            if nDura <= 0 then
                            begin
                              Dispose(UserItem);
                              m_ItemList.Delete(i);
                              boEatOK := True;
                            end
                            else
                            begin
                              UserItem.Dura := nDura;
                              SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                              SendUpdateItem(UserItem);
                              Break;
                            end;
                          end;
                        end;
                      2: if not m_PEnvir.m_MapFlag.boNORANDOMMOVE then
                        begin
                          nDura := UserItem.Dura;
                          Dec(nDura, 1000);
                          if m_PEnvir <> nil then
                            MapRandomMove(m_PEnvir.m_sMapFileName, 0)
                          else
                            MapRandomMove(m_sMapName, 0);
                          if nDura <= 0 then
                          begin
                            Dispose(UserItem);
                            m_ItemList.Delete(i);
                            boEatOK := True;
                          end
                          else
                          begin
                            UserItem.Dura := nDura;
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            SendUpdateItem(UserItem);
                          end;
                        end
                        else
                          SysMsg('±¾µØÍ¼²»ÔÊÐíÊ¹ÓÃ', c_Red, t_Hint);
                      3:
                        begin
                          if m_DetectItem.MakeIndex = 0 then
                          begin
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            Break;
                          end
                          else
                          begin
                            if m_DetectItem.btValueEx[2] >= m_DetectItem.btValueEx[3] then
                            begin
                              SysMsg('ÁéÃ½µÄÁéÆøÒÑÂú£¬ÎÞÐè²¹³ä', c_Green, t_Hint);
                              SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                              Break;
                            end;
                          end;
                          nDura := UserItem.Dura div 100;
                          m_DetectItem.btValueEx[2] := _MIN(m_DetectItem.btValueEx[3], m_DetectItem.btValueEx[2] + nDura);
                          SendUpdateDetectItem(m_DetectItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(i);
                          boEatOK := True;
                        end;
                      9:
                        begin
                          boUseOK := False;
                          for ii := Low(THumanUseItems) to High(THumanUseItems) do
                          begin
                            if m_UseItems[ii].wIndex <= 0 then
                              Continue;
                            GetStdItem := UserEngine.GetStdItem(m_UseItems[ii].wIndex);
                            if GetStdItem <> nil then
                            begin
                              if GetStdItem.StdMode in [7, 25, 40] then
                                Continue;
                              if InLimitItemList('', m_UseItems[ii].wIndex, t_dRepair) then
                              begin
                                SysMsg(GetStdItem.Name + ' ²»ÔÊÐíÐÞÀí...', c_Red, t_Hint);
                                Continue;
                              end;
                              nOLevel := Round((m_UseItems[ii].DuraMax - m_UseItems[ii].Dura) / 10);
                              if nOLevel > 0 then
                              begin
                                if UserItem.Dura > nOLevel then
                                begin
                                  m_UseItems[ii].Dura := m_UseItems[ii].DuraMax;
                                  SendMsg(Self, RM_DURACHANGE, ii, m_UseItems[ii].Dura, m_UseItems[ii].DuraMax, 0, '');
                                  SysMsg(GetStdItem.Name + ' ÐÞ¸´³É¹¦...', c_Green, t_Hint);
                                  Dec(UserItem.Dura, nOLevel);
                                  boUseOK := True;
                                end
                                else
                                begin
                                  Inc(m_UseItems[ii].Dura, UserItem.Dura * 10);
                                  SendMsg(Self, RM_DURACHANGE, ii, m_UseItems[ii].Dura, m_UseItems[ii].DuraMax, 0, '');
                                  Dispose(UserItem);
                                  m_ItemList.Delete(i);
                                  boEatOK := True;
                                  Break;
                                end;
                              end;
                            end;
                          end;
                          if boUseOK then
                          begin
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            SendUpdateItem(UserItem);
                            Break;
                          end;
                        end;
                      10, 11:
                        begin
                          if (UserItem.Dura >= UserItem.DuraMax) then
                          begin
                            case StdItem.Need of
                              1: if m_nGold >= StdItem.Price then
                                begin
                                  Dec(m_nGold, StdItem.Price);
                                  GoldChanged();
                                  b := True;
                                end
                                else
                                begin
                                  SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 1, '');
                                  Break;
                                end;
                              2: if m_nGameGold >= StdItem.Price then
                                begin
                                  Dec(m_nGameGold, StdItem.Price);
                                  GameGoldChanged();
                                  b := True;
                                end
                                else
                                begin
                                  SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 2, '');
                                  Break;
                                end;
                              3: if m_nGameDiamond >= StdItem.Price then
                                begin
                                  Dec(m_nGameDiamond, StdItem.Price);
                                  SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
                                  b := True;
                                end
                                else
                                begin
                                  SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 3, '');
                                  Break;
                                end;
                              4: if m_nGameGird >= StdItem.Price then
                                begin
                                  Dec(m_nGameGird, StdItem.Price);
                                  SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
                                  b := True;
                                end
                                else
                                begin
                                  SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 4, '');
                                  Break;
                                end;
                            else
                              b := True;
                            end;
                            if b then
                            begin
                              dwInt := UserItem.Dura * 10000;
                              if StdItem.Shape = 10 then
                                GetExp(dwInt, True, False, False)
                              else if StdItem.Shape = 11 then
                                GetExp(dwInt, True, True, False);
                              Dispose(UserItem);
                              m_ItemList.Delete(i);
                              boEatOK := True;
                              Break;
                            end;
                          end
                          else
                          begin
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            Break;
                          end;
                        end;
                      13:
                        begin
                          nOLevel := m_nInPowerPoint;
                          Inc(m_nInPowerPoint, UserItem.DuraMax);
                          if m_nInPowerPoint > g_dwIPNeedInfo[m_nInPowerLevel].nPower then
                            m_nInPowerPoint := g_dwIPNeedInfo[m_nInPowerLevel].nPower;
                          if nOLevel <> m_nInPowerPoint then
                            InternalPowerPointChanged(True);
                          if StdItem.Overlap >= 1 then
                          begin
                            nDura := UserItem.Dura;
                            Dec(nDura);
                            if nDura <= 0 then
                            begin
                              Dispose(UserItem);
                              m_ItemList.Delete(i);
                              boEatOK := True;
                            end
                            else
                            begin
                              UserItem.Dura := nDura;
                              SendDefMessage(SM_EAT_FAIL, idx, 0, UserItem.Dura, 0, '');
                              //TPlayObject(HeroObject).SendUpdateItem(UserItem);
                              Break;
                            end;
                          end
                          else
                          begin
                            Dispose(UserItem);
                            m_ItemList.Delete(i);
                            boEatOK := True;
                          end;
                          SendRefMsg(RM_STRUCKEFFECTEX, 0, 23, 0, 0, '');
                        end;
                      18:
                        begin
                          CopyMemory(@nUsedDataTime, @UserItem.btValue, SizeOf(Integer));
                          if nUsedDataTime = 0 then
                          begin
                            nUsedDataTime := GetItemFormatDate();
                            CopyMemory(@UserItem.btValue, @nUsedDataTime, SizeOf(Integer));
                            SysMsg(Format(sStartUseLimitTimeItemMsg1, [StdItem.Name, DateTimeToStr(Now), UserItem.DuraMax]), c_Purple, t_Hint);
                            SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                            SendUpdateItem(UserItem);
                            UseStdmodeFunItem(StdItem);
                          end
                          else
                          begin
                            nSpareDateTime := UserItem.DuraMax - Round((GetItemFormatDate - nUsedDataTime) / (24 * 60 * 60));
                            if nSpareDateTime > 0 then
                            begin
                              SysMsg(Format(sItemLimitDateTimeInfoMsg, [StdItem.Name, DateTimeToStr(GetItemDateTimeInfo(nUsedDataTime)), nSpareDateTime]), c_Green, t_Hint);
                              UseStdmodeFunItem(StdItem);
                            end
                            else
                            begin
                              SysMsg(Format(sItemExpiresMsg, [StdItem.Name]), c_Red, t_Hint);
                              Dispose(UserItem);
                              m_ItemList.Delete(i);
                              boEatOK := True;
                            end;
                          end;
                          Break;
                        end;
                    end;
                  end;
                end;
              0, 1, 3:
                begin
                  if EatItems(StdItem) then
                  begin
                    if StdItem.Overlap >= 1 then
                    begin
                      nDura := UserItem.Dura;
                      Dec(nDura);
                      if nDura <= 0 then
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(i);
                        boEatOK := True;
                      end
                      else
                      begin
                        UserItem.Dura := nDura;
                        SendDefMessage(SM_EAT_FAIL, idx, 0, UserItem.Dura, 0, '');
                        Break;
                      end;
                    end
                    else
                    begin
                      SendDelItems(UserItem);
                      Dispose(UserItem);
                      m_ItemList.Delete(i);
                      boEatOK := True;
                    end;
                  end;
                  Break;
                end;
              4:
                begin //Êé
                  if ReadBook(StdItem) then
                  begin
                    Dispose(UserItem);
                    m_ItemList.Delete(i);
                    boEatOK := True;
                    if (m_MagicArr[0][SKILL_ERGUM] {m_MagicErgumSkill]} <> nil) and (not m_boUseThrusting) then
                    begin
                      ThrustingOnOff(True);
                      SendSocket(nil, '+LNG');
                    end;
                    if (m_MagicArr[0][SKILL_BANWOL] <> nil) and (not m_boUseHalfMoon) then
                    begin
                      HalfMoonOnOff(True);
                      SendSocket(nil, '+WID');
                    end
                    else if (m_MagicArr[0][40] {m_MagicCrsSkill} <> nil) and (not m_boCrsHitkill) then
                    begin
                      SkillCrsOnOff(True);
                      SendSocket(nil, '+CRS');
                    end;
                  end;
                end;
              31:
                begin //½â°üÎïÆ·
                  if {(StdItem.AniCount = 0) or ((m_wClientType in [45, 46]) and}(StdItem.AniCount in [0..3]) {)} then
                  begin
                    if (m_ItemList.Count + 6 - 1) <= GetMaxBagItem then
                    begin

                      if StdItem.Overlap >= 1 then
                      begin
                        nDura := UserItem.Dura;
                        Dec(nDura);
                        if nDura <= 0 then
                        begin
                          Dispose(UserItem);
                          m_ItemList.Delete(i);
                          GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                          boEatOK := True;
                        end
                        else
                        begin
                          UserItem.Dura := nDura;
                          SendDefMessage(SM_EAT_FAIL, idx, 0, UserItem.Dura, 0, '');
                          GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                          Break;
                        end;
                      end
                      else
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(i);
                        GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                        boEatOK := True;
                      end;

                    end;
                  end
                  else
                  begin
                    if (StdItem.Reserved = 99) then
                    begin
                      if (UserItem.Dura > 0) then
                      begin
                        Dec(UserItem.Dura);
                        if UserItem.Dura > 0 then
                        begin
                          SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
                          SendUpdateItem(UserItem);
                          UseStdmodeFunItem(StdItem);
                          Break;
                        end
                        else
                        begin
                          Dispose(UserItem);
                          m_ItemList.Delete(i);
                          boEatOK := True;
                          UseStdmodeFunItem(StdItem);
                        end;
                      end
                      else
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(i);
                        boEatOK := True;
                        UseStdmodeFunItem(StdItem);
                      end;
                    end
                    else
                    begin
                      if StdItem.Overlap >= 1 then
                      begin
                        nDura := UserItem.Dura;
                        Dec(nDura);
                        if nDura <= 0 then
                        begin
                          Dispose(UserItem);
                          m_ItemList.Delete(i);
                          boEatOK := True;
                          UseStdmodeFunItem(StdItem);
                        end
                        else
                        begin
                          UserItem.Dura := nDura;
                          SendDefMessage(SM_EAT_FAIL, idx, 0, UserItem.Dura, 0, '');
                          UseStdmodeFunItem(StdItem);
                          Break;
                        end;
                      end
                      else
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(i);
                        boEatOK := True;
                        UseStdmodeFunItem(StdItem);
                      end;
                    end;
                  end;
                end;
            end;
          end;
          Break;
        end;
      end;
    end;
  end
  else
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
  if boEatOK then
  begin
    WeightChanged();
    SendDefMessage(SM_EAT_OK, idx, 0, 0, 0, '');
    if StdItem.NeedIdentify = 1 then
      AddGameDataLogAPI('11' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(tIdx {UserItem34.MakeIndex}) + #9 + '1' + #9 + '0');
  end
  else
    SendDefMessage(SM_EAT_FAIL, idx, 0, 0, 0, '');
end;

function TPlayObject.UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) and (StdItem.AniCount > 0) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(Self, '@StdModeFunc' + IntToStr(StdItem.AniCount), False);
    Result := True;
  end;
end;

function TPlayObject.DieFunc: Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(Self, '@PlayDie', False);
    Result := True;
  end;
end;

function TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean;
var
  x, y, n10, n14: Integer;
  dwCheckTime: LongWord;
  StdItem: pTStdItem;
resourcestring
  sHintMsg = 'ÄãÉíÉÏÁé·û²»×ã%d¸ö,²»ÄÜÍÚÈ¡%sÉíÉÏµÄÎïÆ·';
begin
  Result := False;
  if not (btDir in [0..7]) then
    Exit;
  if m_StallMgr.OnSale then
    Exit;

  if m_boDeath or m_boGhost then
    Exit;

  dwDelayTime := 0;

  if not g_Config.boSpeedHackCheck then
  begin
    dwCheckTime := GetTickCount - m_dwTurnTick;
    if dwCheckTime < _MAX(150, g_Config.dwTurnIntervalTime - 150) then
    begin
      dwDelayTime := _MAX(150, g_Config.dwTurnIntervalTime - 150) - dwCheckTime;
      Exit;
    end;
    m_dwTurnTick := GetTickCount;
  end;

  SendSocket(nil, Format('%s/%d', [sSTATUS_GOOD, GetTickCount]));

  if Integer(BaseObject) = 0 then
    Exit;

  //1001
  if (m_PEnvir.m_MapFlag.nDigItem > 0) and (m_PEnvir.m_MapFlag.pDigItemList <> nil) then
  begin
    if (m_UseItems[U_WEAPON].wIndex > 0) and (m_UseItems[U_WEAPON].Dura > 0) then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if (StdItem <> nil) and (StdItem.Shape in [75..77]) and (m_DetectItem.MakeIndex > 0) then
      begin //Æ·ÖÊ
        //if GetItemSpiritQuality(@m_DetectItem) > 0 then begin
        m_btDirection := btDir;
        if GetFrontPosition(x, y) and m_PEnvir.CanWalk(x, y, False) then
        begin
          if PileEarth(x, y, StdItem.Shape, Integer(BaseObject)) then
          begin
            SendSocket(nil, '+DIG');
          end;
          Dec(m_nHealthTick, 30);
          Dec(m_nSpellTick, 50);
          m_nSpellTick := _MAX(0, m_nSpellTick);
          Dec(m_nPerHealth, 2);
          Dec(m_nPerSpell, 2);
          Exit;
          //end;
        end;
      end;
    end;
  end;

  if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then
  begin
    if m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then
    begin
      if BaseObject.m_boDeath and not BaseObject.m_boSkeleton and (BaseObject.m_boAnimal or BaseObject.m_boExplore) then
      begin
        if {(BaseObject.m_btRaceServer = RC_HERO)}  BaseObject.m_boExplore and (m_nGameGird < g_Config.nButchItemNeedGird) then
        begin
          SysMsg(Format(sHintMsg, [g_Config.nButchItemNeedGird, BaseObject.m_sFCharName]), c_Blue, t_Hint);
          Exit;
        end;
        n10 := Random(16) + 5;
        n14 := Random(201) + 100;
        Dec(BaseObject.m_nBodyLeathery, n10);
        if BaseObject.m_boAnimal then
          Dec(BaseObject.m_nMeatQuality, n14);
        if BaseObject.m_nMeatQuality < 0 then
          BaseObject.m_nMeatQuality := 0;
        m_btDirection := btDir;
        SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
        if BaseObject.m_nBodyLeathery <= 0 then
        begin
          if {(BaseObject.m_btRaceServer <> RC_HERO) and} not BaseObject.m_boExplore and (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer < RC_MONSTER) then
          begin
            BaseObject.m_boSkeleton := True;
            ApplyMeatQuality();
            BaseObject.SendRefMsg(RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
          end;
          if BaseObject.m_boExplore {BaseObject.m_btRaceServer = RC_HERO} then
          begin
            if ButchMonBagItems(BaseObject, True) then
            begin
              BaseObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 9, 0, 0, '');
              SendRefMsg(RM_STRUCKEFFECTEX, 0, 10, 0, 0, '');
              Dec(m_nGameGird, g_Config.nButchItemNeedGird);
              SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
            end
            else if g_Config.boNoButchItemSubGird then
            begin
              Dec(m_nGameGird, g_Config.nButchItemNeedGird);
              SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
            end;
          end
          else if not ButchMonBagItems(BaseObject) then
            SysMsg(sYouFoundNothing, c_Red, t_Hint);
          BaseObject.m_nBodyLeathery := BaseObject.m_nPerBodyLeathery;
        end;
        //BaseObject.m_dwDeathTick := GetTickCount(); //1001
      end;
    end;
  end;
  //SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: Integer);
begin
  if not (nSkillIdx in [1..255]) then
    Exit;
  if m_MagicArr[0][nSkillIdx] <> nil then
    m_MagicArr[0][nSkillIdx].btKey := nKey;
  {for i := 0 to m_MagicList.Count - 1 do begin
    UserMagic := m_MagicList.Items[i];
    if (UserMagic.MagicInfo.btClass = 0) and (UserMagic.MagicInfo.wMagicId = nSkillIdx) then begin
      UserMagic.btKey := nKey;
      Break;
    end;
  end;}
end;

procedure TPlayObject.ClientHeroChangeMagicKey(nSkillIdx, nKey: Integer);
var
  Hero: TBaseObject;
begin
  if not (nSkillIdx in [1..255]) then
    Exit;
  Hero := GetHeroObjectA();
  if Hero = nil then
    Exit;
  if Hero.m_MagicArr[0][nSkillIdx] <> nil then
    Hero.m_MagicArr[0][nSkillIdx].btKey := nKey;
  {for i := 0 to Hero.m_MagicList.Count - 1 do begin
    UserMagic := Hero.m_MagicList.Items[i];
    if UserMagic.MagicInfo.wMagicId = nSkillIdx then begin
      UserMagic.btKey := nKey;
      Break;
    end;
  end;}
end;

procedure TPlayObject.ClientGropuClose;
resourcestring
  sGropuCloseMsg = 'Èç¹ûÄãÏëÍË³ö×é¶Ó£¬Ê¹ÓÃ±à×é¹¦ÄÜ£¨É¾³ý°´Å¥£©';
begin
  if m_GroupOwner = nil then
  begin
    m_boAllowGroup := False;
    Exit;
  end;
  if m_GroupOwner <> Self then
  begin
    m_GroupOwner.DelMember(Self);
    m_boAllowGroup := False;
  end
  else
    SysMsg(sGropuCloseMsg, c_Red, t_Hint);
end;

procedure TPlayObject.ClientCreateGroup(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if m_GroupOwner <> nil then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if (PlayObject = nil) or (PlayObject = Self) or m_boDeath or m_boGhost or PlayObject.m_boDeath or PlayObject.m_boGhost then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;
  m_GroupMembers.Clear;
  m_GroupMembers.AddObject(m_sCharName, Self);
  m_GroupMembers.AddObject(sHumName, PlayObject);
  JoinGroup(Self);
  PlayObject.JoinGroup(Self);
  m_boAllowGroup := True;
  SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientAddGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  if m_GroupOwner <> Self then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if m_GroupMembers.Count > g_Config.nGroupMembersMax then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, '');
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if (PlayObject = nil) or (PlayObject = Self) or m_boDeath or m_boGhost or PlayObject.m_boDeath or PlayObject.m_boGhost then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  if (not PlayObject.m_boAllowGroup) then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
    Exit;
  end;

  m_GroupMembers.AddObject(sHumName, PlayObject);
  PlayObject.JoinGroup(Self);
  SendDefMessage(SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: string);
var
  PlayObject: TPlayObject;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if m_GroupOwner <> Self then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
    Exit;
  end;
  if PlayObject = nil then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
    Exit;
  end;
  if not IsGroupMember(PlayObject) then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;
  DelMember(PlayObject);
  SendDefMessage(SM_GROUPDELMEM_OK, 0, 0, 0, 0, sHumName);
end;

procedure TPlayObject.ClientDealTry(sHumName: string);
var
  BaseObject: TBaseObject;
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) or (m_sHeroMasterName <> '') then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '·Ç·¨²Ù×÷£¡');
    Exit;
  end;
  if m_StallMgr.OnSale then
  begin
    SysMsg('°ÚÌ¯×´Ì¬²»ÄÜ½»Ò×£¡', c_Red, t_Hint);
    Exit;
  end;
  if (m_PEnvir <> nil) and m_PEnvir.m_MapFlag.boNODEAL then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[ÌáÊ¾]£º±¾µØÍ¼½ûÖ¹½»Ò×');
    Exit;
  end;
  if g_Config.boDisableDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDisableDealItemsMsg);
    Exit;
  end;
  if m_boDealing then
    Exit;
  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime {3000} then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryDealLaterMsg);
    Exit;
  end;
  if not m_boCanDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    Exit;
  end;
  BaseObject := GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> Self) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
  begin
    if TPlayObject(BaseObject).m_StallMgr.OnSale then
    begin
      SysMsg('¶Ô·½´¦ÓÚ°ÚÌ¯×´Ì¬£¬²»ÄÜ½øÐÐ½»Ò×£¡', c_Red, t_Hint);
      Exit;
    end;
    if (BaseObject.GetPoseCreate = Self) and (not TPlayObject(BaseObject).m_boDealing) then
    begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
      begin
        if (BaseObject.m_boAllowDeal and TPlayObject(BaseObject).m_boCanDeal) then
        begin
          BaseObject.SysMsg(m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
          SysMsg(BaseObject.m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
          TPlayObject(Self).OpenDealDlg(TPlayObject(BaseObject));
          TPlayObject(BaseObject).OpenDealDlg(Self);
        end
        else
          SysMsg(g_sPoseDisableDealMsg {'¶Ô·½½ûÖ¹½øÈë½»Ò×'}, c_Red, t_Hint);
      end;
    end
    else
      SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
  end
  else
    SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientAddDealItem(nItemIdx, Count: Integer; sItemName: string);
var
  i, n, iOldCount: Integer;
  Flag: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
  pstd, psDeal: pTStdItem;
  newpu: pTUserItem;
  iRet: Integer;
resourcestring
  ItemDisableDealMsg = '¶Ô²»Æð£¬µ±Ç°ÎïÆ·½ûÖ¹½»Ò×£¡';
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) or (m_sHeroMasterName <> '') then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '·Ç·¨²Ù×÷£¡');
    Exit;
  end;
  if (m_DealCreat = nil) or (not m_boDealing) then
    Exit;
  if Pos(' ', sItemName) >= 0 then
  begin
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  Flag := False;
  n := 0;
  if not m_DealCreat.m_boDealOK then
  begin
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      pstd := UserEngine.GetStdItem(UserItem.wIndex);
      if pstd.Overlap >= 1 then
      begin
        if (Count <= 0) then
          Break;
      end;
      if (pstd <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        {LimitItem by Blue}
        if InLimitItemList('', UserItem.wIndex, t_dDeal) then
        begin
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, ItemDisableDealMsg);
          SendDefMessage(SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
          Break;
        end;
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := pstd.Name;
        if (CompareText(sUserItemName, sItemName) = 0) and (m_DealItemList.Count < 10) then
        begin
          if pstd.Overlap >= 1 then
          begin
            if (Count > 0) and (Count <= MAX_OVERLAPITEM) then
            begin
              psDeal := UserEngine.GetStdItem(UserItem.wIndex);
              iOldCount := UserItem.Dura;
              if Count > iOldCount then
              begin
                Count := iOldCount;
                SysMsg('[¾¯¸æ] ·Ç·¨½»Ò×²Ù×÷£¬ÇëÖØÐÂµÇÂ½ÓÎÏ·£¡', c_Red, t_Hint);
                m_boKickFlag := True;
              end;
              iRet := UserCounterDealItemAdd(psDeal.StdMode, psDeal.Looks, Count, psDeal.Name);
              if iRet = 1 then
              begin // Success
                if iOldCount - Count > 0 then
                begin
                  UserItem.Dura := iOldCount - Count;
                  AddDealCounterItem(UserItem^, 0);
                end
                else if iOldCount - Count <= 0 then
                begin //0618
                  AddDealCounterItem(UserItem^, 0);
                  m_ItemList.Delete(i);
                  Dispose(UserItem); //0420
                end
                else
                begin

                end;
                Flag := True;
                RecalcBagWeight;
                Break;
              end
              else if iRet = 2 then
              begin // Overflow
                Flag := False;
                Break;
              end
              else if iRet = 3 then
              begin // OverCount
                Flag := False;
                n := 1;
                Break;
              end
              else
              begin
                if iOldCount - Count > 0 then
                begin
                  New(newpu);
                  if UserEngine.CopyToUserItemFromName(sItemName, newpu) then
                  begin
                    newpu.Dura := Count;
                    m_DealItemList.Add(newpu);
                    UserItem.Dura := iOldCount - Count;
                    SendAddDealItem(newpu, iOldCount - Count);
                  end
                  else
                  begin
                    Dispose(newpu);
                  end;
                end
                else if iOldCount - Count <= 0 then
                begin
                  m_DealItemList.Add(m_ItemList[i]);
                  SendAddDealItem(UserItem, 0);
                  m_ItemList.Delete(i);
                end;
              end;
            end
            else
            begin
              if Count > MAX_OVERLAPITEM then
                n := 1;
              Break;
            end;
          end
          else
          begin
            m_DealItemList.Add(UserItem);
            TPlayObject(Self).SendAddDealItem(UserItem, 0);
            m_ItemList.Delete(i);
          end;
          RecalcBagWeight();
          Flag := True;
          Break;

        end;
      end;
    end;
  end;
  if not Flag then
    SendDefMessage(SM_DEALADDITEM_FAIL, n, 0, 0, 0, '');
end;

procedure TPlayObject.ClientDelDealItem(nItemIdx: Integer; sItemName: string);
var
  i: Integer;
  Flag: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
  ps: pTStdItem;
begin
  if g_Config.boCanNotGetBackDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if (m_DealCreat = nil) or (not m_boDealing) or (m_btRaceServer <> RC_PLAYOBJECT) then
    Exit;
  if Pos(' ', sItemName) >= 0 then
    GetValidStr3(sItemName, sItemName, [' ']);
  Flag := False;
  if not m_DealCreat.m_boDealOK then
  begin
    for i := 0 to m_DealItemList.Count - 1 do
    begin
      UserItem := m_DealItemList.Items[i];
      if UserItem.MakeIndex = nItemIdx then
      begin
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          ps := UserEngine.GetStdItem(UserItem.wIndex);
          if ps <> nil then
          begin
            if ps.Overlap >= 1 then
            begin
              if UserCounterItemAdd(ps.StdMode, ps.Looks, UserItem.Dura, ps.Name, True, UserItem.MakeIndex) then
              begin
                SendDelDealItem(UserItem);
                Dispose(UserItem); //0420
                m_DealItemList.Delete(i);
                Flag := True;
                Break;
              end
              else
              begin
                m_ItemList.Add(m_DealItemList[i]);
                SendAddItem(pTUserItem(m_DealItemList[i]));
                SendDelDealItem(UserItem);
                m_DealItemList.Delete(i);
                Flag := True;
                Break;
              end;
            end
            else
            begin
              m_ItemList.Add(UserItem);
              TPlayObject(Self).SendDelDealItem(UserItem);
              m_DealItemList.Delete(i);
              Flag := True;
              Break;
            end;
          end;
        end;
      end;
    end;
  end;
  if not Flag then
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientCancelDeal;
begin
  DealCancel();
end;

procedure TPlayObject.ClientChangeDealGold(nGold: Integer); //004DDB04
var
  bo09: Boolean;
begin
  //½ûÖ¹È¡»Ø·ÅÈë½»Ò×À¸ÄÚµÄ½ð±Ò
  if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if nGold < 0 then
  begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
    Exit;
  end;
  bo09 := False;
  if (m_DealCreat <> nil) and (GetPoseCreate() = m_DealCreat) then
  begin
    if not m_DealCreat.m_boDealOK then
    begin
      if (m_nGold + m_nDealGolds) >= nGold then
      begin
        m_nGold := (m_nGold + m_nDealGolds) - nGold;
        m_nDealGolds := nGold;
        SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
        TPlayObject(m_DealCreat).SendDefMessage(SM_DEALREMOTECHGGOLD, m_nDealGolds, 0, 0, 0, '');
        m_DealCreat.m_DealLastTick := GetTickCount();
        bo09 := True;
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
  if not bo09 then
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0, '');
end;

procedure TPlayObject.ClientDealEnd;
var
  i: Integer;
  boCheckOK: Boolean;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  PlayObject: TPlayObject;
begin
  m_boDealOK := True;
  if (m_DealCreat = nil) or m_StallMgr.OnSale or TPlayObject(m_DealCreat).m_StallMgr.OnSale then
    Exit;
  if ((GetTickCount - m_DealLastTick) < g_Config.dwDealOKTime {1000}) or ((GetTickCount - m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime {1000}) then
  begin
    SysMsg(g_sDealOKTooFast, c_Red, t_Hint);
    DealCancel();
    Exit;
  end;
  if m_DealCreat.m_boDealOK then
  begin
    boCheckOK := True;
    if (GetMaxBagItem - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count then
    begin
      boCheckOK := False;
      SysMsg(g_sYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then
    begin
      SysMsg(g_sYourGoldLargeThenLimit, c_Red, t_Hint);
      boCheckOK := False;
    end;
    if (GetMaxBagItem - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count then
    begin
      SysMsg(g_sDealHumanBagSizeTooSmall, c_Red, t_Hint);
      boCheckOK := False;
    end;
    if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then
    begin
      SysMsg(g_sDealHumanGoldLargeThenLimit, c_Red, t_Hint);
      boCheckOK := False;
    end;
    if boCheckOK then
    begin
      for i := 0 to m_DealItemList.Count - 1 do
      begin
        UserItem := m_DealItemList.Items[i];
        m_DealCreat.AddItemToBag(UserItem);
        TPlayObject(m_DealCreat).SendAddItem(UserItem);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
          begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('8' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + m_DealCreat.m_sCharName);
          end;
        end;
      end;

      if m_nDealGolds > 0 then
      begin
        Inc(m_DealCreat.m_nGold, m_nDealGolds);
        m_DealCreat.GoldChanged();
        if g_boGameLogGold then
          AddGameDataLogAPI('8' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 + IntToStr(m_nDealGolds) + #9 + '1' + #9 + m_DealCreat.m_sCharName);
      end;

      for i := 0 to m_DealCreat.m_DealItemList.Count - 1 do
      begin
        UserItem := m_DealCreat.m_DealItemList.Items[i];
        AddItemToBag(UserItem);
        TPlayObject(Self).SendAddItem(UserItem);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
          begin
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('8' + #9 + m_DealCreat.m_sMapName + #9 + IntToStr(m_DealCreat.m_nCurrX) + #9 + IntToStr(m_DealCreat.m_nCurrY) + #9 + m_DealCreat.m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + m_sCharName);
          end;
        end;
      end;

      if m_DealCreat.m_nDealGolds > 0 then
      begin
        Inc(m_nGold, m_DealCreat.m_nDealGolds);
        GoldChanged();
        if g_boGameLogGold then
          AddGameDataLogAPI('8' + #9 + m_DealCreat.m_sMapName + #9 + IntToStr(m_DealCreat.m_nCurrX) + #9 + IntToStr(m_DealCreat.m_nCurrY) + #9 +
            m_DealCreat.m_sCharName + #9 + sSTRING_GOLDNAME + #9 + IntToStr(m_DealCreat.m_nDealGolds) + #9 + '1' + #9 + m_sCharName);
      end;

      PlayObject := TPlayObject(m_DealCreat);
      PlayObject.SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      PlayObject.SysMsg(g_sDealSuccessMsg, c_Green, t_Hint);
      PlayObject.m_DealCreat := nil;
      PlayObject.m_boDealing := False;
      PlayObject.m_DealItemList.Clear;
      PlayObject.m_nDealGolds := 0;
      PlayObject.m_boDealOK := False;

      PlayObject.m_dwSaveRcdTick := GetTickCount; //0408
      UserEngine.SaveHumanRcd(PlayObject);

      SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      SysMsg(g_sDealSuccessMsg {'½»Ò×³É¹¦...'}, c_Green, t_Hint);
      m_DealCreat := nil;
      m_boDealing := False;
      m_DealItemList.Clear;
      m_nDealGolds := 0;
      m_boDealOK := False;

      m_dwSaveRcdTick := GetTickCount; //0408
      UserEngine.SaveHumanRcd(Self);

    end
    else
      DealCancel();
  end
  else
  begin
    SysMsg(g_sYouDealOKMsg {'ÄãÒÑ¾­È·ÈÏ½»Ò×ÁË'}, c_Green, t_Hint);
    m_DealCreat.SysMsg(g_sPoseDealOKMsg {'¶Ô·½ÒÑ¾­È·ÈÏ½»Ò×ÁË'}, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.ClientGetMinMap; //004DE550
var
  nMinMap: Integer;
begin
  nMinMap := m_PEnvir.m_nMinMap;
  if nMinMap > 0 then
    SendDefMessage(SM_READMINIMAP_OK, 0, nMinMap, 0, 0, '')
  else
    SendDefMessage(SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientMakeDrugItem(Npc: TObject; nItemName: string);
var
  Merchant: TMerchant;
begin
  Merchant := UserEngine.FindMerchant(Npc);
  if (Merchant = nil) or (not Merchant.m_boMakeDrug) then
    Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientMakeDrugItem(Self, nItemName);
end;

procedure TPlayObject.ClientOpenGuildDlg; //004DE8E0
var
  i: Integer;
  SC: string;
begin
  if m_MyGuild <> nil then
  begin
    SC := TGuild(m_MyGuild).sGuildName + #13 + ' ' + #13;
    if m_nGuildRankNo = 1 then
    begin
      SC := SC + '1' + #13;
    end
    else
    begin
      SC := SC + '0' + #13;
    end;
    SC := SC + '<Notice>' + #13;
    for i := 0 to TGuild(m_MyGuild).NoticeList.Count - 1 do
    begin
      if Length(SC) > 5000 then
        Break;
      SC := SC + TGuild(m_MyGuild).NoticeList.Strings[i] + #13;
    end;
    SC := SC + '<KillGuilds>' + #13;
    for i := 0 to TGuild(m_MyGuild).m_GuildWarList.Count - 1 do
    begin
      if Length(SC) > 5000 then
        Break;
      SC := SC + TGuild(m_MyGuild).m_GuildWarList.Keys[i] + #13;
    end;
    SC := SC + '<AllyGuilds>' + #13;
    for i := 0 to TGuild(m_MyGuild).m_GuildAllList.Count - 1 do
    begin
      if Length(SC) > 5000 then
        Break;
      SC := SC + TGuild(m_MyGuild).m_GuildAllList.Keys[i] + #13;
    end;
    m_DefMsg := MakeDefaultMsg(SM_OPENGUILDDLG, 0, 0, 0, 1);
    SendSocket(@m_DefMsg, EncodeString(SC));
  end
  else
    SendDefMessage(SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientGuildHome; //004DEBDC
begin
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildMemberList; //004DEBF0
var
  GuildRank: pTGuildRank;
  i, ii: Integer;
  sSENDMSG: string;
begin
  if m_MyGuild = nil then
    Exit;
  sSENDMSG := '';
  for i := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
  begin
    GuildRank := TGuild(m_MyGuild).m_RankList.Items[i];
    sSENDMSG := sSENDMSG + '#' + IntToStr(GuildRank.nRankNo) + '/*' + GuildRank.sRankName + '/';
    for ii := 0 to GuildRank.MemberList.Count - 1 do
    begin
      if Length(sSENDMSG) > 5000 then
        Break;
      sSENDMSG := sSENDMSG + GuildRank.MemberList.Keys[ii] + '/';
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_SENDGUILDMEMBERLIST, 0, 0, 0, 1);
  SendSocket(@m_DefMsg, EncodeString(sSENDMSG));
end;

procedure TPlayObject.ClientGuildAddMember(sHumName: string); //004DEDB4
var
  nC: Integer;
  PlayObject: TPlayObject;
resourcestring
  YourGuildIsFullMsg = '¶Ô²»Æð£¬ÄúµÄÐÐ»áÈËÊýÒÑ´ïµ½ÉÏÏÞ£¡';
begin
  if m_MyGuild = nil then
    Exit;
  if TGuild(m_MyGuild).IsFull then
  begin
    SysMsg(YourGuildIsFullMsg, c_Red, t_Hint);
    Exit;
  end;
  nC := 1;
  if IsGuildMaster then
  begin
    PlayObject := UserEngine.GetPlayObject(sHumName);
    if (PlayObject <> nil) and not PlayObject.m_boOffLineFlag then
    begin //080118
      if PlayObject.GetPoseCreate = Self then
      begin
        if PlayObject.m_boAllowGuild then
        begin
          if not TGuild(m_MyGuild).IsMember(sHumName) then
          begin
            if (PlayObject.m_MyGuild = nil) and (TGuild(m_MyGuild).m_RankList.Count < 400) then
            begin
              TGuild(m_MyGuild).AddMember(PlayObject);
              UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
              PlayObject.m_MyGuild := m_MyGuild;
              PlayObject.m_sGuildRankName := TGuild(m_MyGuild).GetRankName(PlayObject, PlayObject.m_nGuildRankNo);
              PlayObject.RefShowName();
              PlayObject.SysMsg('ÄãÒÑ¼ÓÈëÐÐ»á: ' + TGuild(m_MyGuild).sGuildName + ' µ±Ç°·âºÅÎª: ' + PlayObject.m_sGuildRankName, c_Green, t_Hint);
              nC := 0;
            end
            else
              nC := 4;
          end
          else
            nC := 3;
        end
        else
        begin
          nC := 5;
          PlayObject.SysMsg('Äã¾Ü¾ø¼ÓÈëÐÐ»á¡£ [ÔÊÐíÃüÁîÎª @' + g_GameCommand.LETGUILD.sCmd + ']', c_Red, t_Hint);
        end;
      end
      else
        nC := 2;
    end
    else
      nC := 2;
  end;
  if nC = 0 then
    SendDefMessage(SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '')
  else
    SendDefMessage(SM_GUILDADDMEMBER_FAIL, nC, 0, 0, 0, '');
end;

procedure TPlayObject.ClientGuildDelMember(sHumName: string);
var
  nC: Integer;
  s14: string;
  PlayObject: TPlayObject;
begin
  nC := 1;
  if IsGuildMaster then
  begin
    if TGuild(m_MyGuild).IsMember(sHumName) then
    begin
      if m_sCharName <> sHumName then
      begin
        if TGuild(m_MyGuild).DelMember(sHumName) then
        begin
          PlayObject := UserEngine.GetPlayObject(sHumName);
          if PlayObject <> nil then
          begin
            PlayObject.m_MyGuild := nil;
            PlayObject.RefRankInfo(0, '');
            PlayObject.RefShowName();
          end;
          UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
          nC := 0;
        end
        else
          nC := 4;
      end
      else
      begin
        nC := 3;
        s14 := TGuild(m_MyGuild).sGuildName;
        if TGuild(m_MyGuild).CancelGuld(sHumName) then
        begin
          g_GuildManager.DelGuild(s14);
          UserEngine.SendInterMsg(ISM_DELGUILD, g_nServerIndex, s14);
          m_MyGuild := nil;
          RefRankInfo(0, '');
          RefShowName();
          SysMsg('ÐÐ»á' + s14 + 'ÒÑ±»È¡Ïû', c_Red, t_Hint);
          nC := 0;
        end
      end;
    end
    else
      nC := 2;
  end;
  if nC = 0 then
    SendDefMessage(SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '')
  else
    SendDefMessage(SM_GUILDDELMEMBER_FAIL, nC, 0, 0, 0, '');
end;

procedure TPlayObject.ClientGuildUpdateNotice(sNotict: string);
var
  SC: string;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
    Exit;
  TGuild(m_MyGuild).NoticeList.Clear;
  while (sNotict <> '') do
  begin
    sNotict := GetValidStr3(sNotict, SC, [#$D]);
    TGuild(m_MyGuild).NoticeList.Add(SC);
  end;
  TGuild(m_MyGuild).SaveGuildInfoFile();
  UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: string); //004DF2E8
var
  nCheckCode: Integer;
resourcestring
  sIsInFilterListMsg = 'ÐÐ»á·âºÅÖÐ°üº¬ÁË·Ç·¨×Ö·û£¬ÇëÖØÐÂ±à¼­£¡';
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
    Exit;
  nCheckCode := TGuild(m_MyGuild).UpdateRank(sRankInfo);
  if nCheckCode = -15 then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sIsInFilterListMsg);
    Exit;
  end;
  if nCheckCode = 0 then
  begin
    UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
    ClientGuildMemberList();
  end
  else
  begin
    if nCheckCode <= -2 then
      SendDefMessage(SM_GUILDRANKUPDATE_FAIL, nCheckCode, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientGuildAlly; //004DF3AC
var
  n8: Integer;
  BaseObjectC: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ClientGuildAlly';
begin
  try
    n8 := -1;
    BaseObjectC := GetPoseCreate();
    if (BaseObjectC <> nil) and
      (BaseObjectC.m_MyGuild <> nil) and
      (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
      (BaseObjectC.GetPoseCreate = Self) then
    begin
      if TGuild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly then
      begin
        if BaseObjectC.IsGuildMaster and IsGuildMaster then
        begin
          if TGuild(m_MyGuild).IsNotWarGuild(TGuild(BaseObjectC.m_MyGuild)) and
            TGuild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGuild(m_MyGuild)) then
          begin
            TGuild(m_MyGuild).AllyGuild(TGuild(BaseObjectC.m_MyGuild));
            TGuild(BaseObjectC.m_MyGuild).AllyGuild(TGuild(m_MyGuild));
            TGuild(m_MyGuild).SendGuildMsg(TGuild(BaseObjectC.m_MyGuild).sGuildName + 'ÐÐ»áÒÑ¾­ºÍÄúµÄÐÐ»áÁªÃË³É¹¦');
            TGuild(BaseObjectC.m_MyGuild).SendGuildMsg(TGuild(m_MyGuild).sGuildName + 'ÐÐ»áÒÑ¾­ºÍÄúµÄÐÐ»áÁªÃË³É¹¦');
            TGuild(m_MyGuild).RefMemberName;
            TGuild(BaseObjectC.m_MyGuild).RefMemberName;
            UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
            UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(BaseObjectC.m_MyGuild).sGuildName);
            n8 := 0;
          end
          else
            n8 := -2;
        end
        else
          n8 := -3;
      end
      else
        n8 := -4;
    end;
    if n8 = 0 then
    begin
      SendDefMessage(SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_GUILDMAKEALLY_FAIL, n8, 0, 0, 0, '');
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: string); //004DF604
var
  n10: Integer;
  Guild: TGuild;
begin
  if not IsGuildMaster() then Exit;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    if TGuild(m_MyGuild).IsAllyGuild(Guild) then
    begin
      TGuild(m_MyGuild).DelAllyGuild(Guild);
      Guild.DelAllyGuild(TGuild(m_MyGuild));
      TGuild(m_MyGuild).SendGuildMsg(Guild.sGuildName + ' ÐÐ»áÓëÄúµÄÐÐ»á½â³ýÁªÃË³É¹¦');
      Guild.SendGuildMsg(TGuild(m_MyGuild).sGuildName + ' ÐÐ»á½â³ýÁËÓëÄúÐÐ»áµÄÁªÃË');
      TGuild(m_MyGuild).RefMemberName();
      Guild.RefMemberName();
      UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
      UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, Guild.sGuildName);
      n10 := 0;
    end
    else
      n10 := -2;
  end
  else
    n10 := -3;
  if n10 = 0 then
    SendDefMessage(SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '')
  else
    SendDefMessage(SM_GUILDMAKEALLY_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.RecalcAdjusBonus();

  procedure AdjustAb(Abil: Word; Val: Word; var lov, hiv: Word);
  var
    Lo, Hi: Byte;
    i: Integer;
  begin
    Lo := LoByte(Abil);
    Hi := HiByte(Abil);
    lov := 0;
    hiv := 0;
    for i := 1 to Val do
    begin
      if Lo + 2 < Hi then
      begin
        Inc(Lo);
        Inc(lov);
      end
      else
      begin
        Inc(Hi);
        Inc(hiv);
      end;
    end;
  end;
var
  BonusTick: pTNakedAbility;
  NakedAbil: pTNakedAbility;
  adc, amc, asc, aac, amac: Integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
  wHDC, wHMC, wHSC, wHAC, wHMAC: Word;
  wLDC, wLMC, wLSC, wLAC, wLMAC: Word;
  bplevel: Integer;
begin
  BonusTick := nil;
  NakedAbil := nil;
  case m_btJob of
    0:
      begin
        BonusTick := @g_Config.BonusAbilofWarr;
        NakedAbil := @g_Config.NakedAbilofWarr;
      end;
    1:
      begin
        BonusTick := @g_Config.BonusAbilofWizard;
        NakedAbil := @g_Config.NakedAbilofWizard;
      end;
    2:
      begin
        BonusTick := @g_Config.BonusAbilofTaos;
        NakedAbil := @g_Config.NakedAbilofTaos;
      end;
  end;

  adc := m_BonusAbil.DC div BonusTick.DC;
  amc := m_BonusAbil.MC div BonusTick.MC;
  asc := m_BonusAbil.SC div BonusTick.SC;
  aac := m_BonusAbil.AC div BonusTick.AC;
  amac := m_BonusAbil.MAC div BonusTick.MAC;

  AdjustAb(NakedAbil.DC, adc, ldc, hdc);
  AdjustAb(NakedAbil.MC, amc, lmc, hmc);
  AdjustAb(NakedAbil.SC, asc, lsc, hsc);
  AdjustAb(NakedAbil.AC, aac, lac, hac);
  AdjustAb(NakedAbil.MAC, amac, lmac, hmac);

  bplevel := 1;
  if m_btWeaponSkill = 2 then
  begin
    if g_Config.nEffectBonuPointLevel in [2..255] then
      bplevel := g_Config.nEffectBonuPointLevel;
  end;
  if bplevel = 1 then
  begin
    wLDC := _MIN(High(Word), LoWord(m_WAbil.DC) + ldc);
    wHDC := _MIN(High(Word), HiWord(m_WAbil.DC) + hdc);
    wLMC := _MIN(High(Word), LoWord(m_WAbil.MC) + lmc);
    wHMC := _MIN(High(Word), HiWord(m_WAbil.MC) + hmc);
    wLSC := _MIN(High(Word), LoWord(m_WAbil.SC) + lsc);
    wHSC := _MIN(High(Word), HiWord(m_WAbil.SC) + hsc);
    wLAC := _MIN(High(Word), LoWord(m_WAbil.AC) + lac);
    wHAC := _MIN(High(Word), HiWord(m_WAbil.AC) + hac);
    wLMAC := _MIN(High(Word), LoWord(m_WAbil.MAC) + lmac);
    wHMAC := _MIN(High(Word), HiWord(m_WAbil.MAC) + hmac);
    m_WAbil.DC := MakeLong(wLDC, wHDC);
    m_WAbil.MC := MakeLong(wLMC, wHMC);
    m_WAbil.SC := MakeLong(wLSC, wHSC);
    m_WAbil.AC := MakeLong(wLAC, wHAC);
    m_WAbil.MAC := MakeLong(wLMAC, wHMAC);
    m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP);
    m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP);
  end
  else
  begin
    wLDC := _MIN(High(Word), LoWord(m_WAbil.DC) + ldc * bplevel);
    wHDC := _MIN(High(Word), HiWord(m_WAbil.DC) + hdc * bplevel);
    wLMC := _MIN(High(Word), LoWord(m_WAbil.MC) + lmc * bplevel);
    wHMC := _MIN(High(Word), HiWord(m_WAbil.MC) + hmc * bplevel);
    wLSC := _MIN(High(Word), LoWord(m_WAbil.SC) + lsc * bplevel);
    wHSC := _MIN(High(Word), HiWord(m_WAbil.SC) + hsc * bplevel);
    wLAC := _MIN(High(Word), LoWord(m_WAbil.AC) + lac * bplevel);
    wHAC := _MIN(High(Word), HiWord(m_WAbil.AC) + hac * bplevel);
    wLMAC := _MIN(High(Word), LoWord(m_WAbil.MAC) + lmac * bplevel);
    wHMAC := _MIN(High(Word), HiWord(m_WAbil.MAC) + hmac * bplevel);
    m_WAbil.DC := MakeLong(wLDC, wHDC);
    m_WAbil.MC := MakeLong(wLMC, wHMC);
    m_WAbil.SC := MakeLong(wLSC, wHSC);
    m_WAbil.AC := MakeLong(wLAC, wHAC);
    m_WAbil.MAC := MakeLong(wLMAC, wHMAC);
    m_WAbil.MaxHP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxHP + (m_BonusAbil.HP div BonusTick.HP) * bplevel);
    m_WAbil.MaxMP := _LMIN({$IF HIGHHP}g_Config.nMaxHealth{$ELSE}High(Word){$IFEND}, m_WAbil.MaxMP + (m_BonusAbil.MP div BonusTick.MP) * bplevel);
  end;
 
  //m_btSpeedPoint := m_btSpeedPoint + m_BonusAbil.Speed div BonusTick.Speed;
  //m_btHitPoint := m_btHitPoint + m_BonusAbil.Hit div BonusTick.Hit;
end;

procedure TPlayObject.ClientAffirmPostDeal(nNPC: Integer);
var
  ss, ii, nG, nGT, nCount: Integer;
  DateTime: TDateTime;
  pPostSell: pTPostSell;
  pPostGold: pTPostGold;
  UserItem: TUserItem;
  pUserItem: pTUserItem;
  pStdItem: pTStdItem;
  boPostSell, boFound: Boolean;
  PlayObject: TPlayObject;
  Merchant: TNormNpc;
  pdc: PTDelayCallNPC;
begin
  if m_StallMgr.OnSale then
    Exit;
  if m_nGameGold <= 0 then
  begin
    SendDefMessage(SM_AFFIRMYBDEA_FAIL, -3, 0, 0, 0, '');
    Exit;
  end;

  //if nNPC = 0 then Exit;
  if TObject(nNPC) = m_LastNPC then
  begin
    Merchant := TNormNpc(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nNPC));
    if Merchant = nil then
      Merchant := UserEngine.FindNPC(TObject(nNPC));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;
  //Merchant := UserEngine.FindMerchant(TObject(nNPC));
  //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nNPC));
  if Merchant = nil then
    Merchant := TMerchant(m_NPC);
  if (Merchant <> nil) and TMerchant(Merchant).m_boYBDeal then
  begin
    if (TMerchant(Merchant).m_PostSellList <> nil) and (TMerchant(Merchant).m_PostSellList.Count > 0) then
    begin
      boPostSell := False;
      for ss := 0 to TMerchant(Merchant).m_PostSellList.Count - 1 do
      begin
        pPostSell := pTPostSell(TMerchant(Merchant).m_PostSellList[ss]);
        if pPostSell.sTargName = m_sCharName then
        begin
          DateTime := pPostSell.dPostTime;
          boPostSell := True;
          Break;
        end;
      end;
      if boPostSell then
      begin
        if m_nGameGold < pPostSell.nPostPrice then
        begin
          SendDefMessage(SM_AFFIRMYBDEA_FAIL, -6, 0, 0, 0, '');
          Exit;
        end;
        if GetDayCount(Now, DateTime) <= 3 then
        begin
          nCount := 0;
          for ii := Low(pPostSell.aPostItems) to High(pPostSell.aPostItems) do
          begin
            UserItem := pPostSell.aPostItems[ii];
            if (UserItem.wIndex > 0) and (UserEngine.GetStdItem(UserItem.wIndex) <> nil) then
              Inc(nCount);
          end;
          if nCount > 0 then
          begin
            if m_ItemList.Count + nCount > GetMaxBagItem then
            begin
              SendDefMessage(SM_AFFIRMYBDEA_FAIL, -4, 0, 0, 0, '');
              //SysMsg('ÄãµÄ±³°ü¿ÕÎ»²»×ã£¬ÇëÕûÀíºóÔÙ½øÐÐ²Ù×÷', c_Purple, t_Hint);
              Exit;
            end;
          end;
          //PlayObject.SendMsg(Merchant, RM_MERCHANTDLGCLOSE, 0, Integer(Merchant), 0, 0, '');
          for ii := Low(pPostSell.aPostItems) to High(pPostSell.aPostItems) do
          begin
            UserItem := pPostSell.aPostItems[ii];
            if (UserItem.wIndex > 0) then
            begin
              pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if pStdItem <> nil then
              begin
                New(pUserItem);
                pUserItem^ := UserItem;
                if AddItemToBag(pUserItem) then
                begin
                  SendAddItem(pUserItem);
                  pPostSell.aPostItems[ii].wIndex := 0;
                  if pStdItem.NeedIdentify = 1 then
                    AddGameDataLogAPI('9' + #9 +
                      m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 +
                      IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 +
                      pStdItem.Name + #9 +
                      IntToStr(pUserItem.MakeIndex) + #9 +
                      '1' + #9 +
                      '¹ºÂò¼ÄÊÛ-' + IntToStr(pPostSell.nPostPrice) + g_Config.sGameGoldName + '+' + IntToStr(pPostSell.nPostStone) + '½ð¸ÕÊ¯');
                end
                else
                  Dispose(pUserItem);
              end;
            end;
          end;
          if pPostSell.nPostStone > 0 then
          begin
            Inc(m_nGameDiamond, pPostSell.nPostStone);
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            pPostSell.nPostStone := 0;
          end;
          Dec(m_nGameGold, pPostSell.nPostPrice);
          GameGoldChanged();

          //////////////////// SaveEGoldInfo ////////////////////
          PlayObject := UserEngine.GetPlayObject(pPostSell.sCharName);
          if PlayObject <> nil then
          begin
            Inc(PlayObject.m_nGameGold, pPostSell.nPostPrice);
            PlayObject.GameGoldChanged();
            PlayObject.SysMsg(Format('ÄãµÄÎïÆ·ÒÑ³É¹¦Âô³ö, µÃµ½ %d ¸öÔª±¦, µ±Ç°Ôª±¦ÊýÁ¿: %d', [pPostSell.nPostPrice, PlayObject.m_nGameGold]), c_Purple, t_Hint);
            if g_boGameLogGameGold then
              AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, PlayObject.m_sMapName, PlayObject.m_nCurrX, PlayObject.m_nCurrY, PlayObject.m_sCharName, g_Config.sGameGoldName, pPostSell.nPostPrice, '+', '¼ÄÊÛ»ñµÃ']));
            if TMerchant(Merchant).m_PostGoldList = nil then
              TMerchant(Merchant).m_PostGoldList := TList.Create;
            boFound := False;
            for nG := 0 to TMerchant(Merchant).m_PostGoldList.Count - 1 do
            begin
              pPostGold := TMerchant(Merchant).m_PostGoldList.Items[nG];
              if pPostGold.sCharName = pPostSell.sCharName then
              begin
                boFound := True;
                Break;
              end;
            end;
            if boFound then
            begin
              for nGT := High(pPostGold.EGold) - 1 downto Low(pPostGold.EGold) do
                pPostGold.EGold[nGT + 1] := pPostGold.EGold[nGT];
              pPostGold.EGold[0].boDealFlag := False;
              pPostGold.EGold[0].PostTime := Now;
              pPostGold.EGold[0].nDealGold := pPostSell.nPostPrice;
              pPostGold.EGold[0].sTargName := m_sCharName;
              //TMerchant(Merchant).m_PostgoldList.Add(pPostGold);
            end
            else
            begin
              New(pPostGold);
              FillChar(pPostGold^, SizeOf(TPostGold), 0);
              pPostGold.sCharName := pPostSell.sCharName;
              pPostGold.EGold[0].boDealFlag := False;
              pPostGold.EGold[0].PostTime := Now;
              pPostGold.EGold[0].nDealGold := pPostSell.nPostPrice;
              pPostGold.EGold[0].sTargName := m_sCharName;
              TMerchant(Merchant).m_PostGoldList.Add(pPostGold);
            end;
          end
          else
          begin
            if TMerchant(Merchant).m_PostGoldList = nil then
              TMerchant(Merchant).m_PostGoldList := TList.Create;
            boFound := False;
            for nG := 0 to TMerchant(Merchant).m_PostGoldList.Count - 1 do
            begin
              pPostGold := TMerchant(Merchant).m_PostGoldList.Items[nG];
              if pPostGold.sCharName = pPostSell.sCharName then
              begin
                boFound := True;
                Break;
              end;
            end;
            if boFound then
            begin
              for nGT := High(pPostGold.EGold) - 1 downto Low(pPostGold.EGold) do
                pPostGold.EGold[nGT + 1] := pPostGold.EGold[nGT];
              pPostGold.EGold[0].boDealFlag := True;
              pPostGold.EGold[0].PostTime := Now;
              pPostGold.EGold[0].nDealGold := pPostSell.nPostPrice;
              pPostGold.EGold[0].sTargName := m_sCharName;
              //TMerchant(Merchant).m_PostgoldList.Add(pPostGold);
            end
            else
            begin
              New(pPostGold);
              FillChar(pPostGold^, SizeOf(TPostGold), 0);
              pPostGold.sCharName := pPostSell.sCharName;
              pPostGold.EGold[0].boDealFlag := True;
              pPostGold.EGold[0].PostTime := Now;
              pPostGold.EGold[0].nDealGold := pPostSell.nPostPrice;
              pPostGold.EGold[0].sTargName := m_sCharName;
              TMerchant(Merchant).m_PostGoldList.Add(pPostGold);
            end;
          end;
          //////////////////// SaveEGoldInfo ////////////////////
          Dispose(pTPostSell(TMerchant(Merchant).m_PostSellList[ss]));
          TMerchant(Merchant).m_PostSellList.Delete(ss);
          FrmDB.SavePostSellRecord(TMerchant(Merchant), TMerchant(Merchant).m_sScript + '-' + TMerchant(Merchant).m_sMapName);
          FrmDB.SavePostGoldRecord(TMerchant(Merchant), TMerchant(Merchant).m_sScript + '-' + TMerchant(Merchant).m_sMapName);
          //m_dwSaveRcdTick := 0;         //0408_1

          New(pdc);
          pdc.nDelayCall := 500;
          pdc.sDelayCallLabel := '@YBDealOK';
          pdc.dwDelayCallTick := GetTickCount();
          pdc.bProcessed := False;
          pdc.DelayCallNPC := Integer(Merchant);

          m_DelayCallList.Add(pdc);

          SendDefMessage(SM_AFFIRMYBDEA_FAIL, 1, 0, 0, 0, '');
        end
        else
          SendDefMessage(SM_AFFIRMYBDEA_FAIL, -5, 0, 0, 0, '');
      end
      else
        SendDefMessage(SM_AFFIRMYBDEA_FAIL, -2, 0, 0, 0, '');
    end
    else
      SendDefMessage(SM_AFFIRMYBDEA_FAIL, -1, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientCancelPostDeal(nNPC: Integer);
var
  i: Integer;
  pPostSell: pTPostSell;
  boPostSell: Boolean;
  Merchant: TNormNpc;
begin
  //if nNPC = 0 then Exit;
  if TObject(nNPC) = m_LastNPC then
  begin
    Merchant := TNormNpc(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nNPC));
    if Merchant = nil then
      Merchant := UserEngine.FindNPC(TObject(nNPC));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;
  //Merchant := UserEngine.FindMerchant(TObject(nNPC));
  //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nNPC));
  if Merchant = nil then
    Merchant := TMerchant(m_NPC);
  if (Merchant <> nil) and TMerchant(Merchant).m_boYBDeal then
  begin
    if (TMerchant(Merchant).m_PostSellList <> nil) and (TMerchant(Merchant).m_PostSellList.Count > 0) then
    begin
      boPostSell := False;
      for i := 0 to TMerchant(Merchant).m_PostSellList.Count - 1 do
      begin
        pPostSell := pTPostSell(TMerchant(Merchant).m_PostSellList[i]);
        if pPostSell.sTargName = m_sCharName then
        begin
          pPostSell.sTargName := ' ';
          boPostSell := True;
          Break;
        end;
      end;
      if boPostSell then
        SendDefMessage(SM_CANCELYBSELL_FAIL, 2, 0, 0, 0, '')
      else
        SendDefMessage(SM_CANCELYBSELL_FAIL, -2, 0, 0, 0, '');
    end
    else
      SendDefMessage(SM_CANCELYBSELL_FAIL, -1, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientCancelPostSell(nNPC: Integer);
var
  i, ii, nCount: Integer;
  DateTime: TDateTime;
  pPostSell: pTPostSell;
  UserItem: TUserItem;
  pUserItem: pTUserItem;
  boDecGold, boPostSell: Boolean;
  Merchant: TNormNpc;
label
  lGetBackItem;
begin
  if m_StallMgr.OnSale then
    Exit;
  //if nNPC = 0 then Exit;
  if TObject(nNPC) = m_LastNPC then
  begin
    Merchant := TNormNpc(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nNPC));
    if Merchant = nil then
      Merchant := UserEngine.FindNPC(TObject(nNPC));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;
  //Merchant := UserEngine.FindMerchant(TObject(nNPC));
  //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nNPC));
  if Merchant = nil then
    Merchant := TMerchant(m_NPC);
  if (Merchant <> nil) and TMerchant(Merchant).m_boYBDeal then
  begin
    if (TMerchant(Merchant).m_PostSellList <> nil) and (TMerchant(Merchant).m_PostSellList.Count > 0) then
    begin
      boPostSell := False;
      for i := 0 to TMerchant(Merchant).m_PostSellList.Count - 1 do
      begin
        pPostSell := pTPostSell(TMerchant(Merchant).m_PostSellList[i]);
        if pPostSell.sCharName = m_sCharName then
        begin
          DateTime := pPostSell.dPostTime;
          boPostSell := True;
          Break;
        end;
      end;
      if boPostSell then
      begin
        if GetDayCount(Now, DateTime) <= 3 then
        begin
          boDecGold := False;
          lGetBackItem:
          nCount := 0;
          for ii := Low(pPostSell.aPostItems) to High(pPostSell.aPostItems) do
          begin
            UserItem := pPostSell.aPostItems[ii];
            if (UserItem.wIndex > 0) and (UserEngine.GetStdItem(UserItem.wIndex) <> nil) then
              Inc(nCount);
          end;
          if nCount > 0 then
          begin
            if m_ItemList.Count + nCount >= GetMaxBagItem then
            begin
              SendDefMessage(SM_CANCELYBSELL_FAIL, -3, 0, 0, 0, '');
              //SysMsg('ÄãµÄ±³°ü¿ÕÎ»²»×ã£¬ÇëÕûÀíºóÔÙ½øÐÐ²Ù×÷', c_Purple, t_Hint);
              Exit;
            end;
          end;
          for ii := Low(pPostSell.aPostItems) to High(pPostSell.aPostItems) do
          begin
            UserItem := pPostSell.aPostItems[ii];
            if (UserItem.wIndex > 0) and (UserEngine.GetStdItem(UserItem.wIndex) <> nil) then
            begin
              New(pUserItem);
              pUserItem^ := UserItem;
              if AddItemToBag(pUserItem) then
              begin
                SendAddItem(pUserItem);
                pPostSell.aPostItems[ii].wIndex := 0;
              end
              else
                Dispose(pUserItem);
            end;
          end;
          if pPostSell.nPostStone > 0 then
          begin
            Inc(m_nGameDiamond, pPostSell.nPostStone);
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            pPostSell.nPostStone := 0;
          end;
          Dispose(pTPostSell(TMerchant(Merchant).m_PostSellList[i]));
          TMerchant(Merchant).m_PostSellList.Delete(i);
          FrmDB.SavePostSellRecord(TMerchant(Merchant), TMerchant(Merchant).m_sScript + '-' + TMerchant(Merchant).m_sMapName);
          SendDefMessage(SM_CANCELYBSELL_FAIL, 1, 0, 0, 0, '');
          if boDecGold then
          begin
            if m_nGameGold > 0 then
            begin
              Dec(m_nGameGold);
              GameGoldChanged();
              if g_boGameLogGameGold then
                AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD, m_sMapName, m_nCurrX, m_nCurrY, m_sCharName, g_Config.sGameGoldName, 1, '-', 'È¡Ïû¼ÄÊÛ']));
            end;
          end;
          //m_dwSaveRcdTick := 0;         //0408_1
        end
        else if m_nGameGold > 0 then
        begin
          boDecGold := True;
          goto lGetBackItem;
        end
        else
          SendDefMessage(SM_CANCELYBSELL_FAIL, -4, 0, 0, 0, '');
      end
      else
        SendDefMessage(SM_CANCELYBSELL_FAIL, -2, 0, 0, 0, '');
    end
    else
      SendDefMessage(SM_CANCELYBSELL_FAIL, -1, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientPostSell(nNPC, nCount: Integer; sMsg: string);
var
  i, ii, III, nCode, nCalc, nC: Integer;
  DateTime: TDateTime;
  CPostSell: TCPostSell;
  PostSell: TPostSell;
  pPostSell: pTPostSell;
  sCharName, sD: string;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boSellStone: Boolean;
  Merchant: TNormNpc;
begin
  try
    if not m_boDealing and not m_StallMgr.OnSale then
    begin
      if (nCount > 11) or (nCount < 2) then
      begin
        SendDefMessage(SM_POST_FAIL2, -12, 0, 0, 0, '');
        Exit;
      end;
      //if nNPC = 0 then Exit;
      if TObject(nNPC) = m_LastNPC then
      begin
        Merchant := TNormNpc(m_LastNPC);
      end
      else
      begin
        Merchant := UserEngine.FindMerchant(TObject(nNPC));
        if Merchant = nil then
          Merchant := UserEngine.FindNPC(TObject(nNPC));
        if Merchant <> nil then
          m_LastNPC := Merchant;
      end;
      //Merchant := UserEngine.FindMerchant(TObject(nNPC));
      //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nNPC));
      if Merchant = nil then
        Merchant := TMerchant(m_NPC);
      if (Merchant <> nil) and TMerchant(Merchant).m_boYBDeal then
      begin
        if not TMerchant(Merchant).CheckOnPostSell(m_sCharName, DateTime) then
        begin
          if m_btPostSell <> 0 then
          begin
            if nCount > 1 then
            begin
              FillChar(CPostSell, SizeOf(TCPostSell), #0);
              DecodeBuffer(sMsg, @CPostSell, SizeOf(TPSInfo) * nCount);
              //½»Ò×Ôª±¦¼ì²â
              if (CPostSell[0].nInt <= 0) or (CPostSell[0].nInt > 9999) then
              begin
                SendDefMessage(SM_POST_FAIL2, -10, 0, 0, 0, '');
                Exit;
              end;
              //ÊÇ·ñ´ø½ð¸ÕÊ¯½»Ò×
              boSellStone := False;
              if (CPostSell[nCount - 1].sStr = '½ð¸ÕÊ¯') then
              begin
                if (CPostSell[nCount - 1].nInt < 0) or (CPostSell[nCount - 1].nInt > 9999) or (m_nGameDiamond < CPostSell[nCount - 1].nInt) then
                begin
                  SendDefMessage(SM_POST_FAIL2, -11, 0, 0, 0, ''); //[Ê§°Ü]£ºÄúÃ»ÓÐ×ã¹»µÄ½ð¸ÕÊ¯¡£
                  Exit;
                end;
                boSellStone := True;
              end;

              sCharName := CPostSell[0].sStr;
              if (sCharName <> '') and (Length(sCharName) > 2) and CheckChrName(sCharName) then
              begin
                if not TMerchant(Merchant).CheckOnPostSell(sCharName, DateTime) then
                begin
                  FillChar(PostSell, SizeOf(TPostSell), #0);
                  PostSell.sCharName := m_sCharName;
                  PostSell.sTargName := sCharName;
                  PostSell.dPostTime := Now;
                  PostSell.nPostPrice := CPostSell[0].nInt;
                  if boSellStone then
                    nC := nCount - 2
                  else
                    nC := nCount - 1;

                  for i := Low(TCPostSell) + 1 to nC do
                  begin
                    for ii := 0 to m_ItemList.Count - 1 do
                    begin
                      UserItem := m_ItemList.Items[ii];
                      if CPostSell[i].nInt = UserItem.MakeIndex then
                      begin

                        if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
                        begin
                          if g_Config.boBindNoSell then
                          begin
                            sD := UserEngine.GetStdItemName(UserItem.wIndex);
                            SendDefMessage(SM_POST_FAIL2, -14, 0, 0, 0, sD);
                            Exit;
                          end;
                        end;

                        if InLimitItemList('', UserItem.wIndex, t_dps) then
                        begin
                          sD := UserEngine.GetStdItemName(UserItem.wIndex);
                          SendDefMessage(SM_POST_FAIL2, -13, 0, 0, 0, sD);
                          Exit;
                        end;

                        Break;
                      end;
                    end;
                  end;

                  nCalc := 0;
                  for i := Low(TCPostSell) + 1 to nC do
                  begin
                    for ii := 0 to m_ItemList.Count - 1 do
                    begin
                      UserItem := m_ItemList.Items[ii];
                      if CPostSell[i].nInt = UserItem.MakeIndex then
                      begin
                        for III := Low(PostSell.aPostItems) to High(PostSell.aPostItems) do
                        begin
                          if PostSell.aPostItems[III].wIndex <= 0 then
                          begin
                            PostSell.aPostItems[III] := UserItem^;
                            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                            if StdItem <> nil then
                              if StdItem.NeedIdentify = 1 then
                                AddGameDataLogAPI('10' + #9 +
                                  m_sMapName + #9 +
                                  IntToStr(m_nCurrX) + #9 +
                                  IntToStr(m_nCurrY) + #9 +
                                  m_sCharName + #9 +
                                  StdItem.Name + #9 +
                                  IntToStr(UserItem.MakeIndex) + #9 +
                                  '1' + #9 +
                                  '¼ÄÊÛÎïÆ·');
                            SendDelItems(UserItem);
                            Dispose(UserItem);
                            m_ItemList.Delete(ii);
                            Inc(nCalc);
                            Break;
                          end;
                        end;
                        Break;
                      end;
                    end;
                  end;

                  if boSellStone then
                  begin
                    PostSell.nPostStone := CPostSell[nCount - 1].nInt;
                    Dec(m_nGameDiamond, CPostSell[nCount - 1].nInt);
                    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                    AddGameDataLogAPI('10' + #9 +
                      m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 +
                      IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 +
                      '½ð¸ÕÊ¯' + #9 +
                      IntToStr(PostSell.nPostStone) + #9 +
                      '1' + #9 +
                      '¼ÄÊÛÎïÆ·');
                  end;

                  if (nCalc > 0) or boSellStone then
                  begin
                    New(pPostSell);
                    pPostSell^ := PostSell;
                    TMerchant(Merchant).m_PostSellList.Add(pPostSell);
                    //FrmDB.SavePostSellRecord(TMerchant(Merchant), TMerchant(Merchant).m_sScript + '-' + TMerchant(Merchant).m_sMapName);
                    //m_dwSaveRcdTick := 0; //0408_1
                    nCode := 1;
                  end
                  else
                    nCode := -7; //[Ê§°Ü]£º½»Ò×ÎïÆ·²»ÄÜÎª¿Õ£¬Çë²»ÒªÊ¹ÓÃµÚÈý·½³ÌÐò½øÐÐ·Ç·¨ÐÞ¸Ä
                end
                else
                  nCode := -6; //"[Ê§°Ü]£º¶Ô·½ÒÑÔÚÔª±¦½»Ò×ÖÐ"
              end
              else
                nCode := -1; //[Ê§°Ü]£ºÄú»òÕß¶Ô·½½ÇÉ«ÃûÖÐº¬ÓÐ·Ç·¨×Ö·û
            end
            else
              nCode := -2; //[Ê§°Ü]£º½»Ò×ÎïÆ·²»ÄÜÎª¿Õ
          end
          else
            nCode := -4; //"[Ê§°Ü]£ºÄúÉÐÎ´¿ªÍ¨Ôª±¦½»Ò×ÏµÍ³"
        end
        else
        begin
          if (Now < DateTime) or (GetDayCount(Now, DateTime) > 3) then
            nCode := -3 //"[Ê§°Ü]£ºÉÏ´Î¼ÄÊÛÎïÆ·ÒÑ³¬¹ýÊ±¼äÏÞÖÆ"
          else
            nCode := -5; //"[Ê§°Ü]£ºÄúÉÏ´Î¼ÄÊÛµÄÎïÆ·ÉÐÎ´³É¹¦½»Ò×"
        end;
      end
      else
        nCode := -8; //"[Ê§°Ü]£ºÌá½»µÄ¶¨µ¥Ê§Ð§"
    end
    else
      nCode := -9; //[Ê§°Ü]£º×°±¸½»Ò××´Ì¬²»ÄÜ½øÐÐÔª±¦¼ÄÊÛ²Ù×÷
    SendDefMessage(SM_POST_FAIL2, nCode, 0, 0, 0, '');
  except
    SendDefMessage(SM_POST_FAIL2, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: string);
var
  BonusAbil: TNakedAbility;
  nTotleUsePoint: Integer;
begin
  FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
  DecodeBuffer(sMsg, @BonusAbil, SizeOf(TNakedAbility));

  nTotleUsePoint := BonusAbil.DC +
    BonusAbil.MC +
    BonusAbil.SC +
    BonusAbil.AC +
    BonusAbil.MAC +
    BonusAbil.HP +
    BonusAbil.MP +
    BonusAbil.HIT +
    BonusAbil.Speed +
    BonusAbil.X2;

  if (nPoint >= 0) and ((nPoint + nTotleUsePoint) = m_nBonusPoint) then
  begin
    m_nBonusPoint := nPoint;
    Inc(m_BonusAbil.DC, BonusAbil.DC);
    Inc(m_BonusAbil.MC, BonusAbil.MC);
    Inc(m_BonusAbil.SC, BonusAbil.SC);
    Inc(m_BonusAbil.AC, BonusAbil.AC);
    Inc(m_BonusAbil.MAC, BonusAbil.MAC);
    Inc(m_BonusAbil.HP, BonusAbil.HP);
    Inc(m_BonusAbil.MP, BonusAbil.MP);
    Inc(m_BonusAbil.HIT, BonusAbil.HIT);
    Inc(m_BonusAbil.Speed, BonusAbil.Speed);
    Inc(m_BonusAbil.X2, BonusAbil.X2);

    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end
  else
    SysMsg('·Ç·¨Êý¾Ýµ÷Õû', c_Red, t_Hint);
end;

function TPlayObject.GetMyStatus: Integer; //004C145C
begin
  Result := m_nHungerStatus div 1000;
  if Result > 4 then
    Result := 4;
end;

procedure TPlayObject.SendAdjustBonus;
var
  sSENDMSG: string;
begin
  m_DefMsg := MakeDefaultMsg(SM_ADJUST_BONUS, m_nBonusPoint, 0, 0, 0);
  sSENDMSG := '';
  case m_btJob of
    0: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));
    1: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofWizard, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@g_Config.NakedAbilofWizard, SizeOf(TNakedAbility));
    2: sSENDMSG := EncodeBuffer(@g_Config.BonusAbilofTaos, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' + EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
  end;
  SendSocket(@m_DefMsg, sSENDMSG);
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean; //004C3CA0
begin
  Result := False;
  if (m_nCurrX - 1 <= BaseObject.m_nCurrX) and (m_nCurrX + 1 >= BaseObject.m_nCurrX) and
    (m_nCurrY - 1 <= BaseObject.m_nCurrY) and (m_nCurrY + 1 >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or (m_nCurrY <> BaseObject.m_nCurrY)) then
  begin
    Result := True;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_LEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_RIGHT;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UP;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWN;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPRIGHT;
      Exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNLEFT;
      Exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNRIGHT;
      Exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.GetLongAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
begin
  {Result := False;
  btDir := 0;
  if (abs(m_nCurrX - BaseObject.m_nCurrX) = 2) and (abs(m_nCurrX - BaseObject.m_nCurrX) = 2) then begin
    btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
    Result := True;
  end;}
  Result := False;
  if (m_nCurrX - 2 <= BaseObject.m_nCurrX) and (m_nCurrX + 2 >= BaseObject.m_nCurrX) and
    (m_nCurrY - 2 <= BaseObject.m_nCurrY) and (m_nCurrY + 2 >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or (m_nCurrY <> BaseObject.m_nCurrY)) then
  begin
    if ((m_nCurrX - 2) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_LEFT;
      Result := True;
      Exit;
    end;
    if ((m_nCurrX + 2) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_RIGHT;
      Result := True;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UP;
      Result := True;
      Exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWN;
      Result := True;
      Exit;
    end;
    if ((m_nCurrX - 2) = BaseObject.m_nCurrX) and ((m_nCurrY - 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPLEFT;
      Result := True;
      Exit;
    end;
    if ((m_nCurrX + 2) = BaseObject.m_nCurrX) and ((m_nCurrY - 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPRIGHT;
      Result := True;
      Exit;
    end;
    if ((m_nCurrX - 2) = BaseObject.m_nCurrX) and ((m_nCurrY + 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNLEFT;
      Result := True;
      Exit;
    end;
    if ((m_nCurrX + 2) = BaseObject.m_nCurrX) and ((m_nCurrY + 2) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNRIGHT;
      Result := True;
      Exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.GetLongAttackDirX(BaseObject: TBaseObject; var btDir: Byte): Boolean;
var
  nC: Integer;
begin
  Result := False;
  nC := 2;
  while True do
  begin
    if (m_nCurrX - nC <= BaseObject.m_nCurrX) and (m_nCurrX + nC >= BaseObject.m_nCurrX) and (m_nCurrY - nC <= BaseObject.m_nCurrY) and (m_nCurrY + nC >= BaseObject.m_nCurrY) and ((m_nCurrX <> BaseObject.m_nCurrX) or (m_nCurrY <> BaseObject.m_nCurrY)) then
    begin
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
      begin
        btDir := DR_LEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
      begin
        btDir := DR_RIGHT;
        Result := True;
        Exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UP;
        Result := True;
        Exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWN;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPLEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPRIGHT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNLEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNRIGHT;
        Result := True;
        Exit;
      end;
      btDir := 0;
    end;
    Inc(nC);
    if nC >= 5 then
      Break;
  end;
end;

function TBaseObject.GetLongAttackDir_Dis(BaseObject: TBaseObject; var btDir: Byte; dis: Integer): Boolean;
var
  nC: Integer;
begin
  Result := False;
  nC := 2;
  while True do
  begin
    if (m_nCurrX - nC <= BaseObject.m_nCurrX) and (m_nCurrX + nC >= BaseObject.m_nCurrX) and (m_nCurrY - nC <= BaseObject.m_nCurrY) and (m_nCurrY + nC >= BaseObject.m_nCurrY) and ((m_nCurrX <> BaseObject.m_nCurrX) or (m_nCurrY <> BaseObject.m_nCurrY)) then
    begin
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
      begin
        btDir := DR_LEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
      begin
        btDir := DR_RIGHT;
        Result := True;
        Exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UP;
        Result := True;
        Exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWN;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPLEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and ((m_nCurrY - nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPRIGHT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX - nC) = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNLEFT;
        Result := True;
        Exit;
      end;
      if ((m_nCurrX + nC) = BaseObject.m_nCurrX) and ((m_nCurrY + nC) = BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNRIGHT;
        Result := True;
        Exit;
      end;
      btDir := 0;
    end;
    Inc(nC);
    if nC > dis then
      Break;
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;
var
  nX, nY: Integer;
begin
  Result := False;
  if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 2) then
  begin
    nX := BaseObject.m_nCurrX - m_nCurrX;
    nY := BaseObject.m_nCurrY - m_nCurrY;
    if (abs(nX) <= 1) and (abs(nY) <= 1) then
    begin
      GetAttackDir(BaseObject, btDir);
      Result := True;
      Exit;
    end;
    Inc(nX, 2);
    Inc(nY, 2);
    if ((nX >= 0) and (nX <= 4)) and ((nY >= 0) and (nY <= 4)) then
    begin
      btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
      if g_Config.SpitMap[btDir, nY, nX] = 1 then
        Result := True;
    end;
  end;
end;

function TBaseObject.TargetInSwordLongAttackRange(): Boolean;
var
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
  begin
    BaseObject := m_PEnvir.GetMovingObjectA(nX, nY, True);
    if (BaseObject <> nil) and not BaseObject.m_boGhost and not BaseObject.m_boDeath and IsProperTarget(BaseObject) then
      Result := True;
  end;
end;

function TBaseObject.TargetInSwordLongAttackRangeX(): Boolean;
var
  nC, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 2;
  while True do
  begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObjectA(nX, nY, True);
      if (BaseObject <> nil) and not BaseObject.m_boGhost and not BaseObject.m_boDeath and IsProperTarget(BaseObject) then
      begin
        Result := True;
        Break;
      end;
    end;
    Inc(nC);
    if nC >= 5 then
      Break;
  end;
end;

function TBaseObject.TargetInSwordWideAttackRange(): Boolean;
var
  nC, n10: Integer;
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 0;
  while (True) do
  begin
    n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if (BaseObject <> nil) and not BaseObject.m_boGhost and not BaseObject.m_boDeath and (BaseObject <> Self) {IsProperTarget(BaseObject)} then
        Result := True;
    end;
    Inc(nC);
    if nC >= 3 then
      Break;
  end;
end;

function TBaseObject.CheckMagPassThrough(sX, sY, tX, tY, nDir: Integer): Integer;
var
  i, tCount: Integer;
  BaseObject: TBaseObject;
begin
  tCount := 0;
  for i := 0 to 12 do
  begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sX, sY, True));
    if BaseObject <> nil then
    begin
      if IsProperTarget(BaseObject) then
      begin
        if Random(15) >= BaseObject.m_nAntiMagic then
          Inc(tCount);
      end;
    end;
    if not ((abs(sX - tX) <= 0) and (abs(sY - tY) <= 0)) then
    begin
      nDir := GetNextDirection(sX, sY, tX, tY);
      if not m_PEnvir.GetNextPosition(sX, sY, nDir, 1, sX, sY) then
        Break;
    end
    else
      Break;
  end;
  Result := tCount;
end;

function TBaseObject.RecalcBagWeight: Integer;
var
  i: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  Result := 0;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      if StdItem.Overlap = 1 then
      begin
        Inc(Result, UserItem.Dura div 10);
      end
      else if StdItem.Overlap >= 2 then
      begin
        Inc(Result, UserItem.Dura * StdItem.Weight);
      end
      else
      begin
        Inc(Result, StdItem.Weight);
      end;
    end;
  end;
end;

procedure TBaseObject.RecalcHitSpeed;
var
  i, nC: Integer;
  UserMagic: pTUserMagic;
  BonusTick: pTNakedAbility;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::RecalcHitSpeed Code:%d';
begin
  nC := 0;
  try
    try
      if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        with Self as TPlayObject do
        begin
          nC := 1;
          case m_btJob of
            0: BonusTick := @g_Config.BonusAbilofWarr;
            1: BonusTick := @g_Config.BonusAbilofWizard;
            2: BonusTick := @g_Config.BonusAbilofTaos;
          end;
          nC := 2;
          m_btHitPoint := _MIN(High(Byte), DEFHIT + m_BonusAbil.HIT div BonusTick.HIT);
          case m_btJob of
            TAOS: m_btSpeedPoint := _MIN(High(Byte), DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed + 3);
          else
            m_btSpeedPoint := _MIN(High(Byte), DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed);
          end;
        end;
      end
      else
      begin
        nC := 3;
        m_btHitPoint := DEFHIT;
        case m_btJob of
          TAOS: m_btSpeedPoint := DEFSPEED + 3;
        else
          m_btSpeedPoint := DEFSPEED;
        end;
      end;
    except
    end;

    nC := 4;
    m_nHitPlus := 0;
    m_nHitDouble := 0;
    m_nHitDoubleEx := 0;
    m_nHitDouble_101 := 0;
    nC := 5;
    m_boHaveMag := False;
    FillChar(m_MagicArr, SizeOf(TMagicArr), #0);
    nC := 6;
    for i := 0 to m_MagicList.Count - 1 do
    begin
      nC := 7;
      UserMagic := m_MagicList.Items[i];
      m_MagicArr[UserMagic.MagicInfo.btClass][UserMagic.wMagIdx] := UserMagic;
      if m_btRaceServer = RC_HERO then
        case m_btJob of
          0: if not m_boHaveMag then
              m_boHaveMag := True;
          1: if not m_boHaveMag and (UserMagic.MagicInfo.btJob = 1) and (UserMagic.MagicInfo.btClass = 0)
            and not (UserMagic.wMagIdx in [8, 20, 21, 31]) then
              m_boHaveMag := True;
          2: if not m_boHaveMag and (UserMagic.MagicInfo.btJob = 2) and (UserMagic.MagicInfo.btClass = 0)
            and not (UserMagic.wMagIdx in [2, 4, 14, 15, 17, 29, 30, 34, 55]) then
              m_boHaveMag := True;
        end;

      nC := 8;
      case UserMagic.wMagIdx of
        SKILL_ONESWORD: if UserMagic.MagicInfo.btClass in [0, 1] then
          begin
            if UserMagic.btLevel > 0 then
              m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(9 / 3 * UserMagic.btLevel));
          end;
        SKILL_YEDO: if UserMagic.MagicInfo.btClass = 0 then
          begin
            if UserMagic.btLevel > 0 then
              m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(3 / 3 * UserMagic.btLevel));
            m_nHitPlus := DEFHIT + UserMagic.btLevel;
            m_btAttackSkillCount := 7 - _MIN(4, UserMagic.btLevel);
            m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
          end;
        SKILL_FIRESWORD: if UserMagic.MagicInfo.btClass = 0 then
          begin
            m_nHitDouble := 4 + UserMagic.btLevel * 4;
          end;
        SKILL_56: if UserMagic.MagicInfo.btClass = 0 then
          begin
            m_nHitDoubleEx := 5 + UserMagic.btLevel * 4;
          end;
        101: if UserMagic.MagicInfo.btClass = 0 then
          begin
            m_nHitDouble_101 := 3 + UserMagic.btLevel * 2;
          end;
        SKILL_ILKWANG: if UserMagic.MagicInfo.btClass in [0, 1] then
          begin
            if UserMagic.btLevel > 0 then
              m_btHitPoint := _MIN(High(Byte), m_btHitPoint + Round(8 / 3 * UserMagic.btLevel));
          end;
      end;
    end;
    nC := 9;
    //+3×¼È·¡¢+2¹¥»÷ÉÏÏÞ£¬Í¬Ê±»¹¿É¶ÔÄ¿±êÔì³ÉÒ»¶¨¶îÍâÉËº¦
    if (m_MagicArr[0][3] <> nil) and (m_MagicArr[0][3].btLevel >= 4) then
    begin
      m_btHitPoint := _MIN(High(Byte), m_btHitPoint + 3);
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2);
      Inc(m_nHitPlus, 2);
    end;
    if m_btRaceServer = RC_HERO then
      m_btHitPoint := _MIN(High(Byte), m_btHitPoint);
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [nC]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  mid: Integer;
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  case nIndex of
    1: mid := 1;
    2: mid := 2;
    3: mid := 114;
  else
    Exit;
  end;
  if m_MagicArr[0][mid] = nil then
  begin
    Magic := nil;
    case nIndex of
      1: Magic := UserEngine.FindMagic(g_Config.sFireBallSkill);
      2: Magic := UserEngine.FindMagic(g_Config.sHealSkill);
      3: Magic := UserEngine.FindMagic(114, 0, IsHero);
    end;
    if Magic <> nil then
    begin
      if not IsTrainingSkill(Magic.wMagicId, Magic.btClass) then
      begin
        New(UserMagic);
        UserMagic.MagicInfo := Magic;
        UserMagic.wMagIdx := Magic.wMagicId;
        UserMagic.btKey := 0;
        UserMagic.btLevel := 0;
        if nIndex = 3 then
          UserMagic.btLevel := 3;
        UserMagic.nTranPoint := 0;
        m_MagicList.Add(UserMagic);
        //188
        //RecalcAbilitys();
        RecalcHitSpeed;
        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
          TPlayObject(Self).SendAddMagic(UserMagic);
      end;
    end;
  end;
end;

procedure TBaseObject.DelItemSkill(nIndex: Integer);

  procedure DELETESKILL(mid: Integer; sSkillName: string); //004C00B8
  var
    i: Integer;
    UserMagic: pTUserMagic;
    PlayObject: TPlayObject;
  begin
    if m_MagicArr[0][mid] <> nil then
      for i := 0 to m_MagicList.Count - 1 do
      begin
        UserMagic := m_MagicList.Items[i];
        if UserMagic.MagicInfo.wMagicId = mid then
        begin
          //if UserMagic.MagicInfo.sMagicName = sSkillName then begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          m_MagicList.Delete(i);
          //188
          //RecalcAbilitys;
          RecalcHitSpeed;
          Break;
        end;
      end;
  end;

begin
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    case nIndex of
      1: if m_btJob <> 1 then
          DELETESKILL(1, g_Config.sFireBallSkill);
      2: if m_btJob <> 2 then
          DELETESKILL(2, g_Config.sHealSkill);
      3:
        begin
          DELETESKILL(114, 'ÒÐÌì±ÙµØ');
          DELETESKILL(114, 'Ó¢ÐÛÒÐÌì±ÙµØ');
        end;
    end;
  end;
end;

procedure TBaseObject.AddItemSkillEx(mid, lv: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  if lv > 15 then
    lv := 15;
  if m_MagicArr[0][mid] = nil then
  begin
    Magic := UserEngine.FindMagic(mid, 0, IsHero);
    if Magic <> nil then
    begin
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btKey := 0;
      UserMagic.btLevel := lv;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      RecalcHitSpeed;
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        TPlayObject(Self).SendAddMagic(UserMagic);
    end;
  end
  else
  begin
    if m_MagicArr[0][mid].btLevel <> lv then
    begin
      m_MagicArr[0][mid].btLevel := lv;
      SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, mid, lv, m_MagicArr[0][mid].nTranPoint, '', 100);
    end;
  end;
end;

procedure TBaseObject.DelItemSkillEx(mid: Integer);

  procedure DELETESKILL(mid: Integer; sSkillName: string); //004C00B8
  var
    i: Integer;
    UserMagic: pTUserMagic;
    PlayObject: TPlayObject;
  begin
    if m_MagicArr[0][mid] <> nil then
      for i := 0 to m_MagicList.Count - 1 do
      begin
        UserMagic := m_MagicList.Items[i];
        if UserMagic.MagicInfo.wMagicId = mid then
        begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          m_MagicList.Delete(i);
          RecalcHitSpeed;
          Break;
        end;
      end;
  end;

begin
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    DELETESKILL(mid, '');
end;

function TBaseObject.AddToMap: Boolean;
var
  Point: Pointer;
  Buffer: array[0..255] of Byte;
begin
  Point := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  if Point <> nil then
    Result := True
  else
    Result := False;
  if not m_boFixedHideMode then
    SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer);

  function GetMagicSpell(UserMagic: pTUserMagic): Integer;
  begin
    Result := Round(UserMagic.MagicInfo.wSpell / (4) * (UserMagic.btLevel + 1));
  end;

  procedure CheckWeaponUpgradeStatus(UserItem: pTUserItem);
  begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < g_Config.nUpgradeWeaponMaxPoint then
    begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex := 0;
        10..13: UserItem.btValue[0] := UserItem.btValue[0] + UserItem.btValue[10] - 9;
        20..23: UserItem.btValue[1] := UserItem.btValue[1] + UserItem.btValue[10] - 19;
        30..33: UserItem.btValue[2] := UserItem.btValue[2] + UserItem.btValue[10] - 29;
      end;
    end
    else
      UserItem.wIndex := 0;
    UserItem.btValue[10] := 0;
  end;

  procedure CheckWeaponUpgrade();
  var
    UseItems: TUserItem;
    PlayObject: TPlayObject;
    StdItem: pTStdItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then
    begin
      UseItems := m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then
      begin
        SysMsg(g_sTheWeaponBroke, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        SendRefMsg(RM_BREAKWEAPON, 0, 0, 0, 0, '');
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('21' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 + '1' + #9 + '0');
        RecalcAbilitys();
        FeatureChanged();
      end
      else
      begin
        SysMsg(sTheWeaponRefineSuccessfull, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('20' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UseItems.MakeIndex) + #9 + '1' + #9 + '0');
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
    end;
  end;
var
  wIdent: Word;
  nCheckCode: Integer;
  boPowerHit: Boolean;
  boSmiteSkill: Boolean;
  boSmiteWideSkill: Boolean;
  boSmiteWideSkill2: Boolean;
  boSmiteLongSkill: Boolean;
  boSmiteLongSkill2: Boolean;
  boFireHit: Boolean;
  boCrsHit: Boolean;
  boSuqHit: Boolean;
  boTwnHit, boPursueHit: Boolean;
  boSmiteLongSkill3: Boolean;
  btHeroLongHit: Byte;
  AttackTarget: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::AttackDir Code: %d';
begin
  nCheckCode := 0;
  try
    if not (nDir in [0..7]) then
      Exit;

    if (wHitMode = 5) and (m_MagicArr[0][SKILL_BANWOL] <> nil) then
    begin //°ëÔÂ
      if IsHero or (m_btRaceServer = RC_PLAYOBJECT) then
      begin //20080105
        if m_WAbil.MP > 0 then
        begin
          DamageSpell(m_MagicArr[0][SKILL_BANWOL].MagicInfo.btDefSpell + GetMagicSpell(m_MagicArr[0][SKILL_BANWOL]));
          HealthSpellChanged();
        end
        else
          wHitMode := RM_HIT;
      end;
    end;

    nCheckCode := 1;
    m_btDirection := nDir;
    if TargeTBaseObject = nil then
      AttackTarget := GetPoseCreateA()
    else
      AttackTarget := TargeTBaseObject;

    nCheckCode := 2;
    if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) and (m_btRaceServer = RC_PLAYOBJECT) then //20080105
      CheckWeaponUpgrade();

    boTwnHit := m_boTwinHitSkill;
    boSuqHit := m_boSquareHit;
    boCrsHit := m_boCrsHitkill;
    boFireHit := m_boFireHitSkill;
    boPursueHit := m_boPursueHitSkill;
    boSmiteSkill := m_boSmiteSkill;
    // boRushhitSkill := m_boRushhitSkill;
    boSmiteLongSkill := m_boSmiteLongSkill;
    boSmiteLongSkill2 := m_boSmiteLongSkill2;
    boSmiteLongSkill3 := m_boSmiteLongSkill3;
    boSmiteWideSkill := m_boSmiteWideSkill;
    boSmiteWideSkill2 := m_boSmiteWideSkill2;

    boPowerHit := m_boPowerHit;
    btHeroLongHit := m_btSquareHit;

    nCheckCode := 4;
    if _Attack(wHitMode, AttackTarget) then
      SetTargetCreat(AttackTarget);

    nCheckCode := 5;
    wIdent := RM_HIT;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
    begin
      case wHitMode of
        0: wIdent := RM_HIT;
        1: wIdent := RM_HEAVYHIT;
        2: wIdent := RM_BIGHIT;
        3: if boPowerHit then
            wIdent := RM_SPELL2;
        4: if m_MagicArr[0][SKILL_ERGUM] <> nil then
            wIdent := RM_LONGHIT;
        5: if m_MagicArr[0][SKILL_BANWOL] <> nil then
            wIdent := RM_WIDEHIT;
        7: if boFireHit then
            wIdent := RM_FIREHIT;
        8: if boCrsHit then
            wIdent := RM_CRSHIT;
        9: if boTwnHit then
            wIdent := RM_TWNHIT;
        10: if boSuqHit then
            wIdent := RM_SUQHIT;
        //11: if m_bo43kill then wIdent := RM_43;
        12: if btHeroLongHit = 1 then
            wIdent := RM_HERO_LONGHIT
          else if btHeroLongHit = 2 then
            wIdent := RM_HERO_LONGHIT2;
        13: if boPursueHit then
            wIdent := RM_PURSUEHIT;
        20: if boSmiteSkill then
            wIdent := RM_SMITEHIT;
        21: if boSmiteLongSkill then
            wIdent := RM_SMITELONGHIT;
        22: if boSmiteWideSkill then
            wIdent := RM_SMITEWIDEHIT;
        23: if boSmiteWideSkill2 then
            wIdent := RM_SMITEWIDEHIT2;
        24: if boSmiteLongSkill2 then
            wIdent := RM_SMITELONGHIT2;
        25: if boSmiteLongSkill3 then
            wIdent := RM_SMITELONGHIT3;

        60: if m_MagicArr[0][60] <> nil then
            wIdent := RM_60;
        61: if m_MagicArr[0][61] <> nil then
            wIdent := RM_61;
        62: if m_MagicArr[0][62] <> nil then
            wIdent := RM_62;
      end;
    end;
    nCheckCode := 6;
    SendAttackMsg(wIdent, m_btDirection, m_nCurrX, m_nCurrY); //Effect
    {if IsHero then begin
      Dec(m_nHealthTick, 30);
      Dec(m_nSpellTick, 100);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth, 2);
      Dec(m_nPerSpell, 2);
    end;}
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [nCheckCode]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TBaseObject.CheckPKStatus;
begin
  if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime) then
  begin
    m_boPKFlag := False;
    RefNameColor();
  end;
end;

procedure TBaseObject.DamageSpell(nSpellPoint: Integer); //004BE50C
begin
  if nSpellPoint > 0 then
  begin
    if (m_WAbil.MP - nSpellPoint) > 0 then
      Dec(m_WAbil.MP, nSpellPoint)
    else
      m_WAbil.MP := 0;
  end
  else
  begin
    if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
      Dec(m_WAbil.MP, nSpellPoint)
    else
      m_WAbil.MP := m_WAbil.MaxMP;
  end;
end;

procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC: Integer;
begin
  nC := PKLevel();
  Dec(m_nPkPoint, nPoint);
  if m_nPkPoint < 0 then
    m_nPkPoint := 0;
  if (PKLevel <> nC) and (nC > 0) and (nC <= 2) then
  begin
    RefNameColor();
  end;
end;

procedure TPlayObject.DelMember(BaseObject: TPlayObject);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if m_GroupOwner <> BaseObject then
  begin
    for i := 0 to m_GroupMembers.Count - 1 do
    begin
      if m_GroupMembers.Objects[i] = BaseObject then
      begin
        BaseObject.LeaveGroup();
        BaseObject.ReSetGroupAttrib();
        m_GroupMembers.Delete(i);
        TPlayObject(Self).CheckMapEvent(5, '');
        Break;
      end;
    end;
  end
  else
    for i := m_GroupMembers.Count - 1 downto 0 do
    begin
      TBaseObject(m_GroupMembers.Objects[i]).ReSetGroupAttrib();
      TPlayObject(m_GroupMembers.Objects[i]).LeaveGroup;
      m_GroupMembers.Delete(i);
      TPlayObject(Self).CheckMapEvent(5, '');
    end;
  PlayObject := TPlayObject(Self);
  if not PlayObject.CancelGroup then
    PlayObject.SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '')
  else
    PlayObject.SendGroupMembers();
end;

//  ¹¥»÷Ê±¼õÎäÆ÷³Ö¾Ã
procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer); //004C17B4
var
  nDura, nDuraPoint: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
begin
  if ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) or (IsHero and TPlayObject(m_Master).m_boOffLinePlay) then
    Exit;

  if m_UseItems[U_WEAPON].wIndex <= 0 then
    Exit;
  nDura := m_UseItems[U_WEAPON].Dura;
  nDuraPoint := Round(nDura / 1.03);
  Dec(nDura, nWeaponDamage);
  if nDura <= 0 then
  begin
    nDura := 0;
    m_UseItems[U_WEAPON].Dura := nDura;
    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
      PlayObject := TPlayObject(Self);
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if (PCardinal(@m_UseItems[U_WEAPON].btValue[22])^ > 0) and (PCardinal(@m_UseItems[U_WEAPON].btValue[22])^ = PlayObject.m_dwIdCRC) and g_Config.boBindNoMelt then
      begin
        if (nDura / 1.03) <> nDuraPoint then
        begin
          SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
          SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÊôÐÔÊ§Ð§£¬Çë¼°Ê±ÐÞÀí', [StdItem.Name]), c_Red, t_Hint);
        end;
      end
      else if StdItem.Shape in [75..77] then
      begin
        SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
        SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÒÑ¾­Ê§Ð§£¬Çë¼°Ê±ÐÞÀí', [StdItem.Name]), c_Red, t_Hint);
      end
      else
      begin
        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('3' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + #9 +
            IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
        PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
        m_UseItems[U_WEAPON].wIndex := 0;
      end;
    end
    else
      m_UseItems[U_WEAPON].wIndex := 0;
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    FeatureChanged();
  end
  else
    m_UseItems[U_WEAPON].Dura := nDura;
  if (nDura / 1.03) <> nDuraPoint then
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
end;

procedure TBaseObject.GetAccessory(item: TUserItem; var AddAbility: TAddAbility);
var
  i, Val, spAddLv: Integer;
  boUseItem, bohum, bohum2: Boolean;
  StdItem: pTStdItem;
  StdItemA: TStdItem;
  sShowMsg: string;
begin
  spAddLv := 0;
  StdItem := UserEngine.GetStdItem(item.wIndex);
  if StdItem = nil then
    Exit;

  StdItemA := StdItem^;
  ItemUnit.GetItemAddValue(@item, StdItemA);

  bohum := (m_btRaceServer = RC_PLAYOBJECT) or IsHero;
  bohum2 := m_btRaceServer in [RC_PLAYOBJECT, RC_HERO];
  boUseItem := StdItemA.StdMode in [5, 6, 10..13, 15..24, 26..30];

  if boUseItem then
  begin
    spAddLv := 1;
    if bohum then
    begin
      m_btHitPowerAddOn := _MIN(255, m_btHitPowerAddOn + LoByte(StdItemA.ItemSet));
      TPlayObject(Self).m_nTagDropPlus := _MIN(High(Word), TPlayObject(Self).m_nTagDropPlus + HiByte(StdItemA.ItemSet));
    end;

    if bohum2 then
    begin
      if StdItemA.reserve[0] > 0 then
      begin
        if Integer(m_btIgnoreTagDefence + (StdItemA.reserve[0] div 16)) < 100 then
          m_btIgnoreTagDefence := m_btIgnoreTagDefence + (StdItemA.reserve[0] div 16)
        else
          m_btIgnoreTagDefence := 100;

        if Integer(m_btDamageAddOn + (StdItemA.reserve[0] mod 16)) < 255 then
          m_btDamageAddOn := m_btDamageAddOn + (StdItemA.reserve[0] mod 16)
        else
          m_btDamageAddOn := 255;
      end;

      if StdItemA.reserve[1] > 0 then
      begin
        if Integer(m_btDamageRebound + (StdItemA.reserve[1] div 16)) < 100 then
          m_btDamageRebound := m_btDamageRebound + (StdItemA.reserve[1] div 16)
        else
          m_btDamageRebound := 100;

        if Integer(m_btACDamageReduction + (StdItemA.reserve[1] mod 16)) < 100 then
          m_btACDamageReduction := m_btACDamageReduction + (StdItemA.reserve[1] mod 16)
        else
          m_btACDamageReduction := 100;
      end;

      if StdItemA.reserve[2] > 0 then
      begin
        if Integer(m_btMCDamageReduction + (StdItemA.reserve[2] div 16)) < 100 then
          m_btMCDamageReduction := m_btMCDamageReduction + (StdItemA.reserve[2] div 16)
        else
          m_btMCDamageReduction := 100;

        if Integer(m_btGetExpExRate + (StdItemA.reserve[2] mod 16)) < 100 then
          m_btGetExpExRate := m_btGetExpExRate + (StdItemA.reserve[2] mod 16)
        else
          m_btGetExpExRate := 100;
      end;
    end;
  end;

  case StdItemA.StdMode of
    5, 6:
      begin
        spAddLv := 100;
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        if HiWord(StdItemA.MAC) > 10 then
          Inc(AddAbility.nHitSpeed, HiWord(StdItemA.MAC) - 10)
        else
          Dec(AddAbility.nHitSpeed, HiWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, LoWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
      end;
    19:
      begin
        Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
      end;
    53, 63:
      begin
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wAntiMagic, HiWord(StdItemA.AC));
          Inc(AddAbility.btUnLuck, LoWord(StdItemA.MAC));
          Inc(AddAbility.btLuck, HiWord(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        end;
      end;
    20, 24:
      begin
        Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
      end;
    52, 62:
      begin
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wHitPoint, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpeedPoint, HiWord(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        end;
      end;
    21:
      begin
        Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
        Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
    54, 64:
      begin
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wHealthRecover, HiWord(StdItemA.AC));
          Inc(AddAbility.wSpellRecover, HiWord(StdItemA.MAC));
          Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
          Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
        end;
      end;
    23:
      begin
        Inc(AddAbility.wAntiPoison, HiWord(StdItemA.AC));
        Inc(AddAbility.wPoisonRecover, HiWord(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoWord(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoWord(StdItemA.MAC));
      end;
  else
    begin
      AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
      AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
    end;
  end;
  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItemA.DC), HiWord(AddAbility.wDC) + HiWord(StdItemA.DC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItemA.MC), HiWord(AddAbility.wMC) + HiWord(StdItemA.MC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItemA.SC), HiWord(AddAbility.wSC) + HiWord(StdItemA.SC));

  if bohum and boUseItem and (StdItemA.Eva.EvaTimesMax > 0) then
  begin
    //GetItemEvaInfo(@item, StdItemA.Eva);
    if StdItemA.Eva.EvaTimes > 0 then
    begin
      for i := Low(StdItemA.Eva.Abil) to High(StdItemA.Eva.Abil) do
      begin
        if (StdItemA.Eva.Abil[i].btValue > 0) and (StdItemA.Eva.Abil[i].btType in [1..30]) then
        begin
          Val := StdItemA.Eva.Abil[i].btValue;
          case StdItemA.Eva.Abil[i].btType of
            01: AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC), _MIN(High(Word), HiWord(AddAbility.wDC) + Val));
            02: AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC), _MIN(High(Word), HiWord(AddAbility.wMC) + Val));
            03: AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC), _MIN(High(Word), HiWord(AddAbility.wSC) + Val));
            04: if StdItemA.StdMode in [10..13, 15..18, 22, 26..30] then
                AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC), _MIN(High(Word), HiWord(AddAbility.wAC) + Val));
            05: if StdItemA.StdMode in [10..13, 15..18, 22, 26..30] then
                AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC), _MIN(High(Word), HiWord(AddAbility.wMAC) + Val));
            06: if StdItemA.StdMode in [5, 6, 20, 24] then
                AddAbility.wHitPoint := _MIN(High(Word), AddAbility.wHitPoint + Val);
            07: if StdItemA.StdMode in [20, 24] then
                AddAbility.wSpeedPoint := _MIN(High(Word), AddAbility.wSpeedPoint + Val);
            08: if StdItemA.StdMode in [19] then
                AddAbility.wAntiMagic := _MIN(High(Word), AddAbility.wAntiMagic + Val);
            09: if StdItemA.StdMode in [5, 6, 19] then
                AddAbility.btLuck := _MIN(High(Byte), AddAbility.btLuck + Val);
            10: if StdItemA.StdMode in [5, 6] then
                AddAbility.btUnLuck := _MIN(High(Byte), AddAbility.btUnLuck + Val);
            11: if StdItemA.StdMode in [5, 6] then
                AddAbility.nHitSpeed := AddAbility.nHitSpeed + Val;
            12: if StdItemA.StdMode in [5, 6] then
                AddAbility.btHoly := _MIN(High(Byte), AddAbility.btHoly + Val);
            13: if StdItemA.StdMode in [5, 6] then
                AddAbility.wHealthRecover := _MIN(High(Word), AddAbility.wHealthRecover + Val);
            14: if StdItemA.StdMode in [5, 6] then
                AddAbility.wSpellRecover := _MIN(High(Word), AddAbility.wSpellRecover + Val);
            15: TPlayObject(Self).m_nTagDropPlus := _MIN(High(Word), TPlayObject(Self).m_nTagDropPlus + Val);
            16: TPlayObject(Self).m_nPreventDrop := _MIN(High(Word), TPlayObject(Self).m_nPreventDrop + Val);
            17: TPlayObject(Self).m_wVampire := _MIN(High(Word), TPlayObject(Self).m_wVampire + Val);
            18: TPlayObject(Self).m_IPRecoverRate := _MIN(High(Word), TPlayObject(Self).m_IPRecoverRate + Val);
            19: ; //g_dwIPNeedInfo[m_nInPowerLevel].nPower   ÄÚÁ¦ÉÏÏÞ
            20: TPlayObject(Self).m_AddDamage := _MIN(High(Byte), TPlayObject(Self).m_AddDamage + Val);
            21: TPlayObject(Self).m_DecDamage := _MIN(High(Byte), TPlayObject(Self).m_DecDamage + Val);
            22: TPlayObject(Self).m_wVampire2 := _MIN(High(Word), TPlayObject(Self).m_wVampire2 + Val);
            23: TPlayObject(Self).m_wDoublePower := _MIN(High(Word), TPlayObject(Self).m_wDoublePower + Val);
            24: TPlayObject(Self).m_wInPowerRateEx := _MIN(High(Word), TPlayObject(Self).m_wInPowerRateEx + Val);
            25: TPlayObject(Self).m_btAntiStone := _MIN(High(Byte), TPlayObject(Self).m_btAntiStone + Val);
            26: TPlayObject(Self).m_wHPAddLevel := _MIN(High(Byte), TPlayObject(Self).m_wHPAddLevel + Val);
            27: TPlayObject(Self).m_wMPAddLevel := _MIN(High(Byte), TPlayObject(Self).m_wMPAddLevel + Val);
            28: TPlayObject(Self).m_wJobAbil := _MIN(High(Word), TPlayObject(Self).m_wJobAbil + Val);
            29: AddAbility.wAntiPoison := _MIN(High(Word), AddAbility.wAntiPoison + Val);
            30: AddAbility.wPoisonRecover := _MIN(High(Word), AddAbility.wPoisonRecover + Val);
          end;
        end;
      end;

      if StdItemA.Eva.AdvAbil > 0 then
      begin
        if StdItemA.Eva.AdvAbil and $01 <> 0 then
          m_boMagicShield2 := True;
        if StdItemA.Eva.AdvAbil and $02 <> 0 then
          m_boParalysis2 := True;
        if StdItemA.Eva.AdvAbil and $04 <> 0 then
          m_boRevival := True;
        if StdItemA.Eva.AdvAbil and $08 <> 0 then
          m_boProbeNecklace := True;
        if StdItemA.Eva.AdvAbil and $10 <> 0 then
          m_boTeleport := True;
        if StdItemA.Eva.AdvAbil and $20 <> 0 then
          m_boParalysis := True;
        if StdItemA.Eva.AdvAbil and $40 <> 0 then
          m_boMParalysis := True;
        {if StdItemA.Eva.AdvAbil and $80 <> 0 then begin
          m_wStatusTimeArr[STATE_TRANSPARENT] := g_MaxStatusTime;
          m_boHideMode := True;
        end;}
      end;

      if StdItemA.Eva.SpSkill > 0 then
      begin
        if StdItemA.Eva.SpSkill and $01 <> 0 then
          m_btSpSkill1 := m_btSpSkill1 + spAddLv;
        if StdItemA.Eva.SpSkill and $02 <> 0 then
          m_btSpSkill2 := m_btSpSkill2 + spAddLv;
        if StdItemA.Eva.SpSkill and $04 <> 0 then
          m_btSpSkill3 := m_btSpSkill3 + spAddLv;
        if StdItemA.Eva.SpSkill and $08 <> 0 then
          m_btSpSkill4 := m_btSpSkill4 + spAddLv;
        if StdItemA.Eva.SpSkill and $10 <> 0 then
          m_btSpSkill5 := m_btSpSkill5 + spAddLv;
        if StdItemA.Eva.SpSkill and $20 <> 0 then
          m_btSpSkill6 := m_btSpSkill6 + spAddLv;
        if StdItemA.Eva.SpSkill and $40 <> 0 then
          m_btSpSkill7 := m_btSpSkill7 + spAddLv;
        if StdItemA.Eva.SpSkill and $80 <> 0 then
          m_btSpSkill8 := m_btSpSkill8 + spAddLv;
      end;
    end;
  end;
end;

procedure TBaseObject.GetAccessory2(StdItem: pTStdItem; var AddAbility: TAddAbility);
var
  boUseItem, bohum, bohum2: Boolean;
  StdItemA: TStdItem;
begin
  if StdItem = nil then  Exit;

  StdItemA := StdItem^;

  bohum := (m_btRaceServer = RC_PLAYOBJECT) or IsHero;
  bohum2 := m_btRaceServer in [RC_PLAYOBJECT, RC_HERO];
  boUseItem := StdItemA.StdMode in [5, 6, 10..13, 15..24, 26..30, 51];

  if boUseItem then
  begin
    if bohum then
    begin
      m_btHitPowerAddOn := _MIN(255, m_btHitPowerAddOn + LoByte(StdItemA.ItemSet));
      TPlayObject(Self).m_nTagDropPlus := _MIN(High(Word), TPlayObject(Self).m_nTagDropPlus + HiByte(StdItemA.ItemSet));
    end;

    if bohum2 then
    begin
      if StdItemA.reserve[0] > 0 then
      begin
        if Integer(m_btIgnoreTagDefence + (StdItemA.reserve[0] div 16)) < 100 then
          m_btIgnoreTagDefence := m_btIgnoreTagDefence + (StdItemA.reserve[0] div 16)
        else
          m_btIgnoreTagDefence := 100;

        if Integer(m_btDamageAddOn + (StdItemA.reserve[0] mod 16)) < 255 then
          m_btDamageAddOn := m_btDamageAddOn + (StdItemA.reserve[0] mod 16)
        else
          m_btDamageAddOn := 255;
      end;

      if StdItemA.reserve[1] > 0 then
      begin
        if Integer(m_btDamageRebound + (StdItemA.reserve[1] div 16)) < 100 then
          m_btDamageRebound := m_btDamageRebound + (StdItemA.reserve[1] div 16)
        else
          m_btDamageRebound := 100;

        if Integer(m_btACDamageReduction + (StdItemA.reserve[1] mod 16)) < 100 then
          m_btACDamageReduction := m_btACDamageReduction + (StdItemA.reserve[1] mod 16)
        else
          m_btACDamageReduction := 100;
      end;

      if StdItemA.reserve[2] > 0 then
      begin
        if Integer(m_btMCDamageReduction + (StdItemA.reserve[2] div 16)) < 100 then
          m_btMCDamageReduction := m_btMCDamageReduction + (StdItemA.reserve[2] div 16)
        else
          m_btMCDamageReduction := 100;

        if Integer(m_btGetExpExRate + (StdItemA.reserve[2] mod 16)) < 100 then
          m_btGetExpExRate := m_btGetExpExRate + (StdItemA.reserve[2] mod 16)
        else
          m_btGetExpExRate := 100;
      end;
    end;
  end;

  AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItemA.AC), HiWord(AddAbility.wAC) + HiWord(StdItemA.AC));
  AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItemA.MAC), HiWord(AddAbility.wMAC) + HiWord(StdItemA.MAC));
  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItemA.DC), HiWord(AddAbility.wDC) + HiWord(StdItemA.DC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItemA.MC), HiWord(AddAbility.wMC) + HiWord(StdItemA.MC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItemA.SC), HiWord(AddAbility.wSC) + HiWord(StdItemA.SC));
end;

function TPlayObject.GetCharColor(BaseObject: TBaseObject): Byte;
var
  n10: Integer;
  Castle: TUserCastle;
  Guild: TGuild;
begin
  Result := BaseObject.GetNamecolor();
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  if m_PEnvir.m_MapFlag.nSecret and $02 <> 0 then
  begin
    Exit;
  end;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or BaseObject.IsHero then
  begin
    if BaseObject.PKLevel < 2 then
    begin
      if BaseObject.m_boPKFlag then
        Result := g_Config.btPKFlagNameColor;
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
      begin
        n10 := GetGuildRelation(Self, BaseObject); //hashed............
        case n10 of
          1, 3: Result := g_Config.btAllyAndGuildNameColor;
          2: Result := g_Config.btWarGuildNameColor;
        end;
        if BaseObject.m_PEnvir.m_MapFlag.boFIGHT3Zone then
        begin
          if m_MyGuild = BaseObject.m_MyGuild then
            Result := g_Config.btAllyAndGuildNameColor
          else
            Result := g_Config.btWarGuildNameColor;
        end;
      end
      else {if BaseObject.IsHero then}
      begin
        n10 := GetGuildRelation(Self, BaseObject.m_Master); //hashed............
        case n10 of
          1, 3: Result := g_Config.btAllyAndGuildNameColor;
          2: Result := g_Config.btWarGuildNameColor;
        end;
        if BaseObject.m_PEnvir.m_MapFlag.boFIGHT3Zone then
        begin
          if m_MyGuild = BaseObject.m_Master.m_MyGuild then
            Result := g_Config.btAllyAndGuildNameColor
          else
            Result := g_Config.btWarGuildNameColor;
        end;
      end;
    end;

    //if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
    if m_boInFreePKArea and BaseObject.m_boInFreePKArea then
    begin
      Castle := g_CastleManager.InCastleWarArea(BaseObject); //ok
      if (Castle <> nil) and Castle.m_boUnderWar then
      begin
        Result := g_Config.btInFreePKAreaNameColor;
        m_boGuildWarArea := True;

        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
          Guild := TGuild(BaseObject.m_MyGuild)
        else
          Guild := TGuild(BaseObject.m_Master.m_MyGuild);

        if (m_MyGuild <> nil) then
        begin
          if Castle.IsMasterGuild(TGuild(m_MyGuild)) then
          begin
            if (m_MyGuild = Guild) or (TGuild(m_MyGuild).IsAllyGuild(TGuild(Guild))) then //hashed...
              Result := g_Config.btAllyAndGuildNameColor
            else if Castle.IsAttackGuild(TGuild(Guild)) then
              Result := g_Config.btWarGuildNameColor;
          end
          else if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
          begin
            if (m_MyGuild = Guild) or (TGuild(m_MyGuild).IsAllyGuild(TGuild(Guild))) then //hashed............
              Result := g_Config.btAllyAndGuildNameColor
            else if Castle.IsMember(BaseObject) then
              Result := g_Config.btWarGuildNameColor;
          end;
        end;
      end;
    end;
    //end;

  end
  else
  begin
    if (m_btRaceServer <> RC_HERO) and (BaseObject.m_btSlaveExpLevel <= SLAVEMAXLEVEL) then
      if BaseObject.m_btSlaveExpLevel > 0 then
        Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel - 1]
      else
        Result := 255;
    if (m_btRaceServer = RC_HERO) then
    begin
      if m_Master <> nil then
        Result := g_Config.nHeroNameColor;
      Exit;
    end;
    if BaseObject.m_boCrazyMode then
      Result := $F9;
    if BaseObject.m_boHolySeize then
      Result := $7D;
    if BaseObject.m_dwFightIPExp > 0 then
      Result := 253;
  end;
end;

function TBaseObject.GetLevelExp(nLevel: Integer): LongWord; //004BEDC8
begin
  if nLevel <= MAXLEVEL then
    Result := g_Config.dwNeedExps[nLevel]
  else
    Result := g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
  if IsHero then
    Result := LongWord(Round(Result / 100 * g_Config.nHeroLevelExpRate));
end;

function TBaseObject.GetNamecolor(): Byte;
begin
  if m_PEnvir.m_MapFlag.nSecret and $02 <> 0 then
  begin
    Result := 255;
    Exit;
  end;
  Result := m_btNameColor;
  if PKLevel = 1 then
    Result := g_Config.btPKLevel1NameColor; //$FB;
  if PKLevel >= 2 then
    Result := g_Config.btPKLevel2NameColor; //$F9;
end;

procedure TBaseObject.HearMsg(sMsg: string);
begin
  if sMsg <> '' then
    SendMsg(nil, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, {MakeWord(m_btChatColor, m_btChatFont)} 0, sMsg);
end;

function TBaseObject.InSafeArea(): Boolean;
var
  i: Integer;
  StartPointInfo: pTStartPointInfo;
begin
  Result := m_PEnvir.m_MapFlag.boSAFE;
  if Result then
    Exit;
  for i := 0 to m_CurSafeZoneList.Count - 1 do
  begin
    StartPointInfo := m_CurSafeZoneList.Items[i];
    if {(m_PEnvir <> nil) and}(StartPointInfo.Envir = m_PEnvir) then
    begin
      if (abs(m_nCurrX - StartPointInfo.nX) <= g_Config.nNonGuildWarZoneSize) and (abs(m_nCurrY - StartPointInfo.nY) <= g_Config.nNonGuildWarZoneSize) then
      begin
        Result := True;
        Break;
      end;
    end;
  end;
end;

procedure TBaseObject.MonsterRecalcAbilitys;
var
  n8: Integer;
begin
  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_Abil.DC));
  n8 := 0;
  if (m_btRaceServer = 99) or (m_btRaceServer = 100) or (m_btRaceServer = 113) or (m_btRaceServer = 114) or (m_btRaceServer in [126..128]) then
  begin
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round((m_btSlaveExpLevel * 0.1 + 0.3) * 3.0 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
    n8 := n8 + Round((m_btSlaveExpLevel * 0.1 + 0.3) * m_Abil.MaxHP) * m_btSlaveExpLevel;
    n8 := n8 + m_Abil.MaxHP;
    if m_btSlaveExpLevel > 0 then
      m_WAbil.MaxHP := n8
    else
      m_WAbil.MaxHP := m_Abil.MaxHP;
  end
  else
  begin
    n8 := m_Abil.MaxHP;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), Round(m_btSlaveExpLevel * 2 + HiWord(m_WAbil.DC)));
    n8 := n8 + Round(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel;
    m_WAbil.MaxHP := _MIN(Round(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
  end;
end;

procedure TPlayObject.ShowMapInfo(sMAP, sX, sY: string);
var
  Map: TEnvirnoment;
  nX, nY: Integer;
  MapCellInfo: pTMapCellinfo;
begin
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  if (sMAP <> '') and (nX >= 0) and (nY >= 0) then
  begin
    Map := g_MapManager.FindMap(sMAP);
    if Map <> nil then
    begin
      if Map.GetMapCellInfo(nX, nY, MapCellInfo) then
      begin
        SysMsg('±êÖ¾: ' + IntToStr(MapCellInfo.chFlag), c_Green, t_Hint);
        if MapCellInfo.ObjList <> nil then
          SysMsg('¶ÔÏóÊý: ' + IntToStr(MapCellInfo.ObjList.Count), c_Green, t_Hint);
      end
      else
        SysMsg('È¡µØÍ¼µ¥ÔªÐÅÏ¢Ê§°Ü: ' + sMAP, c_Red, t_Hint);
    end;
  end
  else
    SysMsg('Çë°´ÕýÈ·¸ñÊ½ÊäÈë: ' + g_GameCommand.MAPINFO.sCmd + ' µØÍ¼ºÅ X Y', c_Green, t_Hint);
end;

procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word);
var
  SendMessage: pTSendMessage;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := False;
      SendMessage.nMagicID := nMagID;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.buff^, Length(sMsg) + 1);
        except
          SendMessage.buff := nil;
        end;
      end
      else
        SendMessage.buff := nil;
      m_MsgList.Insert(0, SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string; nMagID: Word);
var
  SendMessage: pTSendMessage;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := nParam1;
      SendMessage.nParam2 := nParam2;
      SendMessage.nParam3 := nParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := False;
      SendMessage.nMagicID := nMagID;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.buff^, Length(sMsg) + 1);
        except
          SendMessage.buff := nil;
        end;
      end
      else
        SendMessage.buff := nil;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord; nMagID: Word);
var
  SendMessage: pTSendMessage;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := GetTickCount + dwDelay;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := True;
      SendMessage.nMagicID := nMagID;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.buff^, Length(sMsg) + 1);
        except
          SendMessage.buff := nil;
        end;
      end
      else
        SendMessage.buff := nil;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord); //004B8930
var
  SendMessage: pTSendMessage;
  i: Integer;
begin

  if gdeny then
  begin
    Exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        Break;
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1) then
      begin
        m_MsgList.Delete(i);
        if SendMessage.buff <> nil then
        begin
          FreeMem(SendMessage.buff);
          SendMessage.buff := nil;
        end;
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendDelayMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, dwDelay);
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word);
var
  SendMessage: pTSendMessage;
  i: Integer;
begin

  if gdeny then
  begin
    Exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        Break;
      SendMessage := m_MsgList.Items[i];
      if SendMessage.wIdent = wIdent then
      begin
        m_MsgList.Delete(i);
        if SendMessage.buff <> nil then
        begin
          FreeMem(SendMessage.buff);
          SendMessage.buff := nil;
        end;
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, nMagID);
end;

procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string; nMagID: Word);
var
  SendMessage: pTSendMessage;
  i: Integer;
begin

  if gdeny then
  begin
    Exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        Break;
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_TURN) or
        (SendMessage.wIdent = CM_WALK) or
        (SendMessage.wIdent = CM_SITDOWN) or
        (SendMessage.wIdent = CM_HORSERUN) or
        (SendMessage.wIdent = CM_RUN) or
        (SendMessage.wIdent = CM_HIT) or
        (SendMessage.wIdent = CM_HEAVYHIT) or
        (SendMessage.wIdent = CM_BIGHIT) or
        (SendMessage.wIdent = CM_POWERHIT) or
        (SendMessage.wIdent = CM_LONGHIT) or
        (SendMessage.wIdent = CM_WIDEHIT) or
        (SendMessage.wIdent = CM_FIREHIT) or
        (SendMessage.wIdent = CM_HERO_LONGHIT2) or
        (SendMessage.wIdent = CM_SQUHIT) or
        (SendMessage.wIdent = CM_PURSUEHIT) then
      begin
        m_MsgList.Delete(i);
        if SendMessage.buff <> nil then
        begin
          FreeMem(SendMessage.buff);
          SendMessage.buff := nil;
        end;
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, nMagID);
end;

function TBaseObject.GetMessage(Msg: pTProcessMessage): Boolean;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    Msg.wIdent := 0;
    while m_MsgList.Count > i do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount < SendMessage.dwDeliveryTime) then
      begin
        Inc(i);
        Continue;
      end;
      m_MsgList.Delete(i);
      Msg.wIdent := SendMessage.wIdent;
      Msg.wParam := SendMessage.wParam;
      Msg.nParam1 := SendMessage.nParam1;
      Msg.nParam2 := SendMessage.nParam2;
      Msg.nParam3 := SendMessage.nParam3;
      Msg.BaseObject := SendMessage.BaseObject;
      Msg.dwDeliveryTime := SendMessage.dwDeliveryTime;
      Msg.boLateDelivery := SendMessage.boLateDelivery;
      Msg.nMagicID := SendMessage.nMagicID;
      //Move(SendMessage^, Msg^, SizeOf(TProcessMessage) - 4);
      if SendMessage.buff <> nil then
      begin
        Msg.sMsg := StrPas(SendMessage.buff);
        FreeMem(SendMessage.buff);
        SendMessage.buff := nil;
      end
      else
        Msg.sMsg := '';
      Dispose(SendMessage);
      Result := True;
      Break;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TBaseObject.GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY, nRage: Integer; rList: TList): Boolean; //004B8D2C
var
  III: Integer;
  x, y: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  //pListNode                 : PTWHNode;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::GetMapBaseObjects';
begin
  Result := False;
  if rList = nil then
    Exit;
  try
    nStartX := nX - nRage;
    nEndX := nX + nRage;
    nStartY := nY - nRage;
    nEndY := nY + nRage;
    for x := nStartX to nEndX do
    begin
      for y := nStartY to nEndY do
      begin
        if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} then
        begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do
          begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
            begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then
                rList.Add(BaseObject);
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
  Result := True;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: string);
var
  ii, nC: Integer;
  nCX, nCY: Integer;
  nLX, nLY, nHX, nHY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::SendRefMsg Name = %s';
begin
  if m_PEnvir = nil then
  begin
    MainOutMessageAPI(m_sCharName + ' SendRefMsg nil PEnvir');
    Exit;
  end;
  if (m_boObMode or m_boFixedHideMode) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
    Exit;
  end;

  //EnterCriticalSection(ProcessMsgCriticalSection); //0409
  //try
  if (m_VisibleHumanList.Count = 0) or (GetTickCount - m_SendRefMsgTick >= 500) then
  begin
    m_SendRefMsgTick := GetTickCount();
    if m_VisibleHumanList.Count > 0 then
      m_VisibleHumanList.Clear;

    nLX := _MAX(0, m_nCurrX - 26);
    nHX := _MIN(m_PEnvir.m_MapHeader.wWidth, m_nCurrX + 26);
    nLY := _MAX(0, m_nCurrY - 26);
    nHY := _MIN(m_PEnvir.m_MapHeader.wHeight, m_nCurrY + 26);

    for nCX := nLX to nHX do
    begin
      for nCY := nLY to nHY do
      begin
        if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} then
        begin
          if MapCellInfo.ObjList <> nil then
          begin
            try
              for ii := MapCellInfo.ObjList.Count - 1 downto 0 do
              begin
                OSObject := MapCellInfo.ObjList.Items[ii];
                if OSObject <> nil then
                begin
                  if OSObject.btType = OS_MOVINGOBJECT then
                  begin
                    if (GetTickCount - OSObject.dwAddTime) >= RELEASE_MAPOBJECT_TIME then
                    begin
                      Dispose(OSObject);
                      MapCellInfo.ObjList.Delete(ii);
                      if MapCellInfo.ObjList.Count > 0 then
                        Continue;
                      MapCellInfo.ObjList.Free;
                      MapCellInfo.ObjList := nil;
                      Break;
                    end;
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and not BaseObject.m_boGhost then
                    begin
                      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                      begin
                        if (abs(BaseObject.m_nCurrX - m_nCurrX) <= BaseObject.m_nViewRangeX) and
                          (abs(BaseObject.m_nCurrY - m_nCurrY) <= BaseObject.m_nViewRangeY) then
                        begin
                          BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                          m_VisibleHumanList.Add(BaseObject);
                        end;
                      end
                      else if BaseObject.m_boWantRefMsg and ((wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH)) then
                      begin
                        if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 12) and
                          (abs(BaseObject.m_nCurrY - m_nCurrY) <= 12) then
                        begin
                          BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
                          m_VisibleHumanList.Add(BaseObject);
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            except
              on E: Exception do
              begin
                MapCellInfo.ObjList.Delete(ii);
                if MapCellInfo.ObjList.Count <= 0 then
                begin
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                end;
                MainOutMessageAPI(Format(sExceptionMsg, [m_sCharName]));
                MainOutMessageAPI(E.Message);
              end;
            end;
          end;
        end;
      end;
    end;
    Exit;
  end;

  for nC := 0 to m_VisibleHumanList.Count - 1 do
  begin
    BaseObject := TBaseObject(m_VisibleHumanList.Items[nC]);
    if BaseObject.m_boGhost then
      Continue; //0412
    if (BaseObject.m_PEnvir = m_PEnvir) then
    begin
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
      begin
        if (abs(BaseObject.m_nCurrX - m_nCurrX) <= BaseObject.m_nViewRangeX) and
          (abs(BaseObject.m_nCurrY - m_nCurrY) <= BaseObject.m_nViewRangeY) then
        begin
          BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
        end;
      end
      else if BaseObject.m_boWantRefMsg and ((wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH)) then
      begin
        if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 12) and
          (abs(BaseObject.m_nCurrY - m_nCurrY) <= 12) then
        begin
          BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
        end;
      end;
    end;
  end;

  {finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;}
end;

procedure TBaseObject.UpdateVisibleGay(BaseObject: TBaseObject);
var
  i: Integer;
  boIsVisible: Boolean;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  boIsVisible := False;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HERO) or (BaseObject.m_Master <> nil) then
    m_boIsVisibleActive := True;

  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    VisibleBaseObject := m_VisibleActors.Items[i];
    if VisibleBaseObject.BaseObject = BaseObject then
    begin
      VisibleBaseObject.nVisibleFlag := 1;
      Exit;
    end;
  end;
  if boIsVisible then
    Exit;
  New(VisibleBaseObject);
  VisibleBaseObject.nVisibleFlag := 2;
  VisibleBaseObject.BaseObject := BaseObject;
  m_VisibleActors.Add(VisibleBaseObject);
end;

function  TBaseObject.FindItemInUnreseachable(VisibleMapItem: pTVisibleMapItem): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to m_UnreachableItemList.Count - 1 do
  begin
    if pTVisibleMapItem(m_UnreachableItemList[I]) = nil then continue ;
    if pTVisibleMapItem(m_UnreachableItemList[I]).MapItem = nil then continue;
    if pTuserItem (@pTVisibleMapItem(m_UnreachableItemList[I]).MapItem.UserItem) = nil then continue;
    if pTVisibleMapItem(m_UnreachableItemList[I]) = VisibleMapItem then
    begin
      Result := True;
      Exit;
    end;
  end;
end;

procedure TBaseObject.AddUnreachableItem(VisibleMapItem: pTVisibleMapItem);
begin
  if not FindItemInUnreseachable(VisibleMapItem) then
    m_UnreachableItemList.Add(VisibleMapItem);
end;

procedure TBaseObject.ClearUnreachableItemList();
begin
 m_UnreachableItemList.Clear;
end;

procedure TPlayObject.SendTestUrl();
begin

{$I '..\Common\Macros\VMPB.inc'}
  SendDefMessage(SM_TEXTURL, 0, 0, 0, TEST_PORT, EncodeString(VMProtectDecryptStringA(TEST_URL)));
{$I '..\Common\Macros\VMPE.inc'}
//    OutputDebugString('SendTestUrl');
end;

procedure TPlayObject.SendQueryVersion();
var Cmd: TDefaultMessage;
  msgstr: string;
begin
{$I '..\Common\Macros\VMPB.inc'}
  Cmd := MakeDefaultMsg(SM_CHECKVER, 0, 0, 0, M2_VERSION);
  msgstr := EncodeMessage(Cmd);
  msgstr := '#' + msgstr + '!';
  SendDefMessage(SM_PROXYDATA, 0, 0, 0, 0, msgstr);
  dwLastCheck := GetTickCount;
{$I '..\Common\Macros\VMPE.inc'}
end;

procedure TPlayObject.UpdateViewRange();
var
  Interval: Integer;
begin
  if (m_btRaceServer <> RC_PLAYOBJECT) or m_boOffLinePlay then
    Exit;

  if (m_nViewRangeX <= 12) or (m_nViewRangeY <= 12) then
    Exit;

  Interval := GetTickCount - m_dwSearchTick;
  if Interval < 400 then
    Exit;

  m_dwSearchTick := 0;

end;

procedure TPlayObject.UpdateVisibleItem(wX, wY: Integer; MapItem: pTMapItem);
var
  i: Integer;
  boIsVisible: Boolean;
  VisibleMapItem: pTVisibleMapItem;
begin
  boIsVisible := False;
  for i := 0 to m_VisibleItems.Count - 1 do
  begin
    VisibleMapItem := m_VisibleItems.Items[i];
    if VisibleMapItem.MapItem = MapItem then
    begin
      VisibleMapItem.nVisibleFlag := 1;
      Exit;
    end;
  end;
  if boIsVisible then
    Exit;
  New(VisibleMapItem);
  VisibleMapItem.nVisibleFlag := 2;
  VisibleMapItem.nX := wX;
  VisibleMapItem.nY := wY;
  VisibleMapItem.MapItem := MapItem;
  VisibleMapItem.sName := MapItem.Name;
  VisibleMapItem.wLooks := MapItem.Looks;
  m_VisibleItems.Add(VisibleMapItem);
end;

procedure TPlayObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
var
  i: Integer;
  boIsVisible: Boolean;
{$IF NewVisibleEvent = 1}
  VisibleEvent: pTVisibleEvent;
{$ELSE}
  Event: TEvent;
{$IFEND}
begin
  boIsVisible := False;
{$IF NewVisibleEvent = 1}
  for i := 0 to m_VisibleEvents.Count - 1 do
  begin
    VisibleEvent := m_VisibleEvents[i];
    if VisibleEvent.Event = MapEvent then
    begin
      VisibleEvent.nVisibleFlag := 1;
      boIsVisible := True;
      Exit;
    end;
  end;
  if boIsVisible then
    Exit;
  New(VisibleEvent);
  VisibleEvent.nX := wX;
  VisibleEvent.nY := wY;
  VisibleEvent.nVisibleFlag := 2;
  VisibleEvent.nEventType := TEvent(MapEvent).m_nEventType;
  VisibleEvent.nEventParam := TEvent(MapEvent).m_nEventParam;
  VisibleEvent.Event := MapEvent;
  m_VisibleEvents.Add(VisibleEvent);
{$ELSE}
  for i := 0 to m_VisibleEvents.Count - 1 do
  begin
    Event := m_VisibleEvents.Items[i];
    if Event = MapEvent then
    begin
      Event.m_nVisibleFlag := 1;
      boIsVisible := True;
      Break;
    end;
  end;
  if boIsVisible then
    Exit;
  TEvent(MapEvent).m_nVisibleFlag := 2;
  TEvent(MapEvent).m_nX := wX;
  TEvent(MapEvent).m_nY := wY;
  m_VisibleEvents.Add(MapEvent);
{$IFEND}
end;

function TBaseObject.IsVisibleHuman: Boolean;
var
  i: Integer;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  Result := False;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    VisibleBaseObject := m_VisibleActors.Items[i];
    if (VisibleBaseObject.BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (VisibleBaseObject.BaseObject.m_Master <> nil) then
    begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TBaseObject.SearchViewRange();
var
  i: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  n24: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  VisibleBaseObject: pTVisibleBaseObject;
  nCheckCode: Integer;
  //dwGoOutTick               : LongWord;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::SearchViewRange Code:%d';
  sExceptionMsg2 = '[Exception] TBaseObject::SearchViewRange 1-%d %s %s %d %d %d';
begin

  if m_PEnvir = nil then
  begin
    MainOutMessageAPI('TBaseObject::SearchViewRange nil PEnvir');
    MainOutMessageAPI(Self.m_sCharName + '--------------'+ Self.m_sMapName);
    Exit;
  end;

  nCheckCode := 0;
  n24 := 0;
  m_boIsVisibleActive := False;
  try
    for i := 0 to m_VisibleActors.Count - 1 do
      pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleFlag := 0;
  except
    MainOutMessageAPI(Format(sExceptionMsg1, [nCheckCode]));
    KickException();
  end;

  nStartX := m_nCurrX - m_nViewRangeX;
  nEndX := m_nCurrX + m_nViewRangeX;
  nStartY := m_nCurrY - m_nViewRangeY;
  nEndY := m_nCurrY + m_nViewRangeY;
  try
    for n18 := nStartX to nEndX do
    begin
      for n1C := nStartY to nEndY do
      begin
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} and (MapCellInfo.ObjList <> nil) then
        begin
          n24 := 1;
          nIdx := 0;
          while (True) do
          begin
            if (MapCellInfo.ObjList.Count <= nIdx) then
              Break;
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            if OSObject <> nil then
            begin
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                if (GetTickCount - OSObject.dwAddTime) >= RELEASE_MAPOBJECT_TIME then
                begin
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx);
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  Break;
                end;
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) and not BaseObject.m_boDeath and not BaseObject.m_boInvisible then
                begin //0901
                  if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode then
                  begin
                    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
                      (m_btRaceServer < RC_ANIMAL) or
                      (m_Master <> nil) or
                      m_boCrazyMode or
                      m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) then
                    begin
                      nCheckCode := 18;
                      UpdateVisibleGay(BaseObject);
                    end;
                  end;
                end;
              end;

              //0618
              if (OSObject.btType = OS_ITEMOBJECT) and not m_boDeath and (m_btRaceServer > RC_MONSTER) then
              begin
                if (GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime then
                begin
                  Dispose(pTMapItem(OSObject.CellObj));
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx); //1219
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  Break;
                end;
              end;
            end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;

  nCheckCode := 40;
  n24 := 2;
  try
    n18 := 0;
    while (True) do
    begin
      if m_VisibleActors.Count <= n18 then
        Break;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      if VisibleBaseObject.nVisibleFlag = 0 then
      begin
        m_VisibleActors.Delete(n18);
        Dispose(VisibleBaseObject);
        Continue;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;
end;

procedure TBaseObject.SearchViewRange_Death();
var
  i: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  n24: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  VisibleBaseObject: pTVisibleBaseObject;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::SearchViewRange_Death Code:%d';
  sExceptionMsg2 = '[Exception] TBaseObject::SearchViewRange_Death 1-%d %s %s %d %d %d';
begin

  if m_PEnvir = nil then
  begin
    MainOutMessageAPI('TBaseObject::SearchViewRange_Death nil PEnvir');
    Exit;
  end;

  nCheckCode := 0;
  n24 := 0;
  m_boIsVisibleActive := False;

  for i := 0 to m_VisibleActors.Count - 1 do
    pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleFlag := 0;

  nStartX := m_nCurrX - m_nViewRangeX;
  nEndX := m_nCurrX + m_nViewRangeX;
  nStartY := m_nCurrY - m_nViewRangeY;
  nEndY := m_nCurrY + m_nViewRangeY;
  try
    for n18 := nStartX to nEndX do
    begin
      for n1C := nStartY to nEndY do
      begin
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} and (MapCellInfo.ObjList <> nil) then
        begin
          n24 := 1;
          nIdx := 0;
          while (True) do
          begin
            if (MapCellInfo.ObjList.Count <= nIdx) then
              Break;
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            if OSObject <> nil then
            begin
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                if (GetTickCount - OSObject.dwAddTime) >= RELEASE_MAPOBJECT_TIME then
                begin
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx);
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  Break;
                end;
              end;

              //0618
              if (OSObject.btType = OS_ITEMOBJECT) and not m_boDeath and (m_btRaceServer > RC_MONSTER) then
              begin
                if (GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime then
                begin
                  Dispose(pTMapItem(OSObject.CellObj));
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx); //1219
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  Break;
                end;
              end;
            end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;

  nCheckCode := 40;
  n24 := 2;
  try
    n18 := 0;
    while (True) do
    begin
      if m_VisibleActors.Count <= n18 then
        Break;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      if VisibleBaseObject.nVisibleFlag = 0 then
      begin
        m_VisibleActors.Delete(n18);
        Dispose(VisibleBaseObject);
        Continue;
      end;
      Inc(n18);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;
end;

function TBaseObject.GetFeatureToLong(Buffer: PByte): Integer;
begin
  Result := GetFeature(nil, Buffer);
end;

function TBaseObject.GetFeatureEx(): Word;
begin
  if m_PEnvir.m_MapFlag.nSecret and $10 <> 0 then
  begin
    Result := 0;
    Exit;
  end;
  {if m_boOnHorse then begin
    if m_btWeaponSkill > 0 then
      Result := MakeWord(m_btHorseType + m_btWeaponSkill * 51, m_btDressEffType)
    else
      Result := MakeWord(m_btHorseType, m_btDressEffType)
  end else begin}

  Result := MakeWord(m_btWeaponEffect, m_btDressEffType)
    //end;
end;

function TBaseObject.GetFeature(BaseObject: TBaseObject; Buffer: pByte): Integer;
var
  nDress, nWeapon, nHair, nRaceImg, nAppr: Integer;
  StdItem: pTStdItem;
  //temp: pByte;
  ptemphum: pThumFeature;
  ptempMon: pTMonFeature;
begin
  if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
  begin
    if m_PEnvir.m_MapFlag.nSecret and $10 <> 0 then
    begin
      nDress := m_PEnvir.m_MapFlag.nSecretClothShape * 2;
      Inc(nDress, m_btGender);

      nWeapon := m_PEnvir.m_MapFlag.nSecretWeaponShape * 2;
      Inc(nWeapon, m_btGender);
      nHair := {m_btHair} 1 * 2 + m_btGender;
      // Result := MakeHumanFeature(0, nDress, nWeapon, nHair);
      ptemphum := pThumFeature(Buffer);
      ptemphum.RaceImg := 0;
      ptemphum.Weapon := nWeapon;
      ptemphum.Dress := nDress;
      ptemphum.Hair := nHair;
      Result := SizeOf(ThumFeature);
      Exit;
    end;

    nDress := 0;
    if m_boShowFashion and (m_UseItems[U_FASHION].wIndex > 0) then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_FASHION].wIndex);
      if StdItem <> nil then
        nDress := StdItem.Shape * 2;
    end
    else if m_UseItems[U_DRESS].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
      if StdItem <> nil then
        nDress := StdItem.Shape * 2;
    end;
    Inc(nDress, m_btGender);

    nWeapon := 0;
    if m_UseItems[U_WEAPON].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if StdItem <> nil then
        nWeapon := StdItem.Shape * 2;
    end;
    Inc(nWeapon, m_btGender);
    nHair := m_btHairEx * 10 + m_btHair * 2 + m_btGender;
    // Result := MakeHumanFeature(0, nDress, nWeapon, nHair);
    ptemphum := pThumFeature(Buffer);
    ptemphum.RaceImg := 0;
    ptemphum.Weapon := nWeapon;
    ptemphum.Dress := nDress;
    ptemphum.Hair := nHair;
    Result := SizeOf(ThumFeature);
    Exit;
  end;

  if (BaseObject <> nil) and (BaseObject.m_boRaceImg) then
  begin
    nRaceImg := m_btRaceImg;
    nAppr := m_wAppr;
    case nAppr of
      0:
        begin
          nRaceImg := 12;
          nAppr := 5;
        end;
      1:
        begin
          nRaceImg := 11;
          nAppr := 9;
        end;
      160:
        begin
          nRaceImg := 10;
          nAppr := 0;
        end;
      161:
        begin
          nRaceImg := 10;
          nAppr := 1;
        end;
      162:
        begin
          nRaceImg := 11;
          nAppr := 6;
        end;
      163:
        begin
          nRaceImg := 11;
          nAppr := 3;
        end;
    end;
    // Result := MakeMonsterFeature(nRaceImg, m_btMonsterWeapon, nAppr);
    ptempMon := pTMonFeature(Buffer);
    ptempMon.RaceImg := nRaceImg;
    ptempMon.Weapon := m_btMonsterWeapon;
    ptempMon.wAppr := nAppr;
    Result := SizeOf(TMonFeature);
    Exit;
  end;
  //Result := MakeMonsterFeature(m_btRaceImg, m_btMonsterWeapon, m_wAppr);
  ptempMon := pTMonFeature(Buffer);
  ptempMon.RaceImg := m_btRaceImg;
  ptempMon.Weapon := m_btMonsterWeapon;
  ptempMon.wAppr := m_wAppr;
  Result := SizeOf(TMonFeature);
end;

function TBaseObject.GetCharStatus(): Integer;
var
  i: Integer;
  nStatus: Integer;
begin
  nStatus := 0;
  for i := Low(TStatusTime) to High(TStatusTime) do
  begin
    if m_wStatusTimeArr[i] > 0 then
      nStatus := ($80000000 shr i) or nStatus;
  end;

  if nStatus and $00100000 <> 0 then
  begin //Ä§·¨¶Ü
    if (m_MagicArr[0][31] <> nil) and (m_MagicArr[0][31].btLevel >= 4) then
      nStatus := ($80000000 shr STATE_12) or nStatus;
  end;

  for i := Low(m_wStatusTimeArrEx) to High(m_wStatusTimeArrEx) do
  begin
    if m_wStatusTimeArrEx[i] > 0 then
      nStatus := ($80000000 shr i) or nStatus;
  end;

  //nStatus := ($80000000 shr i) or nStatus;

  Result := (m_nCharStatusEx {and $FFFFF}) or nStatus;
end;

procedure TBaseObject.AbilCopyToWAbil;
begin
  m_WAbil := m_Abil;
end;

procedure TBaseObject.Initialize;
var
  i: Integer;
  UserMagic: pTUserMagic;
  Magic: pTMagic;
begin
  AbilCopyToWAbil();

  if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
  begin
    m_boHaveMag := False;
    FillChar(m_MagicArr, SizeOf(TMagicArr), #0);
    for i := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      m_MagicArr[UserMagic.MagicInfo.btClass][UserMagic.wMagIdx] := UserMagic;
      if UserMagic.btLevel > 15 then
        UserMagic.btLevel := 15;
      if m_btRaceServer = RC_HERO then
        case m_btJob of
          0: if not m_boHaveMag then
              m_boHaveMag := True;
          1: if not m_boHaveMag and (UserMagic.MagicInfo.btJob = 1) and (UserMagic.MagicInfo.btClass = 0)
            and not (UserMagic.wMagIdx in [8, 20, 21, 31]) then
              m_boHaveMag := True;
          2: if not m_boHaveMag and (UserMagic.MagicInfo.btJob = 2) and (UserMagic.MagicInfo.btClass = 0)
            and not (UserMagic.wMagIdx in [2, 4, 14, 15, 17, 29, 30, 34, 55]) then
              m_boHaveMag := True;
        end;
    end;
  end;

  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if m_MagicArr[0][67] = nil then
    begin
      Magic := UserEngine.FindMagic(67, 0);
      if Magic <> nil then
      begin
        New(UserMagic);
        UserMagic.MagicInfo := Magic;
        UserMagic.wMagIdx := Magic.wMagicId;
        UserMagic.btKey := 0;
        UserMagic.btLevel := 0;
        UserMagic.nTranPoint := 0;
        m_MagicList.Add(UserMagic);
        //SendAddMagic(UserMagic);
        //RecalcAbilitys();
      end;
    end;
  end;

  m_boErrorOnInit := True;
  if m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, True) and AddToMap() then
    m_boErrorOnInit := False; //??? reverse

  m_nCharStatus := GetCharStatus();
  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_HERO) then
    LoadSayMsg();

  if g_Config.boMonSayMsg then
    MonsterSayMsg(nil, s_MonGen);

  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    m_dwWalkWait := 0;
    m_nWalkStep := 1;
    case m_btJob of
      0:
        begin
          m_nNextHitTime := 900;
          m_nWalkSpeed := 570;
        end;
      1:
        begin
          m_nNextHitTime := 1250;
          m_nWalkSpeed := 570;
        end;
      2:
        begin
          m_nNextHitTime := 1250;
          m_nWalkSpeed := 570;
        end;
    end;
    m_nNonFrzWalkSpeed := m_nWalkSpeed;
    m_nNonFrzNextHitTime := m_nNextHitTime;
  end;
end;

procedure TBaseObject.LoadSayMsg();
var
  i: Integer;
begin
  i := g_MonSayMsgList.IndexOf(m_sCharName);
  if i > -1 then
    m_SayMsgList := TList(g_MonSayMsgList.Objects[i]);
  {for i := 0 to g_MonSayMsgList.Count - 1 do begin
    if CompareText(g_MonSayMsgList.Strings[i], m_sCharName) = 0 then begin
      m_SayMsgList := TList(g_MonSayMsgList.Objects[i]);
      Break;
    end;
  end;}
end;

procedure TBaseObject.Disappear();
begin
  //
end;

procedure TBaseObject.FeatureChanged; //004BA58C
var
  Buffer: array[0..255] of Byte;
  FeatureMsg:  string;
  Len: Integer;
begin
  Len := GetFeatureToLong(@Buffer[0]);
  SetLength(FeatureMsg, Len);
  Move(Buffer[0], FeatureMsg[1], Len);
  SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, 0, 0, 0, EncodeBuffer(@FeatureMsg[1], Len));
end;

procedure TBaseObject.StatusChanged(const sEx: string);
begin
  SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, sEx);
end;

function TBaseObject.GetApprStatus(): Word;
begin
  Result := 0;
  //if m_dwSkill77 > 0 then Result := Result or $01;
  //if m_bo70Skill then Result := Result or $02;
  //if m_wSuperSkill > 0 then Result := Result or $04;
end;

procedure TBaseObject.StatusExChanged();
var
  nTime: Integer;
begin
  //
  nTime := 0;
  m_wApprStatus := GetApprStatus();
  SendRefMsg(RM_APPRCHANGED, m_wApprStatus, nTime, 0, 0, '');
end;

procedure TBaseObject.DisappearA(bt: Byte);
begin
  m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  if (m_Master <> nil) or (bt <> 0) then
    SendRefMsg(RM_DISAPPEAR, 1, 0, 0, 0, '')
  else
    SendRefMsg(RM_DISAPPEAR, bt, 0, 0, 0, '');
end;

procedure TBaseObject.KickException();
var
  PlayObject: TPlayObject;
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    m_sMapName := g_Config.sHomeMap;
    m_nCurrX := g_Config.nHomeX;
    m_nCurrY := g_Config.nHomeY;
    PlayObject := TPlayObject(Self);
    PlayObject.m_boEmergencyClose := True;
  end
  else
  begin
    m_boDeath := True;
    m_dwDeathTick := GetTickCount;
    MakeGhost;
  end;
end;

function TBaseObject.Walk(nIdent: Integer): Boolean;
var
  i: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  GateObj: pTGateObj;
  Event: TEvent;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
  Buffer: array[0..255] of Byte;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Walk Code:%d %s %s %d:%d';
begin
  Result := True;
  nCheckCode := 0;
  if m_PEnvir = nil then
  begin
    MainOutMessageAPI('Walk nil PEnvir');
    Exit;
  end;
  try
    Event := nil;
    GateObj := nil;
    nCheckCode := 2;
    if m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then
    begin
      for i := 0 to MapCellInfo.ObjList.Count - 1 do
      begin
        OSObject := MapCellInfo.ObjList[i];
        if OSObject <> nil then
        begin
          nCheckCode := 3;
          if OSObject.btType = OS_GATEOBJECT then
          begin
            GateObj := pTGateObj(OSObject.CellObj);
          end;
          if OSObject.btType = OS_EVENTOBJECT then
          begin
            if TEvent(OSObject.CellObj).m_Owner <> nil then //TEvent(OSObject.CellObj).IsWork
              Event := TEvent(OSObject.CellObj);
          end;
        end;
      end;
    end;

    nCheckCode := 5;
    if Event <> nil then
    begin
      if Event.m_Owner.IsProperTarget(Self) then
      begin
        nCheckCode := 6;
        SendMsg(Event.m_Owner, RM_MAGSTRUCK_MINE, 0, Event.m_nDamage, 0, 0, '', SKILL_EARTHFIRE);
      end;
    end;

    nCheckCode := 7;
    if Result and (GateObj <> nil) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        nCheckCode := 8;
        if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) then
        begin
          nCheckCode := 9;
          if (not TEnvirnoment(GateObj.DEnvir).m_MapFlag.boNEEDHOLE) or (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIGOUTZOMBI) <> nil) then
          begin
            nCheckCode := 10;
            if g_nServerIndex = TEnvirnoment(GateObj.DEnvir).m_nServerIndex then
            begin
              nCheckCode := 11;
              if not TPlayObject(Self).EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX, GateObj.nDMapY) then
                Result := False;
            end
            else
            begin
              nCheckCode := 12;
              PlayObject := TPlayObject(Self);
              if GetTickCount - PlayObject.m_dwLatestDropTime > 1000 then
              begin //·À¸´ÖÆ
                nCheckCode := 13;
                DisappearA();
                m_boHealthCrc := True;
                PlayObject.m_sSwitchMapName := TEnvirnoment(GateObj.DEnvir).m_sMapFileName;
                PlayObject.m_nSwitchMapX := GateObj.nDMapX;
                PlayObject.m_nSwitchMapY := GateObj.nDMapY;
                PlayObject.m_nServerIndex := TEnvirnoment(GateObj.DEnvir).m_nServerIndex;
                PlayObject.m_boSwitchData := True;
                PlayObject.m_boEmergencyClose := True;
                PlayObject.m_boReconnection := True;
              end
              else
                Result := False;
            end;
          end;
        end;
      end
      else
        Result := False;
    end
    else if Result then
    begin
      if nIdent = RM_TURN then
        SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, GetFeatureToLong(@Buffer[0]), '')
      else
        SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [nCheckCode, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean; //004BAADC
var
  i, nrX, nrY: Integer;
  MapCellInfo: pTMapCellinfo;
  OldEnvir: TEnvirnoment;
  nOldX: Integer;
  nOldY: Integer;
  Castle: TUserCastle;
  Buffer: array[0..255] of Byte;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::EnterAnotherMap -> VisibleHumanList Clear';
  sExceptionMsg2 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7 = '[Exception] TBaseObject::EnterAnotherMap';
begin
  Result := False;
  if m_Abil.Level < Envir.m_MapFlag.nL {m_nRequestLevel} then
  begin
    SysMsg(Format('ÐèÒª %d ¼¶ÒÔÉÏ²ÅÄÜ½øÈë %s', [Envir.m_MapFlag.nL - 1, Envir.m_sMapDesc]), c_Red, t_Hint);
    Exit; //0628
  end;

  if Envir.m_QuestNPC <> nil then
    TMerchant(Envir.m_QuestNPC).Click(TPlayObject(Self));

  if Envir.m_MapFlag.nNEEDSETONFlag >= 0 then
    if GetQuestFalgStatus(Envir.m_MapFlag.nNEEDSETONFlag) <> Envir.m_MapFlag.nNeedONOFF then
      Exit;

  if not Envir.GetMapCellInfo(nDMapX, nDMapY, MapCellInfo) then
    Exit;

  Castle := g_CastleManager.IsCastlePalaceEnvir(Envir);
  if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
    if not Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
      Exit;

  OldEnvir := m_PEnvir;
  nOldX := m_nCurrX;
  nOldY := m_nCurrY;
  DisappearA();

  try
    m_VisibleHumanList.Clear;
  except
    MainOutMessageAPI(sExceptionMsg1);
  end;

  try
    for i := 0 to m_VisibleItems.Count - 1 do
      Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
  except
    MainOutMessageAPI(sExceptionMsg2);
  end;
  try
    m_VisibleItems.Clear;
  except
    MainOutMessageAPI(sExceptionMsg3);
  end;

  try
{$IF NewVisibleEvent = 1}
    for i := 0 to m_VisibleEvents.Count - 1 do
      Dispose(pTVisibleEvent(m_VisibleEvents[i]));
{$IFEND}
    m_VisibleEvents.Clear;
  except
    MainOutMessageAPI(sExceptionMsg4);
  end;

  try
    for i := 0 to m_VisibleActors.Count - 1 do
      Dispose(pTVisibleBaseObject(m_VisibleActors[i]));
  except
    MainOutMessageAPI(sExceptionMsg5);
  end;
  try
    m_VisibleActors.Clear;
  except
    MainOutMessageAPI(sExceptionMsg6);
  end;

  try
    SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
    m_PEnvir := Envir;
    m_sMapName := Envir.m_sMapFileName;
    //m_sMapFileName := Envir.m_sSendMapName;
    m_nCurrX := nDMapX;
    m_nCurrY := nDMapY;
    SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, Envir.m_sClientMapName);
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    if AddToMap() then
    begin
      m_dwMapMoveTick := GetTickCount();
      m_boHealthCrc := True;
      Result := True;

      if (m_Escort <> nil) and not m_Escort.m_boGhost and not m_Escort.m_boDeath then
      begin
        if (OldEnvir = m_Escort.m_PEnvir) and ((abs(nOldX - m_Escort.m_nCurrX) <= 8) and (abs(nOldY - m_Escort.m_nCurrY) <= 8)) then
        begin
          //if Envir.CanWalk(nX, nY, True) then
          if GetRecallXY(m_nCurrX, m_nCurrY, 3, nrX, nrY) then
          begin
            //if (m_PEnvir <> nil) and m_PEnvir.CanWalk(nX, nY, True) then begin
            m_Escort.m_PEnvir.DeleteFromMap(m_Escort.m_nCurrX, m_Escort.m_nCurrY, OS_MOVINGOBJECT, m_Escort);
            m_Escort.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
            m_Escort.m_nCurrX := nrX;
            m_Escort.m_nCurrY := nrY;
            m_Escort.m_PEnvir := Envir;
            m_Escort.m_PEnvir.AddToMap(m_Escort.m_nCurrX, m_Escort.m_nCurrY, OS_MOVINGOBJECT, m_Escort);
            m_Escort.m_Master := Self;
            m_Escort.OnEnvirnomentChanged();
            m_Escort.SendRefMsg(RM_DIGUP, m_Escort.m_btDirection, m_Escort.m_nCurrX, m_Escort.m_nCurrY, 0, '');
            m_Escort.SendRefMsg(RM_TURN, m_Escort.m_btDirection, m_Escort.m_nCurrX, m_Escort.m_nCurrY, 0, m_Escort.GetShowName);
            //end;
          end;
        end;
      end;

    end
    else
    begin
      m_PEnvir := OldEnvir;
      m_nCurrX := nOldX;
      m_nCurrY := nOldY;
      m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    end;
    OnEnvirnomentChanged();

    if m_btRaceServer = RC_PLAYOBJECT then
    begin //¸´Î»ÅÝµã£¬¼°½ð±Ò£¬Ê±¼ä
      TPlayObject(Self).m_dwIncGamePointTick := GetTickCount();
      TPlayObject(Self).m_dwIncGameGoldTick := GetTickCount();
      TPlayObject(Self).m_dwAutoGetExpTick := GetTickCount();
    end;
    if m_PEnvir.m_MapFlag.boFIGHT3Zone and (m_PEnvir.m_MapFlag.boFIGHT3Zone <> OldEnvir.m_MapFlag.boFIGHT3Zone) then
      RefShowName();

    //m_boInSafeZone := InSafeZone;
    //SendDefMessage(SM_INSAFEZONEFLAG, Integer(m_boInSafeZone), 0, 0, 0, '');
    m_boSendInSafeZone := True;
    m_dwSafeZoneCheckTick := 0;
    m_dwSearchTick := 0;
  except
    MainOutMessageAPI(sExceptionMsg7);
  end;
end;

procedure TBaseObject.TurnTo(nDir: Integer); //004BB048
var
  Buffer: array[0..255] of Byte;
begin
  if not (nDir in [0..7]) then
    Exit;
  m_btDirection := nDir;
  SendRefMsg(RM_TURN, nDir, m_nCurrX, m_nCurrY, GetFeatureToLong(@Buffer[0]), '');
end;

procedure TBaseObject.ProcessSayMsg(sMsg: string);
var
  sCharName: string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then
    sCharName := m_sCharName
  else
    sCharName := m_sFCharName;
  SendRefMsg(RM_HEAR,
    0,
    g_Config.btHearMsgFColor,
    g_Config.btHearMsgBColor,
    0 {MakeWord(m_btChatColor, m_btChatFont)},
    sCharName + ':' + sMsg);
end;

procedure TBaseObject.SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType; fc, bc, sec: Integer);
var
  BaseObject: TBaseObject;
begin
  //if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(self).m_boOffLineFlag) then Exit; //080118
  if IsHero and (m_Master.m_btRaceServer = RC_PLAYOBJECT) then
  begin
    BaseObject := m_Master;
    sMsg := g_HeroMsg + sMsg;
  end
  else
    BaseObject := Self;

  if g_Config.boShowPreFixMsg then
  begin
    case MsgType of
      t_Mon: sMsg := g_Config.sMonSayMsgpreFix + sMsg;
      t_Hint: sMsg := g_Config.sHintMsgPreFix + sMsg;
      t_GM: sMsg := g_Config.sGMRedMsgpreFix + sMsg;
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
      t_Notice: sMsg := g_Config.sLineNoticePreFix + sMsg;
      t_Cust: sMsg := g_Config.sCustMsgpreFix + sMsg;
      t_Castle: sMsg := g_Config.sCastleMsgpreFix + sMsg;
    end;
  end;

  case MsgColor of
    c_Cust: BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, fc, bc, sec, sMsg);
    c_Blue: BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor, g_Config.btBlueMsgBColor, sec, sMsg);
    c_Green: BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor, g_Config.btGreenMsgBColor, sec, sMsg);
    c_Purple: BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, g_Config.btPurpleMsgFColor, g_Config.btPurpleMsgBColor, sec, sMsg);
  else
    begin
      if MsgType = t_Cust then
        BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, g_Config.btCustMsgFColor, g_Config.btCustMsgBColor, sec, sMsg)
      else if MsgType = t_SysRight then
        BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE4, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, sec, sMsg)
      else
        BaseObject.SendMsg(BaseObject, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, sec, sMsg);
    end;
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
var
  i: Integer;
  sMsg: string;
  MonSayMsg: pTMonSayMsg;
  sAttackName: string;
begin
  if m_SayMsgList = nil then Exit;

  if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) then Exit;
  
  if (AttackBaseObject <> nil) then
  begin
    if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (AttackBaseObject.m_Master = nil) then
      Exit;
    if AttackBaseObject.m_Master <> nil then
      sAttackName := AttackBaseObject.m_Master.m_sCharName
    else
      sAttackName := AttackBaseObject.m_sCharName;
  end;
  for i := 0 to m_SayMsgList.Count - 1 do
  begin
    MonSayMsg := m_SayMsgList.Items[i];
    sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s', m_sFCharName);
    sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);
    if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then
    begin
      if MonStatus = s_MonGen then
      begin
        UserEngine.SendBroadCastMsg(sMsg, t_Mon);
        Break;
      end;
      if MonSayMsg.Color = c_White then
        ProcessSayMsg(sMsg)
      else
        AttackBaseObject.SysMsg(sMsg, MonSayMsg.Color, t_Mon);
      Break;
    end;
  end;
end;

procedure TPlayObject.SendGroupText(sMsg: string; Color, fc, bc, sec: Integer);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if m_GroupOwner <> nil then
  begin
    if g_Config.boViewWhisper then
      MainOutMessageAPI(Format('[×é¶Ó] %s', [sMsg]));
    sMsg := g_Config.sGroupMsgPreFix + sMsg;
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if Color = 0 then
        PlayObject.SendMsg(Self, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor, g_Config.btGroupMsgBColor, 0, sMsg)
      else
        PlayObject.SendMsg(Self, RM_GROUPMESSAGE, 0, fc, bc, sec, sMsg);
    end;
  end;
end;

procedure TBaseObject.MakeGhost();
begin
  if m_boCanReAlive then
  begin
    m_boInvisible := True;
    m_dwGhostTick := GetTickCount();
    m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
  end
  else
  begin
    m_boGhost := True;
    m_dwGhostTick := GetTickCount();
    DisappearA();
  end;
end;

procedure TBaseObject.ApplyMeatQuality;
var
  i: Integer;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
      if StdItem.StdMode = 40 then
        UserItem.Dura := m_nMeatQuality;
  end;
end;

function TBaseObject.ButchMonBagItems(BaseObject: TBaseObject; boHint: Boolean = False): Boolean;

  function IsInMonDropLimitList(StdItem: pTStdItem): Boolean;
  var
    ii: Integer;
    MonDrop: pTMonDrop;
  begin
    g_MonDropLimitLIst.Lock;
    try
      Result := False;
      for ii := 0 to g_MonDropLimitLIst.Count - 1 do
      begin
        MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
        if (GetTickCount - MonDrop^.Time) > 86400000 * MonDrop.ClearTime then
        begin
          MonDrop.nDropCount := 0;
          MonDrop.nNoDropCount := 0;
          MonDrop.Time := GetTickCount;
        end;
        if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[ii]) = 0 then
        begin
          MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
          if MonDrop.nDropCount < MonDrop.nCountLimit then
          begin
            Inc(MonDrop.nDropCount);
            g_MonDropLimitLIst.Objects[ii] := TObject(MonDrop);
          end
          else
          begin
            Inc(MonDrop.nNoDropCount);
            Result := True;
          end;
          Break;
        end;
      end;
    finally
      g_MonDropLimitLIst.UnLock;
    end;
  end;

var
  i: Integer;
  UserItem, GiveItem: pTUserItem;
  StdItem: pTStdItem;
label
  lab, lab2, lab3;
resourcestring
  sYouGetItems = 'ÄãÍÚÈ¡µ½ÎïÆ·: %s';
  sGetItemsSysMsg = '¹§Ï² %s ÔÚ%sËÑÑ°µ½±¦Îï: %s';
begin
  Result := False;

  if (m_btRaceServer <> RC_PLAYOBJECT) or (BaseObject = nil) then
    Exit;

  if BaseObject.m_ItemList.Count > 0 then
  begin
    if BaseObject.m_boExplore and (BaseObject.m_btRaceServer = RC_HERO) then
    begin
      for i := BaseObject.m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := BaseObject.m_ItemList.Items[i];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem = nil) or (IsInMonDropLimitList(StdItem)) then
          Continue;
        if Random(StdItem.SvrSet.nGetRate) <> 0 then
          Continue;

        if StdItem.Overlap >= 1 then
        begin
          if TPlayObject(Self).UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, 1, StdItem.Name, False) then
          begin
            if not IsCheapStuff(StdItem.StdMode) then
              if StdItem.NeedIdentify = 1 then
                AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + '9999' + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
            if boHint then
            begin
              SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
              if (m_PEnvir <> nil) then
                if g_HintItemList.Exists(StdItem.Name) then
                begin //0406
                  UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
                  if (g_FunctionNPC <> nil) then
                  begin
                    g_FunctionNPC.m_OprCount := 0;
                    g_FunctionNPC.GotoLable(TPlayObject(Self), '@GetButchItem' + BaseObject.m_sCharName, False);
                  end;
                end;
            end;
            //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
            Result := True;
            Break; //081214
          end
          else
            goto lab;
        end
        else
        begin
          lab:
          if TPlayObject(Self).IsEnoughBag then
          begin
            New(GiveItem);
            if UserEngine.CopyToUserItemFromName(StdItem.Name, GiveItem) then
            begin
              if not IsCheapStuff(StdItem.StdMode) then
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(GiveItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');

              m_ItemList.Add(GiveItem);
              TPlayObject(Self).SendAddItem(GiveItem);

              if boHint then
              begin
                SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
                if (m_PEnvir <> nil) then
                  if g_HintItemList.Exists(StdItem.Name) then
                  begin //0406
                    UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
                    if (g_FunctionNPC <> nil) then
                    begin
                      g_FunctionNPC.m_OprCount := 0;
                      g_FunctionNPC.GotoLable(TPlayObject(Self), '@GetButchItem' + BaseObject.m_sCharName, False);
                    end;
                  end;
              end;
              //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
              Result := True;
              Break; //081214
            end
            else
            begin
              Dispose(GiveItem);
              Break; //081214
            end;
          end
          else
          begin
            SysMsg('±³°üÒÑÂú,ÇëÇåÀí...', c_Red, t_Hint);
            Exit;
          end;
        end;
      end;
    end
    else if BaseObject.m_boAnimal then
    begin
      while (True) do
      begin
        if BaseObject.m_ItemList.Count <= 0 then
          Exit; //081214
        UserItem := BaseObject.m_ItemList.Items[0];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;
        if IsInMonDropLimitList(StdItem) then
          Continue;

        if StdItem.Overlap >= 1 then
        begin
          if TPlayObject(Self).UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, 1, StdItem.Name, False) then
          begin
            if not IsCheapStuff(StdItem.StdMode) then
              if StdItem.NeedIdentify = 1 then
                AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
            BaseObject.m_ItemList.Delete(0);
            Result := True;
          end
          else
            goto lab2;
        end
        else
        begin
          lab2:
          if not AddItemToBag(UserItem) then
          begin
            SysMsg('±³°üÒÑÂú,ÇëÇåÀí......', c_Red, t_Hint);
            Exit;
          end;

          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
          TPlayObject(Self).SendAddItem(UserItem);
          //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
          BaseObject.m_ItemList.Delete(0);
          Result := True;
          //Break;
        end;
      end;
    end;
  end;
  if (BaseObject.m_StorageItemList.Count > 0) and BaseObject.m_boExplore and (BaseObject.m_btRaceServer <> RC_HERO) then
  begin
    for i := BaseObject.m_StorageItemList.Count - 1 downto 0 do
    begin
      UserItem := BaseObject.m_StorageItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem = nil) or (IsInMonDropLimitList(StdItem)) then
        Continue;
      if Random(StdItem.SvrSet.nGetRate) <> 0 then
        Continue;

      if StdItem.Overlap >= 1 then
      begin
        if TPlayObject(Self).UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, 1, StdItem.Name, False) then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
          BaseObject.m_StorageItemList.Delete(i);
          if boHint then
          begin
            SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
            if (m_PEnvir <> nil) then
              if g_HintItemList.Exists(StdItem.Name) then
                UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
          end;
          //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
          Result := True;
          Exit; //081214
        end
        else
          goto lab3;
      end
      else
      begin
        lab3:
        if TPlayObject(Self).AddItemToBag(UserItem) then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
          TPlayObject(Self).SendAddItem(UserItem);
          BaseObject.m_StorageItemList.Delete(i);
          if boHint then
          begin
            SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
            if (m_PEnvir <> nil) then
              if g_HintItemList.Exists(StdItem.Name) then
                UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
          end;
          //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
          Result := True;
          Exit; //081214
        end
        else
        begin
          SysMsg('±³°üÒÑÂú,ÇëÇåÀí...', c_Red, t_Hint);
          Exit;
        end;
      end;
    end;
  end;

  if ButchMonUseItems(BaseObject) then
    Result := True;
end;

function TBaseObject.ButchMonUseItems(BaseObject: TBaseObject; boHint: Boolean = False): Boolean;

  function IsInMonDropLimitList(StdItem: pTStdItem): Boolean;
  var
    ii: Integer;
    MonDrop: pTMonDrop;
  begin
    g_MonDropLimitLIst.Lock;
    try
      Result := False;
      for ii := 0 to g_MonDropLimitLIst.Count - 1 do
      begin
        MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
        if (GetTickCount - MonDrop^.Time) > 86400000 * MonDrop.ClearTime then
        begin
          MonDrop.nDropCount := 0;
          MonDrop.nNoDropCount := 0;
          MonDrop.Time := GetTickCount;
        end;
        if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[ii]) = 0 then
        begin
          MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
          if MonDrop.nDropCount < MonDrop.nCountLimit then
          begin
            Inc(MonDrop.nDropCount);
            g_MonDropLimitLIst.Objects[ii] := TObject(MonDrop);
          end
          else
          begin
            Inc(MonDrop.nNoDropCount);
            Result := True;
          end;
          Break;
        end;
      end;
    finally
      g_MonDropLimitLIst.UnLock;
    end;
  end;

var
  i: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  DelList: TStringList;
label
  lab;
resourcestring
  sYouGetItems = 'ÄãÍÚÈ¡µ½ÎïÆ·: %s';
  sGetItemsSysMsg = '¹§Ï² %s ÔÚ%sËÑÑ°µ½±¦Îï: %s';
begin
  Result := False;
  if m_btRaceServer <> RC_PLAYOBJECT then
    Exit;
  if (BaseObject.m_btRaceServer <> RC_HERO) or not BaseObject.m_boExplore then
    Exit;
  DelList := nil;
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if BaseObject.m_UseItems[i].wIndex <= 0 then
      Continue;
    StdItem := UserEngine.GetStdItem(BaseObject.m_UseItems[i].wIndex);
    if StdItem = nil then
      Continue;
    if StdItem.StdMode in [25] then
      Continue;
    if IsInMonDropLimitList(StdItem) then
      Continue;
    if Random(StdItem.SvrSet.nGetRate) <> 0 then
      Continue;
    if StdItem.Overlap >= 1 then
    begin
      if TPlayObject(Self).UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, 1, StdItem.Name, False) then
      begin
        if not IsCheapStuff(StdItem.StdMode) then
          if StdItem.NeedIdentify = 1 then
            AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + '9999' + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
        if DelList = nil then
          DelList := TStringList.Create;
        DelList.AddObject(UserEngine.GetStdItemName(BaseObject.m_UseItems[i].wIndex), TObject(BaseObject.m_UseItems[i].MakeIndex));
        BaseObject.m_UseItems[i].wIndex := 0;
        BaseObject.RecalcAbilitys();
        BaseObject.FeatureChanged();
        TPlayObject(Self).SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
        if (m_PEnvir <> nil) then
          if g_HintItemList.Exists(StdItem.Name) then
            UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
        Result := True;
      end
      else
        goto lab;
    end
    else
    begin
      lab:
      New(UserItem);
      UserItem^ := BaseObject.m_UseItems[i];
      if AddItemToBag(UserItem) then
      begin
        if not IsCheapStuff(StdItem.StdMode) then
          if StdItem.NeedIdentify = 1 then
            AddGameDataLogAPI('15'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
        TPlayObject(Self).SendAddItem(UserItem);
        //TPlayObject(self).m_dwSaveRcdTick := 0; //0408_1
        if DelList = nil then
          DelList := TStringList.Create;
        DelList.AddObject(UserEngine.GetStdItemName(BaseObject.m_UseItems[i].wIndex), TObject(BaseObject.m_UseItems[i].MakeIndex));
        BaseObject.m_UseItems[i].wIndex := 0;
        BaseObject.RecalcAbilitys();
        if i in [0, 1, 16] then
          BaseObject.FeatureChanged();
        TPlayObject(Self).SysMsg(Trim(Format(sYouGetItems, [StdItem.Name])), c_Green, t_Hint);
        if (m_PEnvir <> nil) then
          if g_HintItemList.Exists(StdItem.Name) then
            UserEngine.SendBroadCastMsg(Trim(Format(sGetItemsSysMsg, [m_sCharName, m_PEnvir.m_sMapDesc, StdItem.Name])), t_System);
        Result := True;
      end
      else
      begin
        Dispose(UserItem);
        SysMsg('±³°üÒÑÂú,ÇëÇåÀí......', c_Red, t_Hint);
        Break;
      end;
    end;
  end;
  if DelList <> nil then
  begin
    BaseObject.SendMsg(BaseObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    BaseObject.RecalcAbilitys();
    BaseObject.FeatureChanged();
  end;
end;

procedure TBaseObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  i, ii: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  boCanNotDrop: Boolean;
  MonDrop: pTMonDrop;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::ScatterBagItems';
begin
  if m_boNoDropItemEx then
  begin
    //MainOutMessageAPI('123 ScatterBagItems::  m_boNoDropItemEx');
    Exit;
  end;

  if (m_btRaceServer <> RC_PLAYOBJECT) and not IsHero then
  begin
    UserEngine.MonGetRandomItems(Self, ItemOfCreat);
  end;

  try
    g_MonDropLimitLIst.Lock;
    try
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[i];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        boCanNotDrop := False;

        if StdItem <> nil then
        begin
          if IsHero then
          begin
            if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ = TPlayObject(Self).m_dwIdCRC) then
            begin
              if g_Config.boBindNoScatter then
                Continue;
            end;
            if InLimitItemList('', UserItem.wIndex, t_nsc) then
              Continue;
          end;

          for ii := 0 to g_MonDropLimitLIst.Count - 1 do
          begin
            MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
            if (GetTickCount - MonDrop^.Time) > 86400000 * MonDrop.ClearTime then
            begin
              MonDrop.nDropCount := 0;
              MonDrop.nNoDropCount := 0;
              MonDrop.Time := GetTickCount;
            end;
            if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[ii]) = 0 then
            begin
              MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[ii]);
              if MonDrop.nDropCount < MonDrop.nCountLimit then
              begin
                Inc(MonDrop.nDropCount);
                g_MonDropLimitLIst.Objects[ii] := TObject(MonDrop);
              end
              else
              begin
                Inc(MonDrop.nNoDropCount);
                boCanNotDrop := True;
              end;
              Break;
            end;
          end;

          if boCanNotDrop then
            Continue;

          if DropItemDown(UserItem, g_Config.nScatterRange, True, ItemOfCreat, Self) then
          begin
            Dispose(UserItem);
            m_ItemList.Delete(i);

            if ((m_btRaceServer <> RC_PLAYOBJECT) and not IsHero) and
              (m_PEnvir <> nil) and
              g_HintItemList.Exists(StdItem.Name) then
              UserEngine.SendBroadCastMsg(Trim(Format('%sµÄ%s±©³öÁË£º%s', [m_PEnvir.m_sMapDesc, m_sFCharName, StdItem.Name])), t_System);

          end;

        end;
      end;
    finally
      g_MonDropLimitLIst.UnLock;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TBaseObject.ScatterGolds(GoldOfCreat: TBaseObject);
var
  i, ii, nGold, nDropGold: Integer;
begin
  if m_nGold > 0 then
  begin
    if g_Config.boDropGoldToPlayBag and (GoldOfCreat <> nil) and ((GoldOfCreat.m_nGold + m_nGold) <= m_nGoldMax) then
    begin
      Inc(GoldOfCreat.m_nGold, m_nGold);
      GoldOfCreat.GoldChanged();
      Exit;
    end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      for ii := Low(g_Config.DieDropGold) to High(g_Config.DieDropGold) do
      begin
        if g_Config.DieDropGold[ii].nHumLevel <= 0 then
          Break;
        if m_Abil.Level = g_Config.DieDropGold[ii].nHumLevel then
        begin
          nDropGold := _MIN(m_nGold, Round((g_Config.DieDropGold[ii].nEXPRATE / 100) * m_nGold));
          if nDropGold > 0 then
          begin
            Dec(m_nGold, nDropGold);
            GoldChanged();
            i := 0;
            while (True) do
            begin
              if nDropGold > (g_Config.nMonOneDropGoldCount * 1000) then
              begin
                nGold := (g_Config.nMonOneDropGoldCount * 1000);
                nDropGold := nDropGold - (g_Config.nMonOneDropGoldCount * 1000);
              end
              else
              begin
                nGold := nDropGold;
                nDropGold := 0;
              end;
              if nGold > 0 then
              begin
                if not DropGoldDown(nGold, True, GoldOfCreat, Self) then
                begin
                  //  nDropGold := nDropGold + nGold;
                  Break;
                end;
              end
              else
                Break;
              Inc(i);
              if i > 16 * 2 then
                Break;
            end;
          end;
        end;
      end;
      Exit;
    end;

    i := 0;
    while (True) do
    begin
      if m_nGold > g_Config.nMonOneDropGoldCount then
      begin
        nGold := g_Config.nMonOneDropGoldCount;
        m_nGold := m_nGold - g_Config.nMonOneDropGoldCount;
      end
      else
      begin
        nGold := m_nGold;
        m_nGold := 0;
      end;
      if nGold > 0 then
      begin
        if not DropGoldDown(nGold, True, GoldOfCreat, Self) then
        begin
          m_nGold := m_nGold + nGold;
          Break;
        end;
      end
      else
        Break;
      Inc(i);
      if i > 16 then
        Break;
    end;
    GoldChanged();
  end;
end;

procedure TBaseObject.DropUseItems(BaseObject: TBaseObject);
var
  nC, nRate, nRate2, nPKLevel: Integer;
  StdItem: pTStdItem;
  DropItemList: TStringList;
  nPreventDrop, nTagDropPlus: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::DropUseItems';
begin
  if m_boNoDropUseItemEx then
    Exit;
  DropItemList := nil;
  try
    {if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) then begin //) or IsHero
      nC := 0;
      while (True) do begin
        StdItem := UserEngine.GetStdItem(m_UseItems[nC].wIndex);
        if StdItem <> nil then begin
          if StdItem.Reserved and 8 <> 0 then begin
            if DropItemList = nil then
              DropItemList := TStringList.Create;
            DropItemList.AddObject('', TObject(m_UseItems[nC].makeindex));
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('16' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(m_UseItems[nC].makeindex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
            m_UseItems[nC].wIndex := 0;
          end;
        end;
        Inc(nC);
        if nC > 13 then
          Break;
      end;
    end;}

    if g_Config.boDieDropUseItemRateSingle then
    begin
      nPKLevel := PKLevel;

      nC := 0;
      while (True) do
      begin
        if m_UseItems[nC].wIndex = 0 then
        begin
          Inc(nC);
          if nC > U_FASHION then
            Break;
          Continue;
        end;

        if IsHero then
        begin

          if (PCardinal(@m_UseItems[nC].btValue[22])^ > 0) and (PCardinal(@m_UseItems[nC].btValue[22])^ = TPlayObject(Self).m_dwIdCRC) then
          begin
            if g_Config.boBindNoScatter then
            begin
              Inc(nC);
              if nC > U_FASHION then
                Break;
              Continue;
            end;
          end;

          if nPKLevel > 2 then
            nRate := Round(g_Config.aDieDropUseItemRate[nC] / 10 * g_Config.nDieRedDropUseItemRateSingle)
          else
            nRate := g_Config.aDieDropUseItemRate[nC];
        end
        else if (m_btRaceServer = RC_HERO) then
        begin
          if nPKLevel > 2 then
            nRate := m_nDropUseItemRate
          else
            nRate := m_nDropUseItemRate * 2;
        end
        else
        begin
          if nPKLevel > 2 then
            nRate := 15
          else
            nRate := 30;
        end;

        if nRate <= 0 then
          nRate := 1;

        nRate2 := Round(1 * 10000 / nRate);

        nPreventDrop := 0;
        if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) and (TPlayObject(Self).m_nPreventDrop > 0) then
          nPreventDrop := TPlayObject(Self).m_nPreventDrop;

        nTagDropPlus := 0;
        if g_Config.EffectHeroDropRate and (m_LastHiter <> nil) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
        begin
          if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
          begin
            nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
          end;
        end;
        nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);
        //nRate := _MAX(1, nRate + nPreventDrop - nTagDropPlus);

        if (nRate2 > Random(10000)) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[nC].wIndex);
          if StdItem <> nil then
          begin
            if (StdItem.StdMode = 25) and (StdItem.Shape = 9) then
            begin
              Inc(nC);
              if nC > U_FASHION then
                Break;
              Continue;
            end;
            if IsHero and InLimitItemList('', m_UseItems[nC].wIndex, t_nsc) then
            begin
              Inc(nC);
              if nC > U_FASHION then
                Break;
              Continue;
            end;
            if DropItemDown(@m_UseItems[nC], g_Config.nScatterRange, True, BaseObject, Self) then
            begin
              //if StdItem.Reserved and 10 = 0 then begin
              if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
              begin
                if DropItemList = nil then
                  DropItemList := TStringList.Create;
                DropItemList.AddObject(StdItem.Name, TObject(m_UseItems[nC].MakeIndex));
              end;
              m_UseItems[nC].wIndex := 0;
              if ((m_btRaceServer <> RC_PLAYOBJECT) and not IsHero) and (m_PEnvir <> nil) and g_HintItemList.Exists(StdItem.Name) then
                UserEngine.SendBroadCastMsg(Trim(Format('%sµÄ%s±©³öÁË£º%s', [m_PEnvir.m_sMapDesc, m_sFCharName, StdItem.Name])), t_System);
              //end;
            end;
          end;
        end;
        Inc(nC);
        if nC > U_FASHION then
          Break;
      end;
      if DropItemList <> nil then
      begin
        SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DropItemList), 0, 0, '');
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          RecalcAbilitys();
          FeatureChanged();
        end;
      end;
      Exit;
    end;

    if IsHero then
    begin
      if PKLevel > 2 then
        nRate := g_Config.nDieRedDropUseItemRate
      else
        nRate := g_Config.nDieDropUseItemRate;
    end
    else if (m_btRaceServer = RC_HERO) then
    begin
      if PKLevel > 2 then
        nRate := m_nDropUseItemRate
      else
        nRate := m_nDropUseItemRate * 2;
    end
    else
    begin
      if PKLevel > 2 then
        nRate := 15
      else
        nRate := 30;
    end;

    if nRate <= 0 then
      nRate := 1;
    nRate2 := Round(1 * 10000 / nRate);

    nPreventDrop := 0;
    if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) and (TPlayObject(Self).m_nPreventDrop > 0) then
      nPreventDrop := TPlayObject(Self).m_nPreventDrop;

    nTagDropPlus := 0;
    if g_Config.EffectHeroDropRate and (m_LastHiter <> nil) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
    begin
      if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
      begin
        nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
      end;
    end;
    //nRate := _MAX(1, nRate + nPreventDrop - nTagDropPlus);
    nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);

    nC := 0;
    while (True) do
    begin
      if m_UseItems[nC].wIndex = 0 then
      begin
        Inc(nC);
        if nC > U_FASHION then
          Break;
        Continue;
      end;

      if IsHero and (PCardinal(@m_UseItems[nC].btValue[22])^ > 0) and (PCardinal(@m_UseItems[nC].btValue[22])^ = TPlayObject(Self).m_dwIdCRC) then
      begin
        if g_Config.boBindNoScatter then
        begin
          Inc(nC);
          if nC > U_FASHION then
            Break;
          Continue;
        end;
      end;

      if (nRate2 > Random(10000)) then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[nC].wIndex);
        if StdItem <> nil then
        begin
          if (StdItem.StdMode = 25) and (StdItem.Shape = 9) then
          begin
            Inc(nC);
            if nC > U_FASHION then
              Break;
            Continue;
          end;
          if IsHero and InLimitItemList('', m_UseItems[nC].wIndex, t_nsc) then
          begin
            Inc(nC);
            if nC > U_FASHION then
              Break;
            Continue;
          end;
          if DropItemDown(@m_UseItems[nC], g_Config.nScatterRange, True, BaseObject, Self) then
          begin
            //if StdItem.Reserved and 10 = 0 then begin
            if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
            begin
              if DropItemList = nil then
                DropItemList := TStringList.Create;
              DropItemList.AddObject(StdItem.Name, TObject(m_UseItems[nC].MakeIndex));
            end;
            m_UseItems[nC].wIndex := 0;
            if ((m_btRaceServer <> RC_PLAYOBJECT) and not IsHero) and (m_PEnvir <> nil) and g_HintItemList.Exists(StdItem.Name) then
              UserEngine.SendBroadCastMsg(Trim(Format('%sµÄ%s±©³öÁË£º%s', [m_PEnvir.m_sMapDesc, m_sFCharName, StdItem.Name])), t_System);
            //end;
          end;
        end;
      end;
      Inc(nC);
      if nC > U_FASHION then
        Break;
    end;
    if DropItemList <> nil then
    begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DropItemList), 0, 0, '');
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
      begin
        RecalcAbilitys();
        FeatureChanged();
      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

function TBaseObject.KillFunc(): Boolean;
var
  CSObject: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::KillFunc';
begin
  Result := False;
  if (g_MapEventNPC <> nil) and (m_PEnvir <> nil) and m_PEnvir.m_MapFlag.boKILLFUNC then
  begin
    if m_btRaceServer <> RC_PLAYOBJECT then
    begin
      if m_ExpHitter <> nil then
      begin
        CSObject := GetMainPlayer(m_ExpHitter);
        if CSObject.m_btRaceServer = RC_PLAYOBJECT then
        begin
          g_MapEventNPC.m_OprCount := 0;
          g_MapEventNPC.GotoLable(TPlayObject(CSObject), '@KillPlayMon' + IntToStr(m_PEnvir.m_MapFlag.nKILLFUNCNO), False);

        end;
      end
      else if m_LastHiter <> nil then
      begin
        CSObject := GetMainPlayer(m_LastHiter);
        if CSObject.m_btRaceServer = RC_PLAYOBJECT then
        begin
          g_MapEventNPC.m_OprCount := 0;
          g_MapEventNPC.GotoLable(TPlayObject(CSObject), '@KillPlayMon' + IntToStr(m_PEnvir.m_MapFlag.nKILLFUNCNO), False);

        end;
      end;
    end
    else if (m_LastHiter <> nil) then
    begin
      CSObject := GetMainPlayer(m_LastHiter);
      g_MapEventNPC.m_OprCount := 0;
      g_MapEventNPC.GotoLable(TPlayObject(CSObject), '@KillPlay' + IntToStr(m_PEnvir.m_MapFlag.nKILLFUNCNO), False);
    end;
    Result := True;
  end;
end;

function TBaseObject.TakeOnFunc(byWhere: Byte): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(TPlayObject(Self), '@TakeOn' + IntToStr(byWhere), False);
    Result := True;
  end;
end;

function TBaseObject.TakeOffFunc(byWhere: Byte): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(TPlayObject(Self), '@TakeOff' + IntToStr(byWhere), False);
    Result := True;
  end;
end;

function TBaseObject.LevelUPFunc: Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) then
  begin
    if (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      //g_FunctionNPC.m_OprCount := 0;
      g_FunctionNPC.GotoLable(TPlayObject(Self), '@PlayLevelUp', False)
    end
    else if IsHero then
    begin
      g_FunctionNPC.GotoLable(TPlayObject(m_Master), '@HeroLevelUp', False);
    end;
    Result := True;
  end;
end;

function TPlayObject.OffLineFunc(): Boolean;
begin
  Result := False;
  if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    g_FunctionNPC.m_OprCount := 0;
    g_FunctionNPC.GotoLable(TPlayObject(Self), m_sOffLineLabel, False);
    Result := True;
  end;
end;

procedure TBaseObject.Die();
var
  i: Integer;
  boPK, guildwarkill: Boolean;
  tStr: string;
  dwExp, dwIPExp: LongWord;
  GroupHuman: TPlayObject;
  QuestNPC: TMerchant;
  boGroupQuest: Boolean;
  AttackBaseObject, CSObject: TBaseObject;
  Castle: TUserCastle;
  TempLastHiter: TBaseObject;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::Die - GainExp';
  sExceptionMsg2 = '[Exception] TBaseObject::Die - PKFlag';
  sExceptionMsg3 = '[Exception] TBaseObject::Die - DropItems';
begin
  TempLastHiter := nil;
  if m_boSuperMan or m_boSupermanItem then
    Exit;
  if (m_Master <> nil) and (m_LastHiter <> nil) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> m_Master) then
  begin
    if m_btRaceServer = RC_HERO then
    begin
      if IsHero then
      begin
        tStr := g_sHeroKilledByHum;
      end
      else
        tStr := g_sPneumaKilledByHum;
    end
    else
      tStr := g_sSlaveKilledByHum;
    if (m_dwCloneDispearTick = 0) then
    begin
      if (m_LastHiter.m_PEnvir <> nil) and (m_LastHiter.m_PEnvir.m_MapFlag.nSecret and $08 <> 0) then
        m_Master.SysMsg(Format(tStr, [m_sFCharName, m_LastHiter.m_PEnvir.m_MapFlag.nSecretShowName]), c_Red, t_Hint)
      else
        m_Master.SysMsg(Format(tStr, [m_sFCharName, m_LastHiter.m_sCharName]), c_Red, t_Hint);
    end;

  end;

  if (m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_StallMgr.OnSale then
  begin
    TPlayObject(Self).CancelDoStall;
  end;

  if (m_Master <> nil) and (m_Master.IsHero or (m_Master.m_btRaceServer = RC_PLAYOBJECT) or ((m_Master.m_btRaceServer = RC_HERO) and (m_Master.m_dwCloneDispearTick = 0))) and (m_dwCloneDispearTick > 0) then
  begin
    SendRefMsg(RM_HEROLOGOUT, 0, m_nCurrX, m_nCurrY, 0, '');
    m_boDeath := True;
    m_dwDeathTick := GetTickCount() - g_Config.dwMakeGhostTime + 1000;
    m_ExpHitter := nil;
    m_LastHiter := nil;
    m_PoisonHiter := nil;
    m_nIncSpell := 0;
    m_nIncHealth := 0;
    m_nIncHealing := 0;
    if m_Master.m_boAdminMode then
      m_Master.m_boAdminMode := False;
    m_Master.SysMsg(g_sHeroStrikeDispear, c_Blue, t_Hint);
    m_Master.m_dwCloneSelfTick := GetTickCount;
    m_Master := nil;
    MakeGhost;
    Exit;
  end;

  if IsHero then
  begin
    //m_boHeroSaveRcd := True;
    //UserEngine.SaveHumanRcd(TPlayObject(self));

    m_Master.m_dwRecallHeroTick := GetTickCount;
    if g_Config.fDieDeductionExp then
    begin
      dwExp := m_Abil.MaxExp div (28 * m_Abil.Level);
      if m_Abil.Exp >= dwExp then
        Dec(m_Abil.Exp, dwExp)
      else
        m_Abil.Exp := 0;
    end;
  end;

  m_boDeath := True;
  m_dwDeathTick := GetTickCount();

  if m_boCanReAlive then
  begin
//    m_dwReAliveTick := GetTickCount;
    if (m_pMonGen <> nil) and (m_pMonGen.Envir <> m_PEnvir) then
    begin
      m_boCanReAlive := False;
      if m_pMonGen.nActiveCount > 0 then
        Dec(m_pMonGen.nActiveCount);
      m_pMonGen := nil;
    end;
  end;

  if (m_Master <> nil) then
  begin
    if IsHero then
      TempLastHiter := m_LastHiter;
    m_ExpHitter := nil;
    m_LastHiter := nil;
    m_PoisonHiter := nil;
    if (m_Master.m_btRaceServer = RC_PLAYOBJECT) then
      TPlayObject(m_Master).SendDefMessage(SM_HEROSTATEDISPEAR, Integer(Self), 0, 0, 0, '');
  end;

  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;

  KillFunc();

  try
    if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) then
    begin
      if not IsHero then
      begin
        if g_Config.boMonSayMsg then
          MonsterSayMsg(m_LastHiter, s_Die);
        if (m_ExpHitter <> nil) then
        begin
          CSObject := GetMainPlayer(m_ExpHitter);

          //ProcessSayMsg('ExpHitter: ' + m_ExpHitter.m_sCharName);
          //ProcessSayMsg('CSObject: ' + CSObject.m_sCharName);

          if m_PEnvir.IsCheapStuff and (CSObject.m_btRaceServer = RC_PLAYOBJECT) then
          begin
            if TPlayObject(CSObject).m_GroupOwner <> nil then
            begin
              for i := 0 to TPlayObject(CSObject).m_GroupOwner.m_GroupMembers.Count - 1 do
              begin
                GroupHuman := TPlayObject(TPlayObject(CSObject).m_GroupOwner.m_GroupMembers.Objects[i]);
                if not GroupHuman.m_boDeath and
                  (CSObject.m_PEnvir = GroupHuman.m_PEnvir) and
                  (abs(CSObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                  (abs(CSObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                  (CSObject = GroupHuman) then
                begin
                  boGroupQuest := False;
                end
                else
                  boGroupQuest := True;
                QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '', boGroupQuest));
                if QuestNPC <> nil then
                  QuestNPC.Click(GroupHuman);
              end;
            end
            else
            begin
              QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(CSObject, m_sCharName, '', False));
              if QuestNPC <> nil then
                QuestNPC.Click(TPlayObject(CSObject));
            end;
          end;
          if CSObject.m_btRaceServer = RC_PLAYOBJECT then
          begin
            if not g_Config.boVentureServer then
            begin
              dwExp := CSObject.CalcGetExp(m_Abil.Level, m_dwFightExp);
              TPlayObject(CSObject).GainExp(dwExp, m_Abil.Level);
              if m_dwFightIPExp > 0 then
              begin
                dwExp := CSObject.CalcGetExp(m_Abil.Level, m_dwFightIPExp);
                TPlayObject(CSObject).GainExp(dwExp, m_Abil.Level, True);
              end;
            end;
          end;
          if not (m_ExpHitter.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (m_ExpHitter.m_Master <> nil) then
            m_ExpHitter.GainSlaveExp(m_Abil.Level);
        end
        else
        begin
          CSObject := GetMainPlayer(m_LastHiter);
          if CSObject.m_btRaceServer = RC_PLAYOBJECT then
          begin
            if not g_Config.boVentureServer then
            begin
              dwExp := CSObject.CalcGetExp(m_Abil.Level, m_dwFightExp);
              TPlayObject(CSObject).GainExp(dwExp, m_Abil.Level);
              if m_dwFightIPExp > 0 then
              begin
                dwExp := CSObject.CalcGetExp(m_Abil.Level, m_dwFightIPExp);
                TPlayObject(CSObject).GainExp(dwExp, m_Abil.Level, True);
              end;
            end;
          end;
        end;
      end;
    end;
    if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) then
      m_LastHiter.MonsterSayMsg(Self, s_KillHuman);
    if not IsHero and (m_Master <> nil) then
      m_Master := nil;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg1);
      MainOutMessageAPI(E.Message);
    end;
  end;

  try
    boPK := False;
    if not g_Config.boVentureServer and not m_PEnvir.m_MapFlag.boFIGHTZone and not m_PEnvir.m_MapFlag.boFIGHT3Zone and not m_PEnvir.m_MapFlag.boFIGHT2Zone then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and (PKLevel < 2) then
      begin
        //CSObject := GetMainPlayer(m_LastHiter);
        if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or ({g_Config.boHeroHomicideAddPKPoint and} m_LastHiter.IsHero) then
          boPK := True
        else if m_LastHiter.m_Master <> nil then
        begin
          if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then
          begin
            m_LastHiter := m_LastHiter.m_Master;
            boPK := True;
          end
          else if (m_LastHiter.m_Master.m_btRaceServer = RC_HERO) and (m_LastHiter.m_Master.m_Master <> nil) and (m_LastHiter.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT) then
          begin
            m_LastHiter := m_LastHiter.m_Master.m_Master;
            boPK := True;
          end;
        end;
      end;
    end;
    if boPK and (m_LastHiter <> nil) then
    begin

      guildwarkill := False;
      if (m_MyGuild <> nil) then
      begin
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
        begin
          if m_LastHiter.m_MyGuild <> nil then
            if GetGuildRelation(Self, m_LastHiter) = 2 then
              guildwarkill := True;
        end
        else if m_LastHiter.IsHero then
        begin
          if m_LastHiter.m_Master.m_MyGuild <> nil then
            if GetGuildRelation(Self, m_LastHiter.m_Master) = 2 then
              guildwarkill := True;
        end;
      end;

      if not guildwarkill then
      begin
        if m_boInFreePKArea then
          guildwarkill := True
        else
        begin
          Castle := g_CastleManager.InCastleWarArea(Self);
          if (Castle <> nil) and Castle.m_boUnderWar then
            guildwarkill := True;
        end;
      end;

      if not guildwarkill then
      begin
        if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or m_PEnvir.m_MapFlag.boPKWINLEVEL or m_PEnvir.m_MapFlag.boPKWINEXP) then
        begin
          if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero then
            TPlayObject(Self).PKDie(TPlayObject(m_LastHiter))
        end
        else if not m_LastHiter.IsGoodKilling(Self) then
        begin
          {if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (g_Config.boHeroHomicideAddPKPoint and m_LastHiter.IsHero) then begin
            m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint);
            m_LastHiter.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
            if m_LastHiter.IsHero then begin
              SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + m_LastHiter.m_sCharName]), c_Red, t_Hint);
            end else
              SysMsg(Format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);
            m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
            if (PKLevel < 1) and (Random(5) = 0) then
              m_LastHiter.MakeWeaponUnlock;
          end;}
          if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
          begin
            m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint);
            m_LastHiter.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
            if m_LastHiter.IsHero then
            begin
              SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + m_LastHiter.m_sCharName]), c_Red, t_Hint);
            end
            else
              SysMsg(Format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);
            m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
            if (PKLevel < 1) and (Random(5) = 0) then
              m_LastHiter.MakeWeaponUnlock;
          end
          else if m_LastHiter.IsHero then
          begin
            if g_Config.boHeroHomicideAddPKPoint then
            begin
              m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint);
              m_LastHiter.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
              SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + m_LastHiter.m_sCharName]), c_Red, t_Hint);
              m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
              if (PKLevel < 1) and (Random(5) = 0) then
                m_LastHiter.MakeWeaponUnlock;
            end
            else if g_Config.boHeroHomicideAddMasterPkPoint then
            begin
              m_LastHiter.m_Master.IncPkPoint(g_Config.nKillHumanAddPKPoint);
              m_LastHiter.m_Master.SysMsg(g_sYouMurderedMsg + g_HeroMsg, c_Red, t_Hint);
              SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + m_LastHiter.m_sCharName]), c_Red, t_Hint);
              m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
              if (PKLevel < 1) and (Random(5) = 0) then
                m_LastHiter.MakeWeaponUnlock;
            end;
          end;
        end
        else
          m_LastHiter.SysMsg(g_sYouProtectedByLawOfDefense, c_Green, t_Hint);
        if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero then
        begin
          if m_LastHiter.m_dwPKDieLostExp > 0 then
          begin
            if m_Abil.Exp >= m_LastHiter.m_dwPKDieLostExp then
              Dec(m_Abil.Exp, m_LastHiter.m_dwPKDieLostExp)
            else
              m_Abil.Exp := 0;
          end;
          if m_LastHiter.m_nPKDieLostLevel > 0 then
          begin
            if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then
              Dec(m_Abil.Level, m_LastHiter.m_nPKDieLostLevel)
            else
              m_Abil.Level := 0;
          end;
        end;
      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg2);
  end;

  try
    if not m_boSkeleton and (m_boAnimal or m_boExplore) then
    begin
      UserEngine.MonGetRandomItems(Self, nil);
    end;

    if not m_PEnvir.m_MapFlag.boFIGHTZone and not m_PEnvir.m_MapFlag.boFIGHT3Zone and not m_boAnimal {and not m_boExplore} then
    begin
      //AttackBaseObject := nil;
      //if m_ExpHitter <> nil then
      AttackBaseObject := m_ExpHitter;
      if (m_ExpHitter <> nil) and (m_ExpHitter.m_Master <> nil) then
        AttackBaseObject := m_ExpHitter.m_Master;
      if (m_ExpHitter <> nil) and (m_ExpHitter.m_Master <> nil) and (m_ExpHitter.m_Master.m_Master <> nil) then
        AttackBaseObject := m_ExpHitter.m_Master.m_Master;

      if (m_btRaceServer <> RC_PLAYOBJECT) and not IsHero then
      begin
        DropUseItems(AttackBaseObject);
        if (m_Master = nil) and not m_boNoItem then
          ScatterBagItems(AttackBaseObject);
        if (m_btRaceServer >= RC_ANIMAL) and (m_Master = nil) and not m_boNoItem then
          ScatterGolds(AttackBaseObject);
      end
      else
      begin
        if not m_boNoItem then
        begin
          if AttackBaseObject <> nil then
          begin
            if (g_Config.boKillByHumanDropUseItem and (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT)) or (g_Config.boKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
            begin
              TPlayObject(Self).DropUseItems(nil);
            end;
          end
          else
          begin
            if IsHero then
            begin
              m_LastHiter := TempLastHiter;
              try
                if m_LastHiter <> m_Master then
                  TPlayObject(Self).DropUseItems(nil);
              finally
                m_LastHiter := nil;
              end;
            end
            else
              TPlayObject(Self).DropUseItems(nil);
          end;

          if g_Config.boDieScatterBag then
            if IsHero then
            begin
              m_LastHiter := TempLastHiter;
              try
                if m_LastHiter <> m_Master then
                  HeroScatterBagItems(nil);
              finally
                m_LastHiter := nil;
              end;
            end
            else
              ScatterBagItems(nil);

          if g_Config.boDieDropGold then
            ScatterGolds(nil);
        end;
        AddBodyLuck(-_MAX(1000, (50 - (50 - m_Abil.Level * 5))));
      end;
    end;

    //TeamFightWhoWinPoint
    if m_PEnvir.m_MapFlag.boFIGHT3Zone then
    begin
      Inc(m_nFightZoneDieCount);
      if m_MyGuild <> nil then
        TGuild(m_MyGuild).TeamFightWhoDead(m_sCharName);
      if (m_LastHiter <> nil) then
      begin
        if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then
        begin
          TGuild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint(m_LastHiter.m_sCharName, 100);
          tStr := TGuild(m_LastHiter.m_MyGuild).sGuildName + ':' + IntToStr(TGuild(m_LastHiter.m_MyGuild).m_nContestPoint) + '  ' + TGuild(m_MyGuild).sGuildName + ':' + IntToStr(TGuild(m_MyGuild).m_nContestPoint);
          UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ' + tStr);
        end;
      end;
    end;

    //ÈËÎïËÀÍöÁ¢¼´ÍË×é£¬ÒÔ·ÀÖ¹×é¶ÓË¢¾­Ñé
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if TPlayObject(Self).m_GroupOwner <> nil then
        TPlayObject(Self).m_GroupOwner.DelMember(TPlayObject(Self));
      if m_LastHiter <> nil then
      begin
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
          tStr := m_LastHiter.m_sCharName
        else
          tStr := '#' + m_LastHiter.m_sCharName;
      end
      else
        tStr := '####';
      AddGameDataLogAPI('19' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + 'FZ-' + BoolToIntStr(m_PEnvir.m_MapFlag.boFIGHTZone) + '_F3-' + BoolToIntStr(m_PEnvir.m_MapFlag.boFIGHT3Zone) + #9 + '0' + #9 + '1' + #9 + tStr);
    end;

    //¼õÉÙµØÍ¼ÉÏ¹ÖÎï¼ÆÊý
    if (m_Master = nil) and not m_boDelFormMaped then
    begin
      m_PEnvir.DelObjectCount(Self);
      m_boDelFormMaped := True;
      m_boAddToMaped := False;
    end;
    SendRefMsg(RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');

    if IsHero {and not m_boHeroSaveRcd} then
    begin
      m_boHeroSaveRcd := True;
      UserEngine.SaveHumanRcd(TPlayObject(Self));
    end;
  except
    MainOutMessageAPI(sExceptionMsg3);
  end;
end;

procedure TPlayObject.PKDie(PlayObject: TPlayObject);
var
  nWinLevel, nLostLevel, nWinExp, nLostExp: Integer;
  boWinLEvel, boLostLevel, boWinExp, boLostExp: Boolean;
begin
  nWinLevel := g_Config.nKillHumanWinLevel;
  nLostLevel := g_Config.nKilledLostLevel;
  nWinExp := g_Config.nKillHumanWinExp;
  nLostExp := g_Config.nKillHumanLostExp;
  boWinLEvel := g_Config.boKillHumanWinLevel;
  boLostLevel := g_Config.boKilledLostLevel;
  boWinExp := g_Config.boKillHumanWinExp;
  boLostExp := g_Config.boKilledLostExp;
  if m_PEnvir.m_MapFlag.boPKWINLEVEL then
  begin
    boWinLEvel := True;
    nWinLevel := m_PEnvir.m_MapFlag.nPKWINLEVEL;
  end;
  if m_PEnvir.m_MapFlag.boPKLOSTLEVEL then
  begin
    boLostLevel := True;
    nLostLevel := m_PEnvir.m_MapFlag.nPKLOSTLEVEL;
  end;
  if m_PEnvir.m_MapFlag.boPKWINEXP then
  begin
    boWinExp := True;
    nWinExp := m_PEnvir.m_MapFlag.nPKWINEXP;
  end;
  if m_PEnvir.m_MapFlag.boPKLOSTEXP then
  begin
    boLostExp := True;
    nLostExp := m_PEnvir.m_MapFlag.nPKLOSTEXP;
  end;
  if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then
  begin
    if not PlayObject.IsGoodKilling(Self) then
    begin
      {if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) or (g_Config.boHeroHomicideAddPKPoint and PlayObject.IsHero) then begin
        PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint);
        PlayObject.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
        if PlayObject.IsHero then
          SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + PlayObject.m_sCharName]), c_Red, t_Hint)
        else
          SysMsg(Format(g_sYouKilledByMsg, [PlayObject.m_sCharName]), c_Red, t_Hint);
        PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
        if PKLevel < 1 then
          if Random(5) = 0 then PlayObject.MakeWeaponUnlock;
      end;}
      if (PlayObject.m_btRaceServer = RC_PLAYOBJECT) then
      begin
        PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint);
        PlayObject.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
        SysMsg(Format(g_sYouKilledByMsg, [PlayObject.m_sCharName]), c_Red, t_Hint);
        PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
        if PKLevel < 1 then
          if Random(5) = 0 then
            PlayObject.MakeWeaponUnlock;
      end
      else if PlayObject.IsHero then
      begin
        if g_Config.boHeroHomicideAddPKPoint then
        begin
          PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint);
          PlayObject.SysMsg(g_sYouMurderedMsg, c_Red, t_Hint);
          SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + PlayObject.m_sCharName]), c_Red, t_Hint);
          PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
          if PKLevel < 1 then
            if Random(5) = 0 then
              PlayObject.MakeWeaponUnlock;
        end
        else if g_Config.boHeroHomicideAddMasterPkPoint then
        begin
          PlayObject.m_Master.IncPkPoint(g_Config.nKillHumanAddPKPoint);
          PlayObject.m_Master.SysMsg(g_sYouMurderedMsg + g_HeroMsg, c_Red, t_Hint);
          SysMsg(Format(g_sYouKilledByMsg, [g_HeroMsg + PlayObject.m_sCharName]), c_Red, t_Hint);
          PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint);
          if PKLevel < 1 then
            if Random(5) = 0 then
              PlayObject.MakeWeaponUnlock;
        end;
      end;
    end
    else
      PlayObject.SysMsg(g_sYouProtectedByLawOfDefense, c_Green, t_Hint);
    Exit;
  end;
  if boWinLEvel then
  begin
    if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then
      Inc(PlayObject.m_Abil.Level, nWinLevel)
    else
      PlayObject.m_Abil.Level := MAXUPLEVEL;
    PlayObject.HasLevelUp();
    if boLostLevel then
    begin
      if PKLevel >= 2 then
      begin
        if m_Abil.Level >= nLostLevel * 2 then
          Dec(m_Abil.Level, nLostLevel * 2);
      end
      else if m_Abil.Level >= nLostLevel then
        Dec(m_Abil.Level, nLostLevel);
    end;
  end;

  if boWinExp and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    PlayObject.WinExp(nWinExp, False);
    if boLostExp then
    begin
      if m_Abil.Exp >= LongWord(nLostExp) then
      begin
        if m_Abil.Exp >= LongWord(nLostExp) then
        begin
          Dec(m_Abil.Exp, LongWord(nLostExp));
        end
        else
          m_Abil.Exp := 0;
      end
      else
      begin
        if m_Abil.Level >= 1 then
        begin
          Dec(m_Abil.Level);
          Inc(m_Abil.Exp, GetLevelExp(m_Abil.Level));
          if m_Abil.Exp >= LongWord(nLostExp) then
          begin
            Dec(m_Abil.Exp, LongWord(nLostExp));
          end
          else
            m_Abil.Exp := 0;
        end
        else
        begin
          m_Abil.Level := 0;
          m_Abil.Exp := 0;
        end;
      end;
    end;
  end;
end;

procedure TBaseObject.ReAlive;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) then
    ClearStatusTime();
  RecalcAbilitys();
  m_boDeath := False;
  //if IsHero() then
  m_boHeroSaveRcd := False;
  SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;
{$IFDEF TEST }

procedure TBaseObject.ReAliveEx(pMonGen: pTMonGenInfo);
var
  i, nDebug: Integer;
  boErrorOnInit: Boolean;
  nX, nY, nX2, nY2, nC: Integer;
  pObject: Pointer;
  nRange, nRange2: Integer;
begin
  nDebug := $123456;

  m_boGetRandomItems := False;

  try
    m_WAbil := m_Abil;

    m_nGold := 0;

    m_boStrike := False;

    m_boNoItem := False;
    m_boStoneMode := False;
    m_boSkeleton := False;
    m_boHolySeize := False;
    m_boCrazyMode := False;
    m_boShowHP := False;
    m_boPlayerDupMode := False;
    m_boFixedHideMode := False;
    //m_boStickMode := False;

    if Self is TYimoogiMaster then
    begin
      TYimoogiMaster(Self).m_dwCloneSpawn := 0;
      TYimoogiMaster(Self).m_dwLastRecall := GetTickCount();

    end
    else if Self is TYimoogi then
    begin
      TYimoogi(Self).m_boDied := False;
      TYimoogi(Self).m_boApproach := False;
      TYimoogi(Self).m_boActive := False;
      TYimoogi(Self).m_boNoAttackMode := True;

    end
    else if Self is TRockManObject then
    begin
      TRockManObject(Self).m_boHideMode := True;

    end
    else if Self is TMagicMonObject then
    begin
      TMagicMonObject(Self).m_boUseMagic := False;

    end
    else if Self is TMagicMonster then
    begin
      TMagicMonster(Self).m_boDupMode := False;

    end
    else if Self is TMinotaurKing then
    begin
      TMinotaurKing(Self).nextx := 0;
      TMinotaurKing(Self).nexty := 0;
      TMinotaurKing(Self).boMoving := False;
      TMinotaurKing(Self).MassAttackMode := False;
      TMinotaurKing(Self).MassAttackCount := 0;
      TMinotaurKing(Self).NextTarget := nil;
      TMinotaurKing(Self).m_boApproach := False;

    end
    else if Self is TFrostTiger then
    begin
      TFrostTiger(Self).m_boApproach := False;

    end
    else if Self is TOmaKing then
    begin
      TOmaKing(Self).ldistx := 0;
      TOmaKing(Self).ldisty := 0;

    end
    else if Self is TBlackFox then
    begin
      TBlackFox(Self).m_boUseMagic := False;
      TBlackFox(Self).m_boApproach := False;

    end
    else if Self is TBlackFox then
    begin
      TBlackFox(Self).m_boUseMagic := False;
      TBlackFox(Self).m_boApproach := False;

    end
    else if Self is TFoxWarrior then
    begin
      TFoxWarrior(Self).CrazyKingMode := False;
      TFoxWarrior(Self).CriticalMode := False;

    end
    else if Self is TFoxPillar then
    begin
      TFoxPillar(Self).RunDone := False;
      TFoxPillar(Self).m_boHideMode := False;
      TFoxPillar(Self).m_boStickMode := True;
      TFoxPillar(Self).m_boSuperMan := True;

    end
    else if Self is TFoxBead then
    begin
      TFoxBead(Self).RunDone := False;
      TFoxBead(Self).m_boHideMode := False;
      TFoxBead(Self).m_boStickMode := True;
      TFoxBead(Self).m_nBodyState := 1;
      TFoxBead(Self).sectick := GetTickCount;

    end
    else if Self is TSoccerBall then
    begin
      TSoccerBall(Self).n550 := 0;
      TSoccerBall(Self).m_nTargetX := -1;

    end
    else if Self is TCastleDoor then
    begin
      TCastleDoor(Self).m_boOpened := False;
      TCastleDoor(Self).m_boStickMode := True;

    end
    else if Self is TWallStructure then
    begin
      TWallStructure(Self).boSetMapFlaged := False;

    end
    else if Self is TBamTreeMonster then
    begin
      TBamTreeMonster(Self).m_nStruckCount := 0;
      TBamTreeMonster(Self).m_nHealth := 0;

    end
    else if Self is TPlayMonster then
    begin
      TPlayMonster(Self).m_boDupMode := False;
      TPlayMonster(Self).m_dwMag41Tick := 0;
      TPlayMonster(Self).m_nCurMagId := 0;

    end
    else if Self is THeroMonster then
    begin
      THeroMonster(Self).m_boDupMode := False;
      THeroMonster(Self).m_dwMag41Tick := 0;
      THeroMonster(Self).m_nCurMagId := 0;

    end
    else if Self is TCowKingMonster then
    begin
      TCowKingMonster(Self).m_boCowKingMon := True;
      TCowKingMonster(Self).m_nDangerLevel := 0;
      TCowKingMonster(Self).m_boDanger := False;
      TCowKingMonster(Self).m_boCrazy := False;

    end
    else if Self is THongMoMonster then
    begin
      THongMoMonster(Self).m_boCowKingMon := True;
      THongMoMonster(Self).m_nDangerLevel := 0;
      THongMoMonster(Self).m_boDanger := False;
      THongMoMonster(Self).m_boCrazy := False;

    end
    else if Self is TDigOutZombi then
    begin
      TDigOutZombi(Self).m_boFixedHideMode := True;

    end
    else if Self is TWhiteSkeleton then
    begin
      TWhiteSkeleton(Self).m_boIsFirst := True;
      TWhiteSkeleton(Self).m_boFixedHideMode := True;

    end
    else if Self is TScultureMonster then
    begin
      TScultureMonster(Self).m_boStoneMode := True;
      TScultureMonster(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TScultureKingMonster then
    begin
      TScultureKingMonster(Self).m_boStoneMode := True;
      TScultureKingMonster(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TElfMonster then
    begin
      TElfMonster(Self).m_boFixedHideMode := True;
      TElfMonster(Self).m_boNoAttackMode := True;
      TElfMonster(Self).boIsFirst := True;

    end
    else if Self is TElfWarriorMonster then
    begin
      TElfWarriorMonster(Self).m_boFixedHideMode := True;
      TElfWarriorMonster(Self).boIsFirst := True;
      TElfWarriorMonster(Self).m_boUsePoison := False;

    end
    else if Self is TElectronicScolpionMon then
    begin
      TElectronicScolpionMon(Self).m_boUseMagic := False;
      TElectronicScolpionMon(Self).m_boApproach := False;

    end
    else if Self is TCrystalSpider then
    begin
      TCrystalSpider(Self).m_boUseMagic := False;
      TCrystalSpider(Self).m_boApproach := False;

    end
    else if Self is TEidolonMonster then
    begin
      TEidolonMonster(Self).m_boIsFirst := True;
      TEidolonMonster(Self).m_boFixedHideMode := True;

    end
    else if Self is TSnowMonster then
    begin
      TSnowMonster(Self).m_boSmiteHit := False;

    end
    else if Self is TDoubleCriticalMonster then
    begin
      TDoubleCriticalMonster(Self).m_n7A0 := 0;

    end
    else if Self is TDDevil then
    begin
      TDDevil(Self).m_boUseMagic := False;

    end
    else if Self is TRedThunderZuma then
    begin
      TRedThunderZuma(Self).m_boStoneMode := True;
      TRedThunderZuma(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TRebelCommandMonster then
    begin
      TRebelCommandMonster(Self).m_boFixedHideMode := False;

    //end else if Self is TBeeQueen then begin
    //  TBeeQueen(Self).m_boStickMode := True;

    end
    else if Self is TStickMonster then
    begin
      TStickMonster(Self).m_dwSearchTick := GetTickCount();
      TStickMonster(Self).m_boFixedHideMode := True;
      TStickMonster(Self).m_boStickMode := True;
      //TStickMonster(self).m_boAnimal := True;
    end;

    m_nMeatQuality := Random(3500) + 3000;
    m_nBodyLeathery := m_nPerBodyLeathery;
    m_nProcessRunCount := 0;
    m_nPushedCount := 0;
    m_nBodyState := 0;

    case Self.m_btRaceServer of
      51:
        begin
          m_nMeatQuality := Random(3500) + 3000;
          m_nBodyLeathery := 50;
        end;
      52:
        begin
          if Random(30) = 0 then
          begin
            m_nMeatQuality := Random(20000) + 10000;
            m_nBodyLeathery := 150;
          end
          else
          begin
            m_nMeatQuality := Random(8000) + 8000;
            m_nBodyLeathery := 150;
          end;
        end;
      53:
        begin
          m_nMeatQuality := Random(8000) + 8000;
          m_nBodyLeathery := 150;
        end;
      RC_Escort:
        begin
          m_boAnimal := True;
        end;
      95:
        begin
          if Random(2) = 0 then
            m_boSafeWalk := True;
        end;
      96:
        begin
          if Random(4) = 0 then
            m_boSafeWalk := True;
        end;
      97:
        begin
          if Random(2) = 0 then
            m_boSafeWalk := True;
        end;

      169: m_boStickMode := False;

      170: m_boStickMode := True;
    end;

    FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
    FillChar(m_wStatusTimeArrEx, SizeOf(m_wStatusTimeArrEx), #0);

    FillChar(m_UseItems, SizeOf(m_UseItems), #0);

    for i := 0 to m_ItemList.Count - 1 do
      Dispose(pTUserItem(m_ItemList.Items[i]));
    m_ItemList.Clear;

    for i := 0 to m_StorageItemList.Count - 1 do
      Dispose(pTUserItem(m_StorageItemList.Items[i]));
    m_StorageItemList.Clear;

    OnEnvirnomentChanged();

    if m_btRaceServer = RC_HERO then
    begin
      UserEngine.MonGetRandomUseItems(Self);
    end;

    m_nCharStatus := GetCharStatus();
    StatusChanged();

    nX2 := m_nCurrX;
    nY2 := m_nCurrY;

    if m_PEnvir = nil then
      Exit;

    nX := (pMonGen.nX - pMonGen.nRange) + Random(pMonGen.nRange * 2 + 1);
    nY := (pMonGen.nY - pMonGen.nRange) + Random(pMonGen.nRange * 2 + 1);

    m_boErrorOnInit := True;
    if m_PEnvir.CanWalk(nX, nY, True) then
    begin
      m_nCurrX := nX;
      m_nCurrY := nY;
      if AddToMap() then
        m_boErrorOnInit := False;
    end;

    if m_boErrorOnInit then
    begin
      pObject := nil;
      if m_PEnvir.m_MapHeader.wWidth < 50 then
        nRange := 2
      else
        nRange := 3;

      if (m_PEnvir.m_MapHeader.wHeight < 250) then
      begin
        if (m_PEnvir.m_MapHeader.wHeight < 30) then
          nRange2 := 2
        else
          nRange2 := 20;
      end
      else
        nRange2 := 50;

      nC := 0;
      while True do
      begin
        if not m_PEnvir.CanWalk(nX, nY, False) then
        begin
          if (m_PEnvir.m_MapHeader.wWidth - nRange2 - 1) > nX then
            Inc(nX, nRange)
          else
          begin
            nX := Random(m_PEnvir.m_MapHeader.wWidth div 2) + nRange2;
            if m_PEnvir.m_MapHeader.wHeight - nRange2 - 1 > nY then
              Inc(nY, nRange)
            else
              nY := Random(m_PEnvir.m_MapHeader.wHeight div 2) + nRange2;
          end;
        end
        else
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          pObject := m_PEnvir.AddToMap(nX, nY, OS_MOVINGOBJECT, Self);
          Break;
        end;
        Inc(nC);
        if nC >= 46 then
          Break;
      end;

      if pObject = nil then
      begin
        m_nCurrX := nX2;
        m_nCurrY := nY2;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end;

  finally
    //
  end;

  if m_PEnvir = nil then
    Exit;

  {if not m_PEnvir.ExchangeMapPos(m_nCurrX, m_nCurrY, nX, nY, self) then begin
    m_nCurrX := nX;
    m_nCurrY := nY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, self);
  end;}

  m_Abil.HP := m_Abil.MaxHP;
  m_Abil.MP := m_Abil.MaxMP;

  m_WAbil.HP := m_WAbil.MaxHP;
  m_WAbil.MP := m_WAbil.MaxMP;

  RecalcAbilitys();

  m_boDeath := False;
  m_boInvisible := False;
  m_boHeroSaveRcd := False;

  //if not m_boFixedHideMode then
  SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');

  if g_Config.boMonSayMsg then
    MonsterSayMsg(nil, s_MonGen);

  //SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;
{$ELSE}
//Õû¸öº¯ÊýÌæ»»

function TBaseObject.ReAliveEx(pMonGen: pTMonGenInfo): Boolean;
var
  i: Integer;
  boErrorOnInit: Boolean;
  nX, nY, nX2, nY2, nC: Integer;
  pObject: Pointer;
  nRange, nRange2: Integer;
  Buffer: array[0..255] of Byte;
begin
  Result := False;

  m_boGetRandomItems := False;

  try
    m_WAbil := m_Abil;

    m_nGold := 0;

    m_boStrike := False;

    m_boNoItem := False;
    m_boStoneMode := False;
    m_boSkeleton := False;
    m_boHolySeize := False;
    m_boCrazyMode := False;
    m_boShowHP := False;
    m_boPlayerDupMode := False;
    m_boFixedHideMode := False;
    //m_boStickMode := False;

    if Self is TYimoogiMaster then
    begin
      TYimoogiMaster(Self).m_dwCloneSpawn := 0;
      TYimoogiMaster(Self).m_dwLastRecall := GetTickCount();

    end
    else if Self is TYimoogi then
    begin
      TYimoogi(Self).m_boDied := False;
      TYimoogi(Self).m_boApproach := False;
      TYimoogi(Self).m_boActive := False;
      TYimoogi(Self).m_boNoAttackMode := True;

    end
    else if Self is TRockManObject then
    begin
      TRockManObject(Self).m_boHideMode := True;

    end
    else if Self is TMagicMonObject then
    begin
      TMagicMonObject(Self).m_boUseMagic := False;

    end
    else if Self is TMagicMonster then
    begin
      TMagicMonster(Self).m_boDupMode := False;

    end
    else if Self is TMinotaurKing then
    begin
      TMinotaurKing(Self).nextx := 0;
      TMinotaurKing(Self).nexty := 0;
      TMinotaurKing(Self).boMoving := False;
      TMinotaurKing(Self).MassAttackMode := False;
      TMinotaurKing(Self).MassAttackCount := 0;
      TMinotaurKing(Self).NextTarget := nil;
      TMinotaurKing(Self).m_boApproach := False;

    end
    else if Self is TFrostTiger then
    begin
      TFrostTiger(Self).m_boApproach := False;

    end
    else if Self is TOmaKing then
    begin
      TOmaKing(Self).ldistx := 0;
      TOmaKing(Self).ldisty := 0;

    end
    else if Self is TBlackFox then
    begin
      TBlackFox(Self).m_boUseMagic := False;
      TBlackFox(Self).m_boApproach := False;

    end
    else if Self is TBlackFox then
    begin
      TBlackFox(Self).m_boUseMagic := False;
      TBlackFox(Self).m_boApproach := False;

    end
    else if Self is TFoxWarrior then
    begin
      TFoxWarrior(Self).CrazyKingMode := False;
      TFoxWarrior(Self).CriticalMode := False;

    end
    else if Self is TFoxPillar then
    begin
      TFoxPillar(Self).RunDone := False;
      TFoxPillar(Self).m_boHideMode := False;
      TFoxPillar(Self).m_boStickMode := True;
      TFoxPillar(Self).m_boSuperMan := True;

    end
    else if Self is TFoxBead then
    begin
      TFoxBead(Self).RunDone := False;
      TFoxBead(Self).m_boHideMode := False;
      TFoxBead(Self).m_boStickMode := True;
      TFoxBead(Self).m_nBodyState := 1;
      TFoxBead(Self).sectick := GetTickCount;

    end
    else if Self is TSoccerBall then
    begin
      TSoccerBall(Self).n550 := 0;
      TSoccerBall(Self).m_nTargetX := -1;

    end
    else if Self is TCastleDoor then
    begin
      TCastleDoor(Self).m_boOpened := False;
      TCastleDoor(Self).m_boStickMode := True;

    end
    else if Self is TWallStructure then
    begin
      TWallStructure(Self).boSetMapFlaged := False;

    end
    else if Self is TBamTreeMonster then
    begin
      TBamTreeMonster(Self).m_nStruckCount := 0;
      TBamTreeMonster(Self).m_nHealth := 0;

    end
    else if Self is TPlayMonster then
    begin
      TPlayMonster(Self).m_boDupMode := False;
      TPlayMonster(Self).m_dwMag41Tick := 0;
      TPlayMonster(Self).m_nCurMagId := 0;

    end
    else if Self is THeroMonster then
    begin
      THeroMonster(Self).m_boDupMode := False;
      THeroMonster(Self).m_dwMag41Tick := 0;
      THeroMonster(Self).m_nCurMagId := 0;

    end
    else if Self is TCowKingMonster then
    begin
      TCowKingMonster(Self).m_boCowKingMon := True;
      TCowKingMonster(Self).m_nDangerLevel := 0;
      TCowKingMonster(Self).m_boDanger := False;
      TCowKingMonster(Self).m_boCrazy := False;

    end
    else if Self is THongMoMonster then
    begin
      THongMoMonster(Self).m_boCowKingMon := True;
      THongMoMonster(Self).m_nDangerLevel := 0;
      THongMoMonster(Self).m_boDanger := False;
      THongMoMonster(Self).m_boCrazy := False;

    end
    else if Self is TDigOutZombi then
    begin
      TDigOutZombi(Self).m_boFixedHideMode := True;

    end
    else if Self is TWhiteSkeleton then
    begin
      TWhiteSkeleton(Self).m_boIsFirst := True;
      TWhiteSkeleton(Self).m_boFixedHideMode := True;

    end
    else if Self is TScultureMonster then
    begin
      TScultureMonster(Self).m_boStoneMode := True;
      TScultureMonster(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TScultureKingMonster then
    begin
      TScultureKingMonster(Self).m_boStoneMode := True;
      TScultureKingMonster(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TElfMonster then
    begin
      TElfMonster(Self).m_boFixedHideMode := True;
      TElfMonster(Self).m_boNoAttackMode := True;
      TElfMonster(Self).boIsFirst := True;

    end
    else if Self is TElfWarriorMonster then
    begin
      TElfWarriorMonster(Self).m_boFixedHideMode := True;
      TElfWarriorMonster(Self).boIsFirst := True;
      TElfWarriorMonster(Self).m_boUsePoison := False;

    end
    else if Self is TElectronicScolpionMon then
    begin
      TElectronicScolpionMon(Self).m_boUseMagic := False;
      TElectronicScolpionMon(Self).m_boApproach := False;

    end
    else if Self is TCrystalSpider then
    begin
      TCrystalSpider(Self).m_boUseMagic := False;
      TCrystalSpider(Self).m_boApproach := False;

    end
    else if Self is TEidolonMonster then
    begin
      TEidolonMonster(Self).m_boIsFirst := True;
      TEidolonMonster(Self).m_boFixedHideMode := True;

    end
    else if Self is TSnowMonster then
    begin
      TSnowMonster(Self).m_boSmiteHit := False;

    end
    else if Self is TDoubleCriticalMonster then
    begin
      TDoubleCriticalMonster(Self).m_n7A0 := 0;

    end
    else if Self is TDDevil then
    begin
      TDDevil(Self).m_boUseMagic := False;

    end
    else if Self is TRedThunderZuma then
    begin
      TRedThunderZuma(Self).m_boStoneMode := True;
      TRedThunderZuma(Self).m_nCharStatusEx := STATE_STONE_MODE;

    end
    else if Self is TRebelCommandMonster then
    begin
      TRebelCommandMonster(Self).m_boFixedHideMode := False;

    //end else if Self is TBeeQueen then begin
    //  TBeeQueen(Self).m_boStickMode := True;

    end
    else if Self is TStickMonster then
    begin
      TStickMonster(Self).m_dwSearchTick := GetTickCount();
      TStickMonster(Self).m_boFixedHideMode := True;
      TStickMonster(Self).m_boStickMode := True;
      //TStickMonster(self).m_boAnimal := True;
    end;

    m_nMeatQuality := Random(3500) + 3000;
    m_nBodyLeathery := m_nPerBodyLeathery;
    m_nProcessRunCount := 0;
    m_nPushedCount := 0;
    m_nBodyState := 0;

    case Self.m_btRaceServer of
      51:
        begin
          m_nMeatQuality := Random(3500) + 3000;
          m_nBodyLeathery := 50;
        end;
      52:
        begin
          if Random(30) = 0 then
          begin
            m_nMeatQuality := Random(20000) + 10000;
            m_nBodyLeathery := 150;
          end
          else
          begin
            m_nMeatQuality := Random(8000) + 8000;
            m_nBodyLeathery := 150;
          end;
        end;
      53:
        begin
          m_nMeatQuality := Random(8000) + 8000;
          m_nBodyLeathery := 150;
        end;
      RC_Escort:
        begin
          m_boAnimal := True;
        end;
      95:
        begin
          if Random(2) = 0 then
            m_boSafeWalk := True;
        end;
      96:
        begin
          if Random(4) = 0 then
            m_boSafeWalk := True;
        end;
      97:
        begin
          if Random(2) = 0 then
            m_boSafeWalk := True;
        end;

      169: m_boStickMode := False;

      170: m_boStickMode := True;
    end;

    FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
    FillChar(m_wStatusTimeArrEx, SizeOf(m_wStatusTimeArrEx), #0);

    FillChar(m_UseItems, SizeOf(m_UseItems), #0);

    for i := 0 to m_ItemList.Count - 1 do
      Dispose(pTUserItem(m_ItemList.Items[i]));
    m_ItemList.Clear;

    for i := 0 to m_StorageItemList.Count - 1 do
      Dispose(pTUserItem(m_StorageItemList.Items[i]));
    m_StorageItemList.Clear;

    OnEnvirnomentChanged();

    if m_btRaceServer = RC_HERO then
    begin
      UserEngine.MonGetRandomUseItems(Self);
    end;

    m_nCharStatus := GetCharStatus();
    StatusChanged();

    nX2 := m_nCurrX;
    nY2 := m_nCurrY;

    if m_PEnvir = nil then
    begin
      Exit;
    end;

    nX := (pMonGen.nX - pMonGen.nRange) + Random(pMonGen.nRange * 2 + 1);
    nY := (pMonGen.nY - pMonGen.nRange) + Random(pMonGen.nRange * 2 + 1);

    m_boErrorOnInit := True;
    if m_PEnvir.CanWalk(nX, nY, True) then
    begin
      m_nCurrX := nX;
      m_nCurrY := nY;
      if AddToMap() then
        m_boErrorOnInit := False;
    end;

    if m_boErrorOnInit then
    begin
      pObject := nil;
      if m_PEnvir.m_MapHeader.wWidth < 50 then
        nRange := 2
      else
        nRange := 3;

      if (m_PEnvir.m_MapHeader.wHeight < 250) then
      begin
        if (m_PEnvir.m_MapHeader.wHeight < 30) then
          nRange2 := 2
        else
          nRange2 := 20;
      end
      else
        nRange2 := 50;

      nC := 0;
      while True do
      begin
        if not m_PEnvir.CanWalk(nX, nY, False) then
        begin
          if (m_PEnvir.m_MapHeader.wWidth - nRange2 - 1) > nX then
            Inc(nX, nRange)
          else
          begin
            nX := Random(m_PEnvir.m_MapHeader.wWidth div 2) + nRange2;
            if m_PEnvir.m_MapHeader.wHeight - nRange2 - 1 > nY then
              Inc(nY, nRange)
            else
              nY := Random(m_PEnvir.m_MapHeader.wHeight div 2) + nRange2;
          end;
        end
        else
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          pObject := m_PEnvir.AddToMap(nX, nY, OS_MOVINGOBJECT, Self);
          Break;
        end;
        Inc(nC);
        if nC >= 46 then
          Break;
      end;

      if pObject = nil then
      begin
        m_nCurrX := nX2;
        m_nCurrY := nY2;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end;

  finally
    //
  end;

  {if not m_PEnvir.ExchangeMapPos(m_nCurrX, m_nCurrY, nX, nY, self) then begin
    m_nCurrX := nX;
    m_nCurrY := nY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, self);
  end;}

  m_Abil.HP := m_Abil.MaxHP;
  m_Abil.MP := m_Abil.MaxMP;

  m_WAbil.HP := m_WAbil.MaxHP;
  m_WAbil.MP := m_WAbil.MaxMP;

  RecalcAbilitys();

  m_boDeath := False;
  m_boInvisible := False;
  m_boHeroSaveRcd := False;

  //if not m_boFixedHideMode then
  SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');

  if g_Config.boMonSayMsg then
    MonsterSayMsg(nil, s_MonGen);

  Result := True;
  //SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;
{$ENDIF}

procedure TBaseObject.SetLastPoisonHiter(BaseObject: TBaseObject);
begin
  m_PoisonHiter := BaseObject;
  m_PoisonHiterTick := GetTickCount();
end;

procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject);
begin
  m_LastHiter := BaseObject;
  m_LastHiterTick := GetTickCount();
  if m_ExpHitter = nil then
  begin
    m_ExpHitter := BaseObject;
    m_ExpHitterTick := GetTickCount();
  end
  else if m_ExpHitter = BaseObject then
    m_ExpHitterTick := GetTickCount();
end;

procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject);
begin
  if (PKLevel < 2) and
    (BaseObject.PKLevel < 2) and
    (not m_PEnvir.m_MapFlag.boFIGHTZone) and
    (not m_PEnvir.m_MapFlag.boFIGHT2Zone) and
    (not m_PEnvir.m_MapFlag.boFIGHT3Zone) and
    (not m_boPKFlag) and (((m_btRaceServer = RC_PLAYOBJECT) or IsHero) and not InSafeZone) then
  begin
    BaseObject.m_dwPKTick := GetTickCount();
    if not BaseObject.m_boPKFlag then
    begin
      BaseObject.m_boPKFlag := True;
      BaseObject.RefNameColor();
    end;
  end;
end;

function TBaseObject.IsGoodKilling(Cert: TBaseObject): Boolean; //004BC8D8
begin
  Result := False;
  if Cert.m_boPKFlag then
    Result := True;
end;

function TBaseObject.IsProtectTarget(BaseObject: TBaseObject): Boolean;
begin
  Result := True;
  if BaseObject = nil then
    Exit;
  if InSafeZone or BaseObject.InSafeZone then
  begin
    Result := False;
    Exit;
  end;
  if not BaseObject.m_boInFreePKArea then
  begin
    if g_Config.boPKLevelProtect then
    begin
      if (m_Abil.Level > g_Config.nPKProtectLevel) then
      begin
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <= g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
        begin
          Result := False;
          Exit;
        end;
      end;
      if (m_Abil.Level <= g_Config.nPKProtectLevel) then
      begin
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level > g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
        begin
          Result := False;
          Exit;
        end;
      end;
    end;
    if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then
    begin
      if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and (BaseObject.PKLevel < 2) then
      begin
        Result := False;
        Exit;
      end;
    end;
    if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then
    begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > g_Config.nRedPKProtectLevel) then
      begin
        Result := False;
        Exit;
      end;
    end;
    if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount - BaseObject.m_dwMapMoveTick < 3000) then
      Result := False;
  end;
end;

function TBaseObject.IsAttackTarget(BaseObject: TBaseObject; MagFire: Boolean): Boolean;
var
  i: Integer;
  MainObject, MainMaster: TBaseObject;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) or (BaseObject.m_btRaceServer = RC_NPC) or (BaseObject.m_btRaceServer = RC_PEACENPC) then
    Exit;

  if g_Config.boNullAttackOnSale then
  begin
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
      TPlayObject(BaseObject).m_boInSafeZone and
      (TPlayObject(BaseObject).m_StallMgr.OnSale) then
      Exit;
  end;

  if BaseObject.m_btRaceServer = RC_MISSION then
    Exit;
  if m_btRaceServer >= RC_ANIMAL then
  begin
    if m_Master <> nil then
    begin
      if BaseObject.m_btRaceServer = RC_Escort then
      begin
        if BaseObject.m_Master <> nil then
        begin
          if BaseObject.m_Master = m_Master then
            Exit;
          if BaseObject.m_Master = m_Master.m_Master then
            Exit;
        end;
      end;

      if IsHero then
      begin //Ó¢ÐÛÊØ»¤
        if m_Master.m_boHeroSearchTag or m_boAdminMode then
        begin
          if (BaseObject.m_btRaceServer > RC_MONSTER) and (BaseObject.m_Master = nil) and not (BaseObject.m_btRaceServer in [RC_GUARD, 104, 110..112, 120, RC_MISSIONARCHER]) then
            Result := True;
        end;
      end;

      if not Result and (m_Master.m_LastHiter = BaseObject) or (m_Master.m_ExpHitter = BaseObject) or (m_Master.m_TargetCret = BaseObject) then
        Result := True;

      if not Result and (BaseObject.m_TargetCret <> nil) then
        if (BaseObject.m_TargetCret = m_Master) or (BaseObject.m_TargetCret.m_Master = m_Master) and (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then
          Result := True;

      if not Result and (BaseObject.m_TargetCret = Self) then
      begin //Ó¢ÐÛÊÜÈË»ò¹Ö¹¥»÷»¹»÷
        if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
          Result := True
        else if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
          if IsHero() then
            Result := True;
      end;

      if not Result and (BaseObject.m_Master <> nil) then
        if (BaseObject.m_Master = m_Master.m_LastHiter) or (BaseObject.m_Master = m_Master.m_TargetCret) then
          Result := True;

      if MagFire and (m_btRaceServer = RC_HERO) {IsHero} then
      begin
        MainMaster := GetMainPlayer(Self);
        if (MainMaster.m_btRaceServer = RC_PLAYOBJECT) then
        begin
          case MainMaster.m_btAttatckMode of
            HAM_ALL:
              begin
                if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                  Result := True;
                if g_Config.boNonPKServer then
                  Result := False;
              end;
            HAM_PEACE: if not Result then
              begin
                MainObject := GetMainPlayer(BaseObject);
                if MainObject.m_btRaceServer >= RC_ANIMAL then
                  Result := True;
                if MainObject = MainMaster then
                  Result := False;
              end;
            HAM_DEAR: if not Result then
              begin
                MainObject := GetMainPlayer(BaseObject);
                if MainObject <> TPlayObject(MainMaster).m_DearHuman then
                  Result := True;
                if MainObject = MainMaster then
                  Result := False;
              end;
            HAM_MASTER:
              begin
                MainObject := GetMainPlayer(BaseObject);
                if MainObject.m_btRaceServer = RC_PLAYOBJECT then
                begin
                  Result := True;
                  if TPlayObject(MainMaster).m_boMaster then
                  begin
                    for i := 0 to TPlayObject(MainMaster).m_MasterList.Count - 1 do
                    begin
                      if TPlayObject(MainMaster).m_MasterList.Items[i] = MainObject then
                      begin
                        Result := False;
                        Break;
                      end;
                    end;
                  end;
                  if TPlayObject(MainObject).m_boMaster then
                  begin
                    for i := 0 to TPlayObject(MainObject).m_MasterList.Count - 1 do
                    begin
                      if TPlayObject(MainObject).m_MasterList.Items[i] = MainMaster then
                      begin
                        Result := False;
                        Break;
                      end;
                    end;
                  end;
                end
                else
                  Result := True;
                if MainObject = MainMaster then
                  Result := False;
              end;
            HAM_GROUP {2}:
              begin
                MainObject := GetMainPlayer(BaseObject);
                if (MainObject.m_btRaceServer < RC_NPC) or (MainObject.m_btRaceServer > RC_PEACENPC) then
                  Result := True;
                if MainObject.m_btRaceServer = RC_PLAYOBJECT then
                  if TPlayObject(MainMaster).IsGroupMember(MainObject) then
                    Result := False;
                if g_Config.boNonPKServer then
                  Result := False;
                if MainObject = MainMaster then
                  Result := False;
              end;
            HAM_GUILD {3}:
              begin
                MainObject := GetMainPlayer(BaseObject);
                if (MainObject.m_btRaceServer < RC_NPC) or (MainObject.m_btRaceServer > RC_PEACENPC) then
                  Result := True;
                if Result and (MainObject.m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  if MainMaster.m_MyGuild <> nil then
                  begin
                    if MainMaster.m_MyGuild = MainObject.m_MyGuild then //Speed up
                      Result := False
                    else if MainMaster.m_boGuildWarArea and (MainObject.m_MyGuild <> nil) then
                    begin
                      if TGuild(MainMaster.m_MyGuild).IsAllyGuild(TGuild(MainObject.m_MyGuild)) then
                        Result := False;
                    end;
                  end;
                end;
                if g_Config.boNonPKServer then
                  Result := False;
                if MainObject = MainMaster then
                  Result := False;
                if MainObject = MainMaster then
                  Result := False;
              end;
            HAM_PKATTACK {4}:
              begin
                if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
                  Result := True;
                if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                  if MainMaster.PKLevel >= 2 then
                  begin
                    if BaseObject.PKLevel < 2 then
                      Result := True
                    else
                      Result := False;
                  end
                  else
                  begin
                    if BaseObject.PKLevel >= 2 then
                      Result := True
                    else
                      Result := False;
                  end;
                if g_Config.boNonPKServer then
                  Result := False;
                //if MainObject = MainMaster then
                //  Result := False;
              end;
          end;
          if (BaseObject.m_btRaceServer = RC_Escort) and (BaseObject.m_Master = MainMaster) then
            Result := False;
          if TPlayObject(MainMaster).m_boOffLinePlay and (BaseObject.m_btRaceServer in [RC_GUARD, 104, 110..112, 120, RC_MISSIONARCHER]) then
            Result := False;

        end;
      end;

      if Result and (BaseObject.m_Master = m_Master) then //Same Master
        Result := False;
      if Result and (BaseObject = m_Master) then //not attack master
        Result := False;
      if Result and (m_Master.m_Master <> nil) and (BaseObject = m_Master.m_Master) then //not attack master
        Result := False;
      if Result and BaseObject.m_boHolySeize then
        Result := False;
      if Result and (not IsHero and m_Master.m_boSlaveRelax) or (IsHero and (m_Master.m_btHeroRelax in [1, 2])) then
        Result := False;
      if Result and (m_Master.IsHero) and (m_Master.m_Master.m_btHeroRelax in [1, 2]) then
        Result := False;

      if Result and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or BaseObject.IsHero then
      begin
        if BaseObject.InSafeZone or (IsHero and InSafeZone) then //0805
          Result := False;
      end;

      if Result and (m_btRaceServer = RC_HERO) and (BaseObject.m_Master <> nil) and (BaseObject.m_Master = Self) then
        Result := False;

      if Result and (BaseObject = Self.m_Master) then //0413
        Result := False;

      if Result and (m_Master.m_btRaceServer = RC_HERO) and (m_Master.m_Master <> nil) then
        if (BaseObject = m_Master) or (BaseObject = m_Master.m_Master) then
          Result := False;

      BreakCrazyMode();
    end
    else
    begin
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
        Result := True;
      if not Result and (m_btRaceServer > RC_PEACENPC) and (m_btRaceServer < RC_ANIMAL) then
        Result := True;
      //if (BaseObject.m_Master <> nil) then Result := True;
      if not Result then
      begin //main lorder is human, set target
        MainObject := GetMainPlayer(BaseObject);
        if (MainObject <> BaseObject) and (MainObject.m_btRaceServer = RC_PLAYOBJECT) then
          Result := True;
      end;
      if Result and (m_btRaceServer = RC_HERO) and (BaseObject.m_Master <> nil) and (BaseObject.m_Master = Self) then //0413
        Result := False;

      if BaseObject.m_btRaceServer = RC_Escort then
      begin
        Result := False;
      end;

    end;
    if m_boCrazyMode then
      Result := True;
  end
  else
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      case m_btAttatckMode of
        HAM_ALL:
          begin
            if ((BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC)) then
              Result := True;
            if g_Config.boNonPKServer then
              Result := False;
          end;
        HAM_PEACE:
          begin
            MainObject := GetMainPlayer(BaseObject);
            if (MainObject.m_btRaceServer >= RC_ANIMAL) then
              Result := True;
          end;
        HAM_DEAR:
          begin
            MainObject := GetMainPlayer(BaseObject);
            if (MainObject <> TPlayObject(Self).m_DearHuman) then
              Result := True;
          end;
        HAM_MASTER:
          begin
            MainObject := GetMainPlayer(BaseObject);
            if MainObject.m_btRaceServer = RC_PLAYOBJECT then
            begin
              Result := True;
              if TPlayObject(Self).m_boMaster then
              begin
                for i := 0 to TPlayObject(Self).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(Self).m_MasterList.Items[i] = MainObject then
                  begin
                    Result := False;
                    Break;
                  end;
                end;
              end;
              if TPlayObject(MainObject).m_boMaster then
              begin
                for i := 0 to TPlayObject(MainObject).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(MainObject).m_MasterList.Items[i] = Self then
                  begin
                    Result := False;
                    Break;
                  end;
                end;
              end;
            end
            else
              Result := True;
          end;
        HAM_GROUP {2}:
          begin
            MainObject := GetMainPlayer(BaseObject);
            if (MainObject.m_btRaceServer < RC_NPC) or (MainObject.m_btRaceServer > RC_PEACENPC) then
              Result := True;
            if MainObject.m_btRaceServer = RC_PLAYOBJECT then
              if TPlayObject(Self).IsGroupMember(MainObject) then
                Result := False;
            if g_Config.boNonPKServer then
              Result := False;
          end;
        HAM_GUILD {3}:
          begin
            MainObject := GetMainPlayer(BaseObject);
            if (MainObject.m_btRaceServer < RC_NPC) or (MainObject.m_btRaceServer > RC_PEACENPC) then
              Result := True;
            if Result and (MainObject.m_btRaceServer = RC_PLAYOBJECT) then
            begin
              if m_MyGuild <> nil then
              begin
                //if TGuild(m_MyGuild).IsMember(MainObject.m_sCharName) then
                //  Result := False;
                if m_MyGuild = MainObject.m_MyGuild then //Speed up
                  Result := False
                else if m_boGuildWarArea and (MainObject.m_MyGuild <> nil) then
                begin
                  if TGuild(m_MyGuild).IsAllyGuild(TGuild(MainObject.m_MyGuild)) then
                    Result := False;
                end;
              end;
            end;
            if g_Config.boNonPKServer then
              Result := False;
          end;
        HAM_PKATTACK {4}:
          begin
            if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
              Result := True;
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              if PKLevel >= 2 then
              begin
                if BaseObject.PKLevel < 2 then
                  Result := True
                else
                  Result := False;
              end
              else
              begin
                if BaseObject.PKLevel >= 2 then
                  Result := True
                else
                  Result := False;
              end;
            if g_Config.boNonPKServer then
              Result := False;
          end;
      end;
      if (BaseObject.m_btRaceServer = RC_Escort) and (BaseObject.m_Master = Self) then
        Result := False;
      if TPlayObject(Self).m_boOffLinePlay and (BaseObject.m_btRaceServer in [RC_GUARD, 104, 110..112, 120, RC_MISSIONARCHER]) then
        Result := False;
    end
    else
      Result := True;
  end;
  if Result then
  begin
    if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode or BaseObject.m_boSuperMode then
      Result := False;
  end;
  if Result then
  begin
    if BaseObject.IsHero and ((m_btRaceServer >= RC_ANIMAL) and (m_Master = nil)) then
    begin
      if (BaseObject.m_Master.m_btHeroRelax in [1, 2]) and (BaseObject.m_Abil.Level < 23) then
        Result := False;
    end;
  end;
end;

function TBaseObject.IsProperTarget(BaseObject: TBaseObject; MagFire: Boolean): Boolean;
var
  Master: TBaseObject;
begin
  Result := IsAttackTarget(BaseObject, MagFire);
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if BaseObject = nil then
      Exit;
    if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
    begin
      if Result then
        Result := IsProtectTarget(BaseObject);
    end
    else if BaseObject.m_Master <> nil then
    begin
      if BaseObject.m_Master.m_Master <> nil then
        Master := BaseObject.m_Master.m_Master
      else
        Master := BaseObject.m_Master;
      if Master = Self then
      begin
        if (m_btAttatckMode <> HAM_ALL) then
          Result := False;
      end
      else if InSafeZone or BaseObject.InSafeZone then
        Result := False;
      //else Result := IsAttackTarget(BaseObject); //080415
    end;
  end;
end;

procedure TBaseObject.WeightChanged;
begin
  m_WAbil.Weight := RecalcBagWeight();
  SendUpdateMsg(Self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
end;

function TBaseObject.InSafeZone: Boolean;
var
  i, j,k, nSafeX, nSafeY: Integer;
  StartPointInfo: pTStartPointInfo;
  P:pTStartPointRegion;
begin
  Result := False;
  if m_PEnvir = nil then
    Exit;
  Result := m_PEnvir.m_MapFlag.boSAFE;
  if Result then
    Exit;
  if (m_PEnvir.m_sMapFileName <> g_Config.sRedHomeMap) or
    (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
  begin
    Result := False;
  end
  else
    Result := True;
  if Result then
    Exit;

  for i := 0 to m_CurSafeZoneList.Count - 1 do
  begin
    StartPointInfo := m_CurSafeZoneList.Items[i];
    //sMapName := StartPointInfo.sMapName;
    nSafeX := StartPointInfo.nX;
    nSafeY := StartPointInfo.nY;
    if (StartPointInfo.nSize >= CUSTOM_SAFEZONE_CONTROLSTART_INX) and (StartPointInfo.nSize <= CUSTOM_SAFEZONE_CONTROLEND_INX) then
    begin
    // 2019-12-17
      for j := 0 to g_StartPointRegionList_Server.Count - 1 do
      begin
        p := g_StartPointRegionList_Server.Items[j];
        if p^.nSizeCode = StartPointInfo.nSize then
        begin
          if PtInRegion(p^.rgn,m_nCurrX,m_nCurrY) then  //ÅÐ¶ÏµãÊÇ·ñÔÚÒìÐÎÇøÓòÄÚ£¬²»°üº¬±ß¿ò
          begin
            Result := True;
            if StartPointInfo.boPKZone then
              Result := not Result;
            Break;
          end
          else if (PtInRegion(p^.rgn,m_nCurrX,m_nCurrY - 1) or PtInRegion(p^.rgn,m_nCurrX,m_nCurrY + 1) or PtInRegion(p^.rgn,m_nCurrX - 1,m_nCurrY) or PtInRegion(p^.rgn,m_nCurrX + 1,m_nCurrY)) then
          begin //ÅÐ¶Ï±ß¿ò  2019-12-17
            Result := True;
            if StartPointInfo.boPKZone then
              Result := not Result;
            Break;
          end;
        end;
      end;
    end
    else
    begin
      if {(m_PEnvir <> nil) and}(StartPointInfo.Envir = m_PEnvir) and
        (abs(m_nCurrX - nSafeX) <= StartPointInfo.nSize) and
        (abs(m_nCurrY - nSafeY) <= StartPointInfo.nSize) then
      begin
        Result := True;
        if StartPointInfo.boPKZone then
          Result := not Result;
        Break;
      end;
    end;
  end;

end;

function TBaseObject.DisableSyaMsgInSafeZone(): Boolean;
var
  i, nSafeX, nSafeY: Integer;
  StartPointInfo: pTStartPointInfo;
begin
  Result := m_PEnvir.m_MapFlag.boSAFE;
  if Result then  Exit;

  if (m_PEnvir.m_sMapFileName <> g_Config.sRedHomeMap) or
    (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
  begin
    Result := False;
  end
  else
    Result := True;
  if Result then
    Exit;

  for i := 0 to m_CurSafeZoneList.Count - 1 do
  begin
    StartPointInfo := m_CurSafeZoneList.Items[i];
    //sMapName := StartPointInfo.sMapName;
    nSafeX := StartPointInfo.nX;
    nSafeY := StartPointInfo.nY;
    if {(m_PEnvir <> nil) and}(StartPointInfo.Envir = m_PEnvir) and
      (abs(m_nCurrX - nSafeX) <= StartPointInfo.nSize) and
      (abs(m_nCurrY - nSafeY) <= StartPointInfo.nSize) and
      StartPointInfo.boQUIZ then
    begin
      Result := True;
      Break;
    end;
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean;
var
  i, nSafeX, nSafeY: Integer;
  StartPointInfo: pTStartPointInfo;
begin
  Result := Envir.m_MapFlag.boSAFE;
  if Result then  Exit;

  if (Envir.m_sMapFileName <> g_Config.sRedHomeMap) or
    (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
    Result := False
  else
    Result := True;
  if Result then
    Exit;

  for i := 0 to m_CurSafeZoneList.Count - 1 do
  begin
    StartPointInfo := m_CurSafeZoneList.Items[i];
    //sMapName := StartPointInfo.sMapName;
    nSafeX := StartPointInfo.nX;
    nSafeY := StartPointInfo.nY;
    if {(m_PEnvir <> nil) and}(StartPointInfo.Envir = m_PEnvir) and
      (abs(nX - nSafeX) <= StartPointInfo.nSize) and
      (abs(nY - nSafeY) <= StartPointInfo.nSize) then
    begin
      Result := True;
      if StartPointInfo.boPKZone then
        Result := not Result;
      Break;
    end;
  end;
end;

procedure TBaseObject.OpenHolySeizeMode(dwInterval: LongWord);
begin
  m_dwHolySeizeTick := GetTickCount();
  m_dwHolySeizeInterval := dwInterval;
  if not m_boHolySeize then
  begin
    m_boHolySeize := True;
    RefNameColor();
  end;
end;

procedure TBaseObject.BreakHolySeizeMode;
begin
  if m_boHolySeize then
  begin
    m_boHolySeize := False;
    RefNameColor();
  end;
end;

procedure TBaseObject.OpenCrazyMode(nTime: Integer);
begin
  m_dwCrazyModeTick := GetTickCount();
  m_dwCrazyModeInterval := nTime * 1000;
  if not m_boCrazyMode then
  begin
    m_boCrazyMode := True;
    RefNameColor();
  end;
end;

procedure TBaseObject.BreakCrazyMode;
begin
  if m_boCrazyMode then
  begin
    m_boCrazyMode := False;
    RefNameColor();
  end;
end;

procedure TPlayObject.LeaveGroup;
resourcestring
  sExitGropMsg = '%s ÒÑ¾­ÍË³öÁË±¾×é...';
begin
  SendGroupText(Format(sExitGropMsg, [m_sCharName]));
  m_GroupOwner := nil;
  ReSetGroupAttrib();
  SendMsg(Self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
end;

function TPlayObject.CancelGroup: Boolean;
resourcestring
  sCanceGrop = 'ÄãµÄÐ¡×é±»½âÉ¢ÁË...';
begin
  Result := True;
  if m_GroupMembers.Count <= 1 then
  begin
    SendGroupText(sCanceGrop);
    m_GroupMembers.Clear;
    m_GroupOwner := nil;
    ReSetGroupAttrib();
    Result := False;
  end;
end;

procedure TPlayObject.SendGroupMembers; //004DCBA4
var
  i: Integer;
  PlayObject: TPlayObject;
  sSENDMSG: string;
  sTempCharName: string;
begin
  sSENDMSG := '';
  for i := 0 to m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
    if g_Config.boHumanAttribute and (PlayObject.m_btAttribute in [1..5]) then
      sTempCharName := PlayObject.m_sCharName + g_sAttribArr[PlayObject.m_btAttribute]
    else
      sTempCharName := PlayObject.m_sCharName;
    sSENDMSG := sSENDMSG + sTempCharName + '/';
  end;
  for i := 0 to m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
    PlayObject.SendDefMessage(SM_GROUPMEMBERS, 0, 0, 0, 0, sSENDMSG);
  end;
end;

{function TPlayObject.GetMagicInfo(nMagicId: Integer): pTUserMagic;
var
  i                         : Integer;
  UserMagic                 : pTUserMagic;
begin
  Result := nil;
  for i := 0 to m_MagicList.Count - 1 do begin
    UserMagic := m_MagicList.Items[i];
    if UserMagic.MagicInfo.wMagicId = nMagicId then begin
      Result := UserMagic;
      Break;
    end;
  end;
end;}

function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer; //004C6910
begin
  Result := Round(UserMagic.MagicInfo.wSpell / (4) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
end;

function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean; //004C3130

  function CanMotaebo(BaseObject: TBaseObject): Boolean; //0x004C30B0
  var
    nC: Integer;
  begin
    Result := False;
    if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then
    begin
      nC := m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then
      begin
        if IsProperTarget(BaseObject) then
          Result := True;
      end;
    end;
  end;
var
  bo35: Boolean;
  i, n20, n24, n28: Integer;
  PoseCreate: TBaseObject;
  BaseObject_30: TBaseObject;
  BaseObject_34: TBaseObject;
  BaseObject_38: TBaseObject;
  nX, nY: Integer;
begin
  Result := False;
  if not (nDir in [0..7]) then
    Exit;

  nMagicLevel := _MIN(4, nMagicLevel);
  bo35 := True;
  m_btDirection := nDir;
  BaseObject_34 := nil;
  BaseObject_38 := nil;
  n24 := nMagicLevel + 1;
  n28 := n24;
  PoseCreate := GetPoseCreate();
  if PoseCreate <> nil then
  begin
    for i := 0 to _MAX(2, nMagicLevel + 1) do
    begin
      PoseCreate := GetPoseCreate();
      if PoseCreate <> nil then
      begin
        n28 := 0;
        if not CanMotaebo(PoseCreate) then
          Break;
        if nMagicLevel >= 3 then
        begin
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
          begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            BaseObject_38 := BaseObject_30;
            if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30) then
            begin
              if BaseObject_30.CharPushed(m_btDirection, 1, True, nMagicLevel) > 0 then
                Inc(BaseObject_30.m_nPushedCount);
              //BaseObject_30.m_nCharStatus := BaseObject_30.GetCharStatus();
              //BaseObject_30.StatusChanged();
            end;
          end;
        end;
        BaseObject_34 := PoseCreate;
        if PoseCreate.CharPushed(m_btDirection, 1, True, nMagicLevel) <> 1 then
          Break;
        Inc(PoseCreate.m_nPushedCount);

        GetFrontPosition(nX, nY);
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
          bo35 := False;
          Result := True;
        end;
        Dec(n24);
      end;
    end;
  end
  else
  begin
    bo35 := False;
    for i := 0 to _MAX(2, nMagicLevel + 1) do
    begin
      GetFrontPosition(nX, nY);
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
      begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        SendRefMsg(RM_RUSH, nDir, nX, nY, 0, '');
        Dec(n28);
      end
      else if m_PEnvir.CanWalk(nX, nY, True) then
        n28 := 0
      else
      begin
        bo35 := True;
        Break;
      end;
    end;
  end;
  if (BaseObject_34 <> nil) then
  begin
    if n24 < 0 then
      n24 := 0;
    n20 := Random((n24 + 1) * 10) + ((n24 + 1) * 10);
    n20 := BaseObject_34.GetHitStruckDamage(Self, n20);
    BaseObject_34.StruckDamage(Self, n20, 0);
    BaseObject_34.SendRefMsg(RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then
      BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, n20, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');

    BaseObject_34.DMSkillFix();
  end;

  if BaseObject_38 <> nil then
  begin
    BaseObject_38.DMSkillFix();
  end;

  if bo35 then
  begin
    GetFrontPosition(nX, nY);
    SendRefMsg(RM_RUSHKUNG, m_btDirection, nX, nY, 0, '');
    SysMsg(sMateDoTooweak {³å×²Á¦²»¹»£¡}, c_Red, t_Hint);
  end;
  if n28 > 0 then
  begin
    if n24 < 0 then
      n24 := 0;
    n20 := Random(n24 * 10) + ((n24 + 1) * 3);
    n20 := GetHitStruckDamage(Self, n20);
    StruckDamage(nil, n20, 0);
    SendRefMsg(RM_STRUCK, n20, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
  end;
end;

{$IF SERIESSKILL}

function TPlayObject.DoMotaeboEx(nDir: Byte; nMagicLevel: Integer): Boolean;

  procedure BreakDefenceProtector(BaseObject: TBaseObject);
  var
    b: Boolean;
  begin
    if BaseObject.m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] <> 0 then
    begin
      BaseObject.m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] := 1;
      BaseObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 19, 0, 0, '');
    end;
    b := False;
    if BaseObject.m_wStatusTimeArr[STATE_DEFENCEUP] <> 0 then
    begin
      BaseObject.m_wStatusTimeArr[STATE_DEFENCEUP] := 1;
      b := True;
    end;
    if BaseObject.m_wStatusTimeArr[STATE_MAGDEFENCEUP] <> 0 then
    begin
      BaseObject.m_wStatusTimeArr[STATE_MAGDEFENCEUP] := 1;
      b := True;
    end;
    if b then
      BaseObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 20, 0, 0, '');
  end;

  function CanMotaebo(BaseObject: TBaseObject): Boolean; //0x004C30B0
  var
    nC: Integer;
  begin
    Result := False;
    if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then
    begin
      nC := m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then
      begin
        if IsProperTarget(BaseObject) then
          Result := True;
      end;
    end;
  end;

var
  i, nstep, nPower: Integer;
  PoseCreate: TBaseObject;
  BaseObject_30: TBaseObject;
  BaseObject_34: TBaseObject;
  BaseObject_38: TBaseObject;
  nX, nY: Integer;
begin
  Result := False;
  nMagicLevel := _MIN(5, nMagicLevel);
  if not (nDir in [0..7]) then
    Exit;
  m_btDirection := nDir;
  BaseObject_34 := nil;
  BaseObject_38 := nil;
  PoseCreate := GetPoseCreate();
  if PoseCreate <> nil then
  begin
    nstep := 0;
    for i := 0 to (nMagicLevel + 1) do
    begin
      PoseCreate := GetPoseCreate();
      if PoseCreate <> nil then
      begin
        if IsProperTarget(PoseCreate) then
          BaseObject_34 := PoseCreate;

        if not CanMotaebo(PoseCreate) then
          Break;

        if nMagicLevel >= 3 then
        begin //µÚ¶þÈË
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
          begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            if (BaseObject_30 <> nil) then
            begin
              if IsProperTarget(BaseObject_30) then
                BaseObject_38 := BaseObject_30;
              if CanMotaebo(BaseObject_30) then
              begin
                if BaseObject_30.CharPushed(m_btDirection, 1) > 0 then
                  Inc(BaseObject_30.m_nPushedCount);
              end;
            end;
          end;
        end;

        BaseObject_34 := PoseCreate;
        if PoseCreate.CharPushed(m_btDirection, 1) <> 1 then
          Break;
        Inc(PoseCreate.m_nPushedCount);
        //×Ô¼ºÐ§¹û
        GetFrontPosition(nX, nY);
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          Inc(nstep);
          if nstep >= 3 then
            Break;
          Result := True;
        end;
      end;
    end;
    SendRefMsg(RM_RUSHEX, nDir, m_nCurrX, m_nCurrY, nstep, '');
    m_dwReadySeriesSkillTick := GetTickCount();
    m_dwCanNextMoveTick := GetTickCount();
    m_boSuperMode := True;
    m_dwSuperManTick := GetTickCount();
  end
  else
  begin
    nstep := 0;
    for i := 0 to (nMagicLevel + 1) do
    begin
      PoseCreate := GetPoseCreate();
      if PoseCreate <> nil then
      begin
        if IsProperTarget(PoseCreate) then
          BaseObject_34 := PoseCreate;

        if nMagicLevel >= 3 then
        begin //µÚ¶þÈË
          if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
          begin
            BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
            if (BaseObject_30 <> nil) then
            begin
              if IsProperTarget(BaseObject_30) then
                BaseObject_38 := BaseObject_30;
            end;
          end;
        end;
        Break;
      end;

      GetFrontPosition(nX, nY);
      if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
      begin
        m_nCurrX := nX;
        m_nCurrY := nY;
        Inc(nstep);
        if nstep >= 3 then
          Break;
      end
      else
      begin
        Break;
      end;
    end;
    SendRefMsg(RM_RUSHEX, nDir, m_nCurrX, m_nCurrY, nstep, '');
    m_dwReadySeriesSkillTick := GetTickCount();
    m_dwCanNextMoveTick := GetTickCount();
    m_boSuperMode := True;
    m_dwSuperManTick := GetTickCount();
  end;

  if (BaseObject_34 <> nil) then
  begin
    if Random(100) < (nMagicLevel * 10 + 30) then
    begin
      BreakDefenceProtector(BaseObject_34);
    end;
    nPower := Round(GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))) * 1.25 / 100 * g_Config.nPowerRateOfSeriesSkill_100);
    nPower := GetSeriesSkillDamage(100, nPower);
    nPower := BaseObject_34.GetHitStruckDamage(Self, nPower);
    BaseObject_34.StruckDamage(Self, nPower, 0);
    //BaseObject_34.SendRefMsg(RM_STRUCK, nPower, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(self), '');
    BaseObject_34.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nPower, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '', 480);
    if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then
      BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, nPower, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
    BaseObject_34.MagDontMove(2);
    Result := True;
  end;
  if (BaseObject_38 <> nil) then
  begin
    if Random(100) < (nMagicLevel * 10 + 30) then
    begin
      BreakDefenceProtector(BaseObject_38);
    end;
    nPower := Round(GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)))) * 1.25 / 100 * g_Config.nPowerRateOfSeriesSkill_100);
    nPower := GetSeriesSkillDamage(100, nPower);
    nPower := BaseObject_38.GetHitStruckDamage(Self, nPower);
    BaseObject_38.StruckDamage(Self, nPower, 0);
    //BaseObject_38.SendRefMsg(RM_STRUCK, nPower, BaseObject_38.m_WAbil.HP, BaseObject_38.m_WAbil.MaxHP, Integer(self), '');
    BaseObject_38.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nPower, BaseObject_38.m_WAbil.HP, BaseObject_38.m_WAbil.MaxHP, Integer(Self), '', 480);
    if BaseObject_38.m_btRaceServer <> RC_PLAYOBJECT then
      BaseObject_38.SendMsg(BaseObject_38, RM_STRUCK, nPower, BaseObject_38.m_WAbil.HP, BaseObject_38.m_WAbil.MaxHP, Integer(Self), '');
    BaseObject_38.MagDontMove(2);
    Result := True;
  end;
end;
{$IFEND SERIESSKILL}

procedure TBaseObject.DMSkillFix();
begin
  if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    if (m_wStatusTimeArr[POISON_PURPLE] > 0) then
    begin
      m_wStatusTimeArr[POISON_PURPLE] := m_wStatusTimeArr[POISON_PURPLE] + 1;
      m_dwStatusArrTick[POISON_PURPLE] := GetTickCount();
    end;
  end;
end;

procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer); //004C1268
begin
  if m_boFastTrain then
    nTranPoint := nTranPoint * 3;
  Inc(UserMagic.nTranPoint, nTranPoint);
end;

function TBaseObject.MagicMaxTrainLevel(UserMagic: pTUserMagic): Integer;
begin
  Result := UserMagic.MagicInfo.btTrainLv;
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    case UserMagic.MagicInfo.wMagicId of
      101, 107, 108: Result := _MAX(0, TPlayObject(Self).m_VenationInfos[0].Level - 1);
      100, 104, 109: Result := _MAX(0, TPlayObject(Self).m_VenationInfos[1].Level - 1);
      102, 105, 110: Result := _MAX(0, TPlayObject(Self).m_VenationInfos[2].Level - 1);
      103, 106, 111: Result := _MAX(0, TPlayObject(Self).m_VenationInfos[3].Level - 1);
    end;
  end;
end;

function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic; bHighLv: Boolean): Boolean;
var
  n10, n14: Integer;
begin
  Result := False;
  if bHighLv then
    n10 := 15
  else
    n10 := MagicMaxTrainLevel(UserMagic);

  if (n10 > UserMagic.btLevel) and (UserMagic.MagicInfo.MaxTrain[UserMagic.btLevel] <= UserMagic.nTranPoint) then
  begin
    if (n10 > UserMagic.btLevel) then
    begin
      Dec(UserMagic.nTranPoint, UserMagic.MagicInfo.MaxTrain[UserMagic.btLevel]);
      Inc(UserMagic.btLevel);
      if bHighLv then
        n14 := 10
      else
        n14 := 800;
      SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, UserMagic.MagicInfo.btClass, UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint, '', n14);
      CheckSkillShowHP(UserMagic);

      if UserMagic.wMagIdx in [100..111] then
      begin
        RecalcAbilitys();
        if m_MagicArr[0][UserMagic.wMagIdx] <> nil then
          SendMsg(Self, RM_MAGIC_MAXLV, m_MagicArr[0][UserMagic.wMagIdx].MagicInfo.btClass, m_MagicArr[0][UserMagic.wMagIdx].MagicInfo.wMagicId, MagicMaxTrainLevel(m_MagicArr[0][UserMagic.wMagIdx]), 0, '');
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        SendRefMsg(RM_STRUCKEFFECTEX, 0, 18, 0, 0, '');
      end;

    end
    else
      UserMagic.nTranPoint := UserMagic.MagicInfo.MaxTrain[UserMagic.btLevel];
    Result := True;
  end;
end;

function TBaseObject.AutoTakeOnItem(btWhere: Byte; sItemName: string; const boBagItem: Boolean = True): Boolean;
var
  i, nIndex: Integer;
  UserItem: pTUserItem;
  DelItemList: TStringList;
  fTakeOn: Boolean;
begin
  Result := False;
  if not (btWhere in [Low(THumanUseItems)..High(THumanUseItems)]) then
    Exit;
  if boBagItem then
  begin
    DelItemList := nil;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      fTakeOn := False;
      UserItem := m_ItemList.Items[i];
      if sItemName = UserEngine.GetStdItemName(UserItem.wIndex) then
      begin
        nIndex := UserItem.MakeIndex;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
          begin
            Continue;
          end;
        end;
        if IsHero then
        begin
          if TPlayObject(m_Master).ClientHeroTakeOnItems(btWhere, UserItem.MakeIndex, sItemName) > 0 then
          begin
            Result := True;
            fTakeOn := True;
          end;
        end
        else if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if TPlayObject(Self).ClientTakeOnItems(btWhere, UserItem.MakeIndex, sItemName) > 0 then
          begin
            Result := True;
            fTakeOn := True;
          end;
        end;
        if fTakeOn then
        begin
          if DelItemList = nil then
            DelItemList := TStringList.Create;
          DelItemList.AddObject(sItemName, TObject(nIndex));
        end;
        Break;
      end;
    end;
    if DelItemList <> nil then
      SendDelayMsg(Self, RM_SENDDELITEMLIST, 1, Integer(DelItemList), 0, 0, '', 100);
  end
  else
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
    begin
      m_UseItems[btWhere] := UserItem^;
      Dispose(UserItem);
      Result := True;
    end
    else
      Dispose(UserItem);
  end;
end;

function TBaseObject.HeroDoSpell(UserMagic: pTUserMagic; TagObject: TBaseObject; var boTrainOk: Boolean): Boolean;
var
  boSpellOK, boUseOK: Boolean;
  i, nType, nDur, nAmuletIdx, nDura: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
resourcestring
  sNoCharmMsg = '°ü¹ü»òÉíÉÏÃ»ÓÐ»¤Éí·û';
  sNoPoisonMsg1 = '°ü¹ü»òÉíÉÏÃ»ÓÐ»ÒÉ«Ò©·Û';
  sNoPoisonMsg2 = '°ü¹ü»òÉíÉÏÃ»ÓÐ»ÆÉ«Ò©·Û';
begin
  Result := False;
  boTrainOk := False;
  if (UserMagic <> nil) and (TagObject <> nil) then
  begin
    if g_Config.boHeroNeedAmulet then
    begin
      boSpellOK := True;
      if UserMagic.MagicInfo.wMagicId in [13..19, 30, 43, 55, 57] then
      begin
        if UserMagic.MagicInfo.wMagicId in [30, 43] then
          nDur := 5
        else
          nDur := 1;
        if not CheckAmulet(TPlayObject(Self), nDur, 1, nAmuletIdx) then
        begin
          if IsHero then
            boUseOK := True
          else
            boUseOK := False;
          if not AutoTakeOnItem(U_ARMRINGL, '»¤Éí·û(´ó)', boUseOK) and not AutoTakeOnItem(U_ARMRINGL, '»¤Éí·û', boUseOK) then
          begin
            if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
            begin
              m_dwHintMsgTick := GetTickCount();
              SysMsg(sNoCharmMsg, c_Purple, t_Hint);
            end;
            Exit;
          end;
        end;
      end;
    end
    else
    begin
      if IsHero then
      begin
        if UserMagic.MagicInfo.wMagicId in [13..19, 30, 43, 55, 57] then
        begin
          nType := 1; //·û
          if UserMagic.MagicInfo.wMagicId in [30, 43] then
            nDur := 5
          else
            nDur := 1;
        end
        else if UserMagic.MagicInfo.wMagicId in [6, 38] then
        begin
          nType := 2; //¶¾
          nDur := 1;
        end
        else
          nType := 0;

        if nType in [1, 2] then
        begin
          boSpellOK := False;
          if CheckAmuletEx(TPlayObject(Self), nDur, nType, nAmuletIdx) then
          begin
            boSpellOK := True;
            UseAmulet(TPlayObject(Self), nDur, 1, nAmuletIdx);
          end
          else
          begin
            with Self as THeroObject do
            begin
              case nType of
                1: if (m_nLatestFireChamIdx >= 0) and (m_nLatestFireChamIdx < m_ItemList.Count) then
                  begin //·û
                    UserItem := m_ItemList[m_nLatestFireChamIdx];
                    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                    if StdItem <> nil then
                    begin
                      if (StdItem.StdMode = 25) and (StdItem.Shape = 5) then
                      begin
                        nDura := UserItem.Dura;
                        Dec(nDura, nDur * 100);
                        if nDura <= 0 then
                        begin
                          TPlayObject(Self).SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(m_nLatestFireChamIdx);
                          m_nLatestFireChamIdx := -1;
                        end
                        else
                        begin
                          UserItem.Dura := nDura;
                          TPlayObject(Self).SendUpdateItem(UserItem);
                        end;
                        boSpellOK := True;
                      end
                      else
                        m_nLatestFireChamIdx := -1;
                    end;
                  end;
                2:
                  begin
                    case m_btUseAmulet of
                      1: if (m_nLatestAmuounsulIdx1 >= 0) and (m_nLatestAmuounsulIdx1 < m_ItemList.Count) then
                        begin //¶¾
                          UserItem := m_ItemList[m_nLatestAmuounsulIdx1];
                          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                          if (StdItem <> nil) and (StdItem.StdMode = 25) and (StdItem.Shape = 1) then
                          begin
                            nDura := UserItem.Dura;
                            Dec(nDura, nDur * 100);
                            if nDura <= 0 then
                            begin
                              TPlayObject(Self).SendDelItems(UserItem);
                              Dispose(UserItem);
                              m_ItemList.Delete(m_nLatestAmuounsulIdx1);
                              m_nLatestAmuounsulIdx1 := -1;
                            end
                            else
                            begin
                              UserItem.Dura := nDura;
                              TPlayObject(Self).SendUpdateItem(UserItem);
                            end;
                            boSpellOK := True;
                          end
                          else
                            m_nLatestAmuounsulIdx1 := -1;
                        end;
                      2: if (m_nLatestAmuounsulIdx2 >= 0) and (m_nLatestAmuounsulIdx2 < m_ItemList.Count) then
                        begin //¶¾
                          UserItem := m_ItemList[m_nLatestAmuounsulIdx2];
                          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                          if (StdItem <> nil) and (StdItem.StdMode = 25) and (StdItem.Shape = 2) then
                          begin
                            nDura := UserItem.Dura;
                            Dec(nDura, nDur * 100);
                            if nDura <= 0 then
                            begin
                              TPlayObject(Self).SendDelItems(UserItem);
                              Dispose(UserItem);
                              m_ItemList.Delete(m_nLatestAmuounsulIdx2);
                              m_nLatestAmuounsulIdx2 := -1;
                            end
                            else
                            begin
                              UserItem.Dura := nDura;
                              TPlayObject(Self).SendUpdateItem(UserItem);
                            end;
                            boSpellOK := True;
                          end
                          else
                            m_nLatestAmuounsulIdx2 := -1;
                        end;
                    end;
                  end;
              end;
              if not boSpellOK then
              begin
                for i := m_ItemList.Count - 1 downto 0 do
                begin
                  UserItem := m_ItemList[i];
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if StdItem <> nil then
                  begin
                    if (StdItem.StdMode = 25) then
                    begin
                      case nType of
                        1: boUseOK := (StdItem.Shape = 5); //·û
                        2: boUseOK := (StdItem.Shape = m_btUseAmulet); //¶¾
                      end;
                      if boUseOK then
                      begin
                        nDura := UserItem.Dura;
                        Dec(nDura, nDur * 100);
                        if nDura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(i);
                          case nType of
                            1: m_nLatestFireChamIdx := -1; //·û
                            2: case m_btUseAmulet of
                                1: m_nLatestAmuounsulIdx1 := -1;
                                2: m_nLatestAmuounsulIdx2 := -1;
                              end;
                          end;
                        end
                        else
                        begin
                          UserItem.Dura := nDura;
                          SendUpdateItem(UserItem);
                          case nType of
                            1: m_nLatestFireChamIdx := i; //·û
                            2: case m_btUseAmulet of
                                1: m_nLatestAmuounsulIdx1 := i;
                                2: m_nLatestAmuounsulIdx2 := i;
                              end;
                          end;
                        end;
                        boSpellOK := True;
                        Break;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;

          if not boSpellOK then
          begin
            with Self as THeroObject do
            begin
              if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
              begin
                m_dwHintMsgTick := GetTickCount();
                case nType of
                  1:
                    begin
                      SysMsg(sNoCharmMsg, c_Purple, t_Hint);
                      m_nLatestFireChamIdx := -1;
                    end;
                  2: if m_btUseAmulet = 1 then
                    begin
                      SysMsg(sNoPoisonMsg1, c_Purple, t_Hint);
                      m_nLatestAmuounsulIdx1 := -1;
                    end
                    else
                    begin
                      SysMsg(sNoPoisonMsg2, c_Purple, t_Hint);
                      m_nLatestAmuounsulIdx2 := -1;
                    end;
                end;
              end;
              Exit;
            end;
          end;

        end
        else
          boSpellOK := True;
      end
      else
        boSpellOK := True;
    end;
    if boSpellOK then
    begin
      Result := TPlayObject(Self).DoSpell(UserMagic, TagObject.m_nCurrX, TagObject.m_nCurrY, TagObject, boTrainOk);
      if IsHero then
      begin
        Dec(m_nSpellTick, 450);
        m_nSpellTick := _MAX(0, m_nSpellTick);
      end;
    end;
  end;
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer; BaseObject: TBaseObject; var boTrainOk: Boolean): Boolean;
var
  nSpellPoint: Integer;
begin
  Result := False;
  try
    if (UserMagic <> nil) and not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        nSpellPoint := GetSpellPoint(UserMagic);
        if (nSpellPoint > 0) then
        begin

          if (UserMagic.wMagIdx in [104..111]) or ((UserMagic.wMagIdx in [68, 78]) and not g_Config.boSkill_68_MP) then
          begin
            if m_nInPowerPoint < nSpellPoint then
            begin
              if IsHero and (GetTickCount - m_dwHintMsgTick > 15 * 1000) then
              begin
                m_dwHintMsgTick := GetTickCount();
                SysMsg(Format('ÊÍ·Å%sÖÁÉÙÐèÒª%dµãÄÚÁ¦Öµ', [UserMagic.MagicInfo.sMagicName, nSpellPoint]), c_Red, t_Hint);
              end;
              Exit;
            end;
            Dec(m_nInPowerPoint, nSpellPoint);
            TPlayObject(Self).InternalPowerPointChanged(True);
          end
          else
          begin
            if m_WAbil.MP < nSpellPoint then
            begin
              if IsHero and (GetTickCount - m_dwHintMsgTick > 15 * 1000) then
              begin
                m_dwHintMsgTick := GetTickCount();
                SysMsg(Format('ÊÍ·Å%sÖÁÉÙÐèÒª%dµãÄ§·¨Öµ', [UserMagic.MagicInfo.sMagicName, nSpellPoint]), c_Red, t_Hint);
              end;
              Exit;
            end;
            DamageSpell(nSpellPoint);
            HealthSpellChanged();
          end;
        end;
      end;

      Result := MagicManager.DoSpell(Self, UserMagic, nTargetX, nTargetY, BaseObject, boTrainOk);

      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        if Result and (m_nInPowerLevel > 0) then
        begin
          Dec(m_nPerInPower);
          m_dwIncInPowerTick := 0;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format('[Exception] TPlayObject.DoSpell MagID:%d X:%d Y:%d', [UserMagic.wMagIdx, nTargetX, nTargetY]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.PileEarth(nX, nY, Shape, EventId: Integer): Boolean; //004CB64C
var
  Event: TEvent;
  sSENDMSG: string;

  UserItem: pTUserItem;
  pDigItem: pTDigItem;
  Abil: array[0..3] of TEvaAbil;
  StdItem: pTStdItem;

  function GetDigItem(List: TList): Boolean;
  var
    ret: Byte;
    i, nInteger: Integer;
    dwInt: LongWord;
  begin
    Result := False;
    if (List.Count > 0) and (m_DetectItem.MakeIndex > 0) then
    begin
      pDigItem := List.Items[Random(List.Count)];
      if Random(pDigItem.nRate) = 0 then
      begin
        if UseItemSpiritQuality(@m_DetectItem, ret) > 0 then
        begin
          if ret = 0 then
            SysMsg('ÄãµÄÁéÃ½Æ·ÖÊÒÑ¾­ÏûºÄ¾¡£¬²»ÄÜÔÙÌ½Ë÷ºÍÍÚÈ¡µ½±¦Îï£¬Çë¼°Ê±¸ü»»', c_Red, t_Hint);

          SendUpdateDetectItem(m_DetectItem);

          if CompareText(pDigItem.sName, 'ÉùÍû') = 0 then
          begin
            m_btCreditPoint := _MIN(High(Byte), m_btCreditPoint + pDigItem.nCnt);
            //SysMsg(Format('»ñµÃ%d%s£¬µ±Ç°%s£º%d', [pDigItem.nCnt, pDigItem.sName, pDigItem.sName, m_btCreditPoint]), c_Green, t_Hint);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else if CompareText(pDigItem.sName, '¾­Ñé') = 0 then
          begin
            if m_Abil.Exp + LongWord(pDigItem.nCnt) > High(LongWord) then
              dwInt := High(LongWord) - m_Abil.Exp
            else
              dwInt := LongWord(pDigItem.nCnt);
            GetExp(dwInt, True, False);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else if CompareText(pDigItem.sName, 'Áé·û') = 0 then
          begin
            m_nGameGird := _MIN(High(Word), m_nGameGird + pDigItem.nCnt);
            SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
            //SysMsg(Format('»ñµÃ%d%s£¬µ±Ç°%s£º%d', [pDigItem.nCnt, pDigItem.sName, pDigItem.sName, m_nGameGird]), c_Green, t_Hint);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else if CompareText(pDigItem.sName, '½ð¸ÕÊ¯') = 0 then
          begin
            m_nGameDiamond := _MIN(High(Word), m_nGameDiamond + pDigItem.nCnt);
            SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
            //SysMsg(Format('»ñµÃ%d%s£¬µ±Ç°%s£º%d', [pDigItem.nCnt, pDigItem.sName, pDigItem.sName, m_nGameDiamond]), c_Green, t_Hint);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else if CompareText(pDigItem.sName, 'ÄÚ¹¦¾­Ñé') = 0 then
          begin
            if m_dwInPowerExp + LongWord(pDigItem.nCnt) > High(LongWord) then
              dwInt := High(LongWord) - m_dwInPowerExp
            else
              dwInt := LongWord(pDigItem.nCnt);
            GetExp(dwInt, True, True);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else if CompareText(pDigItem.sName, 'Ôª±¦') = 0 then
          begin
            if (m_nGameGold + pDigItem.nCnt) < High(Integer) then
            begin
              Inc(m_nGameGold, pDigItem.nCnt);
              nInteger := pDigItem.nCnt;
            end
            else
            begin
              nInteger := High(Integer) - m_nGameGold;
              m_nGameGold := High(Integer);
            end;
            GameGoldChanged();
            if g_boGameLogGameGold then
            begin
              AddGameDataLogAPI(Format(g_sGameLogMsg1, [LOG_GAMEGOLD,
                m_sMapName,
                  m_nCurrX,
                  m_nCurrY,
                  m_sCharName,
                  g_Config.sGameGoldName,
                  nInteger,
                  '+',
                  'ÍÚ±¦']));
            end;
            //SysMsg(Format('»ñµÃ%s£º%d£¬µ±Ç°%s£º%d', [pDigItem.sName, pDigItem.nCnt, pDigItem.sName, m_nGameGold]), c_Blue, t_Hint);
            if g_HintItemList.Exists(pDigItem.sName) then
              UserEngine.SendBroadCastMsg(Trim(Format('%s»ñµÃ%s%d', [m_sCharName, pDigItem.sName, pDigItem.nCnt])), t_SysRight);
          end
          else
          begin
            ret := 0;
            for i := 0 to _MIN(9, pDigItem.nCnt - 1) do
            begin //×î¶à10¼þ
              New(UserItem);
              if UserEngine.CopyToUserItemFromName(pDigItem.sName, UserItem) then
              begin
                //±Ø³öÉñÃØÊôÐÔ
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);

                //Shape = 75..77

                if (StdItem.Eva.EvaTimesMax > 0) and (StdItem.StdMode in [5, 6, 10..13, 15..24, 26..30, 51..54, 62..64]) then
                begin
                  SetItemEvaInfo(UserItem, t_AdvAbilMax, 1 + Random(79 - Shape), Abil);
                end;

                if IsEnoughBag then
                begin
                  m_ItemList.Add(UserItem);
                  WeightChanged();
                  SendAddItem(UserItem);
                end
                else
                begin
                  DropItemDown(UserItem, 3, False, Self, nil);
                  Dispose(UserItem);
                end;
                Inc(ret);
                //SysMsg(Format('»ñµÃÎïÆ·%s(%d)', [pDigItem.sName, 1]), c_Blue, t_Hint);
              end
              else
                Dispose(UserItem);
            end;
            if (ret > 0) and g_HintItemList.Exists(pDigItem.sName) then
            begin //0406
              if ret = 1 then
                UserEngine.SendBroadCastMsg(Trim(Format('%sÔÚ%s»Ó¶¯²ù×Ó£¬ÍÚµ½±¦Îï£º%s', [m_sCharName, m_PEnvir.m_sMapDesc, pDigItem.sName])), t_System)
              else
                UserEngine.SendBroadCastMsg(Trim(Format('%sÔÚ%s»Ó¶¯²ù×Ó£¬ÍÚµ½±¦Îï£º%s %d', [m_sCharName, m_PEnvir.m_sMapDesc, pDigItem.sName, ret])), t_System);
            end;
          end;

          //DoDamageWeapon(Random(25) + 10);

          SendRefMsg(RM_FIREWORKS, 0, 8, nX, nY, '');
          SendDelayMsg(Self, RM_STRUCKEFFECTEX_DELAY, 0, 32, 0, Integer(Self), '', 220);

          if m_MagicArr[0][67] <> nil then
          begin
            TrainSkill(m_MagicArr[0][67], Random(3) + 1);
            if not CheckMagicLevelup(m_MagicArr[0][67]) then
            begin
              SendDelayMsg(Self,
                RM_MAGIC_LVEXP,
                0,
                m_MagicArr[0][67].MagicInfo.wMagicId,
                m_MagicArr[0][67].btLevel,
                m_MagicArr[0][67].nTranPoint,
                '', 1000);
            end;
          end;

          if (g_FunctionNPC <> nil) then
          begin
            g_FunctionNPC.m_OprCount := 0;
            g_FunctionNPC.GotoLable(TPlayObject(Self), '@DigItem', False);
          end;
        end
        else
        begin
          SysMsg('ÁéÃ½µÄÆ·ÖÊÌ«µÍÁË£¬Äã½«²»ÄÜ»ñÈ¡ÎïÆ·£¡', c_Red, t_Hint);
        end;
        Result := True;
      end;
    end;
  end;
begin
  Result := False;
  //sSENDMSG := '';
  if (m_DetectItem.MakeIndex = 0) then
    Exit;

  Event := TEvent(m_PEnvir.GetRangeEvent(nX, nY, Shape - 74, EventId));

  if (Event <> nil) and (Event.m_nEventType in [ET_ITEMMINE1..ET_ITEMMINE3]) then
  begin
    SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, sSENDMSG);
    if TStoneMineEvent(Event).m_nMineCount > 0 then
    begin
      Dec(TStoneMineEvent(Event).m_nMineCount);
      if Random(g_Config.nMakeItemButchRate {4}) = 0 then
      begin
        if Random(g_Config.nMakeItemRate {10} + (Shape - 75) * 4) = 0 then
        begin //²ù×Ó¼¸ÂÊ
          if m_ItemList.Count < GetMaxBagItem then
          begin
            case m_DetectItem.btValueEx[17] of
              001..050:
                begin
                  GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[0]);
                end;
              051..100:
                begin
                  if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[1]) then
                  begin
                    GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[0]);
                  end;
                end;
              101..150:
                begin
                  if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[2]) then
                  begin
                    if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[1]) then
                    begin
                      GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[0]);
                    end;
                  end;
                end;
              151..250:
                begin
                  if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[3]) then
                  begin
                    if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[2]) then
                    begin
                      if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[1]) then
                      begin
                        GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[0]);
                      end;
                    end;
                  end;
                end;
              251..255:
                begin
                  if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[4]) then
                  begin
                    if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[3]) then
                    begin
                      if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[2]) then
                      begin
                        if not GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[1]) then
                        begin
                          GetDigItem(m_PEnvir.m_MapFlag.pDigItemList[0]);
                        end;
                      end;
                    end;
                  end;
                end;
            end;
          end;
        end;
        //sSENDMSG := '1';
        DoDamageWeapon(Random(15) + 5);
        Result := True;
      end;
    end
    else
    begin
      if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) > 8 * 60 * 1000 then
      begin
        TStoneMineEvent(Event).AddStoneMine();
      end
      else
        SysMsg('´ËµØÎÞÒøÈý°ÙÁ½£¡', c_Red, t_Hint);
    end;
  end;
end;

function TPlayObject.PileStones(nX, nY: Integer): Boolean; //004CB64C
var
  Event: TEvent;
  PileEvent: TEvent;
  sSENDMSG: string;
begin
  Result := False;
  sSENDMSG := '';
  Event := TEvent(m_PEnvir.GetEvent(nX, nY));
  if (Event <> nil) and (Event.m_nEventType = ET_STONEMINE) then
  begin
    if TStoneMineEvent(Event).m_nMineCount > 0 then
    begin
      Dec(TStoneMineEvent(Event).m_nMineCount);
      if Random(g_Config.nMakeMineHitRate {4}) = 0 then
      begin

        //0710
        PileEvent := TEvent(m_PEnvir.GetEvent(m_nCurrX, m_nCurrY));
        if PileEvent = nil then
        begin
          PileEvent := TPileStones.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_PILESTONES, 5 * 60 * 1000);
          g_EventManager.AddEvent(PileEvent);
        end
        else if PileEvent.m_nEventType = ET_PILESTONES then
          TPileStones(PileEvent).AddEventParam;

        if Random(g_Config.nMakeMineRate {12}) = 0 then
        begin
          MakeMine();
        end;
        sSENDMSG := '1';
        DoDamageWeapon(Random(15) + 5);
        Result := True;
      end;
    end
    else if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) > 10 * 60 * 1000 then
      TStoneMineEvent(Event).AddStoneMine();
  end;
  SendRefMsg(RM_HEAVYHIT, m_btDirection, m_nCurrX, m_nCurrY, 0, sSENDMSG);
end;

function TPlayObject.GetNearNumbusPoints(): Integer;
var
  n, x, y: Integer;
  Event: TEvent;
  BaseObject: TBaseObject;
begin
  Result := 0;
  if (m_PEnvir = nil) or (m_PEnvir.NimbusCount <= 0) then
    Exit;
  for x := m_nCurrX - 3 to m_nCurrX + 3 do
  begin
    for y := m_nCurrY - 3 to m_nCurrY + 3 do
    begin
      if not m_PEnvir.CanWalk(x, y, True) then
        Continue;
      Event := TEvent(m_PEnvir.GetEvent(x, y));
      if (Event = nil) or not (Event.m_nEventType in [ET_NIMBUS_1, ET_NIMBUS_2, ET_NIMBUS_3]) then
        Continue;
      n := 0;
      BaseObject := m_PEnvir.GetMovingObjectA(x, y, True);
      if (BaseObject <> nil) and not BaseObject.m_boGhost and not BaseObject.m_boDeath and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
        n := 2;
      Inc(Result, (Event.m_nEventType - 49) * 5 - n);
    end;
  end;
end;

procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
var
  HeroObject: TBaseObject;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) and g_Config.boHeroSystem then
  begin
    m_dwTargetFocusTick := GetTickCount();
    if m_TargetCret <> BaseObject then
    begin
      m_TargetCret := BaseObject;
      with TPlayObject(Self) do
      begin
        HeroObject := GetHeroObjectA;
        if (HeroObject <> nil) then
        begin
          if not HeroObject.m_boJointAttackReady then
            Exit;
          if g_Config.boHeroAutoLockTarget and (m_TargetCret <> nil) then
          begin
            if IsProperTarget(m_TargetCret) then
            begin
              if m_btHeroRelax <> 0 then
                m_btHeroRelax := 0;

              if m_boHeroSearchTag then
              begin
                m_boHeroSearchTag := False;
                TAnimalObject(HeroObject).m_nTargetX2 := -1;
                TAnimalObject(HeroObject).m_nTargetY2 := -1;
              end;

              HeroObject.m_LockTarget := m_TargetCret;
              HeroObject.SetTargetCreat(m_TargetCret);
              m_dwHeroSetTargetTick := GetTickCount;
            end;
          end;
        end;
      end;
    end;
    Exit;
  end;
  m_TargetCret := BaseObject;
  m_dwTargetFocusTick := GetTickCount();
end;

procedure TBaseObject.DelTargetCreat();
begin
  m_TargetCret := nil;
end;

function TBaseObject.DirectAttack(BaseObject: TBaseObject; nSecPwr, nMid: Integer): Boolean;

  function GetDirectAttackStruckDamage1(Cert: TBaseObject; nDamage: Integer): Integer;
  var
    nAc: Integer;
  begin
    //if LoWord(Cert.m_WAbil.AC) > HiWord(Cert.m_WAbil.AC) then
    //  nAc := Round((HiWord(Cert.m_WAbil.AC) + Random(SmallInt(LoWord(Cert.m_WAbil.AC) - HiWord(Cert.m_WAbil.AC)) + 1)) / 2.3)
    //else
    //  nAc := Round((LoWord(Cert.m_WAbil.AC) + Random(SmallInt(HiWord(Cert.m_WAbil.AC) - LoWord(Cert.m_WAbil.AC)) + 1)) / 2.3);
    nAc := Round((LoWord(Cert.m_WAbil.AC) + Random(abs(HiWord(Cert.m_WAbil.AC) - LoWord(Cert.m_WAbil.AC)) + 1)) / 2.3);
    Result := _MAX(0, nDamage - nAc);
  end;

  function GetDirectAttackStruckDamage2(Cert: TBaseObject; nDamage: Integer): Integer;
  begin
    if (nDamage > 0) and Cert.m_boAbilMagBubbleDefence then
    begin
      nDamage := Round(nDamage / ((g_Config.nMagBubbleDefenceRate / 2.8) * (Cert.m_btMagBubbleDefenceLevel + 2)) * 8);
      Cert.DamageBubbleDefence(nDamage);
    end;
    if (Cert.m_btRaceServer = RC_PLAYOBJECT) or Cert.IsHero then
    begin
      if Cert.m_boAcItem then
        nDamage := Round(Cert.m_rAcItem * nDamage);
    end;
    Result := _MAX(0, nDamage);
  end;

begin
  Result := False;
  if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) or (BaseObject.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) or not (InSafeZone and BaseObject.InSafeZone) then
  begin
    if (Random(BaseObject.m_btSpeedPoint) < m_btHitPoint) or (BaseObject.IsHero and (m_btSquareHit in [1, 2])) then
    begin
      //
      if (nMid in [12, 42, 56, 61, 66]) then
      begin
        if not g_Config.boIgnoreTagDefence then
          nSecPwr := GetDirectAttackStruckDamage1(BaseObject, nSecPwr);

        if not g_Config.boIgnoreTagDefence2 then
          nSecPwr := GetDirectAttackStruckDamage2(BaseObject, nSecPwr);
      end;

      nSecPwr := BaseObject.GetDirectAttackStruckDamage(Self, nSecPwr, g_Config.boIgnoreTagDefence);
      BaseObject.StruckDamage(Self, nSecPwr, nMid);

      if nMid = 115 then
      begin
        BaseObject.SendDelayMsg(BaseObject,
          RM_STRUCKEFFECTEX_DELAY,
          0,
          30,
          0,
          Integer(BaseObject),
          '', 120);
      end;

      BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),
        RM_STRUCKEFFECT,
        nSecPwr,
        BaseObject.m_WAbil.HP,
        BaseObject.m_WAbil.MaxHP,
        Integer(Self),
        '', 400);

      if BaseObject.m_btRaceServer <> RC_PLAYOBJECT then
        BaseObject.SendMsg(BaseObject,
          RM_STRUCK,
          nSecPwr,
          BaseObject.m_WAbil.HP,
          BaseObject.m_WAbil.MaxHP,
          Integer(Self),
          '', nMid);
      Result := True;
    end;
  end;
end;

function TBaseObject.SwordLongAttack(nSecPwr: Integer): Boolean; //´ÌÉ±
var
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
  if (nSecPwr > 0) then
  begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if IsProperTarget(BaseObject, True) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr, SKILL_ERGUM);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
  end;
end;

function TBaseObject.SwordLongAttackA(nSecPwr: Integer): Boolean;
var
  nC, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
  nC := 2;
  while (True) do
  begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject, True) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr, 66);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
    Inc(nC);
    if nC >= 5 then
      Break;
  end;
end;

function TBaseObject.SwordLongAttackX(nSecPwr, step, id: Integer): Boolean;
var
  nC, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  //nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
  nC := 2;
  while (True) do
  begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject, True) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr, id);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
    Inc(nC);
    if nC >= step then
      Break;
  end;
end;

function TBaseObject.SwordLongAttackY(nSecPwr, step, id: Integer): Boolean;
var
  b: Boolean;
  nC, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  b := False;
  //nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
  nC := 1;
  Randomize();
  while (True) do
  begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject, True) then
        begin
          if Random(3) = 0 then
          begin
            if (m_MagicArr[0][id] <> nil) and (m_MagicArr[0][id].btLevel > Random(20)) then
            begin
              BaseObject.m_btDoubleDamage := 1;
              b := True;
            end;
          end
          else
          begin
            if (m_MagicArr[0][id] <> nil) and (m_MagicArr[0][id].btLevel > Random(18)) then
              BaseObject.m_btDoubleDamage := 2;
          end;
          Result := DirectAttack(BaseObject, nSecPwr, id);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
    Inc(nC);
    if nC >= step then
      Break;
  end;
  if b then
    SendDelayMsg(Self,
      RM_STRUCKEFFECTEX_DELAY,
      0,
      22,
      0,
      Integer(Self),
      '', 100);
end;

{function TBaseObject.SwordLongAttack_3(nSecPwr: Integer): Boolean;
var
  nC, nX, nY                : Integer;
  BaseObject                : TBaseObject;
begin
  Result := False;
  nC := 2;
  while (True) do begin
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, nX, nY) then begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
          Result := DirectAttack(BaseObject, nSecPwr, 102);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
    Inc(nC);
    if nC >= 5 then
      Break;
  end;
end;}

function TBaseObject.SUQAttack(nSecPwr: Integer): Boolean;
var
  nC, nCount, nDir, nX, nY, npX, npY: Integer;
  aDirAttack: array of Byte;
  BaseObject: TBaseObject;
begin
  Result := False;
  nSecPwr := Round(nSecPwr * g_Config.nSwordLongPowerRate / 100);
  nC := 0;
  while (True) do
  begin
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, npX, npY);
    if nC = 0 then
    begin
      SetLength(aDirAttack, 2);
      aDirAttack[0] := 7;
      aDirAttack[1] := 1;
    end
    else
    begin
      SetLength(aDirAttack, 3);
      aDirAttack[0] := 0;
      aDirAttack[1] := 7;
      aDirAttack[2] := 1;
    end;
    nCount := 0;
    while (True) do
    begin
      nDir := (m_btDirection + aDirAttack[nCount]) mod 8;
      if m_PEnvir.GetNextPosition(npX, npY, nDir, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr, 42);
          SetTargetCreat(BaseObject);
        end;
      end;
      if (nC = 1) and (aDirAttack[nCount] in [1, 7]) then
      begin
        if m_PEnvir.GetNextPosition(npX, npY, nDir, 2, nX, nY) then
        begin
          BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
          if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
          begin
            Result := DirectAttack(BaseObject, nSecPwr, 42);
            SetTargetCreat(BaseObject);
          end;
        end;
      end;
      Inc(nCount);
      if nCount >= Length(aDirAttack) then
        Break;
    end;
    Inc(nC);
    if nC >= 4 then
      Break;
  end;
end;

function TBaseObject.GetSUQAttack(): Boolean;
var
  nC, nCount, nDir, nX, nY, npX, npY: Integer;
  aDirAttack: array of Byte;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 0;
  while (True) do
  begin
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, nC, npX, npY);
    if nC = 0 then
    begin
      SetLength(aDirAttack, 2);
      aDirAttack[0] := 7;
      aDirAttack[1] := 1;
    end
    else
    begin
      SetLength(aDirAttack, 3);
      aDirAttack[0] := 0;
      aDirAttack[1] := 7;
      aDirAttack[2] := 1;
    end;
    nCount := 0;
    while (True) do
    begin
      nDir := (m_btDirection + aDirAttack[nCount]) mod 8;
      if m_PEnvir.GetNextPosition(npX, npY, nDir, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
        begin
          Result := True;
          Exit;
        end;
      end;
      if (nC = 1) and (aDirAttack[nCount] in [1, 7]) then
      begin
        if m_PEnvir.GetNextPosition(npX, npY, nDir, 2, nX, nY) then
        begin
          BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
          if (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
          begin
            Result := True;
            Exit;
          end;
        end;
      end;
      Inc(nCount);
      if nCount >= Length(aDirAttack) then
        Break;
    end;
    Inc(nC);
    if nC >= 4 then
      Break;
  end;
end;

function TBaseObject.SwordLongAttack61(nSecPwr: Integer): Boolean;
var
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
  begin
    BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
    if BaseObject <> nil then
    begin
      if (nSecPwr > 0) and IsProperTarget(BaseObject, True) then
      begin
        Result := DirectAttack(BaseObject, nSecPwr, 61);
        SetTargetCreat(BaseObject);
      end;
    end;
  end;
end;

function TBaseObject.SwordWideAttack(nSecPwr: Integer): Boolean; //°ëÔÂ¹¥»÷
var
  nC, n10: Integer;
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 0;
  while (True) do
  begin
    n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
      begin
        Result := DirectAttack(BaseObject, nSecPwr, 25);
        SetTargetCreat(BaseObject);
      end;
    end;
    Inc(nC);
    if nC >= 3 then
      Break;
  end;
end;

function TBaseObject.SwordWideAttack2(nSecPwr: Integer): Boolean; //°ëÔÂ¹¥»÷
const
  g_WideAttack2: array[0..4] of Byte = (6, 7, 1, 2, 3);
var
  nC, n10: Integer;
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 0;
  while (True) do
  begin
    n10 := (m_btDirection + g_WideAttack2[nC]) mod 8;
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
      begin
        Result := DirectAttack(BaseObject, nSecPwr, 25);
        SetTargetCreat(BaseObject);
      end;
    end;
    Inc(nC);
    if nC >= 5 then
      Break;
  end;
end;

function TBaseObject.CrsWideAttack(nSecPwr: Integer): Boolean;
var
  nC, n10: Integer;
  nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  Result := False;
  nC := 0;
  while (True) do
  begin
    n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject, True) then
      begin
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then //Fixed
          Result := DirectAttack(BaseObject, nSecPwr, 40)
        else
          Result := DirectAttack(BaseObject, Round(nSecPwr * 0.8), 40);
        SetTargetCreat(BaseObject);
      end;
    end;
    Inc(nC);
    if nC >= 7 then
      Break;
  end;
end;

function TBaseObject.SmiteWideAttack(nSecPwr: Integer): Boolean;
var
  i, n: Integer;
  BaseObjectList: TList;
  p, TargeTBaseObject: TBaseObject;
begin
  Result := False;
  BaseObjectList := TList.Create;
  GetMapBaseObjects(m_PEnvir, m_nCurrX, m_nCurrY, 2, BaseObjectList);
  n := 0;
  p := GetPoseCreate;
  for i := 0 to BaseObjectList.Count - 1 do
  begin
    TargeTBaseObject := TBaseObject(BaseObjectList.Items[i]);
    if p = TargeTBaseObject then
      Continue;
    if IsProperTarget(TargeTBaseObject, True) then
    begin
      SetTargetCreat(TargeTBaseObject);
      Result := DirectAttack(TargeTBaseObject, nSecPwr, 103);
      Inc(n);
    end;
    if n > 45 then
      Break;
  end;
  BaseObjectList.Free;
end;

function TBaseObject.SmiteWideAttack2(nSecPwr: Integer): Boolean;
var
  i, n: Integer;
  BaseObjectList: TList;
  p, TargeTBaseObject: TBaseObject;
begin
  Result := False;
  BaseObjectList := TList.Create;
  GetMapBaseObjects(m_PEnvir, m_nCurrX, m_nCurrY, 9, BaseObjectList);
  n := 0;
  p := GetPoseCreate;
  for i := 0 to BaseObjectList.Count - 1 do
  begin
    TargeTBaseObject := TBaseObject(BaseObjectList.Items[i]);
    if p = TargeTBaseObject then
      Continue;
    if IsProperTarget(TargeTBaseObject, True) then
    begin
      SetTargetCreat(TargeTBaseObject);
      //Result := DirectAttack(TargeTBaseObject, nSecPwr, 114);

      SendDelayMsg(Self,
        RM_DELAYMAGIC,
        2,
        MakeLong(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY),
        nSecPwr,
        Integer(TargeTBaseObject),
        '',
        500, 114);

      Result := True;
      Inc(n);
    end;
    if n > 999 then
      Break;
  end;
  BaseObjectList.Free;
end;

procedure TBaseObject.TrainCurrentSkill(t, wHitMode: Integer);
var
  nCLevel: Integer;
begin
  if t = 0 then
  begin
    if wHitMode in [20..22] then
      nCLevel := m_nInPowerLevel
    else
      nCLevel := m_Abil.Level;
  end
  else
    nCLevel := m_nInPowerLevel;

  if (m_MagicArr[t][SKILL_ONESWORD] <> nil) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (m_MagicArr[t][SKILL_ONESWORD].btLevel < m_MagicArr[t][SKILL_ONESWORD].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_ONESWORD].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_ONESWORD].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_ONESWORD], Random(3) + 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_ONESWORD]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_ONESWORD].MagicInfo.wMagicId,
          m_MagicArr[t][SKILL_ONESWORD].btLevel,
          m_MagicArr[t][SKILL_ONESWORD].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (m_MagicArr[t][SKILL_ILKWANG] <> nil) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (m_MagicArr[t][SKILL_ILKWANG].btLevel < m_MagicArr[t][SKILL_ILKWANG].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_ILKWANG].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_ILKWANG].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_ILKWANG], Random(3) + 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_ILKWANG]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_ILKWANG].MagicInfo.wMagicId,
          m_MagicArr[t][SKILL_ILKWANG].btLevel,
          m_MagicArr[t][SKILL_ILKWANG].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 3) and (m_MagicArr[t][SKILL_YEDO] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][SKILL_YEDO].btLevel < m_MagicArr[t][SKILL_YEDO].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_YEDO].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_YEDO].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_YEDO], Random(3) + 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_YEDO]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_YEDO].MagicInfo.wMagicId,
          m_MagicArr[t][SKILL_YEDO].btLevel,
          m_MagicArr[t][SKILL_YEDO].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 4) and (m_MagicArr[t][SKILL_ERGUM] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][SKILL_ERGUM].btLevel < m_MagicArr[t][SKILL_ERGUM].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_ERGUM].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_ERGUM].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_ERGUM], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_ERGUM]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_ERGUM].MagicInfo.wMagicId, m_MagicArr[t][SKILL_ERGUM].btLevel,
          m_MagicArr[t][SKILL_ERGUM].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 5) and (m_MagicArr[t][SKILL_BANWOL] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][SKILL_BANWOL].btLevel < m_MagicArr[t][SKILL_BANWOL].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_BANWOL].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_BANWOL].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_BANWOL], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_BANWOL]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_BANWOL].MagicInfo.wMagicId, m_MagicArr[t][SKILL_BANWOL].btLevel,
          m_MagicArr[t][SKILL_BANWOL].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 7) and (m_MagicArr[t][SKILL_FIRESWORD] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][SKILL_FIRESWORD].btLevel < m_MagicArr[t][SKILL_FIRESWORD].MagicInfo.btTrainLv) and
      (m_MagicArr[t][SKILL_FIRESWORD].MagicInfo.TrainLevel[m_MagicArr[t][SKILL_FIRESWORD].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][SKILL_FIRESWORD], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][SKILL_FIRESWORD]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][SKILL_FIRESWORD].MagicInfo.wMagicId,
          m_MagicArr[t][SKILL_FIRESWORD].btLevel, m_MagicArr[t][SKILL_FIRESWORD].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 9) and (m_MagicArr[t][43] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][43].btLevel < m_MagicArr[t][43].MagicInfo.btTrainLv) and
      (m_MagicArr[t][43].MagicInfo.TrainLevel[m_MagicArr[t][43].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][43], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][43]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][43].MagicInfo.wMagicId,
          m_MagicArr[t][43].btLevel, m_MagicArr[t][43].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 13) and (m_MagicArr[t][56] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][56].btLevel < m_MagicArr[t][56].MagicInfo.btTrainLv) and
      (m_MagicArr[t][56].MagicInfo.TrainLevel[m_MagicArr[t][56].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][56], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][56]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][56].MagicInfo.wMagicId,
          m_MagicArr[t][56].btLevel, m_MagicArr[t][56].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 8) and (m_MagicArr[t][40] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][40].btLevel < m_MagicArr[t][40].MagicInfo.btTrainLv) and
      (m_MagicArr[t][40].MagicInfo.TrainLevel[m_MagicArr[t][40].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][40], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][40]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][40].MagicInfo.wMagicId,
          m_MagicArr[t][40].btLevel, m_MagicArr[t][40].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 10) and (m_MagicArr[t][42] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][42].btLevel < m_MagicArr[t][42].MagicInfo.btTrainLv) and
      (m_MagicArr[t][42].MagicInfo.TrainLevel[m_MagicArr[t][42].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][42], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][42]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][42].MagicInfo.wMagicId,
          m_MagicArr[t][42].btLevel, m_MagicArr[t][42].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 12) and (m_MagicArr[t][66] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][66].btLevel < m_MagicArr[t][66].MagicInfo.btTrainLv) and
      (m_MagicArr[t][66].MagicInfo.TrainLevel[m_MagicArr[t][66].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][66], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][66]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][66].MagicInfo.wMagicId,
          m_MagicArr[t][66].btLevel, m_MagicArr[t][66].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 61) and (m_MagicArr[t][61] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][61].btLevel < m_MagicArr[t][61].MagicInfo.btTrainLv) and
      (m_MagicArr[t][61].MagicInfo.TrainLevel[m_MagicArr[t][61].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][61], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][61]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][61].MagicInfo.wMagicId,
          m_MagicArr[t][61].btLevel, m_MagicArr[t][61].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 20) and (m_MagicArr[t][101] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][101].btLevel < MagicMaxTrainLevel(m_MagicArr[t][101])) and
      (m_MagicArr[t][101].MagicInfo.TrainLevel[m_MagicArr[t][101].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][101], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][101]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][101].MagicInfo.wMagicId,
          m_MagicArr[t][101].btLevel, m_MagicArr[t][101].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 21) and (m_MagicArr[t][102] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][102].btLevel < MagicMaxTrainLevel(m_MagicArr[t][102])) and
      (m_MagicArr[t][102].MagicInfo.TrainLevel[m_MagicArr[t][102].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][102], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][102]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][102].MagicInfo.wMagicId,
          m_MagicArr[t][102].btLevel, m_MagicArr[t][102].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 22) and (m_MagicArr[t][103] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][103].btLevel < MagicMaxTrainLevel(m_MagicArr[t][103])) and
      (m_MagicArr[t][103].MagicInfo.TrainLevel[m_MagicArr[t][103].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][103], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][103]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][103].MagicInfo.wMagicId,
          m_MagicArr[t][103].btLevel, m_MagicArr[t][103].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 23) and (m_MagicArr[t][114] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][114].btLevel < MagicMaxTrainLevel(m_MagicArr[t][114])) and
      (m_MagicArr[t][114].MagicInfo.TrainLevel[m_MagicArr[t][114].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][114], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][114]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][114].MagicInfo.wMagicId,
          m_MagicArr[t][114].btLevel, m_MagicArr[t][114].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 24) and (m_MagicArr[t][113] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][113].btLevel < MagicMaxTrainLevel(m_MagicArr[t][113])) and
      (m_MagicArr[t][113].MagicInfo.TrainLevel[m_MagicArr[t][113].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][113], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][113]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][113].MagicInfo.wMagicId,
          m_MagicArr[t][113].btLevel, m_MagicArr[t][113].nTranPoint, '', 3000);
      end;
    end;
  end;

  if (wHitMode = 25) and (m_MagicArr[t][115] <> nil) and
    ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
  begin
    if (t = 1) and (m_nInPowerPoint >= 9) then
    begin
      Dec(m_nInPowerPoint, 9);
      TPlayObject(Self).InternalPowerPointChanged(True);
    end;
    if (m_MagicArr[t][115].btLevel < MagicMaxTrainLevel(m_MagicArr[t][115])) and
      (m_MagicArr[t][115].MagicInfo.TrainLevel[m_MagicArr[t][115].btLevel] <= nCLevel) then
    begin
      TPlayObject(Self).TrainSkill(m_MagicArr[t][115], 1);
      if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[t][115]) then
      begin
        SendDelayMsg(Self, RM_MAGIC_LVEXP, t,
          m_MagicArr[t][115].MagicInfo.wMagicId,
          m_MagicArr[t][115].btLevel, m_MagicArr[t][115].nTranPoint, '', 3000);
      end;
    end;
  end;

end;

function TBaseObject._Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
var
  nPower, nSecPwr, nWeaponDamage: Integer;
  boTwin, bTrain: Boolean;
  nMagIdx, n20: Integer;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::_Attack Name:= %s Code:=%d';
begin
  Result := False;
  bTrain := False;
  boTwin := False;
  nWeaponDamage := 0;

  nCheckCode := 0;
  try
    if AttackTarget <> nil then
    begin
      nCheckCode := 1;
      nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));

      if (wHitMode = 3) then
      begin
        if m_boPowerHit then
        begin
          m_boPowerHit := False;
          Inc(nPower, m_nHitPlus);
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 7) then
      begin //ÁÒ»ð½£·¨
        if m_boFireHitSkill then
        begin
          m_boFireHitSkill := False;
          if g_Config.boNoDoubleFireHit then
            m_dwLatestFireHitTick := GetTickCount();
          nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));
          nPower := Round(nPower * g_Config.nFireHitPowerRate / 100);
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 9) then
      begin
        if m_boTwinHitSkill then
        begin
          m_boTwinHitSkill := False;
          //m_boTwinHitSkillPhase := True;
          m_dwLatestTwinHitTick := GetTickCount();
          nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));
          nPower := Round(nPower / 100 * g_Config.nMagTwinPowerRate);
          boTwin := True;
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 13) then
      begin //ÖðÈÕ½£·¨
        if m_boPursueHitSkill then
        begin
          m_boPursueHitSkill := False;
          if g_Config.boNoDoublePursueHit then
            m_dwLatestPursueHitTick := GetTickCount();
          nPower := nPower + Round(nPower / 100 * (m_nHitDoubleEx * 10));
          nPower := Round(nPower * g_Config.nPursueHitPowerRate / 100);
          if nPower > 0 then
            SwordLongAttackX(nPower, 5, 56);
        end
        else
          wHitMode := 0;
{$IF SERIESSKILL}
      end
      else if (wHitMode = 20) then
      begin
        if m_boSmiteSkill then
        begin
          m_boSmiteSkill := False;
          //if g_Config.boNoDoublePursueHit then
          m_dwLatestSmiteTick := GetTickCount();
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            TPlayObject(Self).m_dwReadySeriesSkillTick := GetTickCount();
          nPower := Round((nPower + Round(nPower / 100 * (m_nHitDouble_101 * 8))) / 100 * g_Config.nPowerRateOfSeriesSkill_101);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            nPower := TPlayObject(Self).GetSeriesSkillDamage(101, nPower);
          m_boSuperMode := True;
          m_dwSuperManTick := GetTickCount();
        end
        else
          Exit;
{$IFEND SERIESSKILL}
      end;
    end
    else
    begin
      nCheckCode := 2;
      nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
      if (wHitMode = 3) then
      begin
        if m_boPowerHit then
        begin
          m_boPowerHit := False;
          Inc(nPower, m_nHitPlus);
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 7) then
      begin
        if m_boFireHitSkill then
        begin
          m_boFireHitSkill := False;
          m_dwLatestFireHitTick := GetTickCount();
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 9) then
      begin
        if m_boTwinHitSkill then
        begin
          m_boTwinHitSkill := False;
          nPower := nPower + Round(nPower / 100 * (m_nHitDouble * 10));
          nPower := Round(nPower / 100 * g_Config.nMagTwinPowerRate);
          m_dwLatestTwinHitTick := GetTickCount(); //½ûÖ¹Ë«ÁÒ»ð
          boTwin := True;
        end
        else
          wHitMode := 0;
      end
      else if (wHitMode = 13) then
      begin //ÖðÈÕ½£·¨
        if m_boPursueHitSkill then
        begin
          m_boPursueHitSkill := False;
          m_dwLatestPursueHitTick := GetTickCount();
          nPower := nPower + Round(nPower / 100 * (m_nHitDoubleEx * 10));
          nPower := Round(nPower * g_Config.nPursueHitPowerRate / 100);
          if (nPower > 0) and SwordLongAttackX(nPower, 5, 56) then
            bTrain := True;
        end
        else
          wHitMode := 0;
{$IF SERIESSKILL}
      end
      else if (wHitMode = 20) then
      begin
        if m_boSmiteSkill then
        begin
          m_boSmiteSkill := False;
          m_dwLatestSmiteTick := GetTickCount();
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            TPlayObject(Self).m_dwReadySeriesSkillTick := GetTickCount();
          nPower := Round((nPower + Round(nPower / 100 * (m_nHitDouble_101 * 8))) / 100 * g_Config.nPowerRateOfSeriesSkill_101);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            nPower := TPlayObject(Self).GetSeriesSkillDamage(101, nPower);
          m_boSuperMode := True;
          m_dwSuperManTick := GetTickCount();
        end
        else
          Exit;
{$IFEND SERIESSKILL}
      end;
    end;

    nCheckCode := 3;
    if wHitMode = 4 then
    begin //´ÌÉ±
      nSecPwr := 0;
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
      begin
        if m_MagicArr[0][SKILL_ERGUM] <> nil then
          nSecPwr := Round(nPower / (3 + 2) * (m_MagicArr[0][SKILL_ERGUM].btLevel + 2));
      end;
      if nSecPwr > 0 then
      begin
        if not SwordLongAttack(nSecPwr) then
        begin
          if g_Config.boLimitSwordLong then
            wHitMode := 0;
        end
        else
          bTrain := True;
      end;
    end;

    nCheckCode := 4;
    if (wHitMode = 12) then
    begin //¿ªÌìÕ¶
      nSecPwr := 0;
      if (m_btSquareHit in [1, 2]) then
      begin
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][66] <> nil then
            nSecPwr := Round((nPower / (3 + 2) * (m_MagicArr[0][66].btLevel + 2)) * 1.33) * m_btSquareHit;
        end;
        if nSecPwr > 0 then
        begin
          nSecPwr := Round(nSecPwr / 100 * g_Config.nSquareHitPowerRate);
          case m_btSquareHit of
            1:
              begin
                if not SwordLongAttack(nSecPwr) then
                begin
                  //if g_Config.boLimitSwordLong then
                  //  wHitMode := 0;
                end
                else
                  bTrain := True;
              end;
            2:
              begin
                if not SwordLongAttackA(nSecPwr) then
                begin
                  //if g_Config.boLimitSwordLong then
                  //  wHitMode := 0;
                end
                else
                  bTrain := True;
              end;
          end;
          m_dwLatestHeroLongHitTick := GetTickCount();
          nPower := nSecPwr;
        end;
        m_btSquareHit := 0;
      end;
    end;

    nCheckCode := 4;
    if (wHitMode = 24) then
    begin
      nSecPwr := 0;
      if m_boSmiteLongSkill2 then
      begin
        m_boSmiteLongSkill2 := False;
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][113] <> nil then
            nSecPwr := Round(nPower / 5 * (m_MagicArr[0][113].btLevel + 2));
        end;
        if nSecPwr > 0 then
        begin
          nSecPwr := Round(nSecPwr / 38 * g_Config.SmiteLongHit2PowerRate);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            nSecPwr := TPlayObject(Self).GetSeriesSkillDamage(113, nSecPwr);
          SwordLongAttackX(nSecPwr, 5, 113);
          bTrain := True;
          m_dwLatestSmiteLongTick2 := GetTickCount();
          m_boSuperMode := True;
          m_dwSuperManTick := GetTickCount();
          nPower := Round(nSecPwr * 1.8);
        end;
      end
      else
        Exit;
    end;

    if (wHitMode = 25) then
    begin
      nSecPwr := 0;
      if m_boSmiteLongSkill3 then
      begin
        m_boSmiteLongSkill3 := False;
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][115] <> nil then
            nSecPwr := Round(nPower / 5 * (m_MagicArr[0][115].btLevel + 3));
        end;
        if nSecPwr > 0 then
        begin
          nSecPwr := Round(nSecPwr / 28 * g_Config.ssPowerRate_115);
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            nSecPwr := TPlayObject(Self).GetSeriesSkillDamage(115, nSecPwr);
          SwordLongAttackY(nSecPwr, 4, 115);
          bTrain := True;
          m_dwLatestSmiteLongTick3 := GetTickCount();
          m_boSuperMode := True;
          m_dwSuperManTick := GetTickCount();
          nPower := 0;
        end;
      end
      else
        Exit;
    end;

{$IF SERIESSKILL}
    if (wHitMode = 21) then
    begin
      nSecPwr := 0;
      if m_boSmiteLongSkill then
      begin
        m_boSmiteLongSkill := False;
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][102] <> nil then
            nSecPwr := Round((nPower / 5 * (m_MagicArr[0][102].btLevel + 2)) * 1.19 / 100 * g_Config.nPowerRateOfSeriesSkill_102);
        end;
        if nSecPwr > 0 then
        begin
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            nSecPwr := TPlayObject(Self).GetSeriesSkillDamage(102, nSecPwr);
          SwordLongAttackX(nSecPwr, 4, 102);
          bTrain := True;
          m_dwLatestSmiteLongTick := GetTickCount();
          if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
            TPlayObject(Self).m_dwReadySeriesSkillTick := GetTickCount();
          m_boSuperMode := True;
          m_dwSuperManTick := GetTickCount();
          nPower := nSecPwr;
        end;
      end
      else
        Exit;
    end;

    if (wHitMode = 22) then
    begin
      if m_boSmiteWideSkill then
      begin
        m_boSmiteWideSkill := False;
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][103] <> nil then
          begin
            nSecPwr := Round((nPower / 4 * (m_MagicArr[0][103].btLevel + 2)) / 100 * g_Config.nPowerRateOfSeriesSkill_103);
            if nSecPwr > 0 then
            begin
              if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
                nSecPwr := TPlayObject(Self).GetSeriesSkillDamage(103, nSecPwr);
              SmiteWideAttack(nSecPwr);
              bTrain := True;
              //m_boSmiteWideSkill := False;
              nPower := Round(nSecPwr * 1.45);
              m_dwLatestSmiteWideTick := GetTickCount();
              if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
                TPlayObject(Self).m_dwReadySeriesSkillTick := GetTickCount();
              m_boSuperMode := True;
              m_dwSuperManTick := GetTickCount();
            end;
          end;
        end;
      end
      else
        Exit;
    end;

    if (wHitMode = 23) then
    begin
      if m_boSmiteWideSkill2 then
      begin
        m_boSmiteWideSkill2 := False;

        case m_btJob of
          0: nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
          1: nPower := Round(GetAttackPower(LoWord(m_WAbil.MC), SmallInt((HiWord(m_WAbil.MC) - LoWord(m_WAbil.MC)))) * 1.1);
          2: nPower := Round(GetAttackPower(LoWord(m_WAbil.SC), SmallInt((HiWord(m_WAbil.SC) - m_wStatusArrValue[2] - LoWord(m_WAbil.SC)))) * 1.1);
        else
          nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
        end;

        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          if m_MagicArr[0][114] <> nil then
          begin
            nSecPwr := Round((nPower / 5 * (m_MagicArr[0][114].btLevel + 2)) * 4.5 / 100 * g_Config.nPowerRateOfSeriesSkill_114);
            if nSecPwr > 0 then
            begin
              SmiteWideAttack2(nSecPwr);
              bTrain := True;

              nPower := Round(nSecPwr * 1.24);
              m_dwLatestSmiteWideTick2 := GetTickCount();
              m_boSuperMode := True;
              m_dwSuperManTick := GetTickCount();
            end;
          end;
        end;
      end
      else
        Exit;
    end;

{$IFEND SERIESSKILL}

    nCheckCode := 5;
    if wHitMode = 61 then
    begin
      nSecPwr := 0;
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
      begin
        if m_MagicArr[0][61] <> nil then
          nSecPwr := Round(nPower / (3 + 2) * (m_MagicArr[0][61].btLevel + 2)) * 3;
      end;
      if nSecPwr > 0 then
      begin
        SwordLongAttack61(nSecPwr);
        bTrain := True;
        nPower := nSecPwr;
      end;
    end;

    nCheckCode := 6;
    if (wHitMode = 5) then
    begin
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
      begin
        if m_MagicArr[0][SKILL_BANWOL] {m_MagicBanwolSkill} <> nil then
        begin
          nSecPwr := Round(nPower / (3 + 10) * (m_MagicArr[0][SKILL_BANWOL].btLevel + 2));
          if nSecPwr > 0 then
          begin
            if m_MagicArr[0][SKILL_BANWOL].btLevel > 3 then
            begin
              if CrsWideAttack(nSecPwr) then
                bTrain := True;
            end
            else if SwordWideAttack(nSecPwr) then
              bTrain := True;
          end;
        end;
      end;
    end;

    nCheckCode := 7;
    if (wHitMode = 10) then
    begin
      nSecPwr := 0;
      if (m_MagicArr[0][42] <> nil) and (m_nVigour > 0 {(m_MagicArr[0][42].btLevel + 1) * 2}) then
      begin
        if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
          nSecPwr := Round(nPower / (3 + 3) * (m_MagicArr[0][42].btLevel + 5));
      end;

      if nSecPwr > 0 then
      begin
        if (AttackTarget <> nil) or not g_Config.boLimitSquAttack then
        begin
          nSecPwr := Round(nSecPwr / 100 * g_Config.nMagSquPowerRate);
          m_boVigourAddAble := False;
          if m_nVigour > (m_MagicArr[0][42].btLevel + 1) * 2 then
          begin
            Dec(m_nVigour, (m_MagicArr[0][42].btLevel + 1) * 2);
            TPlayObject(Self).SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
          end
          else
          begin
            m_nVigour := 0;
            TPlayObject(Self).SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
            m_boVigourAddAble := True;
            m_dwSquSkillPowerUpTick := GetTickCount();
          end;
          if SUQAttack(nSecPwr) then
            bTrain := True;
        end
        else
        begin
          wHitMode := 0;
          m_boVigourAddAble := True;
        end;
      end
      else
      begin
        wHitMode := 0;
      end;
    end;

    nCheckCode := 8;
    if (wHitMode = 8) then
    begin
      nSecPwr := 0;
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
      begin
        if m_MagicArr[0][40] {m_MagicCrsSkill} <> nil then
          nSecPwr := Round(nPower / (3 + 10) * (m_MagicArr[0][40].btLevel + 2));
      end;
      if nSecPwr > 0 then
        if CrsWideAttack(nSecPwr) then
          bTrain := True;
    end;

    nCheckCode := 9;
    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
      if TPlayObject(Self).m_nInPowerLevel > 0 then
      begin
        Dec(TPlayObject(Self).m_nPerInPower);
        TPlayObject(Self).m_dwIncInPowerTick := 0;
      end;
    end;

    nCheckCode := 10;
    if ((AttackTarget = nil) or (wHitMode in [25])) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
    begin
      if bTrain then
        TrainCurrentSkill(0, wHitMode);
      TrainCurrentSkill(1, wHitMode);
      Exit;
    end;

    nCheckCode := 11;
    if IsProperTarget(AttackTarget) then
    begin
      if not (wHitMode in [20..25]) and (Random(AttackTarget.m_btSpeedPoint) >= m_btHitPoint) then
        nPower := 0;
    end
    else
      nPower := 0;

    nCheckCode := 12;
    if nPower > 0 then
    begin
      nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
      nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong;
    end;

    nCheckCode := 13;
    if nPower > 0 then
    begin
      //internal power skill
      nMagIdx := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        case wHitMode of
          03: if (m_MagicArr[0][SKILL_YEDO] <> nil) then
              nMagIdx := SKILL_YEDO;
          04: if (m_MagicArr[0][SKILL_ERGUM] <> nil) then
              nMagIdx := SKILL_ERGUM;
          05: if (m_MagicArr[0][SKILL_BANWOL] <> nil) then
              nMagIdx := SKILL_BANWOL;
          07: if (m_MagicArr[0][SKILL_FIRESWORD] <> nil) then
              nMagIdx := SKILL_FIRESWORD;
          08: if (m_MagicArr[0][SKILL_40] <> nil) then
              nMagIdx := SKILL_40;
          09: if (m_MagicArr[0][SKILL_43] <> nil) then
              nMagIdx := SKILL_43;
          10: if (m_MagicArr[0][SKILL_42] <> nil) then
              nMagIdx := SKILL_42;
          13: if (m_MagicArr[0][SKILL_56] <> nil) then
              nMagIdx := SKILL_56;
          20: if (m_MagicArr[0][101] <> nil) then
              nMagIdx := 101;
          21: if (m_MagicArr[0][102] <> nil) then
              nMagIdx := 102;
          22: if (m_MagicArr[0][103] <> nil) then
              nMagIdx := 103;
          23: if (m_MagicArr[0][114] <> nil) then
              nMagIdx := 114;
          24: if (m_MagicArr[0][113] <> nil) then
              nMagIdx := 113;
          25: if (m_MagicArr[0][115] <> nil) then
              nMagIdx := 115;
        end;
      end;

      AttackTarget.StruckDamage(Self, nPower, nMagIdx);

      nCheckCode := 14;
      if boTwin then
      begin
        AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nPower * 2, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
        if g_Config.boTDBeffect then
          if Random(m_MagicArr[0][43].btLevel + 4) >= 2 then
          begin
            AttackTarget.MakePosion(nil, 0, POISON_DONTMOVE, (m_MagicArr[0][43].btLevel + 1 + Random(3)), 0); //yellow effect
          end;
      end
      else
      begin
        if wHitMode in [20..24] then
        begin
          if (wHitMode <> 23) and (wHitMode <> 24) then
            AttackTarget.MagDontMove(1);
          AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 480);
        end
        else
        begin
          AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
        end;
      end;

      nCheckCode := 15;
      if not (AttackTarget.m_boUnParalysis or AttackTarget.m_boUnAllParalysis) and (m_boParalysis or m_boParalysis2) and (Random(AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate) = 0) then
        if (AttackTarget.m_btAntiStone = 0) or (AttackTarget.m_btAntiStone <= Random(100)) then
        begin
          if m_boParalysis then
            AttackTarget.MakePosion(Self, 0, POISON_STONE, g_Config.nAttackPosionTime, 0)
          else if m_boParalysis2 then
            AttackTarget.MakePosion(Self, 0, POISON_STONE, 2, 0);
        end;

      if (m_wVampire > 0) and (m_btSuckRate > Random(100)) then
        SendDelayMsg(Self, RM_DELAYINCHEALTHSPELL, 0, m_wVampire, 0, Integer(Self), '', 300);

      if (m_wVampire2 > 0) and ((AttackTarget.m_btRaceServer = RC_PLAYOBJECT) or AttackTarget.IsHero) and AttackTarget.IPLevelInRange() then
        AttackTarget.SendDelayMsg(AttackTarget, RM_DELAYDECINTERNALPOWER, 0, m_wVampire2, 0, Integer(AttackTarget), '', 100);

      nCheckCode := 16;
      if m_nHongMoSuite > 0 then
      begin
        m_dbHongMoSuite := nPower / 1.E2 * m_nHongMoSuite;
        if m_dbHongMoSuite >= 2.0 then
        begin
          n20 := Trunc(m_dbHongMoSuite);
          m_dbHongMoSuite := n20;
          DamageHealth(-n20, False);
        end;
      end;

      nCheckCode := 17;
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        TrainCurrentSkill(0, wHitMode);
        TrainCurrentSkill(1, wHitMode);
      end;
      Result := True;
    end;

    if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
      DoDamageWeapon(nWeaponDamage);

    nCheckCode := 18;
    if (nPower > 0) and (AttackTarget.m_btRaceServer <> RC_PLAYOBJECT) then
      AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '');

  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg, [m_sCharName, nCheckCode]));
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);
var
  nLv: Integer;
begin
  nLv := 0;
  if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
    case wIdent of
      RM_SPELL2: if (m_MagicArr[0][7] <> nil) then
          nLv := m_MagicArr[0][7].btLevel;
      RM_LONGHIT: if (m_MagicArr[0][12] <> nil) then
          nLv := m_MagicArr[0][12].btLevel;
      RM_WIDEHIT: if (m_MagicArr[0][25] <> nil) then
          nLv := m_MagicArr[0][25].btLevel;
      RM_FIREHIT: if (m_MagicArr[0][SKILL_FIRESWORD] <> nil) then
          nLv := m_MagicArr[0][SKILL_FIRESWORD].btLevel;
      RM_PURSUEHIT: if (m_MagicArr[0][56] <> nil) then
          nLv := m_MagicArr[0][56].btLevel;
    end;
  SendRefMsg(wIdent, btDir, nX, nY, nLv, '');
end;

function TBaseObject.GetAttackPower(nBasePower, nPower: Integer): Integer;
begin
  if nPower < 0 then
    nPower := -nPower;
  if m_nLuck > 0 then
  begin
    if Random(g_Config.btMaxPowerLuck + 1 - _MIN(g_Config.btMaxPowerLuck, m_nLuck)) = 0 then
      Result := nBasePower + nPower
    else
      Result := nBasePower + Random(nPower + 1);
  end
  else
  begin
    Result := nBasePower + Random(nPower + 1);
    if m_nLuck < 0 then
    begin
      if Random(g_Config.btMaxPowerLuck + 1 - _MAX(0, -m_nLuck)) = 0 then
        Result := nBasePower;
    end;
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    Result := Round(Result * (TPlayObject(Self).m_nPowerRate / 100));
    if TPlayObject(Self).m_boPowerItem then
      Result := Round(m_rPowerItem * Result);
  end;
end;

function TBaseObject.GetIPStruckDamage(Attacker: TBaseObject; nDamage: Integer; nMagIdx: Integer): Integer;
var
  na, nd, np: Integer;
begin
  Result := nDamage;
  if Result <= 0 then
    Exit;
  np := 0;
  na := 0;
  nd := 0;
  if (Attacker <> nil) and not Attacker.m_boDeath and not Attacker.m_boGhost and ((Attacker.m_btRaceServer = RC_PLAYOBJECT) or Attacker.IsHero) then
  begin
    if (Attacker.m_nInPowerLevel > 0) and (Attacker.m_nInPowerPoint > 0) then
    begin
      if TPlayObject(Attacker).m_AddDamage > 0 then
      begin
        na := Round(nDamage / 100 * TPlayObject(Attacker).m_AddDamage);
      end;

      //µÐ·½Å­¼¼ÄÜÉËº¦Ôö¼Ó
      if (nMagIdx > 0) and (Attacker.m_MagicArr[1][nMagIdx] <> nil) and (Attacker.m_nInPowerPoint > 8) then
      begin
        na := na + Round((nDamage * (Attacker.m_MagicArr[1][nMagIdx].btLevel + 1) / 15) / 100 * g_Config.nInternalPowerSkillRate);
      end;
    end;

    //×ÔÉíÉËº¦¼õÃâ
    if (m_nInPowerPoint >= 10) and (m_MagicArr[2][nMagIdx] <> nil) then
    begin
      np := m_nInPowerPoint;
      Dec(m_nInPowerPoint, 10);
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        TPlayObject(Self).InternalPowerPointChanged(True);
      na := na - Round((nDamage * (m_MagicArr[2][nMagIdx].btLevel + 1) / 15) / 100 * g_Config.nInternalPowerSkillRate);
      if (m_MagicArr[2][nMagIdx] <> nil) and
        (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and
        (m_MagicArr[2][nMagIdx].btLevel < m_MagicArr[2][nMagIdx].MagicInfo.btTrainLv) and
        (m_MagicArr[2][nMagIdx].MagicInfo.TrainLevel[m_MagicArr[2][nMagIdx].btLevel] <= m_nInPowerLevel) then
      begin
        TPlayObject(Self).TrainSkill(m_MagicArr[2][nMagIdx], Random(3) + 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[2][nMagIdx]) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 2,
            m_MagicArr[2][nMagIdx].MagicInfo.wMagicId,
            m_MagicArr[2][nMagIdx].btLevel,
            m_MagicArr[2][nMagIdx].nTranPoint, '', 3000);
        end;
      end;
    end;

  end;

  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    if (m_nInPowerLevel > 0) and (m_nInPowerPoint > 0) then
    begin
      nd := Round(nDamage / 100 * m_DecDamage);
      if np = 0 then
      begin
        Dec(m_nInPowerPoint);
        TPlayObject(Self).InternalPowerPointChanged(True);
      end;
    end;
  end;

  //Ç¿»¯÷¼÷ÃÉËº¦¼õÃâ
  np := 0;
  if (m_MagicArr[0][17] <> nil) and (m_MagicArr[0][17].btLevel > 3) then
  begin
    np := Round(nDamage / 100 * (m_MagicArr[0][17].btLevel));
  end;
  Result := _MAX(0, nDamage + na - nd - np);
end;

function TBaseObject.GetHitStruckDamage(Attacker: TBaseObject; nDamage: Integer): Integer;
var
  nAc: Integer;
  boIgnore: Boolean;
begin
  boIgnore := False;
  if (Attacker <> nil) then
  begin
    if (Attacker.m_btIgnoreTagDefence > 0) and (Random(100) < Attacker.m_btIgnoreTagDefence) then
      boIgnore := True;
    //ÔöÉË
    if (0 < Attacker.m_btDamageAddOn) then
    begin
      nDamage := nDamage + Round((nDamage / 100) * Attacker.m_btDamageAddOn);
    end;
  end;
  //ºöÊÓ
  if not boIgnore then
  begin
    //if LoWord(m_WAbil.AC) > HiWord(m_WAbil.AC) then
    //  nAc := HiWord(m_WAbil.AC) + Random(SmallInt(LoWord(m_WAbil.AC) - HiWord(m_WAbil.AC)) + 1)
    //else
    //  nAc := LoWord(m_WAbil.AC) + Random(SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1);
    nAc := LoWord(m_WAbil.AC) + Random(abs(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1);
    nDamage := _MAX(0, nDamage - nAc);
  end;

  //Îï¼õ
  if (0 < m_btACDamageReduction) then
  begin
    nDamage := _MAX(0, nDamage - Round(nDamage / 100 * m_btACDamageReduction));
  end;

  if (m_btLifeAttrib = LA_UNDEAD) and (Attacker <> nil) then
    Inc(nDamage, Attacker.m_AddAbil.btHoly);
  if (nDamage > 0) and m_boAbilMagBubbleDefence then
  begin
    nDamage := Round(nDamage / (g_Config.nMagBubbleDefenceRate * (m_btMagBubbleDefenceLevel + 2)) * 8);
    DamageBubbleDefence(nDamage);
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    if m_boAcItem then
      nDamage := Round(m_rAcItem * nDamage);
  end;
  if m_btMedusaEyeAttack > 0 then
  begin
    nDamage := Round(nDamage / 100 * 8);
  end;
  Result := _MAX(0, nDamage);
end;

function TBaseObject.GetDirectAttackStruckDamage(Attacker: TBaseObject; nDamage: Integer; IgnoreDefence: Boolean): Integer;
var
  nAc: Integer;
  boIgnore: Boolean;
begin
  boIgnore := False;
  if (Attacker <> nil) then
  begin
    if (Attacker.m_btIgnoreTagDefence > 0) and (Random(100) < Attacker.m_btIgnoreTagDefence) then
      boIgnore := True;
    //ÔöÉË
    if (0 < Attacker.m_btDamageAddOn) then
    begin
      nDamage := nDamage + Round((nDamage / 100) * Attacker.m_btDamageAddOn);
    end;
  end;

  //ºöÊÓ
  if boIgnore and not IgnoreDefence then
  begin
    //if LoWord(m_WAbil.AC) > HiWord(m_WAbil.AC) then
    //  nAc := Round((HiWord(m_WAbil.AC) + Random(SmallInt(LoWord(m_WAbil.AC) - HiWord(m_WAbil.AC)) + 1)) / 2.3)
    //else
    //  nAc := Round((LoWord(m_WAbil.AC) + Random(SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1)) / 2.3);
    nAc := Round((LoWord(m_WAbil.AC) + Random(abs(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1)) / 2.3);
    nDamage := _MAX(0, nDamage + nAc);
  end;

  //Îï¼õ
  if (0 < m_btACDamageReduction) then
  begin
    nDamage := _MAX(0, nDamage - Round(nDamage / 100 * m_btACDamageReduction));
  end;

  if m_btMedusaEyeAttack > 0 then
  begin
    if IgnoreDefence or boIgnore then
      nDamage := Round(nDamage / 100 * 1)
    else
      nDamage := Round(nDamage / 100 * 4);
  end;
  Result := _MAX(0, nDamage);
end;

function TBaseObject.GetMagStruckDamage(Attacker: TBaseObject; nDamage: Integer): Integer;
var
  nMac: Integer;
  boIgnore: Boolean;
begin
  boIgnore := False;
  if (Attacker <> nil) then
  begin
    if (Attacker.m_btIgnoreTagDefence > 0) and (Random(100) < Attacker.m_btIgnoreTagDefence) then
      boIgnore := True;
    //ÔöÉË
    if (0 < Attacker.m_btDamageAddOn) then
    begin
      nDamage := nDamage + Round((nDamage / 100) * Attacker.m_btDamageAddOn);
    end;
  end;

  //ºöÊÓ
  if not boIgnore then
  begin
    //if LoWord(m_WAbil.MAC) > HiWord(m_WAbil.MAC) then
    //  nMac := HiWord(m_WAbil.MAC) + Random(SmallInt(LoWord(m_WAbil.MAC) - HiWord(m_WAbil.MAC)) + 1)
    //else
    //  nMac := LoWord(m_WAbil.MAC) + Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1);
    nMac := LoWord(m_WAbil.MAC) + Random(abs(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1);
    nDamage := _MAX(0, nDamage - nMac);
  end;
  //Ä§¼õ
  if (0 < m_btMCDamageReduction) then
  begin
    nDamage := _MAX(0, nDamage - Round(nDamage / 100 * m_btMCDamageReduction));
  end;

  if (m_btLifeAttrib = LA_UNDEAD) and (Attacker <> nil) then
    Inc(nDamage, Attacker.m_AddAbil.btHoly); //fix 081127
  if (nDamage > 0) and m_boAbilMagBubbleDefence then
  begin
    nDamage := Round(nDamage / (g_Config.nMagBubbleDefenceRate * (m_btMagBubbleDefenceLevel + 2)) * 8);
    DamageBubbleDefence(nDamage);
  end;
  if m_boAttackedMag62 then
  begin
    m_boAttackedMag62 := False;
    if nDamage > 0 then
      nDamage := Round(nDamage * 1.5);
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    //PlayObject := TPlayObject(self);
    if m_boMacItem then
      nDamage := Round(m_rMacItem * nDamage);
  end;
  if m_btMedusaEyeAttack > 0 then
  begin
    nDamage := Round(nDamage / 100 * 8);
  end;
  Result := _MAX(0, nDamage);
end;


// µÖÓùÉËº¦¼ôÒÂ·þ³Ö¾Ã  
procedure TBaseObject.StruckDamage(Attacker: TBaseObject; nDamage: Integer; nMagIdx: Integer);
var
  i, nDam: Integer;
  nDura, nOldDura: Integer;
  PlayObject: TPlayObject;
  StdItem: pTStdItem;
  boRecalcAbi: Boolean;
begin
  if nDamage <= 0 then
    Exit;

  nDam := Random(10) + 5;
  if m_wStatusTimeArr[POISON_DAMAGEARMOR] > 0 then
  begin
    nDam := Round(nDam * (g_Config.nPosionDamagarmor / 10));
    nDamage := Round(nDamage * (g_Config.nPosionDamagarmor / 10));
  end;

  if (m_wStatusTimeArr[POISON_DONTMOVE] > 0) and m_boTDBeffect then //when yellow from tdb do more damage
    Inc(nDamage, nDamage shr 1)
  else if m_boTDBeffect then
    m_boTDBeffect := False;

  if ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) or (IsHero and TPlayObject(m_Master).m_boOffLinePlay) then

  else
  begin
    boRecalcAbi := False;                                 
    if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) then
    begin
      for i := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if (m_UseItems[i].wIndex > 0) and (Random(8) = 0) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
          if (StdItem <> nil) then
          begin
            if (StdItem.StdMode = 7) and (StdItem.Shape = 0) then
              Continue;
            if StdItem.StdMode = 25 then
              Continue;
            if (StdItem.StdMode = 2) and (StdItem.Source <> 0) then
              Continue;
            nDura := m_UseItems[i].Dura;
            nOldDura := Round(nDura / 1000);
            Dec(nDura, nDam);
            if nDura <= 0 then
            begin
              nDura := 0;
              m_UseItems[i].Dura := 0;
              if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
              begin
                PlayObject := TPlayObject(Self);

                if (PCardinal(@m_UseItems[i].btValue[22])^ > 0) and (PCardinal(@m_UseItems[i].btValue[22])^ = PlayObject.m_dwIdCRC) and g_Config.boBindNoMelt then
                begin
                  if nOldDura <> Round(nDura / 1000) then
                  begin
                    SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
                    SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÊôÐÔÊ§Ð§£¬Çë¼°Ê±ÐÞÀí', [StdItem.Name]), c_Red, t_Hint);
                  end;
                end
                else
                begin
                  PlayObject.SendDelItems(@m_UseItems[i]);
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLogAPI('3' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(m_UseItems[i].MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '0');
                  m_UseItems[i].wIndex := 0;
                  RecalcAbilitys();
                  FeatureChanged();
                end;
              end
              else
                m_UseItems[i].wIndex := 0;
              boRecalcAbi := True;
            end
            else
              m_UseItems[i].Dura := nDura;
            if nOldDura <> Round(nDura / 1000) then
              SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
          end;
        end;
      end;
    end;
    if boRecalcAbi then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    end;
  end;

  //nDamage := GetIPStruckDamage(Attacker, nDamage, nMagIdx);
  nDamage := GetPowerDamage(Attacker, nDamage);
  nDamage := GetIPStruckDamage(Attacker, nDamage, nMagIdx);

  if (Attacker <> nil) and not Attacker.m_boGhost then
    SetLastHiter(Attacker);
  DamageHealth(nDamage);

  //·´Éä
  if (nDamage > 0) and (Attacker <> nil) and (g_BaseObject <> Attacker) and not Attacker.m_boDeath and not Attacker.m_boGhost and (m_btDamageRebound > 0) then
  begin
    nDamage := Round(nDamage / 100 * m_btDamageRebound);
    Attacker.SendRefMsg(RM_STRUCK_MAG, nDamage, Attacker.m_WAbil.HP, Attacker.m_WAbil.MaxHP, 0 {Integer(Self)}, '');
    Attacker.DamageHealth(nDamage);
  end;
end;

function TBaseObject.GeTBaseObjectInfo(): string; //004CF87C
begin
  Result := m_sCharName + ' ' +
    'µØÍ¼:' + m_sMapName + '(' + m_PEnvir.m_sMapDesc + ') ' +
    '×ù±ê:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
    'µÈ¼¶:' + IntToStr(m_Abil.Level) + ' ' +
    '¾­Ñé:' + IntToStr(m_Abil.Exp) + ' ' +
    'ÉúÃüÖµ:' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' ' +
    'Ä§·¨Öµ:' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' ' +
    '¹¥»÷Á¦:' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) + ' ' +
    'Ä§·¨Á¦:' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) + ' ' +
    'µÀÊõ:' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) + ' ' +
    '·ÀÓùÁ¦:' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) + ' ' +
    'Ä§·ÀÁ¦:' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) + ' ' +
    '×¼È·:' + IntToStr(m_btHitPoint) + ' ' +
    'Ãô½Ý:' + IntToStr(m_btSpeedPoint);
end;

function TBaseObject.GetBackPosition(var nX, nY: Integer): Boolean; //004B2900
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP: if nY < (Envir.m_MapHeader.wHeight - 1) then
        Inc(nY);
    DR_DOWN: if nY > 0 then
        Dec(nY);
    DR_LEFT: if nX < (Envir.m_MapHeader.wWidth - 1) then
        Inc(nX);
    DR_RIGHT: if nX > 0 then
        Dec(nX);
    DR_UPLEFT:
      begin
        if (nX < (Envir.m_MapHeader.wWidth - 1)) and (nY < (Envir.m_MapHeader.wHeight - 1)) then
        begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_UPRIGHT:
      begin
        if (nY < (Envir.m_MapHeader.wHeight - 1)) and (nX > 0) then
        begin //0619
          Dec(nX);
          Inc(nY);
        end
      end;
    DR_DOWNLEFT:
      begin
        if (nY > 0) and (nX < (Envir.m_MapHeader.wWidth - 1)) then
        begin //0619
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_DOWNRIGHT:
      begin
        if (nX > 0) and (nY > 0) then
        begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

function TBaseObject.GetBackPosition2(var nX, nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP: if nY < (Envir.m_MapHeader.wHeight - 2) then
        Inc(nY, 2);
    DR_DOWN: if nY > 1 then
        Dec(nY, 2);
    DR_LEFT: if nX < (Envir.m_MapHeader.wWidth - 2) then
        Inc(nX, 2);
    DR_RIGHT: if nX > 1 then
        Dec(nX, 2);
    DR_UPLEFT:
      begin
        if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
        begin
          Inc(nX, 2);
          Inc(nY, 2);
        end;
      end;
    DR_UPRIGHT:
      begin
        if (nY < (Envir.m_MapHeader.wHeight - 2)) and (nX > 1) then
        begin //0619
          Dec(nX, 2);
          Inc(nY, 2);
        end
      end;
    DR_DOWNLEFT:
      begin
        if (nY > 1) and (nX < (Envir.m_MapHeader.wWidth - 2)) then
        begin //0619
          Inc(nX, 2);
          Dec(nY, 2);
        end;
      end;
    DR_DOWNRIGHT:
      begin
        if (nX > 1) and (nY > 1) then
        begin
          Dec(nX, 2);
          Dec(nY, 2);
        end;
      end;
  end;
  Result := True;
end;

function TBaseObject.GetBackPositionEx(var nX, nY: Integer; bRandom: Boolean): Boolean;
var
  nr3, nr5: Integer;
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  if m_TargetCret <> nil then
  begin
    m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
  end;
  nr3 := 0;
  nr5 := 0;
  if bRandom then
  begin
    nr3 := Random(3);
    nr5 := Random(5);
  end;
  case m_btDirection of
    DR_UP:
      begin
        case nr3 of
          0:
            begin
              if nY < (Envir.m_MapHeader.wHeight - 2) then
                Inc(nY, 2);
            end;
          1:
            begin
              if nY < (Envir.m_MapHeader.wHeight - 2) then
                Inc(nY, 2);
              if nX < (Envir.m_MapHeader.wWidth - 2) then
                Inc(nX, 2);
            end;
          2:
            begin
              if nY < (Envir.m_MapHeader.wHeight - 2) then
                Inc(nY, 2);
              if nX > 1 then
                Dec(nX, 2);
            end;
        end;

      end;
    DR_DOWN:
      begin
        case nr3 of
          0:
            begin
              if nY > 1 then
                Dec(nY, 2);
            end;
          1:
            begin
              if nY > 1 then
                Dec(nY, 2);
              if nX < (Envir.m_MapHeader.wWidth - 2) then
                Inc(nX, 2);
            end;
          2:
            begin
              if nY > 1 then
                Dec(nY, 2);
              if nX > 1 then
                Dec(nX, 2);
            end;
        end;
      end;
    DR_LEFT:
      begin
        case nr3 of
          0:
            begin
              if nX < (Envir.m_MapHeader.wWidth - 2) then
                Inc(nX, 2);
            end;
          1:
            begin
              if nX < (Envir.m_MapHeader.wWidth - 2) then
                Inc(nX, 2);
              if nY < (Envir.m_MapHeader.wHeight - 2) then
                Inc(nY, 2);
            end;
          2:
            begin
              if nX < (Envir.m_MapHeader.wWidth - 2) then
                Inc(nX, 2);
              if nY > 1 then
                Dec(nY, 2);
            end;
        end;
      end;
    DR_RIGHT:
      begin
        case nr3 of
          0:
            begin
              if nX > 1 then
                Dec(nX, 2);
            end;
          1:
            begin
              if nX > 1 then
                Dec(nX, 2);
              if nY < (Envir.m_MapHeader.wHeight - 2) then
                Inc(nY, 2);
            end;
          2:
            begin
              if nX > 1 then
                Dec(nX, 2);
              if nY > 1 then
                Dec(nY, 2);
            end;
        end;
      end;
    DR_UPLEFT:
      begin
        case nr5 of
          0:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Inc(nX, 2);
                Inc(nY, 2);
              end;
            end;
          1:
            begin
              if nX < Envir.m_MapHeader.wWidth - 2 then
              begin
                Inc(nX, 2);
              end;
            end;
          2:
            begin
              if nY < Envir.m_MapHeader.wHeight - 2 then
              begin
                Inc(nY, 2);
              end;
            end;
          3:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY > 1) then
              begin
                Inc(nX, 2);
                Dec(nY, 2);
              end;
            end;
          4:
            begin
              if (nX > 1) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Dec(nX, 2);
                Inc(nY, 2);
              end;
            end;
        end;
      end;
    DR_UPRIGHT:
      begin
        case nr5 of
          0:
            begin
              if (nX > 1) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Dec(nX, 2);
                Inc(nY, 2);
              end
            end;
          1:
            begin
              if nY < Envir.m_MapHeader.wHeight - 2 then
              begin
                Inc(nY, 2);
              end;
            end;
          2:
            begin
              if (nX > 1) then
              begin
                Dec(nX, 2);
              end;
            end;
          3:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Inc(nX, 2);
                Inc(nY, 2);
              end;
            end;
          4:
            begin
              if (nX > 1) and (nY > 1) then
              begin
                Dec(nX, 2);
                Dec(nY, 2);
              end;
            end;
        end;
      end;
    DR_DOWNLEFT:
      begin
        case nr5 of
          0:
            begin
              if (nY > 1) and (nX < (Envir.m_MapHeader.wWidth - 2)) then
              begin
                Inc(nX, 2);
                Dec(nY, 2);
              end;
            end;
          1:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) then
              begin
                Inc(nX, 2);
              end;
            end;
          2:
            begin
              if (nY > 1) then
              begin
                Dec(nY, 2);
              end;
            end;
          3:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Inc(nX, 2);
                Inc(nY, 2);
              end;
            end;
          4:
            begin
              if (nX > 1) and (nY > 1) then
              begin
                Dec(nX, 2);
                Dec(nY, 2);
              end;
            end;
        end;
      end;
    DR_DOWNRIGHT:
      begin
        case nr5 of
          0:
            begin
              if (nX > 1) and (nY > 1) then
              begin
                Dec(nX, 2);
                Dec(nY, 2);
              end;
            end;
          1:
            begin
              if (nX > 1) then
              begin
                Dec(nX, 2);
              end;
            end;
          2:
            begin
              if (nY > 1) then
              begin
                Dec(nY, 2);
              end;
            end;
          3:
            begin
              if (nX < (Envir.m_MapHeader.wWidth - 2)) and (nY > 1) then
              begin
                Inc(nX, 2);
                Dec(nY, 2);
              end;
            end;
          4:
            begin
              if (nX > 1) and (nY < (Envir.m_MapHeader.wHeight - 2)) then
              begin
                Dec(nX, 2);
                Inc(nY, 2);
              end;
            end;
        end;
      end;
  end;
  Result := True;
end;

procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower, nMagPower: Integer; boFlag: Boolean; nRange: Integer = 0); //004C2E40
var
  i: Integer;
  nDamage: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
  BaseObjectList := TList.Create;
  m_PEnvir.GetRangeBaseObject(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, nRange, False, BaseObjectList);
  for i := 0 to BaseObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(BaseObjectList.Items[i]);
    if IsProperTarget(BaseObject, True) then
    begin
      nDamage := 0;
      if nHitPower > 0 then
        Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
      if nMagPower > 0 then
        Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
      if nDamage > 0 then
      begin
        BaseObject.StruckDamage(Self, nDamage, 0);
        BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_STRUCKEFFECT, nDamage, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
      end;
    end;
  end;
  BaseObjectList.Free;
  SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TAnimalObject.DelTargetCreat;
begin
  inherited;
  m_nTargetX := -1;
  m_nTargetY := -1;
end;

procedure TAnimalObject.SearchTarget;
var
  BaseObject, BaseObject18: TBaseObject;
  i, nC, n10: Integer;
begin
  BaseObject18 := nil;
  n10 := 999;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject);
    if (BaseObject <> nil) and not BaseObject.m_boDeath and not BaseObject.m_boGhost then
    begin
      if IsProperTarget(BaseObject) and (not BaseObject.m_boHideMode or m_boCoolEye) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          BaseObject18 := BaseObject;
        end;
      end;
    end;
  end;
  if BaseObject18 <> nil then
    SetTargetCreat(BaseObject18);
end;

procedure TAnimalObject.SearchTargetA();
var
  i, nC, n10: Integer;
  Creat, BaseObject: TBaseObject;
begin
  Creat := nil;
  n10 := 999;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject);
    if (BaseObject <> nil) and not BaseObject.m_boDeath and not BaseObject.m_boGhost then
    begin
      if IsProperTarget(BaseObject) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          Creat := BaseObject;
        end;
      end;
    end;
  end;
  if Creat <> nil then
    SetTargetCreat(Creat);
end;

procedure TAnimalObject.SearchTargetHero();
var
  i, nC, n10: Integer;
  Creat, BaseObject: TBaseObject;
begin
  Creat := nil;
  n10 := 999;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject);
    if (BaseObject <> nil) and not BaseObject.m_boDeath and not BaseObject.m_boGhost then
    begin
      if IsProperTarget(BaseObject) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          Creat := BaseObject;
        end;
      end;
    end;
  end;
  if Creat <> nil then
  begin
    SetTargetCreat(Creat);
    {if Ishero then begin
      THeroObject(Self).m_RoundPoint.X := (m_Master.m_nCurrX + Creat.m_nCurrX) div 2;
      THeroObject(Self).m_RoundPoint.Y := (m_Master.m_nCurrY + Creat.m_nCurrY) div 2;
    end;}
  end;
end;

procedure TAnimalObject.HeroSearchTarget;
var
  i, nC, n10: Integer;
  Creat, BaseObject: TBaseObject;
begin
  Creat := nil;
  n10 := 999;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject);
    if (BaseObject <> nil) and not BaseObject.m_boDeath and not BaseObject.m_boGhost then
    begin
      if IsProperTarget(BaseObject) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          Creat := BaseObject;
        end;
      end;
    end;
  end;
  if Creat <> nil then
    SetTargetCreat(Creat);
end;

procedure TAnimalObject.SetTargetXY(nX, nY: Integer); //004C9668
begin
  m_nTargetX := nX;
  m_nTargetY := nY;
end;

procedure TAnimalObject.Wondering; //004C9810
begin
  if m_boStickMode then
    Exit;
  if (Random(30) = 0) then
    if (Random(4) = 1) then
      TurnTo(Random(8))
    else
      WalkTo(m_btDirection, False);
end;

var
  g_sPosionType: array[0..MAX_STATUS_ATTRIBUTE] of string = (
    '[ÖÐ¶¾] %dÃëÄÚHP³ÖÐøÏÂ½µ', //POISON_DECHEALTH
    '[ÖÐ¶¾] %dÃëÄÚ·ÀÓùÁ¦¼õÈõ', //POISON_DAMAGEARMOR
    '', //POISON_SHOCKED
    '[Âé±Ô] %dÃëÄÚ½ûÖ¹ÊÍ·ÅÄ§·¨£¬ÊÜµ½µÄÉËº¦Ôö¼Ó1/4', //POISON_DONTMOVE
    '[±ù¶³] %dÃëÄÚ¹¥»÷ÒÆ¶¯ËÙ¶ÈÏÂ½µ', //POISON_FREEZE
    '[Ê¯»¯] %dÃëÄÚ½ûÖ¹ÈÎºÎ¶¯×÷', //POISON_STONE
    '', //POISON_PURPLE
    '', //STATE_STONE_MODE = 7;
    '', //STATE_TRANSPARENT = 8;
    '', //STATE_DEFENCEUP = 9;
    '', //STATE_MAGDEFENCEUP = 10;
    '', //STATE_BUBBLEDEFENCEUP = 11;
    ''
    );

function TBaseObject.MakePosion(Attacker: TBaseObject; nMid, nType, nTime, nPoint: Integer): Boolean;
var
  n, p, t: Integer;
  nOldCharStatus: Integer;
  boVaHuman: Boolean;
begin
  Result := False;
  if m_boUnAllParalysis {and (nType in [POISON_STONE])} then
    Exit;

  boVaHuman := (Attacker <> nil) and ((Attacker.m_btRaceServer = RC_PLAYOBJECT) or Attacker.IsHero);

  if (m_dwUnParalysisTick > GetTickCount) then
  begin
    if boVaHuman and (nType = POISON_STONE) then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        SysMsg(Format('µÖ¿¹ÁË%sµÄÊ¯»¯¼¼ÄÜ', [Attacker.m_sCharName]), c_Blue, t_Hint);
      if (Attacker.m_btRaceServer = RC_PLAYOBJECT) or Attacker.IsHero then
        Attacker.SysMsg(Format('%sµÖ¿¹ÁËÄãµÄÊ¯»¯¼¼ÄÜ', [m_sCharName]), c_Blue, t_Hint);
    end;
    Exit;
  end;

  if m_wStatusTimeArrEx[STATE_14] > 0 then
  begin
    if boVaHuman and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
    begin
      if nType = POISON_STONE then
        SysMsg(Format('µÖ¿¹ÁË%sµÄÊ¯»¯', [Attacker.m_sCharName]), c_Blue, t_Hint)
      else if nType = POISON_FREEZE then
        SysMsg(Format('µÖ¿¹ÁË%sµÄ±ù¶³', [Attacker.m_sCharName]), c_Blue, t_Hint)
      else if nType = POISON_DONTMOVE then
        SysMsg(Format('µÖ¿¹ÁË%sµÄÂé±Ô', [Attacker.m_sCharName]), c_Blue, t_Hint);
    end;
  end;

  if nPoint > 0 then
  begin
    n := 0;
    p := 0;
    t := 0;
    if boVaHuman then
    begin

      //Attacker
      if (Attacker.m_nInPowerLevel > 0) and (Attacker.m_nInPowerPoint > 0) then
      begin
        if Attacker.m_AddDamage > 0 then
        begin
          t := nTime + Round(nTime / 100 * Attacker.m_AddDamage);
        end
        else
          t := nTime;

        if (nMid > 0) and (Attacker.m_MagicArr[1][nMid] <> nil) and (Attacker.m_nInPowerPoint > 8) then
        begin
          p := Round(nPoint * (Attacker.m_MagicArr[1][nMid].btLevel + 1.5) / 100 * g_Config.nInternalPowerSkillRate);
        end;
      end;

      //self
      if (m_nInPowerPoint >= 10) and (m_MagicArr[2][nMid] <> nil) then
      begin
        n := m_nInPowerPoint;
        Dec(m_nInPowerPoint, 10);
        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
          TPlayObject(Self).InternalPowerPointChanged(True);
        p := p - Round(nPoint * (m_MagicArr[2][nMid].btLevel + 1.5) / 100 * g_Config.nInternalPowerSkillRate);
        if (m_MagicArr[2][nMid] <> nil) and
          (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and
          (m_MagicArr[2][nMid].btLevel < m_MagicArr[2][nMid].MagicInfo.btTrainLv) and
          (m_MagicArr[2][nMid].MagicInfo.TrainLevel[m_MagicArr[2][nMid].btLevel] <= m_nInPowerLevel) then
        begin
          TPlayObject(Self).TrainSkill(m_MagicArr[2][nMid], Random(3) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicArr[2][nMid]) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 2,
              m_MagicArr[2][nMid].MagicInfo.wMagicId,
              m_MagicArr[2][nMid].btLevel,
              m_MagicArr[2][nMid].nTranPoint, '', 3000);
          end;
        end;
      end;
    end;
    if (t <> 0) and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
    begin
      if (m_nInPowerLevel > 0) and (m_nInPowerPoint > 0) then
      begin
        if m_AddDamage > 0 then
        begin
          t := t - Round(nTime / 100 * m_AddDamage);
        end;

        if n = 0 then
        begin
          Dec(m_nInPowerPoint);
          TPlayObject(Self).InternalPowerPointChanged(True);
        end;
      end;
    end;
    if p <> 0 then
      nPoint := _MAX(1, p);
    if t <> 0 then
      nTime := _MAX(1, t);
  end;

  if nType < MAX_STATUS_ATTRIBUTE then
  begin
    if nType in [0, 1] then
    begin
      if nTime > 180 then
        nTime := 180;
    end;

    nOldCharStatus := m_nCharStatus;
    if m_wStatusTimeArr[nType] > 0 then
    begin
      if m_wStatusTimeArr[nType] < nTime then
        m_wStatusTimeArr[nType] := nTime;
    end
    else
    begin
      m_wStatusTimeArr[nType] := nTime;
      if nType = POISON_FREEZE then
      begin //if got frozen then slow down hitspeed and walkspeed
        if m_nNonFrzWalkSpeed = 0 then
          m_nNonFrzWalkSpeed := m_nWalkSpeed;
        m_nWalkSpeed := m_nWalkSpeed * 3;
        if m_nNonFrzNextHitTime = 0 then
          m_nNonFrzNextHitTime := m_nNextHitTime;
        m_nNextHitTime := m_nNextHitTime * 3;
      end;
    end;
    m_dwStatusArrTick[nType] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    m_btGreenPoisoningPoint := nPoint;
    if nOldCharStatus <> m_nCharStatus then
    begin
      StatusChanged();
      if nType = POISON_DONTMOVE then //0618
        m_boTDBeffect := True;
    end;

    if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    begin
{$IF DEBUG = 1}
      if g_sPosionType[nType] <> '' then
        SysMsg(Format(g_sPosionType[nType], [nTime]), c_Red, t_Hint);
{$ELSE}
      SysMsg(sYouPoisoned, c_Red, t_Hint);
{$IFEND}
    end;
    Result := True;
  end;
end;

procedure TBaseObject.MagCurse(sec, pwrrate: Integer);
begin
  //MakePosion(nil, 0, POISON_DONTMOVE, sec, 0);

  {nOldCharStatus := m_nCharStatus;
  if m_wStatusTimeArr[POISON_DONTMOVE] > 0 then begin
    if m_wStatusTimeArr[POISON_DONTMOVE] < sec then
      m_wStatusTimeArr[POISON_DONTMOVE] := sec;
  end else begin
    m_wStatusTimeArr[POISON_DONTMOVE] := nTime;
  end;
  m_dwStatusArrTick[POISON_DONTMOVE] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  if nOldCharStatus <> m_nCharStatus then begin
    StatusChanged();
  end;}

  if m_nCursePowerRateTime < (GetTickCount + LongWord(sec * 1000)) then
  begin
    m_nCursePowerRate := pwrrate;
    m_nCursePowerRateTime := GetTickCount + LongWord(sec * 1000);

    if pwrrate < 100 then
    begin
      SysMsg('¹¥»÷Á¦¼õÉÙ' + IntToStr(100 - pwrrate) + '%£¬Ê§È¥ÎïÀí·ÀÓù' + IntToStr(sec) + 'Ãë',
        c_Red, t_Hint);
    end
    else if pwrrate = 100 then
    begin
      SysMsg('Ê§È¥ÎïÀí·ÀÓù' + IntToStr(sec) + 'Ãë', c_Red, t_Hint);
    end
    else
    begin
      SysMsg('¹¥»÷Á¦Ôö¼Ó' + IntToStr(pwrrate - 100) + '%£¬Ê§È¥ÎïÀí·ÀÓù' + IntToStr(sec) + 'Ãë',
        c_Red, t_Hint);
    end;
    RecalcAbilitys;
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  end;
end;

function TBaseObject.MakeSinSuSlave: Boolean;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if SendMessage.wIdent = RM_MAKESLAVE then
      begin
        Result := True;
        Break;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TPLayObject.sendStorageItemList(nBaseObject: Integer);
var
  i: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  sSENDMSG := '';
  for i := 0 to m_StorageItemList.Count - 1 do
  begin
    UserItem := m_StorageItemList.Items[i];
    item := UserEngine.GetStdItem(UserItem.wIndex);
    if item <> nil then
    begin
      StdItem := item^;
      ItemUnit.GetItemAddValue(UserItem, StdItem);
      Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.s.ItemType := UserItem.btValue[14];
      GetSendClientItem(UserItem, Self, ClientItem);

      sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_GETSTORAGEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count);
  SendSocket(@m_DefMsg, sSENDMSG);
end;

procedure TPlayObject.SendSaveItemList(nBaseObject: Integer);
var
  i: Integer;
  item: pTStdItem;
  sSENDMSG: string;
  ClientItem: TClientItem;
  StdItem: TStdItem;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
{$IF VER_ClientType_45}
  if m_nSoftVersionDateEx = 0 then
  begin
    sSENDMSG := '';
    for i := 0 to m_StorageItemList.Count - 1 do
    begin
      UserItem := m_StorageItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        CopyStdItemToOStdItem(@StdItem, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        sSENDMSG := sSENDMSG + EncodeBuffer(@OClientItem, SizeOf(TOClientItem)) + '/';
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count);
    SendSocket(@m_DefMsg, sSENDMSG);
  end
  else
  begin
{$IFEND VER_ClientType_45}
    sSENDMSG := '';
    for i := 0 to m_StorageItemList.Count - 1 do
    begin
      UserItem := m_StorageItemList.Items[i];
      item := UserEngine.GetStdItem(UserItem.wIndex);
      if item <> nil then
      begin
        StdItem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        Move(StdItem, ClientItem.s, SizeOf(TClientStdItem));
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, Self, ClientItem);

        sSENDMSG := sSENDMSG + EncodeBuffer(@ClientItem, SizeOf(TClientItem)) + '/';
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, m_StorageItemList.Count);
    SendSocket(@m_DefMsg, sSENDMSG);
{$IF VER_ClientType_45}
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.SendChangeGuildName;
begin
  if m_MyGuild <> nil then
  begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGuild(m_MyGuild).sGuildName + '/' + m_sGuildRankName);
  end
  else
  begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList; wParam: Word);
var
  i: Integer;
  s10: string;
begin
  s10 := '';
  for i := 0 to ItemList.Count - 1 do
    s10 := s10 + ItemList.Strings[i] + '/' + IntToStr(Integer(ItemList.Objects[i])) + '/';
  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HERODELITEMS, 0, wParam, 0, ItemList.Count);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeString(s10));
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_DefMsg := MakeDefaultMsg(SM_DELITEMS, 0, wParam, 0, ItemList.Count);
    SendSocket(@m_DefMsg, EncodeString(s10));
  end;
end;

procedure TPlayObject.SendDelItems(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
begin
{$IF VER_ClientType_45}
  if (m_wClientType = 46) then
  begin
{$IFEND VER_ClientType_45}
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      Move(StdItem80, ClientItem.s, SizeOf(TClientStdItem));
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;

      ClientItem.s.ItemType := UserItem.btValue[14];
      GetSendClientItem(UserItem, Self, ClientItem);

      if IsHero then
      begin
        TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HERODELITEM, Integer(m_Master), 0, 0, 1);
        TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
      end
      else if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
      end;
    end;
{$IF VER_ClientType_45}
  end
  else if (m_wClientType = 45) or ((m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0)) then
  begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;

      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      if StdItem.StdMode = 50 then
        OClientItem.s.Name := OClientItem.s.Name + ' #' + IntToStr(UserItem.Dura);
      if IsHero then
      begin
        TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HERODELITEM, {Integer(m_Master)} Integer(m_Master), 0, 0, 1);
        TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
      end
      else if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
      end;
    end;
  end;
{$IFEND VER_ClientType_45}
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem); //004D0A10
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
begin
{$IF VER_ClientType_45}
  if (m_wClientType = 46) then
  begin
{$IFEND VER_ClientType_45}
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      Move(StdItem80, ClientItem.s, SizeOf(TClientStdItem));
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := sUserItemName;
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;

      ClientItem.s.ItemType := UserItem.btValue[14];
      GetSendClientItem(UserItem, Self, ClientItem);

      if IsHero then
      begin
        TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROUPDATEITEM, Integer(m_Master), 0, 0, 1);
        TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
      end
      else if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
      end;
    end;
{$IF VER_ClientType_45}
  end
  else if (m_wClientType = 45) or ((m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0)) then
  begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);
      CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        OClientItem.s.Name := sUserItemName;
      OClientItem.MakeIndex := UserItem.MakeIndex;
      OClientItem.Dura := UserItem.Dura;
      OClientItem.DuraMax := UserItem.DuraMax;
      if IsHero then
      begin
        TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROUPDATEITEM, Integer(m_Master), 0, 0, 1);
        TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
      end
      else if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
      end;
    end;
  end;
{$IFEND VER_ClientType_45}
end;

function TPlayObject.CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean; //004C5084
var
  n: Integer;
  s: string;
  Castle: TUserCastle;
begin
  Result := False;
  if m_StallMgr.OnSale then
    Exit;
  if (StdItem.StdMode in [10, 12]) and (m_btGender <> 0) then
  begin
    SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
    Exit;
  end;
  if (StdItem.StdMode in [11, 13]) and (m_btGender <> 1) then
  begin
    SysMsg(sWearNotOfMan, c_Red, t_Hint);
    Exit;
  end;
  if (nWhere = 1) or (nWhere = 2) then
  begin
    if StdItem.Weight > m_WAbil.MaxHandWeight then
    begin
      SysMsg(sHandWeightNot, c_Red, t_Hint);
      Exit;
    end;
  end
  else if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight then
  begin
    SysMsg(sWearWeightNot, c_Red, t_Hint);
    Exit;
  end;

  if StdItem.Need in [14..17] then
  begin
    n := 0;
    case m_btJob of
      0: n := 1;
      1: n := 2;
      2: n := 4;
    end;

    s := '';
    if LoWord(StdItem.NeedLevel) and 1 <> 0 then
    begin
      s := ' ÎäÊ¿ ';
    end;
    if LoWord(StdItem.NeedLevel) and 2 <> 0 then
    begin
      if s = '' then
        s := ' ·¨Ê¦ '
      else
        s := s + '·¨Ê¦ ';
    end;
    if LoWord(StdItem.NeedLevel) and 4 <> 0 then
    begin
      if s = '' then
        s := ' µÀÊ¿ '
      else
        s := s + 'µÀÊ¿ ';
    end;
    if LoWord(StdItem.NeedLevel) and n = 0 then
    begin
      SysMsg(Format('Ö°Òµ²»¶ÔÓ¦£¬Ö»ÊÊºÏ%s´©´÷', [s]), c_Red, t_Hint);
      Exit;
    end;
  end;

  case StdItem.Need of
    0: if m_Abil.Level >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sLevelNot, c_Red, t_Hint);
    1: if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sDCNot, c_Red, t_Hint);
    2: if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sMCNot, c_Red, t_Hint);
    3: if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sSCNot, c_Red, t_Hint);
    4: if m_btReLevel >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);

    10:
      begin
        if (m_btJob <> LoWord(StdItem.NeedLevel)) then
        begin
          SysMsg('²»ÊÊºÏÄãµÄÖ°Òµ', c_Red, t_Hint);
          Exit;
        end;
        if (m_Abil.Level < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('µÈ¼¶²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    11:
      begin
        if (m_btJob <> LoWord(StdItem.NeedLevel)) then
        begin
          SysMsg('²»ÊÊºÏÄãµÄÖ°Òµ', c_Red, t_Hint);
          Exit;
        end;
        if (HiWord(m_WAbil.DC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('ÎïÀí¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    12:
      begin
        if (m_btJob <> LoWord(StdItem.NeedLevel)) then
        begin
          SysMsg('²»ÊÊºÏÄãµÄÖ°Òµ', c_Red, t_Hint);
          Exit;
        end;
        if (HiWord(m_WAbil.MC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('Ä§·¨¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    13:
      begin
        if (m_btJob <> LoWord(StdItem.NeedLevel)) then
        begin
          SysMsg('²»ÊÊºÏÄãµÄÖ°Òµ', c_Red, t_Hint);
          Exit;
        end;
        if (HiWord(m_WAbil.SC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('µÀÊõ¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;

    //
    14:
      begin
        if (m_Abil.Level < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('µÈ¼¶²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    15:
      begin
        if (HiWord(m_WAbil.DC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('ÎïÀí¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    16:
      begin
        if (HiWord(m_WAbil.MC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('Ä§·¨¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;
    17:
      begin
        if (HiWord(m_WAbil.SC) < HiWord(StdItem.NeedLevel)) then
        begin
          SysMsg('µÀÊõ¹¥»÷²»¹»', c_Red, t_Hint);
          Exit;
        end;
        Result := True;
      end;

    {10: if (m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sJobOrLevelNot, c_Red, t_Hint);

    11: if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sJobOrDCNot, c_Red, t_Hint);
    12: if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sJobOrMCNot, c_Red, t_Hint);
    13: if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sJobOrSCNot, c_Red, t_Hint);}

    40: if m_btReLevel >= LoWord(StdItem.NeedLevel) then
      begin
        if m_Abil.Level >= HiWord(StdItem.NeedLevel) then
          Result := True
        else
          SysMsg(g_sLevelNot, c_Red, t_Hint);
      end
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
    41: if m_btReLevel >= LoWord(StdItem.NeedLevel) then
      begin
        if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then
          Result := True
        else
          SysMsg(g_sDCNot, c_Red, t_Hint);
      end
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
    42: if m_btReLevel >= LoWord(StdItem.NeedLevel) then
      begin
        if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then
          Result := True
        else
          SysMsg(g_sMCNot, c_Red, t_Hint);
      end
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
    43: if m_btReLevel >= LoWord(StdItem.NeedLevel) then
      begin
        if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then
          Result := True
        else
          SysMsg(g_sSCNot, c_Red, t_Hint);
      end
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
    44: if m_btReLevel >= LoWord(StdItem.NeedLevel) then
      begin
        if m_btCreditPoint >= HiWord(StdItem.NeedLevel) then
          Result := True
        else
          SysMsg(g_sCreditPointNot, c_Red, t_Hint);
      end
      else
        SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
    5: if m_btCreditPoint >= StdItem.NeedLevel then
        Result := True
      else
        SysMsg(g_sCreditPointNot, c_Red, t_Hint);
    6: if (m_MyGuild <> nil) then
        Result := True
      else
        SysMsg(g_sGuildNot, c_Red, t_Hint);
    7:
      begin
        Castle := g_CastleManager.IsCastleMember(Self);
        if (m_MyGuild <> nil) and (Castle <> nil) then
          Result := True
        else
          SysMsg(g_sSabukHumanNot, c_Red, t_Hint);
      end;
    60: if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
        Result := True
      else
        SysMsg(g_sGuildMasterNot, c_Red, t_Hint);
    70:
      begin
        Castle := g_CastleManager.IsCastleMember(Self);
        if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then
        begin
          if m_Abil.Level >= StdItem.NeedLevel then
            Result := True
          else
            SysMsg(g_sLevelNot, c_Red, t_Hint);
        end
        else
          SysMsg(g_sSabukMasterManNot, c_Red, t_Hint);
      end;
    8: if m_nMemberType <> 0 then
        Result := True
      else
        SysMsg(g_sMemberNot, c_Red, t_Hint);
    81: if (m_nMemberType = LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
    82: if (m_nMemberType >= LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >= HiWord(StdItem.NeedLevel)) then
        Result := True
      else
        SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
  end;
end;

function TBaseObject.GetRecallXY(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer): Boolean;
var
  i: Integer;
  ii: Integer;
  III: Integer;
begin
  Result := False;
  //if m_PEnvir.GetMovingObject(nX, nY, True) = nil then begin
  if m_PEnvir.CanWalk(nX, nY, True) then
  begin
    Result := True;
    nDX := nX;
    nDY := nY;
  end;
  if not Result then
  begin
    for i := 1 to nRange do
    begin
      for ii := -i to i do
      begin
        for III := -i to i do
        begin
          nDX := nX + III;
          nDY := nY + ii;
          //if m_PEnvir.GetMovingObject(nDX, nDY, True) = nil then begin
          if m_PEnvir.CanWalk(nDX, nDY, True) then
          begin
            Result := True;
            Break;
          end;
        end;
        if Result then
          Break;
      end;
      if Result then
        Break;
    end;
  end;
  if not Result then
  begin
    nDX := nX;
    nDY := nY;
  end;
end;

function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer; //004BF764
var
  i: Integer;
  n14: Integer;
  StdItem: pTStdItem;
begin
  n14 := 0;
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if (nWhere = -1) or (not (i = nWhere) and not (i = 1) and not (i = 2)) then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if StdItem <> nil then
        Inc(n14, StdItem.Weight);
    end;
  end;
  Result := n14;
end;

function TPlayObject.EatItems(StdItem: pTStdItem): Boolean;
var
  bo06: Boolean;
  nOldStatus: Integer;
begin
  Result := False;
  if m_PEnvir.m_MapFlag.boNODRUG then
  begin
    SysMsg(sCanotUseDrugOnThisMap, c_Red, t_Hint);
    Exit;
  end;
  if GetTickCount - m_dwEatItemTick > g_Config.nEatItemTime then
  begin
    m_dwEatItemTick := GetTickCount;
  end
  else
    Exit;
  case StdItem.StdMode of
    0:
      begin
        case StdItem.Shape of
          1:
            begin //Ì«ÑôË®ÀàÎïÆ·
              IncHealthSpell(StdItem.AC, StdItem.MAC);
              Result := True;
            end;
          2:
            begin //ÉñË®Àà
              m_boUserUnLockDurg := True;
              Result := True;
            end;
          3: if m_MagicArr[0][42] <> nil then
            begin
              m_nVigour := _MIN((m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour + StdItem.AC);
              SendDefMessage(SM_SQUAREPOWERUP, (m_MagicArr[0][42].btLevel + 1) * 500, m_nVigour, 0, 0, '');
              Result := True;
            end;
          5:
            begin //ÔªÉñÎïÆ·
              IncHealthSpellEx(StdItem.AC, StdItem.MAC);
              Result := True;
            end;
        else
          begin
            if (StdItem.AC > 0) then //ÆÕÍ¨Ò©Æ·
              Inc(m_nIncHealth, StdItem.AC);
            if (StdItem.MAC > 0) then
              Inc(m_nIncSpell, StdItem.MAC);
            Result := True;
          end;
        end;
      end;
    1:
      begin //¸ÉÈâ
        nOldStatus := GetMyStatus();
        Inc(m_nHungerStatus, StdItem.DuraMax div 10);
        m_nHungerStatus := _MIN(5000, m_nHungerStatus);
        if nOldStatus <> GetMyStatus() then
          RefMyStatus();
        Result := True;
      end;
    2: Result := True;
    3:
      begin //Ôö¼ÓÊôÐÔÒ©Æ·
        if StdItem.Shape = 12 then
        begin
          bo06 := False;
          if LoWord(StdItem.DC) > 0 then
          begin
            m_wStatusArrValue[0 {0x218}] := LoWord(StdItem.DC);
            m_dwStatusArrTimeOutTick[0 {0x220}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('¹¥»÷Á¦Ôö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.MC) > 0 then
          begin
            m_wStatusArrValue[1 {0x219}] := LoWord(StdItem.MC);
            m_dwStatusArrTimeOutTick[1 {0x224}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('Ä§·¨Á¦Ôö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoByte(StdItem.SC) > 0 then
          begin
            m_wStatusArrValue[2 {0x21A}] := LoWord(StdItem.SC);
            m_dwStatusArrTimeOutTick[2 {0x228}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('µÀÊõÔö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if HiWord(StdItem.AC) > 0 then
          begin
            m_wStatusArrValue[3 {0x21B}] := HiWord(StdItem.AC);
            m_dwStatusArrTimeOutTick[3 {0x22C}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('¹¥»÷ËÙ¶ÈÔö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.AC) > 0 then
          begin
            m_wStatusArrValue[4 {0x21C}] := LoWord(StdItem.AC);
            m_dwStatusArrTimeOutTick[4 {0x230}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('ÉúÃüÖµÔö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoWord(StdItem.MAC) > 0 then
          begin
            m_wStatusArrValue[5 {0x21D}] := LoWord(StdItem.MAC);
            m_dwStatusArrTimeOutTick[5 {0x234}] := GetTickCount + HiWord(StdItem.MAC) * 1000;
            SysMsg('Ä§·¨ÖµÔö¼Ó' + IntToStr(HiWord(StdItem.MAC)) + 'Ãë', c_Green, t_Hint);
            bo06 := True;
          end;
          if bo06 then
          begin
            RecalcAbilitys();
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            Result := True;
          end;
        end
        else
          Result := EatUseItems(StdItem.Shape);
      end;
  end;
end;

function TPlayObject.ReadBook(StdItem: pTStdItem): Boolean; //004C67DC
var
  btClass: Byte;
  nLvNeed: Integer;
  Magic: pTMagic;
  sMagName: string;
  UserMagic: pTUserMagic;
resourcestring
  sHintMsg1 = 'ÈËÎï¼¼ÄÜ£¬Ó¢ÐÛ²»ÄÜÑ§Ï°£º%s';
  sHintMsg2 = 'Ó¢ÐÛ¼¼ÄÜ£¬ÈËÎï²»ÄÜÑ§Ï°£º%s';
  sHintMsg3 = 'Ìõ¼þ²»·û£¬²»ÄÜÑ§Ï°´ËÓ¢ÐÛºÏ»÷ÃØ¼¼';
  sHintMsg4 = ' ÊÇÓ¢ÐÛºÏ»÷ÃØ¼¼£¬Äú²»ÄÜÑ§Ï°';
begin
  Result := False;

  btClass := 0;
  sMagName := Copy(StdItem.Name, 1, 4);
  if (CompareText(sMagName, 'Å­Ö®') = 0) then
  begin
    btClass := 1;
    if m_nInPowerLevel < 1 then
    begin
      SysMsg('±ØÐëÏÈÑ§Ï°ÄÚ¹¦²ÅÄÜÑ§Ï°' + StdItem.Name, c_Red, t_Hint);
      Exit;
    end;
  end
  else if (CompareText(sMagName, '¾²Ö®') = 0) then
  begin
    btClass := 2;
    if m_nInPowerLevel < 1 then
    begin
      SysMsg('±ØÐëÏÈÑ§Ï°ÄÚ¹¦²ÅÄÜÑ§Ï°' + StdItem.Name, c_Red, t_Hint);
      Exit;
    end;
  end
  else if (CompareText(sMagName, g_sHeroName) = 0) then
  begin
    btClass := 3;
    if not IsHero then
    begin
      SysMsg(Format(sHintMsg1, [StdItem.Name]), c_Red, t_Hint);
      Exit;
    end;
  end;

  if (StdItem.Shape = 3) then
  begin
    if not IsHero then
    begin
      SysMsg(StdItem.Name + sHintMsg4, c_Red, t_Hint);
      Exit;
    end;

    if (btClass in [0, 1]) then
    begin
      case StdItem.AniCount of
        60: if (m_btJob <> 0) or (m_Master.m_btJob <> 0) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
        61: if ((m_btJob <> 0) or (m_Master.m_btJob <> 2)) and ((m_btJob <> 2) or (m_Master.m_btJob <> 0)) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
        62: if ((m_btJob <> 0) or (m_Master.m_btJob <> 1)) and ((m_btJob <> 1) or (m_Master.m_btJob <> 0)) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
        63: if (m_btJob <> 2) or (m_Master.m_btJob <> 2) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
        64: if ((m_btJob <> 2) or (m_Master.m_btJob <> 1)) and ((m_btJob <> 1) or (m_Master.m_btJob <> 2)) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
        65: if (m_btJob <> 1) or (m_Master.m_btJob <> 1) then
          begin
            SysMsg(sHintMsg3, c_Red, t_Hint);
            Exit;
          end;
      else
        Exit;
      end;
    end;
  end
  else
  begin
    case btClass of
      0: if IsHero then
        begin
          SysMsg(Format(sHintMsg2, [StdItem.Name]), c_Red, t_Hint);
          Exit;
        end;
      //1: ;                              //Å­
      //2: ;                              //¾²
      //3: ;                              //Ó¢ÐÛ
    end;
  end;

  Magic := UserEngine.FindMagic(StdItem.Name);
  if Magic <> nil then
  begin
    if not IsTrainingSkill(Magic.wMagicId, Magic.btClass) then
    begin
      if (Magic.btJob = 99) or (Magic.btJob = m_btJob) then
      begin
        if btClass in [0, 3] then
        begin
          if StdItem.AniCount = 1 then
            nLvNeed := m_nInPowerLevel
          else
            nLvNeed := m_Abil.Level;
        end
        else
          nLvNeed := m_nInPowerLevel;
        if nLvNeed >= Magic.TrainLevel[0] then
        begin
          New(UserMagic);
          UserMagic.MagicInfo := Magic;
          UserMagic.wMagIdx := Magic.wMagicId;
          UserMagic.btKey := 0;
          if StdItem.AniCount = 1 then
            UserMagic.btLevel := 1
          else
            UserMagic.btLevel := 0;
          UserMagic.nTranPoint := 0;
          //if UserMagic.wMagIdx = 4 then UserMagic.btKey := 1;
          m_MagicList.Add(UserMagic);
          RecalcAbilitys();
          if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
            TPlayObject(Self).SendAddMagic(UserMagic);
          Result := True;
        end
        else
        begin
          if btClass in [0, 3] then
          begin
            if StdItem.AniCount = 1 then
              SysMsg(Format('ÐèÒªÄÚ¹¦µÈ¼¶%d²ÅÄÜÑ§Ï°%s', [Magic.TrainLevel[0], StdItem.Name]), c_Red, t_Hint)
            else
              SysMsg(Format('ÐèÒªµÈ¼¶%d²ÅÄÜÑ§Ï°%s', [Magic.TrainLevel[0], StdItem.Name]), c_Red, t_Hint);
          end
          else
            SysMsg(Format('ÐèÒªÄÚ¹¦µÈ¼¶%d²ÅÄÜÑ§Ï°%s', [Magic.TrainLevel[0], StdItem.Name]), c_Red, t_Hint);
        end;
      end
      else
        SysMsg(Format('%s²»ÊÊºÏÄãµÄÖ°Òµ', [StdItem.Name]), c_Red, t_Hint);
    end
    else
      SysMsg(Format('ÄãÒÑÑ§Ï°¹ý%s', [StdItem.Name]), c_Red, t_Hint);
  end;
end;

function TBaseObject.IsTrainingSkill(nIndex: Integer; btClass: Byte): Boolean;
begin
  Result := m_MagicArr[btClass][nIndex] <> nil;
  {Result := False;
  for i := 0 to m_MagicList.Count - 1 do begin
    UserMagic := m_MagicList.Items[i];
    if (UserMagic <> nil) and (UserMagic.wMagIdx = nIndex) and (UserMagic.MagicInfo.btClass = btClass) then begin
      Result := True;
      Break;
    end;
  end;}
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic); //004D12F4
var
  ClientMagic: TClientMagic;
begin
  ClientMagic.Key := Char(UserMagic.btKey);
  ClientMagic.Level := UserMagic.btLevel;
  ClientMagic.CurTrain := UserMagic.nTranPoint;
  ClientMagic.Def := UserMagic.MagicInfo^;
  ClientMagic.Def.btTrainLv := MagicMaxTrainLevel(UserMagic);
  if IsHero then
  begin
    //TPlayObject(m_Master).SendHeroUseMagic()
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROADDMAGIC, 0, 0, 0, 1);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_DefMsg := MakeDefaultMsg(SM_ADDMAGIC, 0, 0, 0, 1);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
  end;
end;

procedure TPlayObject.SendConvertMagic(t1, t2, id1, id2: Integer; UserMagic: pTUserMagic);
var
  ClientMagic: TClientMagic;
begin
  ClientMagic.Key := Char(UserMagic.btKey);
  ClientMagic.Level := UserMagic.btLevel;
  ClientMagic.CurTrain := UserMagic.nTranPoint;
  ClientMagic.Def := UserMagic.MagicInfo^;
  ClientMagic.Def.btTrainLv := MagicMaxTrainLevel(UserMagic);
  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HCONVERTMAGIC, t1, t2, id1, id2);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    TPlayObject(Self).m_DefMsg := MakeDefaultMsg(SM_CONVERTMAGIC, t1, t2, id1, id2);
    TPlayObject(Self).SendSocket(@TPlayObject(Self).m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
  end;
end;

procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HERODELMAGIC, UserMagic.wMagIdx, UserMagic.MagicInfo.btClass, 0, 1);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, '');
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_DefMsg := MakeDefaultMsg(SM_DELMAGIC, UserMagic.wMagIdx, UserMagic.MagicInfo.btClass, 0, 1);
    SendSocket(@m_DefMsg, '');
  end;
end;

procedure TPlayObject.SendDelHeroMagic(UserMagic: pTUserMagic);
begin
  m_DefMsg := MakeDefaultMsg(SM_HERODELMAGIC, UserMagic.wMagIdx, 0, 0, 1);
  SendSocket(@m_DefMsg, '');
end;

function TPlayObject.EatUseItems(nShape: Integer): Boolean; //004BD1BC
var
  Castle: TUserCastle;
begin
  Result := False;
  case nShape of //
    1:
      begin //µØÀÎ¾í
        if m_StallMgr.OnSale then
        begin
          SysMsg('°ÚÌ¯×´Ì¬ÎÞ·¨Ê¹ÓÃ£¡', c_Red, t_Hint);
          Exit;
        end;
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        BaseObjectMove(m_sHomeMap, '', '');
        Result := True;
      end;
    2:
      begin //Ëæ»ú¾í
        if m_StallMgr.OnSale then
        begin
          SysMsg('°ÚÌ¯×´Ì¬ÎÞ·¨Ê¹ÓÃ£¡', c_Red, t_Hint);
          Exit;
        end;
        if not m_PEnvir.m_MapFlag.boNORANDOMMOVE then
        begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          BaseObjectMove(m_sMapName, '', '');
          Result := True;
        end;
      end;
    3:
      begin //»Ø³Ç¾í
        if m_StallMgr.OnSale then
        begin
          SysMsg('°ÚÌ¯×´Ì¬ÎÞ·¨Ê¹ÓÃ£¡', c_Red, t_Hint);
          Exit;
        end;
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        if PKLevel < 2 then
          BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY))
        else
          BaseObjectMove(g_Config.sRedHomeMap, IntToStr(g_Config.nRedHomeX), IntToStr(g_Config.nRedHomeY));
        Result := True;
      end;
    4:
      begin //×£¸£ÓÍ
        if WeaptonMakeLuck() then
          Result := True;
      end;
    5:
      begin //ÐÐ»á»Ø³Ç
        if m_StallMgr.OnSale then
        begin
          SysMsg('°ÚÌ¯×´Ì¬ÎÞ·¨Ê¹ÓÃ£¡', c_Red, t_Hint);
          Exit;
        end;
        if m_MyGuild <> nil then
        begin
          if not m_boInFreePKArea then
          begin
            Castle := g_CastleManager.IsCastleMember(Self);
            if (Castle <> nil) and Castle.IsMasterGuild(TGuild(m_MyGuild)) then
              BaseObjectMove(Castle.m_sHomeMap, IntToStr(Castle.GetHomeX), IntToStr(Castle.GetHomeY))
            else
              SysMsg('ÎÞÐ§', c_Red, t_Hint);
            Result := True;
          end
          else
            SysMsg('´Ë´¦ÎÞ·¨Ê¹ÓÃ', c_Red, t_Hint);
        end;
      end;
    9:
      begin //ÐÞ¸´ÓÍ
        if RepairWeapon() then
          Result := True;
      end;
    10:
      begin //Õ½ÉñÓÍ
        if SuperRepairWeapon() then
          Result := True;
      end;
    11:
      begin //²ÊÆ±
        if WinLottery() then
          Result := True;
      end;
  end;
end;

procedure TPlayObject.MoveToHome;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
end;

procedure TPlayObject.MoveToHomeRandom;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX - 9 + Random(19)), IntToStr(m_nHomeY - 9 + Random(19)));
end;

procedure TPlayObject.BaseObjectMove(sMAP, sX, sY: string); //004BD0C4
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  Envir := m_PEnvir;
  if sMAP = '' then
    sMAP := m_sMapName;
  if (sX <> '') and (sY <> '') then
  begin
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    SpaceMove(sMAP, nX, nY, 0);
  end
  else
    MapRandomMove(sMAP, 0);
  if (Envir <> m_PEnvir) and (m_btRaceServer = RC_PLAYOBJECT) then
    m_boTimeRecall := False;
end;

function TPlayObject.WeaptonMakeLuck: Boolean;
var
  StdItem: pTStdItem;
  nRand: Integer;
  boMakeLuck: Boolean;
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    Exit;
  nRand := 0;
  StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
  if StdItem <> nil then
    nRand := abs((HiWord(StdItem.DC) - LoWord(StdItem.DC))) div 5;
  if Random(g_Config.nWeaponMakeUnLuckRate) = 1 then
    MakeWeaponUnlock()
  else
  begin
    boMakeLuck := False;
    if m_UseItems[U_WEAPON].btValue[4] > 0 then
    begin
      Dec(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sWeaptonMakeLuck {'ÎäÆ÷±»¼ÓÐÒÔËÁË...'}, c_Green, t_Hint);
      boMakeLuck := True;
    end
    else if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1 {1} then
    begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck {'ÎäÆ÷±»¼ÓÐÒÔËÁË...'}, c_Green, t_Hint);
      boMakeLuck := True;
    end
    else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2
      {3}) and (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate {6}) = 1) then
    begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck {'ÎäÆ÷±»¼ÓÐÒÔËÁË...'}, c_Green, t_Hint);
      boMakeLuck := True;
    end
    else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3
      {7}) and (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate {10 + 30}) = 1) then
    begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck {'ÎäÆ÷±»¼ÓÐÒÔËÁË...'}, c_Green, t_Hint);
      boMakeLuck := True;
    end;
    if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (boMakeLuck) then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      SendUpdateItem(@m_UseItems[U_WEAPON])
    end;
    if not boMakeLuck then
      SysMsg(g_sWeaptonNotMakeLuck {'ÎÞÐ§'}, c_Green, t_Hint);
  end;
  Result := True;
end;

function TPlayObject.RepairWeapon: Boolean; //004BD69C
var
  nDura: Integer;
  UserItem: pTUserItem;
begin
  Result := False;
  UserItem := @m_UseItems[U_WEAPON];
  if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then
    Exit;
  Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura {30});
  nDura := _MIN(5000, UserItem.DuraMax - UserItem.Dura);
  if nDura > 0 then
  begin
    Inc(UserItem.Dura, nDura);
    SendMsg(Self, RM_DURACHANGE, 1, UserItem.Dura, UserItem.DuraMax, 0, '');
    SysMsg(g_sWeaponRepairSuccess {'ÎäÆ÷ÐÞ¸´³É¹¦...'}, c_Green, t_Hint);
    Result := True;
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean; //004BD768
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    Exit;
  m_UseItems[U_WEAPON].Dura := m_UseItems[U_WEAPON].DuraMax;
  SendMsg(Self, RM_DURACHANGE, 1, m_UseItems[U_WEAPON].Dura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  SysMsg(g_sWeaponRepairSuccess {'ÎäÆ÷ÐÞ¸´³É¹¦...'}, c_Green, t_Hint);
  Result := True;
end;

function TPlayObject.WinLottery: Boolean; //004BD7F8
var
  nGold, nWinLevel, nRate: Integer;
begin
  nGold := 0;
  nWinLevel := 0;
  nRate := Random(g_Config.nWinLotteryRate);
  if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery6Gold;
      nWinLevel := 6;
      Inc(g_Config.nWinLotteryLevel6);
    end;
  end
  else if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery5Gold;
      nWinLevel := 5;
      Inc(g_Config.nWinLotteryLevel5);
    end;
  end
  else if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery4Gold;
      nWinLevel := 4;
      Inc(g_Config.nWinLotteryLevel4);
    end;
  end
  else if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery3Gold;
      nWinLevel := 3;
      Inc(g_Config.nWinLotteryLevel3);
    end;
  end
  else if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery2Gold;
      nWinLevel := 2;
      Inc(g_Config.nWinLotteryLevel2);
    end;
  end
  else if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery1Gold;
      nWinLevel := 1;
      Inc(g_Config.nWinLotteryLevel1);
    end;
  end;
  if nGold > 0 then
  begin
    case nWinLevel of //
      1: SysMsg(g_sWinLottery1Msg {'×£ºØÄú£¬ÖÐÁËÒ»µÈ½±'}, c_Green, t_Hint);
      2: SysMsg(g_sWinLottery2Msg {'×£ºØÄú£¬ÖÐÁË¶þµÈ½±'}, c_Green, t_Hint);
      3: SysMsg(g_sWinLottery3Msg {'×£ºØÄú£¬ÖÐÁËÈýµÈ½±'}, c_Green, t_Hint);
      4: SysMsg(g_sWinLottery4Msg {'×£ºØÄú£¬ÖÐÁËËÄµÈ½±'}, c_Green, t_Hint);
      5: SysMsg(g_sWinLottery5Msg {'×£ºØÄú£¬ÖÐÁËÎåµÈ½±'}, c_Green, t_Hint);
      6: SysMsg(g_sWinLottery6Msg {'×£ºØÄú£¬ÖÐÁËÁùµÈ½±'}, c_Green, t_Hint);
    end;
    if IncGold(nGold) then
      GoldChanged()
    else
      DropGoldDown(nGold, True, nil, nil);
  end
  else
  begin
    Inc(g_Config.nNoWinLotteryCount, 500);
    SysMsg(g_sNotWinLotteryMsg {'µÈÏÂ´Î»ú»á°É'}, c_Red, t_Hint);
  end;
  Result := True;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer);
begin
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 0 then
  begin
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 3 then
      Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}], 3)
    else
      m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := 1;
  end;
end;

function TBaseObject.IsGuildMaster: Boolean; //004BF4A0
begin
  Result := False;
  if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
    Result := True;
end;

procedure TPlayObject.ChangeServerMakeSlave(SalveInfo: pTSlaveInfo); //004DF84C
var
  nSlavecount: Integer;
  BaseObject: TBaseObject;
begin
  //if m_btJob = 2 then
  //  nSlavecount := 1
  //else
  nSlavecount := 5;
  BaseObject := MakeSlave(SalveInfo.sSalveName, 3, SalveInfo.btSalveLevel, nSlavecount, SalveInfo.dwRoyaltySec);
  if BaseObject <> nil then
  begin
    BaseObject.m_nKillMonCount := SalveInfo.nKillCount;
    BaseObject.m_btSlaveExpLevel := SalveInfo.btSlaveExpLevel;
    BaseObject.m_WAbil.HP := SalveInfo.nHP;
    BaseObject.m_WAbil.MP := SalveInfo.nMP;
    if (1500 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nWalkSpeed then
      BaseObject.m_nWalkSpeed := 1500 - SalveInfo.btSalveLevel * 200;
    if Integer(2000 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nNextHitTime then
      BaseObject.m_nWalkSpeed := 2000 - SalveInfo.btSalveLevel * 200;
    RecalcAbilitys();
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem: pTUserItem);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then
  begin
{$IF VER_ClientType_45}
    if TPlayObject(m_DealCreat).m_nSoftVersionDateEx = 0 then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          OClientItem.s.Name := sUserItemName;
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
    end
    else
    begin
{$IFEND VER_ClientType_45}
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        Move(StdItem80, ClientItem.s, SizeOf(TClientStdItem));
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := sUserItemName;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;

        ClientItem.s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, Self, ClientItem);
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
{$IF VER_ClientType_45}
    end;
{$IFEND VER_ClientType_45}
    m_DealCreat.m_DealLastTick := GetTickCount();
    m_DealLastTick := GetTickCount();
  end;
end;

procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem; remain: Integer);
var
  StdItem: pTStdItem;
  StdItem80: TStdItem;
  ClientItem: TClientItem;
  sUserItemName: string;
begin
  SendDefMessage(SM_DEALADDITEM_OK, UserItem.MakeIndex, remain, 0, 0, '');
  if m_DealCreat <> nil then
  begin
{$IF VER_ClientType_45}
    if TPlayObject(m_DealCreat).m_nSoftVersionDateEx = 0 then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;

        CopyStdItemToOStdItem(@StdItem80, @OClientItem.s);
        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1);
        TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@OClientItem, SizeOf(TOClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end
    else
    begin
{$IFEND VER_ClientType_45}
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        StdItem80 := StdItem^;
        ItemUnit.GetItemAddValue(UserItem, StdItem80);

        //È¡×Ô¶¨ÒåÎïÆ·Ãû³Æ
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;
        Move(StdItem80, ClientItem.s, SizeOf(TClientStdItem));
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;

        ClientItem.s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, TPlayObject(m_DealCreat), ClientItem);

        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1);
        TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
{$IF VER_ClientType_45}
      end;
{$IFEND VER_ClientType_45}
    end;
  end;
end;

procedure TPlayObject.OpenDealDlg(BaseObject: TPlayObject);
begin
  m_boDealing := True;
  m_DealCreat := BaseObject;
  GetBackDealItems();
  SendDefMessage(SM_DEALMENU, 0, 0, 0, 0, m_DealCreat.m_sCharName);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.JoinGroup(PlayObject: TPlayObject);
begin
  m_GroupOwner := PlayObject;
  SendGroupText(Format(g_sJoinGroup, [m_sCharName]));
  CheckMapEvent(5, '');
end;

function TBaseObject.MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;
var
  n14, n18, n1C, n20: Integer;
begin
  Result := False;
  if TargeTBaseObject = nil then
    Exit;
  if g_Config.boMagCanHitTarget or (m_btRaceServer = RC_HERO) then
  begin
    Result := True;
    Exit;
  end;
  n20 := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
  n14 := 0;
  while (n14 < 13) do
  begin
    n18 := GetNextDirection(nX, nY, TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
    if m_PEnvir.GetNextPosition(nX, nY, n18, 1, nX, nY) and m_PEnvir.IsValidCell(nX, nY) then
    begin
      if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY) then
      begin
        Result := True;
        Break;
      end
      else
      begin
        n1C := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
        if n1C > n20 then
        begin
          Result := True;
          Break;
        end;
      end;
    end
    else
      Break;
    Inc(n14);
  end;
end;

function TBaseObject.IsProperFriend(BaseObject: TBaseObject): Boolean; //004C909C

  function IsFriend(cret: TBaseObject): Boolean;
  var
    i: Integer;
    SelfPlay, CretPlay: TBaseObject;
  begin
    Result := False;
    if cret.m_btRaceServer = RC_PLAYOBJECT then
    begin
      SelfPlay := GetMainPlayer(Self);
      CretPlay := GetMainPlayer(cret);
      case m_btAttatckMode of
        HAM_ALL: Result := True;
        HAM_PEACE: Result := True;
        HAM_DEAR: if (SelfPlay = CretPlay) or (CretPlay = TPlayObject(SelfPlay).m_DearHuman) then
            Result := True;
        HAM_MASTER: if (SelfPlay = CretPlay) then
            Result := True
          else if TPlayObject(SelfPlay).m_boMaster then
          begin
            for i := 0 to TPlayObject(SelfPlay).m_MasterList.Count - 1 do
            begin
              if TPlayObject(SelfPlay).m_MasterList.Items[i] = CretPlay then
              begin
                Result := True;
                Break;
              end;
            end;
          end
          else if TPlayObject(CretPlay).m_boMaster then
          begin
            for i := 0 to TPlayObject(CretPlay).m_MasterList.Count - 1 do
            begin
              if TPlayObject(CretPlay).m_MasterList.Items[i] = SelfPlay then
              begin
                Result := True;
                Break;
              end;
            end;
          end;
        HAM_GROUP:
          begin
            if CretPlay = SelfPlay then
              Result := True;
            if TPlayObject(Self).IsGroupMember(CretPlay) then
              Result := True;
          end;
        HAM_GUILD:
          begin
            if CretPlay = SelfPlay then
              Result := True;
            if not Result and (m_MyGuild <> nil) then
            begin
              if m_MyGuild = CretPlay.m_MyGuild then //speed up
                Result := True
              else if m_boGuildWarArea and (CretPlay.m_MyGuild <> nil) then
              begin
                if TGuild(m_MyGuild).IsAllyGuild(TGuild(CretPlay.m_MyGuild)) then
                  Result := True;
              end;
            end;
          end;
        HAM_PKATTACK:
          begin
            if CretPlay = SelfPlay then
              Result := True;
            if PKLevel >= 2 then
            begin
              if CretPlay.PKLevel < 2 then
                Result := True;
            end
            else
            begin
              if CretPlay.PKLevel >= 2 then
                Result := True;
            end;
          end;
      end;
    end;
  end;

begin
  Result := False;
  if BaseObject = nil then
    Exit;
  if (m_btRaceServer >= RC_ANIMAL) then
  begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result := True;
    if BaseObject.m_Master <> nil then
      Result := False;
    Exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    Result := IsFriend(BaseObject);
    if BaseObject.m_btRaceServer < RC_ANIMAL then
      Exit;
    if BaseObject.m_Master = Self then
    begin
      Result := True;
      Exit;
    end;
    if BaseObject.m_Master <> nil then
    begin
      Result := IsFriend(BaseObject.m_Master);
      Exit;
    end;
  end
  else
    Result := True;
end;

function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState, mlevel: Byte): Integer; //004C6F04
var
  III: Integer;
  i, ii: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for i := nStartX to nEndX do
  begin
    for ii := nStartY to nEndY do
    begin
      if m_PEnvir.GetMapCellInfo(i, ii, MapCellInfo) and (MapCellInfo.ObjList <> nil){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} then
      begin
        for III := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[III];
          if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (not BaseObject.m_boGhost) then
            begin
              if IsHero then
              begin
                if m_Master.IsProperFriend(BaseObject) then
                begin
                  if btState = 0 then
                    BaseObject.DefenceUp(nSec, mlevel)
                  else
                    BaseObject.MagDefenceUp(nSec, mlevel);
                  Inc(Result);
                end;
              end
              else if ((m_btRaceServer = RC_HERO) and (BaseObject.m_btRaceServer = RC_HERO)) or
                ((m_btRaceServer = RC_PLAYOBJECT) and IsProperFriend(BaseObject)) then
              begin
                if btState = 0 then
                  BaseObject.DefenceUp(nSec, mlevel)
                else
                  BaseObject.MagDefenceUp(nSec, mlevel);
                Inc(Result);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TBaseObject.MagMakeCurseArea(xx, yy, range, sec, Pwr, SkillLevel: Integer; BoMag: Boolean): Integer;
var
  i, j, k, stx, sty, enx, eny, tCount: Integer;
  pm: pTMapCellinfo;
  OSObject: pTOSObject;
  inrange: Boolean;
  cret: TBaseObject;
  isNormalAttack: Boolean;
  isAttack: Boolean;
  targetsec: Integer;
begin
  tCount := 0;
  stx := xx - range;
  enx := xx + range;
  sty := yy - range;
  eny := yy + range;
  for i := stx to enx do
  begin
    for j := sty to eny do
    begin
      inrange := m_PEnvir.GetMapCellInfo(i, j, pm);
      if inrange then
        if pm.ObjList <> nil then
        begin
          for k := 0 to pm.ObjList.Count - 1 do
          begin
            OSObject := pm.ObjList.Items[k];
            if OSObject.btType = OS_MOVINGOBJECT then
            begin
              cret := TBaseObject(OSObject.CellObj);
              if cret <> nil then
              begin
                if (not cret.m_boGhost) and (not cret.m_boDeath) then
                begin
                  if not BoMag then
                  begin
                    if IsProperTarget(cret) then
                    begin
                      targetsec := (sec div 6) - cret.m_nPoisonRecover;
                      isAttack := False;

                      if (Random(90 + (cret.m_btAntiPoison * 2)) < (14 + (SkillLevel + 1) * 8)) then
                        isAttack := True;

                      if isAttack and (targetsec > 0) then
                      begin
                        cret.SendDelayMsg(Self, RM_CURSE, targetsec, Pwr, 0, 0, '', 1200);
                        cret.SendDelayMsg(cret, RM_STRUCK, 1, m_WAbil.HP, m_WAbil.MP, Integer(Self), '', 1200);
                        Inc(tCount);
                      end;
                    end;
                  end
                  else
                  begin
                    if IsProperTarget(cret) then
                    begin
                      isNormalAttack := True;
                      targetsec := sec;
                      if cret.m_btRaceServer = RC_PLAYOBJECT then
                      begin
                        isNormalAttack := False;
                        targetsec := (sec div 6) - cret.m_nPoisonRecover;
                      end
                      else
                      begin
                        if cret.m_Abil.Level >= 60 then
                        begin
                          isNormalAttack := False;
                          targetsec := (sec div 4);
                        end;
                      end;

                      isAttack := False;
                      if isNormalAttack then
                      begin
                        if (Random(80) < (14 + (SkillLevel + 1) * 3 + (Integer(m_Abil.Level) - Integer(cret.m_Abil.Level)))) then
                          isAttack := True;
                      end
                      else
                      begin
                        if (Random(90 + (cret.m_btAntiPoison * 2)) < (14 + (SkillLevel + 1) * 3 + (Integer(m_Abil.Level) - Integer(cret.m_Abil.Level)))) then
                          isAttack := True;
                      end;

                      if isAttack and (targetsec > 0) then
                      begin
                        cret.SendDelayMsg(Self, RM_CURSE, targetsec, Pwr, 0, 0, '', 1200);
                        cret.SendDelayMsg(cret, RM_STRUCK, 1, m_WAbil.HP, m_WAbil.MP, Integer(Self), '', 1200);
                        Inc(tCount);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
    end;
  end;
  Result := tCount;
end;

function TBaseObject.AttPowerUp(nPower, nTime: Integer): Boolean;
var
  nMIN, nSec: Integer;
begin
  m_wStatusArrValue[0] := nPower;
  m_dwStatusArrTimeOutTick[0] := GetTickCount + nTime * 1000;

  nMIN := nTime div 60;
  nSec := nTime mod 60;

  SysMsg(Format(g_sAttPowerUpTime, [nMIN, nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  Result := True;
end;

function TBaseObject.AttPowerDown(nPower, nTime: Integer): Boolean;
var
  nMIN, nSec: Integer;
begin
  m_wStatusArrValue[6] := nPower;
  m_dwStatusArrTimeOutTick[6] := GetTickCount + nTime * 1000;

  nMIN := nTime div 60;
  nSec := nTime mod 60;

  SysMsg(Format(g_sAttPowerDownTime, [nMIN, nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  Result := True;
end;

function TBaseObject.DefenceUp(nSec, mlevel: Integer): Boolean; //004C6C28
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] > 0 then
  begin
    if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] < nSec then
    begin
      m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
      m_DefenceRate := mlevel;
      Result := True;
    end;
  end
  else
  begin
    m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
    m_DefenceRate := mlevel;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_DEFENCEUP {0x20C}] := GetTickCount;
  SysMsg(Format(g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
    StatusChanged();
end;

function TBaseObject.MagDefenceUp(nSec, mlevel: Integer): Boolean; //004C6D38
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] > 0 then
  begin
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] < nSec then
    begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
      m_MagDefenceRate := mlevel;
      Result := True;
    end;
  end
  else
  begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
    m_MagDefenceRate := mlevel;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP {0x210}] := GetTickCount;
  SysMsg(Format(g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
    StatusChanged();
end;

function TBaseObject.MagPoison7(nSec, mlevel: Integer): Boolean;
var
  nOldStatus: Integer;
begin
  m_wStatusTimeArr[POISON_7] := nSec;
  m_dwStatusArrTick[POISON_7] := GetTickCount;
  SysMsg(Format('%dÃëÄÚ·ÀÓùÄÜÁ¦ÎªÁã', [nSec]), c_Red, t_Hint);
  RecalcAbilitys();
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
    StatusChanged();
end;
//Ä§·¨¶Ü

function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
var
  nOldStatus: Integer;
begin
  Result := False;
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] <> 0 then
    Exit;
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := nSec;
  m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP {0x214}] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
    StatusChanged();
  m_boAbilMagBubbleDefence := True;
  m_btMagBubbleDefenceLevel := nLevel;
  Result := True;
end;

function TBaseObject.MagPossessedUp(nState, nLevel, nSec: Integer): Boolean; //¸½Éí¼¼ÄÜ
var
  nOldStatus: Integer;
begin
  Result := False;
  if not nState in [STATE_13..STATE_28] then
    Exit;
  if m_wStatusTimeArrEx[nState] <> 0 then
    Exit;
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArrEx[nState] := nSec;
  m_dwStatusArrTickEx[nState] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
  begin
    StatusChanged();
    case nState of
      STATE_13: SysMsg('Äã»ñµÃÁË[ÉñÁú¸½Éí]ÉñÁ¦', c_Green, t_Hint);
      STATE_14: SysMsg('Äã»ñµÃÁË[Áú»¯]ÉñÁ¦', c_Green, t_Hint);
      STATE_15: SysMsg('[ÖØÉË] Ò»¶¨Ê±¼äÄÚHP²»¶Ï¼õÉÙ', c_Red, t_Hint);
    end;
  end;
  Result := True;
end;

function TBaseObject.MagShieldDefenceUp(nLevel: Integer): Boolean;
begin
  Result := False;
  if m_nMagShieldHP <= 0 then
  begin
    m_btMagShieldLevel := nLevel;
    m_nMagShieldHP := (nLevel + 1) * (66 + m_Abil.Level) * 2;
    SendRefMsg(RM_STRUCKEFFECTEX, 0, 11, 0, 0, '');
    Result := True;
  end
  else if m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
    SysMsg('²»ÄÜÁ¬ÐøÊÍ·Å¼¼ÄÜ...', c_Green, t_Hint);
end;

function TBaseObject.MagDontMove(nSec: Integer): Boolean;
begin
  Result := False;
  Randomize();
  if Random(100) < g_Config.nSSFreezeRate then
  begin
    try
      m_wStatusTimeArr[POISON_PURPLE] := nSec;
      m_dwStatusArrTick[POISON_PURPLE] := GetTickCount();
    finally
      m_nCharStatus := GetCharStatus();
      //if nOldStatus <> m_nCharStatus then
      StatusChanged();
    end;
    Result := True;
  end;
end;

function TBaseObject.MagTransparent(nSec: Integer): Boolean;
begin
  m_wStatusTimeArr[STATE_TRANSPARENT] := nSec;
  m_dwStatusArrTick[STATE_TRANSPARENT] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  StatusChanged();
  m_boHideMode := True;
  m_boTransparent := True;
  Result := True;
end;

procedure TPlayObject.DigItem(Shape: Integer);

  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {1300}) + g_Config.nStoneMinDura{3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then
      Result := Result + Random(g_Config.nStoneAddDuraMax {1000});
  end;
var
  UserItem: pTUserItem;
begin
  if m_ItemList.Count >= GetMaxBagItem then
    Exit;
  New(UserItem);
  if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then
  begin
    //³ö¼«Æ·ÊôÐÔ
    m_ItemList.Add(UserItem);
    WeightChanged();
    SendAddItem(UserItem);
  end
  else
    Dispose(UserItem);

  //BaseObject.SendRefMsg(RM_STRUCKEFFECTEX, 0, 9, 0, 0, '');
 //SendRefMsg(RM_STRUCKEFFECTEX, 0, 10, 0, 0, '');
end;

procedure TPlayObject.MakeMine;

  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) + g_Config.nStoneMinDura {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
  end;
var
  UserItem: pTUserItem;
  nRANDOM: Integer;
begin
  if m_ItemList.Count >= GetMaxBagItem then
    Exit;
  nRANDOM := Random(g_Config.nStoneTypeRate {120});
  if nRANDOM in [g_Config.nGoldStoneMin {1}..g_Config.nGoldStoneMax {2}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        CheckMapEvent(3, g_Config.sGoldStone);
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSilverStoneMin {3}..g_Config.nSilverStoneMax {20}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        CheckMapEvent(3, g_Config.sSilverStone);
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nSteelStoneMin {21}..g_Config.nSteelStoneMax {45}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        CheckMapEvent(3, g_Config.sSteelStone);
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    Exit;
  end;
  if nRANDOM in [g_Config.nBlackStoneMin {46}..g_Config.nBlackStoneMax {56}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        CheckMapEvent(3, g_Config.sBlackStone);
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    Exit;
  end;
  New(UserItem);
  if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
      CheckMapEvent(3, g_Config.sCopperStone);
    UserItem.Dura := RandomDrua();
    m_ItemList.Add(UserItem);
    WeightChanged();
    SendAddItem(UserItem);
  end
  else
    Dispose(UserItem);
end;

function TPlayObject.QuestCheckItem(sItemName: string; var nCount, nParam: Integer; var nDura: Integer): pTUserItem;
var
  i: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
begin
  Result := nil;
  nParam := 0;
  nDura := 0;
  nCount := 0;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    ps := UserEngine.GetStdItem(UserItem.wIndex);
    if ps = nil then Exit;                       
    if CompareText(ps.Name, sItemName) = 0 then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
        begin
          Continue;
        end;
      end;
      if ps.Overlap >= 1 then
      begin
        if UserItem.Dura > nDura then
        begin
          nDura := UserItem.Dura;
          Result := UserItem;
        end;
        Inc(nParam, UserItem.Dura);
        if Result = nil then
          Result := UserItem;
        Inc(nCount, UserItem.Dura);
      end
      else
      begin
        if UserItem.Dura > nDura then
        begin
          nDura := UserItem.Dura;
          Result := UserItem;
        end;
        Inc(nParam, UserItem.Dura);
        if Result = nil then
          Result := UserItem;
        Inc(nCount);
      end;
    end;
  end;
end;

function TBaseObject.sub_4C4CD4(sItemName: string; var nCount: Integer): pTUserItem; //004C4CD4
var
  i: Integer;
  sName: string;
begin
  Result := nil;
  nCount := 0;
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    sName := UserEngine.GetStdItemName(m_UseItems[i].wIndex);
    if CompareText(sName, sItemName) = 0 then
    begin
      Result := @m_UseItems[i];
      Inc(nCount);
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem): Boolean; //004C4F6C
var
  i, t: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
begin
  Result := False;
  if m_StallMgr.OnSale then
    Exit;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem = CheckItem then
    begin
      ps := UserEngine.GetStdItem(UserItem.wIndex);
      if ps <> nil then
      begin
        if ps.Overlap >= 1 then
        begin
          t := UserItem.Dura;
          Dec(t);
          if t <= 0 then
          begin
            SendDelItems(UserItem);
            Dispose(UserItem);
            m_ItemList.Delete(i);
            Result := True;
          end
          else
          begin
            UserItem.Dura := t;
            SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, ps.Name);
            Result := True;
          end;
        end
        else
        begin
          SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(i);
          Result := True;
        end;
      end;
      Break;
    end;
  end;
  for i := Low(m_UseItems) to High(m_UseItems) do
  begin
    if @m_UseItems[i] = CheckItem then
    begin
      SendDelItems(@m_UseItems[i]);
      m_UseItems[i].wIndex := 0;
      Result := True;
      Break;
    end;
  end;
  if Result then
    WeightChanged;
end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
var
  i: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItemA := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if (UserItem.MakeIndex = nInt) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
        begin
          Exit;
        end;
      end;
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if (CompareText(sUserItemName, sMsg) = 0) then
      begin
        UserItemA := UserItem;
        Break;
      end;
    end;
  end;
  if UserItemA = nil then
    Exit;

  if nParam1 = 0 then
    Exit;
  if TObject(nParam1) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nParam1));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;

  //Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and ((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryRepairCost(Self, UserItemA);
end;

procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
var
  i: Integer;
  UserItem, UserItem2: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItem := nil;
  UserItem2 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
    if (UserItem.MakeIndex = nInt) and (CompareText(sUserItemName, sMsg) = 0) then
    begin
      UserItem2 := UserItem;
      Break;
    end;
  end;
  if UserItem2 = nil then
    Exit;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if TPlayObject(Self).IsOnSaleItem(UserItem2.MakeIndex) then
    begin
      Exit;
    end;
  end;
  if InLimitItemList('', UserItem2.wIndex, t_dRepair) then
  begin
    SendDefMessage(SM_USERREPAIRITEM_FAIL, nParam1, 0, 0, 0, '');
    Exit;
  end;
  if nParam1 = 0 then
    Exit;
  if TObject(nParam1) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(nParam1));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;
  //Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and ((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientRepairItem(Self, UserItem2);
end;

procedure TPlayObject.ClientStorageItem(Npc: TObject; nItemIdx, Count: Integer; sMsg: string; bIsStorageView:Boolean);

  function SaveCountItemAdd(uitem: pTUserItem; var Cnt: Integer; var bak_ui: TUserItem): Integer;
  var
    i: Integer;
    ps, ps2: pTStdItem;
  begin
    Result := 0;
    ps := UserEngine.GetStdItem(uitem.wIndex);
    if ps <> nil then
    begin
      for i := 0 to m_StorageItemList.Count - 1 do
      begin
        ps2 := UserEngine.GetStdItem(pTUserItem(m_StorageItemList[i]).wIndex);
        if ps2 <> nil then
        begin
          if (ps.StdMode = ps2.StdMode) and (ps.Looks = ps2.Looks) and (ps2.Overlap >= 1) then
          begin
            if CompareText(ps.Name, ps2.Name) = 0 then
            begin
              if pTUserItem(m_StorageItemList[i]).Dura + Cnt <= MAX_OVERLAPITEM then
              begin //ok... del uitem
                bak_ui.wIndex := pTUserItem(m_StorageItemList[i]).wIndex;
                bak_ui.MakeIndex := pTUserItem(m_StorageItemList[i]).MakeIndex;
                pTUserItem(m_StorageItemList[i]).Dura := pTUserItem(m_StorageItemList[i]).Dura + Cnt;
                Result := 1;
                Break;
              end
              else
              begin
                if MAX_OVERLAPITEM <= pTUserItem(m_StorageItemList[i]).Dura then
                begin //full
                  Result := 2;
                end
                else
                begin
                  bak_ui.wIndex := pTUserItem(m_StorageItemList[i]).wIndex;
                  bak_ui.MakeIndex := pTUserItem(m_StorageItemList[i]).MakeIndex;
                  Cnt := MAX_OVERLAPITEM - pTUserItem(m_StorageItemList[i]).Dura; //Storage cnt
                  pTUserItem(m_StorageItemList[i]).Dura := MAX_OVERLAPITEM;
                  Result := 3;
                  Break;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;

var
  Merchant: TMerchant;
  i, remain, nStorageCount: Integer;
  newpu, UserItem: pTUserItem;
  bak_ui: TUserItem;
  Flag, renew: Boolean;
  StdItem: pTStdItem;
  sUserItemName: string;
  iRetVal: Integer;
  countstr: string;
resourcestring
  sDisableStorageMsg = 'ÎïÆ·:%s ½ûÖ¹´æ´¢';
begin
  if m_StallMgr.OnSale then
    Exit;
  Flag := False;
  renew := False;
  remain := 0;
  newpu := nil;
  UserItem := nil;
  countstr := '';
  if Pos(' ', sMsg) >= 0 then
    GetValidStr3(sMsg, sMsg, [' ']);
  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
  begin
    SysMsg(g_sTryModeCanotUseStorage {'ÊÔÍæÄ£Ê½²»¿ÉÒÔÊ¹ÓÃ²Ö¿â¹¦ÄÜ'}, c_Red, t_Hint);
    Exit;
  end;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then
    begin
      if Integer(Npc) = 0 then
        Exit;
      if TObject(Npc) = m_LastNPC then
      begin
        Merchant := TMerchant(m_LastNPC);
      end
      else
      begin
        Merchant := UserEngine.FindMerchant(TObject(Npc));
        if Merchant <> nil then
          m_LastNPC := Merchant;
      end;

      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (Merchant <> nil) and (StdItem <> nil) and (Merchant.m_boStorage) and (((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then
      begin
        {LimitItem by Blue ½ûÖ¹´æ´¢µÄÎïÆ·}
        if InLimitItemList(sUserItemName, UserItem.wIndex, t_dStorage) then
        begin
          SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
          SysMsg(Format(sDisableStorageMsg, [sUserItemName]), c_Red, t_Hint);
          SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, sDisableStorageMsg);
          Break;
        end;

        if StdItem.Overlap >= 1 then
        begin
          if (Count > MAX_OVERLAPITEM) or (UserItem.Dura <= 0) then
            Break;
          if Count <= 0 then
            Count := 1;
          if Count > UserItem.Dura then
            Count := UserItem.Dura;
          remain := UserItem.Dura - Count;
          iRetVal := SaveCountItemAdd(UserItem, Count, bak_ui);

          if iRetVal = 1 then
          begin //del
            UserItem.Dura := remain;
            Flag := True;
          end
          else if iRetVal = 2 then
          begin //full
            SendDefMessage(SM_STORAGE_FAIL, 2, 0, 0, 0, '');
            Exit;
          end
          else if iRetVal = 3 then
          begin //remain
            SendDefMessage(SM_STORAGE_FAIL, 3, Count, 0, 0, '');
            UserItem.Dura := UserItem.Dura - Count;
            Flag := True;
          end
          else
          begin
            if g_Config.boExtendStorage then
              nStorageCount := High(TStorageItems) + High(TStorageItemsEx)
            else
              nStorageCount := High(TStorageItems);
            if m_StorageItemList.Count < nStorageCount then
            begin
              New(newpu);
              if UserEngine.CopyToUserItemFromName(sMsg, newpu) then
              begin
                newpu.Dura := Count;
                m_StorageItemList.Add(newpu);
                UserItem.Dura := remain;
                Flag := True;
              end
              else
              begin
                Dispose(newpu);
                newpu := nil;
              end;
            end;
          end;
          if UserItem.Dura = 0 then
          begin
            Dispose(pTUserItem(m_ItemList[i]));
            m_ItemList.Delete(i);
            //m_dwSaveRcdTick := 0; //blue
            UserItem := newpu;
            renew := True;
          end;
        end
        else
        begin
          if g_Config.boExtendStorage then
            nStorageCount := High(TStorageItems) + High(TStorageItemsEx)
          else
            nStorageCount := High(TStorageItems);
          if m_StorageItemList.Count < nStorageCount then
          begin
            m_StorageItemList.Add(UserItem);
            CheckDelStoCopyed();
            m_ItemList.Delete(i);
            //m_dwSaveRcdTick := 0; //blue
            Flag := True;
          end;
        end;

        if Flag then
        begin
          countstr := '(' + IntToStr(Count) + ')';
          WeightChanged;
          if UserItem <> nil then
          begin
            if bIsStorageView then
            begin
              SendDefMessage(SM_STORAGE_OK, UserItem.MakeIndex, remain, Count, Byte(renew), '1');
            end
            else
            begin
              SendDefMessage(SM_STORAGE_OK, UserItem.MakeIndex, remain, Count, Byte(renew), '');
            end;
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('1' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + '0' + countstr);
          end
          else
          begin

            if bIsStorageView then
            begin
              SendDefMessage(SM_STORAGE_OK, bak_ui.MakeIndex, remain, Count, Byte(renew), '1');
            end
            else
            begin
              SendDefMessage(SM_STORAGE_OK, bak_ui.MakeIndex, remain, Count, Byte(renew), '');
            end;
            if StdItem.NeedIdentify = 1 then
              AddGameDataLogAPI('1' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(bak_ui.MakeIndex) + #9 + '1' + #9 + '0' + countstr);
          end;
        end
        else
          SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
        Flag := True;
      end;
      Break;
    end;
  end;
  if not Flag then
    SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientTakeBackStorageItem(Npc: TObject; nItemIdx, TakeBackCnt: Integer; sMsg: string; bIsStorageView: Boolean); //004DC664
var
  Merchant: TMerchant;
  i: Integer;
  bak_ui: TUserItem;
  newpu, UserItem: pTUserItem;
  boGetBackOK: Boolean;
  StdItem: pTStdItem;
  remain: Integer;
  countstr, sUserItemName: string;
begin
  remain := 0;
  countstr := '';
  boGetBackOK := False;
  UserItem := nil;

  if Integer(Npc) = 0 then
  begin
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if TObject(Npc) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(Npc));
    //if Merchant = nil then Merchant := UserEngine.FindNPC(TObject(NPC));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;
  //Merchant := UserEngine.FindMerchant(NPC);
  if Merchant = nil then
  begin
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
  begin
    SysMsg(g_sTryModeCanotUseStorage {'ÊÔÍæÄ£Ê½²»¿ÉÒÔÊ¹ÓÃ²Ö¿â¹¦ÄÜ'}, c_Red, t_Hint);
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
{$IF VEROWNER = WL}
  if not m_boCanGetBackItem then
  begin
    SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\ \' + '²Ö¿â¿ªËøÃüÁî: @' + g_GameCommand.PASSWORDLOCK.sCmd);
    Exit;
  end;
{$ELSE}
  if not m_boCanGetBackItem then
  begin
    SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg
      + '\ \'
      + '²Ö¿â¿ªËøÃüÁî: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
      + '²Ö¿â¼ÓËøÃüÁî: @' + g_GameCommand.Lock.sCmd + '\'
      + 'ÉèÖÃÃÜÂëÃüÁî: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
      + 'ÐÞ¸ÄÃÜÂëÃüÁî: @' + g_GameCommand.CHGPASSWORD.sCmd);
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
    Exit;
  end;
{$IFEND}
  for i := 0 to m_StorageItemList.Count - 1 do
  begin
    UserItem := m_StorageItemList.Items[i];
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then
    begin
      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex, TakeBackCnt))) then
      begin
        if (Merchant <> nil) and (Merchant.m_boGetback) and (((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then
        begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem = nil then
            Break;
          if StdItem.Overlap >= 1 then
          begin
            if TakeBackCnt <= 0 then
              TakeBackCnt := 1;
            if TakeBackCnt > UserItem.Dura then
              TakeBackCnt := UserItem.Dura;
            remain := UserItem.Dura - TakeBackCnt;
            countstr := '(' + IntToStr(TakeBackCnt) + ')';
            if UserCounterItemAdd(StdItem.StdMode, StdItem.Looks, TakeBackCnt, StdItem.Name, False) then
            begin
              if remain > 0 then
              begin
                UserItem.Dura := remain;
                bak_ui.wIndex := UserItem.wIndex;
                bak_ui.MakeIndex := UserItem.MakeIndex;
              end
              else
              begin
                bak_ui.wIndex := UserItem.wIndex;
                bak_ui.MakeIndex := UserItem.MakeIndex;
                Dispose(pTUserItem(m_StorageItemList[i]));
                m_StorageItemList.Delete(i);
              end;
              SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, remain, TakeBackCnt, Integer(bIsStorageView), '');
              if StdItem.NeedIdentify = 1 then
                AddGameDataLogAPI('0' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(bak_ui.MakeIndex) + #9 + '1' + #9 + countstr);
            end
            else
            begin
              New(newpu);
              if UserEngine.CopyToUserItemFromName(sMsg, newpu) then
              begin
                newpu.Dura := TakeBackCnt;
                if AddItemToBag(newpu) then
                begin
                  SendAddItem(newpu);
                  if remain > 0 then
                  begin
                    bak_ui.wIndex := UserItem.wIndex;
                    bak_ui.MakeIndex := UserItem.MakeIndex;
                    UserItem.Dura := remain;
                  end
                  else
                  begin
                    bak_ui.wIndex := newpu.wIndex;
                    bak_ui.MakeIndex := newpu.MakeIndex;
                    Dispose(pTUserItem(m_StorageItemList[i]));
                    m_StorageItemList.Delete(i);
                  end;
                  SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, remain, TakeBackCnt, Integer(bIsStorageView), '');
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLogAPI('0' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(bak_ui.MakeIndex) + #9 + '1' + #9 + countstr);
                end
                else
                begin
                  Dispose(newpu);
                  SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
                  Break;
                end;
              end
              else
              begin
                Dispose(newpu);
              end;
            end;
          end
          else
          begin
            if AddItemToBag(UserItem) then
            begin
              SendAddItem(UserItem);
              m_StorageItemList.Delete(i);
              //m_dwSaveRcdTick := 0;       //0408_1
              SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, remain, TakeBackCnt, Integer(bIsStorageView), '');
              if StdItem.NeedIdentify = 1 then
                AddGameDataLogAPI('0' + #9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + '1' + #9 + '0');
            end
            else
              SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
          end;
          boGetBackOK := True;
        end;
      end
      else
        SysMsg(g_sCanotGetItems {'ÎÞ·¨Ð¯´ø¸ü¶àµÄ¶«Î÷'}, c_Red, t_Hint);
      Break;
    end;
  end;
  if not boGetBackOK then
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
end;

function TBaseObject.CheckItems(sItemName: string): pTUserItem;
var
  i: Integer;
  UserItem: pTUserItem;
begin
  Result := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
        begin
          Continue;
        end;
      end;
      Result := UserItem;
      Break;
    end;
  end;
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumDataInfo {; var CustomData: TCustomData});
var
  midx: Word;
  i, nStorageCount: Integer;
  HumData: pTHumData;
  BagItems: pTBagItems;
  HumMagic: pTHumMagic;
  UserMagic: pTUserMagic;
  StorageItems: pTStorageItems;
  //CustomData                : TCustomData;
begin
  HumData := @HumanRcd.Data;
  HumData.sChrName := m_sCharName;
  HumData.sCurMap := m_sMapName;
  HumData.wCurX := m_nCurrX;
  HumData.wCurY := m_nCurrY;
  HumData.btDir := m_btDirection;
  HumData.btHair := m_btHair;
  HumData.btSex := m_btGender;
  HumData.btJob := m_btJob;
  HumData.nGold := m_nGold;
  HumData.dwGatherNimbus := m_dwGatherNimbus;

  HumData.Abil.Level := m_Abil.Level;

{$IF HIGHHP}
  HumData.Abil.HP := LoWord(m_Abil.HP);
  HumData.Abil.AC := HiWord(m_Abil.HP);
  HumData.Abil.MP := LoWord(m_Abil.MP);
  HumData.Abil.MAC := HiWord(m_Abil.MP);

  HumData.Abil.MaxHP := LoWord(m_Abil.MaxHP);
  HumData.Abil.DC := HiWord(m_Abil.MaxHP);
  HumData.Abil.MaxMP := LoWord(m_Abil.MaxMP);
  HumData.Abil.MC := HiWord(m_Abil.MaxMP);
{$ELSE}
  HumData.Abil.HP := m_Abil.HP;
  HumData.Abil.MP := m_Abil.MP;
  HumData.Abil.MaxHP := m_Abil.MaxHP;
  HumData.Abil.MaxMP := m_Abil.MaxMP;
{$IFEND}

  HumData.Abil.Exp := m_Abil.Exp;
  HumData.Abil.MaxExp := m_Abil.MaxExp;
  HumData.Abil.Diamond := m_nGameDiamond; //New
  HumData.Abil.Gird := m_nGameGird; //New
  HumData.btOptnYBDeal := m_btPostSell; //New
  HumData.Abil.Weight := m_Abil.Weight;
  HumData.Abil.MaxWeight := m_Abil.MaxWeight;
  HumData.Abil.WearWeight := m_Abil.WearWeight;
  HumData.Abil.MaxWearWeight := m_Abil.MaxWearWeight;
  HumData.Abil.HandWeight := m_Abil.HandWeight;
  HumData.Abil.MaxHandWeight := m_Abil.MaxHandWeight;
{$IF HIGHHP}
  HumData.Abil.HP := LoWord(m_WAbil.HP);
  HumData.Abil.AC := HiWord(m_WAbil.HP);
  HumData.Abil.MP := LoWord(m_WAbil.MP);
  HumData.Abil.MAC := HiWord(m_WAbil.MP);
{$ELSE}
  HumData.Abil.HP := m_WAbil.HP;
  HumData.Abil.MP := m_WAbil.MP;
{$IFEND}
  HumData.wStatusTimeArrEx := m_wStatusTimeArrEx;
  HumData.boShowFashion := m_boShowFashion;

  HumData.btActiveTitle := m_btActiveTitle;
  // HumData.HumTitles := m_Titles;
  Move(m_Titles[0], HumData.HumTitles[0], Sizeof(THumTitles));

  HumData.wStatusTimeArr := m_wStatusTimeArr;
  HumData.btMedusaEyeAttack := m_btMedusaEyeAttack;

  HumData.sHomeMap := m_sHomeMap;
  HumData.wHomeX := m_nHomeX;
  HumData.wHomeY := m_nHomeY;

  HumData.nPKPOINT := m_nPkPoint;
  HumData.BonusAbil := m_BonusAbil;
  HumData.nBonusPoint := m_nBonusPoint;

  HumData.btAttribute := m_btAttribute;
  HumData.sStoragePwd := m_sStoragePwd;
  HumData.btCreditPoint := m_btCreditPoint;
  HumData.btReLevel := m_btReLevel;
  HumData.sMasterName := m_sMasterName;
  HumData.boMaster := m_boMaster;
  HumData.sDearName := m_sDearName;
  HumData.nGameGold := m_nGameGold;
  HumData.nGamePoint := m_nGamePoint;
  HumData.boLockLogon := m_boLockLogon;
  HumData.sMarkerMap := m_sMarkerMap;
  HumData.wMarkerX := m_wMarkerX;
  HumData.wMarkerY := m_wMarkerY;
  if g_Config.boSaveKillMonExpRate then
  begin
    if (m_nKillMonExpRate > 0) and (m_dwKillMonExpRateTime > 0) then
    begin
      HumData.nKillMonExpRate := m_nKillMonExpRate;
      HumData.dwKillMonExpRateTime := m_dwKillMonExpRateTime;
    end;
  end;
  HumData.sHeroName := m_sHeroName;
  HumData.sHeroMasterName := m_sHeroMasterName;
  HumData.btInPowerLevel := m_nInPowerLevel;
  HumData.wInPowerPoint := m_nInPowerPoint;
  HumData.dwInPowerExp := m_dwInPowerExp;
  if m_boAllowGroup then
    HumData.btAllowGroup := 1
  else
    HumData.btAllowGroup := 0;
  HumData.btClPkPoint := m_btClPkPoint;

  HumData.btAttatckMode := m_btAttatckMode;
  HumData.btIncHealth := m_nIncHealth;
  HumData.btIncSpell := m_nIncSpell;
  HumData.btIncHealing := m_nIncHealing;
  HumData.btFightZoneDieCount := m_nFightZoneDieCount;
  HumData.sAccount := m_sUserID;
  HumData.btNewHuman := m_btNewHuman;
  HumData.nHungerStatus := m_nHungerStatus;
  HumData.boAllowGuildReCall := m_boAllowGuildReCall;
  HumData.wGroupRcallTime := m_wGroupRcallTime;
  HumData.dBodyLuck := m_dBodyLuck;
  HumData.boAllowGroupReCall := m_boAllowGroupReCall;
  HumData.QuestUnitOpen := m_QuestUnitOpen;
  HumData.QuestUnit := m_QuestUnit;
  HumData.QuestFlag := m_QuestFlag;
{$IF SERIESSKILL}
  HumData.SeriesSkillArr := m_SeriesSkillArr;
  HumData.VenationInfos := m_VenationInfos;
{$IFEND SERIESSKILL}

  HumData.btSPLuck := m_btSPLuck;
  HumData.btSPEnergy := m_btSPEnergy;

  for i := Low(THumanUseItems) to High(THumanUseItems) do
    Move(m_UseItems[i], HumanRcd.Data.HumItems[i], SizeOf(TUserItem));
  //for i := Low(THumAddItems) to High(THumAddItems) do
  //  Move(m_UseItems[i], HumanRcd.Data.HumAddItems[i], SizeOf(TUserItem));

  BagItems := @HumanRcd.Data.BagItems;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    if i >= GetMaxBagItem then
      Break;
    BagItems[i] := pTUserItem(m_ItemList.Items[i])^;
  end;

  HumMagic := @HumanRcd.Data.Magic;
  for i := 0 to m_MagicList.Count - 1 do
  begin
    if i > High(THumMagic) then
      Break;
    UserMagic := m_MagicList.Items[i];
    HumMagic[i].wMagIdx := UserMagic.wMagIdx;
    HumMagic[i].btClass := UserMagic.MagicInfo.btClass; //0424
    HumMagic[i].btLevel := UserMagic.btLevel;
    HumMagic[i].btKey := UserMagic.btKey;
    HumMagic[i].nTranPoint := UserMagic.nTranPoint;
  end;

  StorageItems := @HumanRcd.Data.StorageItems;
  //FillChar(CustomData, SizeOf(TCustomData), #0);
  //if g_Config.boExtendStorage then
  //  nStorageCount := High(TStorageItems) + High(TStorageItemsEx)
  //else
  nStorageCount := High(TStorageItems);
  for i := 0 to m_StorageItemList.Count - 1 do
  begin
    if i >= nStorageCount then
      Break;
    //if i >= High(TStorageItems) then
    //  CustomData.StorageItems[i - High(TStorageItems)] := pTUserItem(m_StorageItemList.Items[i])^
    //else
    StorageItems[i] := pTUserItem(m_StorageItemList.Items[i])^;
  end;
  //if g_Config.boUseCustomData then
  //  SaveHumanCustomData(CustomData);

  for i := 0 to m_MissionList.Count - 1 do
  begin
    if i >= MAXMISSION then
      Break;
    midx := StrToInt(m_MissionList[i]);
    if (midx > 0) and (Word(m_MissionList.Objects[i]) > 0) then
    begin
      HumData.MissionFlag[i].idx := midx;
      HumData.MissionFlag[i].step := Word(m_MissionList.Objects[i]);
    end;
  end;
end;

function TBaseObject.CanWalkRage: Integer;
var
  nX, nY: Integer;
begin
  Result := 0;
  nX := -1;
  while (nX <> 2) do
  begin
    nY := -1;
    while (nY <> 2) do
    begin
      if not m_PEnvir.CanWalk(m_nCurrX + nX, m_nCurrY + nY, False) then
      begin
        if (nX <> 0) or (nY <> 0) then
          Inc(Result);
      end;
      Inc(nY);
    end;
    Inc(nX);
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo: Integer; sRankName: string);
begin
  m_nGuildRankNo := nRankNo;
  m_sGuildRankName := sRankName;
  SendMsg(Self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;

function TBaseObject.DelBagItem(nIndex: Integer; renew: Boolean; log: string): Boolean;
var
  n, t: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
label
  lab;
begin
  Result := False;
  if (nIndex < 0) or (nIndex >= m_ItemList.Count) then
    Exit;
  UserItem := pTUserItem(m_ItemList.Items[nIndex]);

  n := UserItem.MakeIndex;
  ps := UserEngine.GetStdItem(UserItem.wIndex);
  if ps <> nil then
  begin
    if ps.Overlap >= 1 then
    begin
      t := UserItem.Dura;
      Dec(t);
      if t <= 0 then
      begin
        goto lab;
      end
      else
      begin
        UserItem.Dura := t;
        SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, ps.Name);
        Result := True;
      end;
    end
    else
    begin
      lab:
      if renew and ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
        TPlayObject(Self).SendDelItems(UserItem);
      Dispose(UserItem);
      m_ItemList.Delete(nIndex);
      Result := True;
    end;
  end;
  if Result and (log <> '') then
    AddGameDataLogAPI('10' + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      ps.Name + #9 +
      IntToStr(n) + #9 +
      '1' + #9 +
      log);
end;

function TBaseObject.GetBagStdItemCount(StdMode, Shape, maxcnt: Integer): Integer;
var
  i: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
label
  lab;
begin
  Result := 0;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList[i];
    ps := UserEngine.GetStdItem(UserItem.wIndex);
    if (ps <> nil) and (ps.StdMode = StdMode) and (ps.Shape = Shape) then
    begin
      if ps.Overlap >= 1 then
      begin
        Inc(Result, UserItem.Dura);
      end
      else
      begin
        Inc(Result);
      end;
      if Result >= maxcnt then
        Break;
    end;
  end;
end;

function TBaseObject.GetBagStdItemNameCount(Name: string; maxcnt: Integer): Integer;
var
  i: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
label
  lab;
begin
  Result := 0;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList[i];
    ps := UserEngine.GetStdItem(UserItem.wIndex);
    if (ps <> nil) and (CompareText(ps.Name, Name) = 0) then
    begin
      if ps.Overlap >= 1 then
      begin
        Inc(Result, UserItem.Dura);
      end
      else
      begin
        Inc(Result);
      end;
      if Result >= maxcnt then
        Break;
    end;
  end;
end;

function TBaseObject.DelBagStdItemCount(StdMode, Shape, maxcnt: Integer; log: string): Integer;
var
  i, n: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
label
  lab;
begin
  Result := 0;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList[i];
    n := UserItem.MakeIndex;
    ps := UserEngine.GetStdItem(UserItem.wIndex);
    if (ps <> nil) and (ps.StdMode = StdMode) and (ps.Shape = Shape) then
    begin
      if ps.Overlap >= 1 then
      begin
        if UserItem.Dura > (maxcnt - Result) then
        begin
          Dec(UserItem.Dura, (maxcnt - Result));
          SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, ps.Name);
          Inc(Result, (maxcnt - Result));
          if Result >= maxcnt then
            Break;
        end
        else
        begin
          if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
            TPlayObject(Self).SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(i);
          Inc(Result, UserItem.Dura);
          if Result >= maxcnt then
            Break;
        end;
      end
      else
      begin
        if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
          TPlayObject(Self).SendDelItems(UserItem);
        Dispose(UserItem);
        m_ItemList.Delete(i);
        Inc(Result);
        if Result >= maxcnt then
          Break;
      end;

    end;
  end;
  if (Result > 0) and (log <> '') then
    AddGameDataLogAPI('10' + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      ps.Name + #9 +
      IntToStr(n) + #9 +
      '1' + #9 +
      log);
end;

function TBaseObject.DelBagStdItemNameCount(Name: string; maxcnt: Integer; log: string): Integer;
var
  i, n: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
label
  lab;
begin
  Result := 0;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList[i];
    n := UserItem.MakeIndex;
    ps := UserEngine.GetStdItem(UserItem.wIndex);
    if (ps <> nil) and (CompareText(ps.Name, Name) = 0) then
    begin
      if ps.Overlap >= 1 then
      begin
        if UserItem.Dura > (maxcnt - Result) then
        begin
          Dec(UserItem.Dura, (maxcnt - Result));
          SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, ps.Name);
          Inc(Result, (maxcnt - Result));
          if Result >= maxcnt then
            Break;
        end
        else
        begin
          if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
            TPlayObject(Self).SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(i);
          Inc(Result, UserItem.Dura);
          if Result >= maxcnt then
            Break;
        end;
      end
      else
      begin
        if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
          TPlayObject(Self).SendDelItems(UserItem);
        Dispose(UserItem);
        m_ItemList.Delete(i);
        Inc(Result);
        if Result >= maxcnt then
          Break;
      end;

    end;
  end;
  if (Result > 0) and (log <> '') then
    AddGameDataLogAPI('10' + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      ps.Name + #9 +
      IntToStr(n) + #9 +
      IntToStr(Result) + #9 +
      log);
end;

function TBaseObject.DelBagItem(nItemIndex: Integer; sItemName: string): Boolean;
var
  i, t: Integer;
  UserItem: pTUserItem;
  ps: pTStdItem;
begin
  Result := False;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if (UserItem.MakeIndex = nItemIndex) and
      (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) then
    begin
      ps := UserEngine.GetStdItem(UserItem.wIndex);
      if ps <> nil then
      begin
        if ps.Overlap >= 1 then
        begin
          t := UserItem.Dura;
          Dec(t);
          if t <= 0 then
          begin
            Dispose(UserItem);
            m_ItemList.Delete(i);
            Result := True;
          end
          else
          begin
            UserItem.Dura := t;
            SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, ps.Name);
            Result := True;
          end;
        end
        else
        begin
          Dispose(UserItem);
          m_ItemList.Delete(i);
          Result := True;
        end;
      end;
      Break;
    end;
  end;
  if Result then
    WeightChanged();
end;

function TBaseObject.DeleteBagItem(UserItem: pTUserItem): Boolean;
var
  i, t: Integer;
  tpu: pTUserItem;
  ps: pTStdItem;
begin
  Result := False;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    tpu := m_ItemList.Items[i];
    if tpu = UserItem then
    begin
      ps := UserEngine.GetStdItem(tpu.wIndex);
      if ps <> nil then
      begin
        if ps.Overlap >= 1 then
        begin
          t := tpu.Dura;
          Dec(t);
          if t <= 0 then
          begin
            Dispose(tpu);
            m_ItemList.Delete(i);
            Result := True;
          end
          else
          begin
            tpu.Dura := t;
            SendMsg(Self, RM_COUNTERITEMCHANGE, 0, tpu.MakeIndex, tpu.Dura, 0, ps.Name);
            Result := True;
          end;
        end
        else
        begin
          //SendDelItems(tpu);
          Dispose(tpu);
          m_ItemList.Delete(i);
          Result := True;
        end;
      end;
      Break;
    end;
  end;
  if Result then
    WeightChanged();
end;

procedure TPlayObject.GetOldAbil(var OAbility: TOAbility);
begin
  FillChar(OAbility, SizeOf(TOAbility), #0);
  OAbility.Level := m_WAbil.Level;
  OAbility.AC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.AC)), _MIN(High(Byte), HiWord(m_WAbil.AC)));
  OAbility.MAC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MAC)), _MIN(High(Byte), HiWord(m_WAbil.MAC)));
  OAbility.DC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.DC)), _MIN(High(Byte), HiWord(m_WAbil.DC)));
  OAbility.MC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MC)), _MIN(High(Byte), HiWord(m_WAbil.MC)));
  OAbility.SC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.SC)), _MIN(High(Byte), HiWord(m_WAbil.SC)));
  OAbility.HP := m_WAbil.HP;
  OAbility.MP := m_WAbil.MP;
  OAbility.MaxHP := m_WAbil.MaxHP;
  OAbility.MaxMP := m_WAbil.MaxMP;
  OAbility.Exp := m_WAbil.Exp;
  OAbility.MaxExp := m_WAbil.MaxExp;
  OAbility.Weight := m_WAbil.Weight;
  OAbility.MaxWeight := m_WAbil.MaxWeight;
  OAbility.WearWeight := _MIN(High(Byte), m_WAbil.WearWeight);
  OAbility.MaxWearWeight := _MIN(High(Byte), m_WAbil.MaxWearWeight);
  OAbility.HandWeight := _MIN(High(Byte), m_WAbil.HandWeight);
  OAbility.MaxHandWeight := _MIN(High(Byte), m_WAbil.MaxHandWeight);
end;

function TPlayObject.GetHitMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_HIT) or
        (SendMessage.wIdent = CM_HEAVYHIT) or
        (SendMessage.wIdent = CM_BIGHIT) or
        (SendMessage.wIdent = CM_POWERHIT) or
        (SendMessage.wIdent = CM_LONGHIT) or
        (SendMessage.wIdent = CM_WIDEHIT) or
        (SendMessage.wIdent = CM_FIREHIT) or
        (SendMessage.wIdent = CM_HERO_LONGHIT2) or
        (SendMessage.wIdent = CM_SQUHIT) or
        (SendMessage.wIdent = CM_PURSUEHIT) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSpellMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_SPELL) then
        Inc(Result);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_RUN) then
        Inc(Result);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_WALK) then
        Inc(Result);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_TURN) then
        Inc(Result);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  i: Integer;
  SendMessage: pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for i := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_SITDOWN) then
        Inc(Result);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
var
  dwCheckTime: LongWord;
  dwActionIntervalTime: LongWord;
begin
  Result := False;
  dwDelayTime := 0;

  if g_Config.boSpeedHackCheck then
  begin
    Result := True;
    Exit;
  end;

  if not g_Config.boDisableStruck then
  begin
    dwCheckTime := GetTickCount - m_dwStruckTick;
    if g_Config.dwStruckTime > dwCheckTime then
    begin
      dwDelayTime := g_Config.dwStruckTime - dwCheckTime;
      m_btOldDir := m_btDirection;
      Exit;
    end;
  end;

  dwCheckTime := GetTickCount - m_dwActionTick;

  if m_boTestSpeedMode then
    SysMsg('¼ä¸ô: ' + IntToStr(dwCheckTime), c_Blue, t_Notice);

  if m_wOldIdent = wIdent then
  begin //µ±¶þ´Î²Ù×÷Ò»ÑùÊ±£¬Ôò½« boFirst ÉèÖÃÎª Õæ £¬ÍË³öÓÉµ÷ÓÃº¯Êý±¾Éí¼ì²é¶þ¸öÏàÍ¬²Ù×÷Ö®¼äµÄ¼ä¸ôÊ±¼ä
    Result := True;
    Exit;
  end;
  if not g_Config.boControlActionInterval then
  begin
    Result := True;
    Exit;
  end;

  dwActionIntervalTime := m_dwActionIntervalTime;
  case wIdent of
    CM_LONGHIT:
      begin
        //ÅÜÎ»´ÌÉ±
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_HIT:
      begin
        //×ßÎ»¹¥»÷
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_WALK) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //ÅÜÎ»¹¥»÷
        if g_Config.boControlRunHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
      end;
    CM_RUN:
      begin
        //ÅÜÎ»´ÌÉ±
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
        //ÅÜÎ»¹¥»÷
        if g_Config.boControlRunHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
        //ÅÜÎ»Ä§·¨
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_SPELL) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
    CM_WALK:
      begin
        //×ßÎ»¹¥»÷
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //ÅÜÎ»´ÌÉ±
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_SPELL:
      begin
        //ÅÜÎ»Ä§·¨
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
  end;

  //½«¼¸¸ö¹¥»÷²Ù×÷ºÏ²¢³ÉÒ»¸ö¹¥»÷²Ù×÷´úÂë
  if (wIdent = CM_HIT) or
    (wIdent = CM_HEAVYHIT) or
    (wIdent = CM_BIGHIT) or
    (wIdent = CM_POWERHIT) or
    (wIdent = CM_SQUHIT) or
    (wIdent = CM_WIDEHIT) or
    (wIdent = CM_FIREHIT) or
    (wIdent = CM_HERO_LONGHIT2) or
    (wIdent = CM_PURSUEHIT) or
    (wIdent = CM_CRSHIT) or
    (wIdent = CM_TWNHIT) then
  begin
    wIdent := CM_HIT;
  end;

  if dwCheckTime >= dwActionIntervalTime then
  begin
    m_dwActionTick := GetTickCount();
    Result := True;
  end
  else
    dwDelayTime := dwActionIntervalTime - dwCheckTime;
  m_wOldIdent := wIdent;
  m_btOldDir := m_btDirection;
end;

//È¡µÃµ±Ç°½Å±¾¿ÉÒÔÌø×ªµÄ±êÇ©

procedure TPlayObject.GetScriptLabel(sMsg: string);
var
  nPos: Integer;
  sText: string;
  sData: string;
  sCmdStr, sLabel: string;
begin
  m_CanJmpScriptLableList.Clear;
  while (True) do
  begin
    if sMsg = '' then
      Break;
    sMsg := GetValidStr3(sMsg, sText, ['\']);
    if sText <> '' then
    begin
      sData := '';
      while (sText <> '') and (Pos('<', sText) > 0) and (Pos('>', sText) > 0) do
      begin

        if sText[1] <> '<' then
          sText := '<' + GetValidStr3(sText, sData, ['<']);

        sText := ArrestStringEx(sText, '<', '>', sCmdStr);
        if (sCmdStr <> '') then
        begin
          if (TagCount(sCmdStr, '/') >= 1) then
          begin
            sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);
            if sLabel <> '' then
              m_CanJmpScriptLableList.Add(sLabel);
          end
          else
          begin
            nPos := Pos(' LABEL=', UpperCase(sCmdStr));
            if nPos > 0 then
            begin
              sLabel := Copy(sCmdStr, nPos + 7, Length(sCmdStr));
              if sLabel <> '' then
                m_CanJmpScriptLableList.Add(sLabel);
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: string): Boolean;
var
  i: Integer;
begin
  Result := False;
  if CompareText(sLabel, '@main') = 0 then
  begin
    Result := True;
    Exit;
  end;
  for i := 0 to m_CanJmpScriptLableList.Count - 1 do
  begin
    if CompareText(sLabel, m_CanJmpScriptLableList.Strings[i]) = 0 then
    begin
      Result := True;
      Exit;
    end;
  end;
  if CompareText(sLabel, m_sPlayDiceLabel) = 0 then
  begin
    m_sPlayDiceLabel := '';
    Result := True;
    Exit;
  end;
end;

//nType ÎªÖ¸¶¨ÀàÐÍ 1 Îª»¤Éí·û 2 Îª¶¾Ò©  3 Îª´«ËÍ·û

function TPlayObject.CheckAmulet(nCount: Integer; nType: Integer; var idx: Integer): Boolean;
var
  AmuletStdItem: pTStdItem;
begin
  Result := False;
  idx := 0;
  if m_UseItems[U_BUJUK].wIndex > 0 then
  begin
    AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then
    begin
      case nType of
        1:
          begin //»¤Éí·û  Shape = 5 »¤Éí·û
            if (AmuletStdItem.Shape = 5) and (Round(m_UseItems[U_BUJUK].Dura / 100) >= nCount) then
            begin
              idx := U_BUJUK;
              Result := True;
              Exit;
            end;
          end;
        2:
          begin //¶¾Ò©  Shape <= 2
            if (AmuletStdItem.Shape in [1, 2]) and (Round(m_UseItems[U_BUJUK].Dura / 100) >= nCount) then
            begin
              idx := U_BUJUK;
              Result := True;
              Exit;
            end;
          end;
        3:
          begin //´«ËÍ·û  Shape = 6
            if (AmuletStdItem.Shape = 6) and (Round(m_UseItems[U_BUJUK].Dura / 100) >= nCount) then
            begin
              idx := U_BUJUK;
              Result := True;
              Exit;
            end;
          end;
      end;
    end;
  end;
  if m_UseItems[U_ARMRINGL].wIndex > 0 then
  begin
    AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
    if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then
    begin
      case nType of
        1:
          begin
            if (AmuletStdItem.Shape = 5) and (Round(m_UseItems[U_ARMRINGL].Dura / 100) >= nCount) then
            begin
              idx := U_ARMRINGL;
              Result := True;
              Exit;
            end;
          end;
        2:
          begin
            if (AmuletStdItem.Shape in [1, 2]) and (Round(m_UseItems[U_ARMRINGL].Dura / 100) >= nCount) then
            begin
              idx := U_ARMRINGL;
              Result := True;
              Exit;
            end;
          end;
        3:
          begin
            if (AmuletStdItem.Shape = 6) and (Round(m_UseItems[U_ARMRINGL].Dura / 100) >= nCount) then
            begin
              idx := U_ARMRINGL;
              Result := True;
              Exit;
            end;
          end;
      end;
    end;
  end;
end;

procedure TPlayObject.UseAmulet(nCount: Integer; nType: Integer; var idx: Integer);
var
  StdItem: pTStdItem;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    if m_UseItems[idx].Dura > nCount * 100 then
    begin
      Dec(m_UseItems[idx].Dura, nCount * 100);
      SendMsg(Self, RM_DURACHANGE, idx, m_UseItems[idx].Dura, m_UseItems[idx].DuraMax, 0, '');
    end
    else
    begin
      m_UseItems[idx].Dura := 0;
      if (PCardinal(@m_UseItems[idx].btValue[22])^ > 0) and (PCardinal(@m_UseItems[idx].btValue[22])^ = m_dwIdCRC) and g_Config.boBindNoMelt then
      begin
        //if (nDura / 1.03) <> nDuraPoint then begin
        SendMsg(Self, RM_DURACHANGE, idx, 0, m_UseItems[idx].DuraMax, 0, '');
        //SysMsg(Format('ÄãµÄ%s³Ö¾ÃÎª0£¬ÊôÐÔÊ§Ð§£¬Çë¼°Ê±ÐÞÀí', [StdItem.Name]), c_Green, t_Hint);
        //end;
      end
      else
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[idx].wIndex);
        if (StdItem <> nil) and (StdItem.NeedIdentify = 1) then
          AddGameDataLogAPI('3' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + #9 +
            IntToStr(m_UseItems[idx].MakeIndex) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
        SendDelItems(@m_UseItems[idx]);
        m_UseItems[idx].wIndex := 0;
      end;
    end;
  end;
end;

procedure TPlayObject.RecalcAbilitys(boAction: Boolean = False);
begin
  inherited RecalcAbilitys(boAction);
  RecalcAdjusBonus();
end;

procedure TPlayObject.SearchViewRange();
var
  i, nX, nY: Integer;
  nStartX, nEndX: Integer;
  nStartY, nEndY: Integer;
  nPar, nCheckCode: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: pTMapItem;
  MapEvent: TEvent;
{$IF NewVisibleEvent = 1}
  VisibleEvent: pTVisibleEvent;
{$IFEND}
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  uname: string;
  Buffer: array[0..255] of Byte;
resourcestring
  sExceptionMsg1 = '[Exception] TPlayObject::SearchViewRange';
  sExceptionMsg2 = '[Exception] TPlayObject::SearchViewRange 1-%d %s %s %d %d Code:%d';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited SearchViewRange();
    Exit;
  end;

  try
    for i := 0 to m_VisibleItems.Count - 1 do
      pTVisibleMapItem(m_VisibleItems.Items[i]).nVisibleFlag := 0;
    for i := 0 to m_VisibleEvents.Count - 1 do
{$IF NewVisibleEvent = 1}
      pTVisibleEvent(m_VisibleEvents.Items[i]).nVisibleFlag := 0;
{$ELSE}
    TEvent(m_VisibleEvents.Items[i]).m_nVisibleFlag := 0;
{$IFEND}

    for i := 0 to m_VisibleActors.Count - 1 do
      pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleFlag := 0;
  except
    MainOutMessageAPI(sExceptionMsg1);
    KickException();
  end;

  nPar := 1;
  nCheckCode := 0;
  nStartX := m_nCurrX - m_nViewRangeX;
  nEndX := m_nCurrX + m_nViewRangeX;
  nStartY := m_nCurrY - m_nViewRangeY;
  nEndY := m_nCurrY + m_nViewRangeY;
  try
    for nX := nStartX to nEndX do
    begin
      for nY := nStartY to nEndY do
      begin
        nCheckCode := 1;
        if m_PEnvir.GetMapCellInfo(nX, nY, MapCellInfo) and (MapCellInfo.ObjList <> nil){$IF NEWGETMAPCELL = 1} and (MapCellInfo.chFlag <> 1){$IFEND} then
        begin
          i := 0;
          while (True) do
          begin
            if MapCellInfo.ObjList.Count <= i then
              Break;
            OSObject := MapCellInfo.ObjList.Items[i];
            if OSObject <> nil then
            begin
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                if (GetTickCount - OSObject.dwAddTime) >= RELEASE_MAPOBJECT_TIME then
                begin
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(i); //1219
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  Break;
                end;

                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) and not BaseObject.m_boInvisible then
                begin
                  if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode then
                  begin
                    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
                      (m_btRaceServer < RC_ANIMAL) or
                      (m_Master <> nil) or
                      m_boCrazyMode or
                      m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) then
                    begin
                      nCheckCode := 9;
                      UpdateVisibleGay(BaseObject);
                    end;
                  end;
                end;
              end;

              if m_btRaceServer = RC_PLAYOBJECT then
              begin
                if OSObject.btType = OS_ITEMOBJECT then
                begin
                  if (GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then
                  begin
                    Dispose(pTMapItem(OSObject.CellObj));
                    Dispose(OSObject);
                    MapCellInfo.ObjList.Delete(i); //1219
                    if MapCellInfo.ObjList.Count > 0 then
                      Continue;
                    MapCellInfo.ObjList.Free;
                    MapCellInfo.ObjList := nil;
                    Break;
                  end;
                  MapItem := pTMapItem(OSObject.CellObj);
                  UpdateVisibleItem(nX, nY, MapItem);

                  if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then
                  begin
                    if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then
                    begin
                      MapItem.OfBaseObject := nil;
                      MapItem.DropBaseObject := nil;
                    end
                    else
                    begin
                      if TBaseObject(MapItem.OfBaseObject) <> nil then
                      begin
                        if TBaseObject(MapItem.OfBaseObject).m_boGhost then
                          MapItem.OfBaseObject := nil;
                      end;
                      if TBaseObject(MapItem.DropBaseObject) <> nil then
                      begin
                        if TBaseObject(MapItem.DropBaseObject).m_boGhost then
                          MapItem.DropBaseObject := nil;
                      end;
                    end;
                  end;
                end;

                if OSObject.btType = OS_EVENTOBJECT then
                begin
                  MapEvent := TEvent(OSObject.CellObj);
                  if MapEvent.m_boVisible then
                  begin
                    //0331
                    UpdateVisibleEvent(nX, nY, MapEvent);
                  end;
                end;
              end;
            end;
            Inc(i);
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [nPar, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;

  nPar := 2;
  nCheckCode := 20;
  try
    i := 0;
    while (True) do
    begin
      if m_VisibleActors.Count <= i then
        Break;

      VisibleBaseObject := m_VisibleActors.Items[i];
      if VisibleBaseObject.nVisibleFlag = 0 then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
          if not BaseObject.m_boFixedHideMode and not BaseObject.m_boGhost then
            SendMsg(BaseObject, RM_DISAPPEAR, 0, 0, 0, 0, '');
        end;
        m_VisibleActors.Delete(i);
        Dispose(VisibleBaseObject);
        Continue;
      end;

      if (m_btRaceServer = RC_PLAYOBJECT) and (VisibleBaseObject.nVisibleFlag = 2) then
      begin
        BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
        if BaseObject <> Self then
        begin
          if BaseObject.m_boDeath then
          begin
            if BaseObject.m_boSkeleton then
              SendMsg(BaseObject, RM_SKELETON, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '')
            else
              SendMsg(BaseObject, RM_DEATH, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
          end
          else
          begin
            uname := BaseObject.GetShowName;
            SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, uname);
            if BaseObject.m_btRaceServer = RC_FOXBEAD then
              SendMsg(BaseObject, RM_FOXSTATE, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, BaseObject.m_nBodyState, uname);
          end;
        end;
      end;
      Inc(i);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(Format(sExceptionMsg2, [nPar, m_sCharName, m_sMapName, m_nCurrX, m_nCurrY, nCheckCode]));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;

  try
    i := 0;
    nCheckCode := 28;
    while (True) do
    begin
      if m_VisibleItems.Count <= i then
        Break;
      VisibleMapItem := m_VisibleItems.Items[i];
      if VisibleMapItem.nVisibleFlag = 0 then
      begin
        SendMsg(Self, RM_ITEMHIDE, 0, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, '');
        m_VisibleItems.Delete(i);
        Dispose(VisibleMapItem);
        Continue;
      end;
      if VisibleMapItem.nVisibleFlag = 2 then
        SendMsg(Self, RM_ITEMSHOW, VisibleMapItem.wLooks, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY, VisibleMapItem.sName);
      Inc(i);
    end;

    i := 0;
    nCheckCode := 29;
    while (True) do
    begin
      if m_VisibleEvents.Count <= i then
        Break;
{$IF NewVisibleEvent = 1}
      VisibleEvent := m_VisibleEvents[i];
      if VisibleEvent.nVisibleFlag = 0 then
      begin
        SendMsg(Self, RM_HIDEEVENT, 0, Integer(VisibleEvent.Event), VisibleEvent.nX, VisibleEvent.nY, '');
        m_VisibleEvents.Delete(i);
        Dispose(VisibleEvent);
        Continue;
      end;
      if VisibleEvent.nVisibleFlag = 2 then
        SendMsg(Self, RM_SHOWEVENT, VisibleEvent.nEventType, Integer(VisibleEvent.Event), MakeLong(VisibleEvent.nX, VisibleEvent.nEventParam), VisibleEvent.nY, Format('%d', [VisibleEvent.m_nEventLevel]));
{$ELSE}
      MapEvent := m_VisibleEvents.Items[i];
      if MapEvent.m_nVisibleFlag = 0 then
      begin
        SendMsg(Self, RM_HIDEEVENT, 0, Integer(MapEvent), MapEvent.m_nX, MapEvent.m_nY, '');
        m_VisibleEvents.Delete(i);
        Continue;
      end;
      if MapEvent.m_nVisibleFlag = 2 then
        SendMsg(Self, RM_SHOWEVENT, MapEvent.m_nEventType, Integer(MapEvent), MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam), MapEvent.m_nY, Format('%d', [MapEvent.m_nEventLevel]));
{$IFEND}
      Inc(i);
    end;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(m_sCharName + ',' + m_sMapName + ',' + IntToStr(m_nCurrX) + ',' + IntToStr(m_nCurrY) + ',' + ' SearchViewRange Code:' + IntToStr(nCheckCode));
      MainOutMessageAPI(E.Message);
      KickException();
    end;
  end;
end;

procedure TPlayObject.SearchViewRange_Death();
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited SearchViewRange_Death();
    Exit;
  end;
  SearchViewRange();
end;

function TPlayObject.GetShowName(): string;
var
  sShowName: string;
  sCharName: string;
  sGuildName: string;
  sDearName: string;
  sMasterName: string;
  sTempCharName: string;
  Castle: TUserCastle;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::GetShowName';
begin
  if m_PEnvir.m_MapFlag.nSecret and $08 <> 0 then
  begin
    Result := m_PEnvir.m_MapFlag.nSecretShowName;
    Exit;
  end;

  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    Result := inherited GetShowName();
    Exit;
  end;
  try
    sCharName := '';
    sGuildName := '';
    sDearName := '';
    sMasterName := '';
    if m_MyGuild <> nil then
    begin
      Castle := g_CastleManager.IsCastleMember(Self);
      if Castle <> nil then
      begin
        sGuildName := AnsiReplaceText(g_sCastleGuildName, '%castlename', Castle.m_sName);
        sGuildName := AnsiReplaceText(sGuildName, '%guildname', TGuild(m_MyGuild).sGuildName);
        sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
      end
      else
      begin
        if g_Config.boShowGuildName or m_boInFreePKArea then
        begin
          sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname', TGuild(m_MyGuild).sGuildName);
          sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
        end
        else
        begin
          Castle := g_CastleManager.InCastleWarArea(Self);
          if (Castle <> nil) and Castle.m_boUnderWar then
          begin
            sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname', TGuild(m_MyGuild).sGuildName);
            sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
          end;
        end;
      end;
    end;
    //if g_Config.boHumanAttribute and (m_btAttribute in [1..5]) then
    //  sTempCharName := m_sCharName + g_sAttribArr[m_btAttribute]
    //else
    sTempCharName := m_sCharName;
    if not g_Config.boShowRankLevelName then
    begin
      if m_btReLevel > 0 then
      begin
        case m_btJob of
          0: sCharName := AnsiReplaceText(g_sWarrReNewName, '%chrname', sTempCharName);
          1: sCharName := AnsiReplaceText(g_sWizardReNewName, '%chrname', sTempCharName);
          2: sCharName := AnsiReplaceText(g_sTaosReNewName, '%chrname', sTempCharName);
        end;
      end
      else
        sCharName := sTempCharName;
    end
    else
      sCharName := Format(m_sRankLevelName, [sTempCharName]);

    if m_sMasterName <> '' then
    begin
      if m_boMaster then
        sMasterName := Format(g_sMasterName, [m_sMasterName])
      else
        sMasterName := Format(g_sNoMasterName, [m_sMasterName]);
    end;
    if m_sDearName <> '' then
    begin
      if m_btGender = 0 then
        sDearName := Format(g_sManDearName, [m_sDearName])
      else
        sDearName := Format(g_sWoManDearName, [m_sDearName]);
    end;

    sShowName := AnsiReplaceText(g_sHumanShowName, '%chrname', sCharName);
    sShowName := AnsiReplaceText(sShowName, '%guildname', sGuildName);
    sShowName := AnsiReplaceText(sShowName, '%dearname', sDearName);
    sShowName := AnsiReplaceText(sShowName, '%mastername', sMasterName);
    if m_sStatuName <> '' then
      sShowName := StringReplace(sShowName, '\', '\' + m_sStatuName + ' \', [rfIgnoreCase]);

    Result := sShowName;
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
end;

function TPlayObject.CheckItemsNeed(StdItem: pTStdItem): Boolean;
var
  Castle: TUserCastle;
begin
  Result := True;
  case StdItem.Need of
    6:
      begin
        if (m_MyGuild = nil) then
        begin
          Result := False;
        end;
      end;
    60:
      begin
        if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
        begin
          Result := False;
        end;
      end;
    7:
      begin
        Castle := g_CastleManager.IsCastleMember(Self);
        if Castle = nil then
          Result := False;
      end;
    70:
      begin
        Castle := g_CastleManager.IsCastleMember(Self);
        if (Castle = nil) or (m_nGuildRankNo <> 1) then
        begin
          Result := False;
        end;
      end;
    8:
      begin
        if m_nMemberType = 0 then
          Result := False;
      end;
    81:
      begin
        if (m_nMemberType <> LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
    82:
      begin
        if (m_nMemberType < LoWord(StdItem.NeedLevel)) or (m_nMemberLevel < HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
  end;

end;

procedure TPlayObject.CheckMarry;
var
  boIsfound: Boolean;
  sUnMarryFileName: string;
  LoadList: TStringList;
  i: Integer;
  sSayMsg: string;
begin
  boIsfound := False;
  sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
  if FileExists(sUnMarryFileName) then
  begin
    LoadList := TStringList.Create;
    LoadList.LoadFromFile(sUnMarryFileName);
    for i := 0 to LoadList.Count - 1 do
    begin
      if CompareText(LoadList.Strings[i], m_sCharName) = 0 then
      begin
        LoadList.Delete(i);
        boIsfound := True;
        Break;
      end;
    end;
    LoadList.SaveToFile(sUnMarryFileName);
    LoadList.Free;
  end;
  if boIsfound then
  begin
    if m_btGender = 0 then
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryManLoginMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sDearName);
    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryWoManLoginMsg, '%d', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sDearName := '';
    RefShowName;
  end;
  m_DearHuman := UserEngine.GetPlayObject(m_sDearName);
  if m_DearHuman <> nil then
  begin
    m_DearHuman.m_DearHuman := Self;
    if m_btGender = 0 then
    begin
      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end;
  end
  else
  begin
    if m_btGender = 0 then
      SysMsg(g_sManLoginDearNotOnlineMsg, c_Red, t_Hint)
    else
      SysMsg(g_sWoManLoginDearNotOnlineMsg, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CheckMaster;
var
  boIsfound: Boolean;
  sSayMsg: string;
  i: Integer;
  Human: TPlayObject;
begin
  boIsfound := False;
  g_UnForceMasterList.Lock;
  try
    for i := 0 to g_UnForceMasterList.Count - 1 do
    begin
      if CompareText(g_UnForceMasterList.Strings[i], m_sCharName) = 0 then
      begin
        g_UnForceMasterList.Delete(i);
        SaveUnForceMasterList();
        boIsfound := True;
        Break;
      end;
    end;
  finally
    g_UnForceMasterList.UnLock;
  end;

  if boIsfound then
  begin
    if m_boMaster then
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterLoginMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterListLoginMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sMasterName := '';
    RefShowName;
  end;

  if (m_sMasterName <> '') and not m_boMaster then
  begin
    if m_Abil.Level >= g_Config.nMasterOKLevel then
    begin
      Human := UserEngine.GetPlayObject(m_sMasterName);
      if (Human <> nil) and (not Human.m_boDeath) and (not Human.m_boGhost) then
      begin
        sSayMsg := AnsiReplaceText(g_sYourMasterListUnMasterOKMsg, '%d', m_sCharName);
        Human.SysMsg(sSayMsg, c_Red, t_Hint);
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);

        //Èç¹û´óÍ½µÜÔò½«Ê¦¸¸ÉÏµÄÃû×ÖÈ¥µô
        if m_sCharName = Human.m_sMasterName then
        begin
          Human.m_sMasterName := '';
          Human.RefShowName;
        end;
        for i := 0 to Human.m_MasterList.Count - 1 do
        begin
          if Human.m_MasterList.Items[i] = Self then
          begin
            Human.m_MasterList.Delete(i);
            Break;
          end;
        end;

        m_sMasterName := '';
        RefShowName;
        if Human.m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte) then
        begin
          Inc(Human.m_btCreditPoint, g_Config.nMasterOKCreditPoint);
        end;
        Inc(Human.m_nBonusPoint, g_Config.nMasterOKBonusPoint);
        Human.SendMsg(Human, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end
      else
      begin
        //Èç¹ûÊ¦¸¸²»ÔÚÏßÔò±£´æµ½¼ÇÂ¼±íÖÐ
        g_UnMasterList.Lock;
        try
          boIsfound := False;
          for i := 0 to g_UnMasterList.Count - 1 do
          begin
            if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
            begin
              boIsfound := True;
              Break;
            end;
          end;
          if not boIsfound then
          begin
            g_UnMasterList.Add(m_sMasterName);
          end;
        finally
          g_UnMasterList.UnLock;
        end;
        if not boIsfound then
        begin
          SaveUnMasterList();
        end;
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        m_sMasterName := '';
        RefShowName;
      end;
    end;
  end;

  //´¦Àí³öÊ¦¼ÇÂ¼
  boIsfound := False;
  g_UnMasterList.Lock;
  try
    for i := 0 to g_UnMasterList.Count - 1 do
    begin
      if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
      begin
        g_UnMasterList.Delete(i);
        SaveUnMasterList();
        boIsfound := True;
        Break;
      end;
    end;
  finally
    g_UnMasterList.UnLock;
  end;

  if boIsfound and m_boMaster then
  begin
    SysMsg(g_sUnMasterLoginMsg, c_Red, t_Hint);

    m_sMasterName := '';
    RefShowName;

    if m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte) then
    begin
      Inc(m_btCreditPoint, g_Config.nMasterOKCreditPoint);
    end;
    Inc(m_nBonusPoint, g_Config.nMasterOKBonusPoint);
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  end;

  if m_sMasterName = '' then
    Exit;
  if m_boMaster then
  begin
    //Ê¦¸¸ÉÏÏßÍ¨Öª
    m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
    if m_MasterHuman <> nil then
    begin
      m_MasterHuman.m_MasterHuman := Self;
      m_MasterList.Add(m_MasterHuman);

      sSayMsg := AnsiReplaceText(g_sMasterOnlineSelfMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sMasterOnlineMasterListMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end
    else
    begin
      SysMsg(g_sMasterNotOnlineMsg, c_Red, t_Hint);
    end;
  end
  else
  begin
    //Í½µÜÉÏÏßÍ¨Öª
    if m_sMasterName <> '' then
    begin
      m_MasterHuman := UserEngine.GetPlayObject(m_sMasterName);
      if m_MasterHuman <> nil then
      begin

        if m_MasterHuman.m_sMasterName = m_sCharName then
        begin
          m_MasterHuman.m_MasterHuman := Self;
        end;

        m_MasterHuman.m_MasterList.Add(Self);

        sSayMsg := AnsiReplaceText(g_sMasterListOnlineSelfMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.m_sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);

        sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
      end
      else
        SysMsg(g_sMasterListNotOnlineMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.MakeGhost();
var
  i: Integer;
  sSayMsg: string;
  Human: TPlayObject;
  pu: pTUserItem;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::MakeGhost';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    //DropUseItemsWithoutFail(nil);
    //ScatterBagItemsWithoutFail(nil);
    inherited;
    Exit;
  end;
  try
    if m_DetectItem.MakeIndex > 0 then
    begin
      New(pu);
      pu^ := m_DetectItem;
      m_DetectItem.MakeIndex := 0;
      m_ItemList.Add(pu);
    end;

    if m_Escort <> nil then
      m_Escort := nil;

    if (g_HighLevelHuman = Self) then
      g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) then
      g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) then
      g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) then
      g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) then
      g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) then
      g_HighOnlineHuman := nil;

    if m_DearHuman <> nil then
    begin
      if m_btGender = 0 then
      begin
        sSayMsg := AnsiReplaceText(g_sManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
      end
      else
      begin
        sSayMsg := AnsiReplaceText(g_sWoManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
      end;
      m_DearHuman.m_DearHuman := nil;
      m_DearHuman := nil;
    end;

    if (m_MasterHuman <> nil) or (m_MasterList.Count > 0) then
    begin
      if m_boMaster then
      begin
        for i := 0 to m_MasterList.Count - 1 do
        begin
          Human := TPlayObject(m_MasterList.Items[i]);
          sSayMsg := AnsiReplaceText(g_sMasterLongOutMasterListOnlineMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          Human.SysMsg(sSayMsg, c_Red, t_Hint);
          Human.m_MasterHuman := nil;
        end;
      end
      else
      begin
        if m_MasterHuman = nil then
          Exit;
        sSayMsg := AnsiReplaceText(g_sMasterListLongOutMasterOnlineMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.m_sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        if m_MasterHuman.m_sMasterName = m_sCharName then
          m_MasterHuman.m_MasterHuman := nil;
        for i := 0 to m_MasterHuman.m_MasterList.Count - 1 do
        begin
          if m_MasterHuman.m_MasterList.Items[i] = Self then
          begin
            m_MasterHuman.m_MasterList.Delete(i);
            Break;
          end;
        end;
      end;
    end;

    if m_sOffLineLabel <> '' then
      OffLineFunc();

    DropUseItemsWithoutFail(nil);
    ScatterBagItemsWithoutFail(nil);
  except
    on E: Exception do
    begin
      MainOutMessageAPI(sExceptionMsg);
      MainOutMessageAPI(E.Message);
    end;
  end;
  inherited;
end;

function TPlayObject.GetMyInfo: string;
var
  sMyInfo: string;
begin
  sMyInfo := g_sMyInfo;
  sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
  sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.m_sMapDesc);
  sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
  sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
  sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
  sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
  sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%mindc', IntToStr(LoWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc', IntToStr(HiWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmc', IntToStr(LoWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc', IntToStr(HiWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minsc', IntToStr(LoWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc', IntToStr(HiWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logontime', DateTimeToStr(m_dLogonTime));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount - m_dwLogonTick) div 60000));
  Result := sMyInfo;
end;

function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  i: Integer;
  ItemBind: pTItemBind;
begin
  Result := True;
  g_ItemBindAccount.Lock;
  try
    for i := 0 to g_ItemBindAccount.Count - 1 do
    begin
      ItemBind := g_ItemBindAccount.Items[i];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sUserID) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisAccount, c_Red, t_Hint);
        end;
        Exit;
      end;
    end;
  finally
    g_ItemBindAccount.UnLock;
  end;

  g_ItemBindIPaddr.Lock;
  try
    for i := 0 to g_ItemBindIPaddr.Count - 1 do
    begin
      ItemBind := g_ItemBindIPaddr.Items[i];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sIPaddr) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisIPaddr, c_Red, t_Hint);
        end;
        Exit;
      end;
    end;
  finally
    g_ItemBindIPaddr.UnLock;
  end;
  g_ItemBindCharName.Lock;
  try
    for i := 0 to g_ItemBindCharName.Count - 1 do
    begin
      ItemBind := g_ItemBindCharName.Items[i];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisCharName, c_Red, t_Hint);
        end;
        Exit;
      end;
    end;
  finally
    g_ItemBindCharName.UnLock;
  end;
end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen: Integer;
  sData: string;
begin
  if ProcessMsg.wParam = 0 then
  begin
    ProcessUserLineMsg('@' + g_GameCommand.UnLock.sCmd);
    Exit;
  end;
  sData := ProcessMsg.sMsg;
  nLen := Length(sData);
  if m_boSetStoragePwd then
  begin
    m_boSetStoragePwd := False;
    if (nLen > 3) and (nLen < 8) then
    begin
      m_sTempPwd := sData;
      m_boReConfigPwd := True;
      SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint); {'ÇëÖØ¸´ÊäÈëÒ»´Î²Ö¿âÃÜÂë£º'}
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
    end
    else
    begin
      SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'ÊäÈëµÄÃÜÂë³¤¶È²»ÕýÈ·£¡£¬ÃÜÂë³¤¶È±ØÐëÔÚ 4 - 7 µÄ·¶Î§ÄÚ£¬ÇëÖØÐÂÉèÖÃÃÜÂë'}
    end;
    Exit;
  end;
  if m_boReConfigPwd then
  begin
    m_boReConfigPwd := False;
    if CompareStr(m_sTempPwd, sData) = 0 then
    begin
      m_sStoragePwd := sData;
      m_boPasswordLocked := True;
      m_sTempPwd := '';
{$IF VEROWNER = WL}
      SysMsg(Format('ÃÜÂëÉèÖÃ³É¹¦£¡£¬²Ö¿âÒÑ¾­×Ô¶¯ÉÏËø£¬Çë¼ÇºÃÄúµÄ²Ö¿âÃÜÂë£¬ÔÚÈ¡²Ö¿âÊ±ÐèÒªÊ¹ÓÃ´ËÃÜÂë¿ªËø¡£ÄúÕý´¦ÓÚ·Ç±£»¤Ä£Ê½,ÈçÏëÄúµÄ×°±¸¸ü°²È«,ÇëÊäÈëÖ¸Áî@%s', [g_GameCommand.LOCKLOGON.sCmd]), c_Blue, t_Hint);
{$ELSE}
      SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'ÃÜÂëÉèÖÃ³É¹¦£¡£¬²Ö¿âÒÑ¾­×Ô¶¯ÉÏËø£¬Çë¼ÇºÃÄúµÄ²Ö¿âÃÜÂë£¬ÔÚÈ¡²Ö¿âÊ±ÐèÒªÊ¹ÓÃ´ËÃÜÂë¿ªËø'}
{$IFEND}
    end
    else
    begin
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
    end;
    Exit;
  end;
  if m_boUnLockPwd or m_boUnLockStoragePwd then
  begin
    if CompareStr(m_sStoragePwd, sData) = 0 then
    begin
      m_boPasswordLocked := False;
      if m_boUnLockPwd then
      begin
        if g_Config.boLockDealAction then
          m_boCanDeal := True;
        if g_Config.boLockRecallAction then
          m_boCanRecallHero := True;
        if g_Config.boLockDropAction then
          m_boCanDrop := True;
        if g_Config.boLockWalkAction then
          m_boCanWalk := True;
        if g_Config.boLockRunAction then
          m_boCanRun := True;
        if g_Config.boLockHitAction then
          m_boCanHit := True;
        if g_Config.boLockSpellAction then
          m_boCanSpell := True;
        if g_Config.boLockSendMsgAction then
          m_boCanSendMsg := True;
        if g_Config.boLockUserItemAction then
          m_boCanUseItem := True;
        if g_Config.boLockInObModeAction then
        begin
          m_boObMode := False;
          m_boAdminMode := False;
        end;
        m_boLockLogoned := True;
        SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
      end;
      if m_boUnLockStoragePwd then
      begin
        if g_Config.boLockGetBackItemAction then
          m_boCanGetBackItem := True;
        SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
      end;

    end
    else
    begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
      end;
    end;
    m_boUnLockPwd := False;
    m_boUnLockStoragePwd := False;
    Exit;
  end;

  if m_boCheckOldPwd then
  begin
    m_boCheckOldPwd := False;
    if m_sStoragePwd = sData then
    begin
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      m_boSetStoragePwd := True;
    end
    else
    begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
      end;
    end;
    Exit;
  end;
end;

procedure TBaseObject.HeroScatterBagItems(ItemOfCreat: TBaseObject);
var
  i, nRate2: Integer;
  drCount, icount: Integer;
  pu, newpu: pTUserItem;
  DelList: TStringList;
  bHero, boDropall: Boolean;
  StdItem: pTStdItem;
  nDieScatterBagRate: Integer;
  nPreventDrop, nTagDropPlus: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::HeroScatterBagItems';
begin
  try
    if m_boAngryRing or m_boNoDropItem then
      Exit;
    DelList := nil;
    boDropall := False;
    if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) and (m_btRaceServer <> RC_HERO) then
      boDropall := True;

    nDieScatterBagRate := g_Config.nDieScatterBagRate;
    if nDieScatterBagRate <= 0 then
      nDieScatterBagRate := 1;
    nRate2 := Round(1 * 10000 / nDieScatterBagRate);

    if not boDropall then
    begin
      nPreventDrop := 0;
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero and (TPlayObject(Self).m_nPreventDrop > 0) then
        nPreventDrop := TPlayObject(Self).m_nPreventDrop;

      nTagDropPlus := 0;
      if g_Config.EffectHeroDropRate and (m_LastHiter <> nil) then
      begin
        if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
        begin
          nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
        end;
      end;
      //nDieScatterBagRate := _MAX(1, nDieScatterBagRate + nPreventDrop - nTagDropPlus);

      nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);
    end;

    {if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      nDieScatterBagRate := nDieScatterBagRate + TPlayObject(self).m_nPreventDrop;

    if not boDropall and g_Config.EffectHeroDropRate and (m_LastHiter <> nil) then begin
      if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) then begin
        nDieScatterBagRate := _MAX(1, nDieScatterBagRate - TPlayObject(m_LastHiter).m_nTagDropPlus);
      end;
    end;}

    bHero := IsHero;
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      pu := m_ItemList[i];
      if bHero then
      begin
        if (PCardinal(@pu.btValue[22])^ > 0) and (PCardinal(@pu.btValue[22])^ = TPlayObject(Self).m_dwIdCRC) then
        begin
          if g_Config.boBindNoScatter then
            Continue;
        end;
        if InLimitItemList('', pu.wIndex, t_nsc) then
          Continue;
      end;
      if boDropall or ((nRate2 > Random(10000))) then
      begin
        StdItem := UserEngine.GetStdItem(pu.wIndex);
        if StdItem = nil then
          Continue;
        if StdItem.Overlap >= 1 then
        begin
          icount := pu.Dura;
          drCount := _MAX(1, _MIN(500, Random(icount div 2)));
          icount := _MAX(0, icount - drCount);
          if drCount > 0 then
          begin
            New(newpu);
            if UserEngine.CopyToUserItemFromName(StdItem.Name, newpu) then
            begin
              newpu.Dura := drCount;
              if DropItemDown(newpu, g_Config.nScatterRange, True, ItemOfCreat, Self) then
              begin
                if icount <= 0 then
                begin
                  if DelList = nil then
                    DelList := TStringList.Create;
                  DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
                  Dispose(pu);
                  m_ItemList.Delete(i);
                end
                else
                begin
                  pu.Dura := icount;
                  SendMsg(Self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 0, StdItem.Name);
                end;
                SysMsg(Format('[±³°üµôÂä] %s(%d)', [StdItem.Name, newpu.Dura]), c_Purple, t_Hint);
              end;
            end;
            if newpu <> nil then
            begin
              Dispose(newpu);
              newpu := nil;
            end;
          end;
        end
        else
        begin
          if DropItemDown(pu, g_Config.nScatterRange, True, ItemOfCreat, Self) then
          begin
            SysMsg(Format('[±³°üµôÂä] %s', [UserEngine.GetStdItemName(pu.wIndex)]), c_Purple, t_Hint);
            if DelList = nil then
              DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
            Dispose(pu);
            m_ItemList.Delete(i);
          end;
        end;
      end;
    end;
    if DelList <> nil then
    begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  drCount, icount: Integer;
  i, nRate2: Integer;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  newpu: pTUserItem;
  StdItem: pTStdItem;
  nDieScatterBagRate: Integer;
  nPreventDrop, nTagDropPlus: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ScatterBagItems';
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
  begin
    inherited ScatterBagItems(ItemOfCreat);
    Exit;
  end;

  if m_boNoDropItemEx then
    Exit;

  if (m_btRaceServer = RC_PLAYOBJECT) and g_Config.boNoDropItemOfGameGold and (m_nGameGold > g_Config.nNoScatterBagGamegold) then
    Exit;

  if (m_boAngryRing or m_boNoDropItem)
{$IF CustomBuild = 1}
  and ((m_ExpHitter <> nil) and not m_ExpHitter.m_boUnAngryRing)
{$IFEND} then
    Exit;

  DelList := nil;
  boDropall := False;
  if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) and (m_btRaceServer <> RC_HERO) then
    boDropall := True;

  {nDieScatterBagRate := g_Config.nDieScatterBagRate + m_nPreventDrop;
  if not boDropall and (m_LastHiter <> nil) then begin
    if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then begin
      nDieScatterBagRate := _MAX(1, nDieScatterBagRate - TPlayObject(m_LastHiter).m_nTagDropPlus);
    end;
  end;}

  nDieScatterBagRate := g_Config.nDieScatterBagRate;
  if nDieScatterBagRate <= 0 then
    nDieScatterBagRate := 1;
  nRate2 := Round(1 * 10000 / nDieScatterBagRate);

  if not boDropall then
  begin
    nPreventDrop := 0;
    if m_nPreventDrop > 0 then
      nPreventDrop := m_nPreventDrop;

    nTagDropPlus := 0;
    if m_LastHiter <> nil then
    begin
      if ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or m_LastHiter.IsHero) and (TPlayObject(m_LastHiter).m_nTagDropPlus > 0) then
      begin
        nTagDropPlus := TPlayObject(m_LastHiter).m_nTagDropPlus;
      end;
    end;

    //nDieScatterBagRate := _MAX(1, nDieScatterBagRate + nPreventDrop - nTagDropPlus);
    nRate2 := nRate2 + Round((nTagDropPlus - nPreventDrop) / 100 * nRate2);
  end;

  try
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      newpu := nil;
      pu := pTUserItem(m_ItemList[i]);
      if (PCardinal(@pu.btValue[22])^ > 0) and (PCardinal(@pu.btValue[22])^ = TPlayObject(Self).m_dwIdCRC) then
      begin
        if g_Config.boBindNoScatter then
          Continue;
      end;
      if InLimitItemList('', pu.wIndex, t_nsc) then
        Continue;

      if boDropall or ((nRate2 > Random(10000))) then
      begin

        StdItem := UserEngine.GetStdItem(pu.wIndex);
        if StdItem = nil then
          Continue;
        if StdItem.Overlap >= 1 then
        begin
          icount := pu.Dura;
          drCount := _MAX(1, _MIN(500, Random(icount div 2)));
          icount := _MAX(0, icount - drCount);
          if drCount > 0 then
          begin
            New(newpu);
            if UserEngine.CopyToUserItemFromName(StdItem.Name, newpu) then
            begin
              newpu.Dura := drCount;
              if DropItemDown(newpu, g_Config.nScatterRange, True, ItemOfCreat, Self) then
              begin
                if icount <= 0 then
                begin
                  if DelList = nil then
                    DelList := TStringList.Create;
                  DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
                  Dispose(pu);
                  m_ItemList.Delete(i);
                end
                else
                begin
                  pu.Dura := icount;
                  SendMsg(Self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 0, StdItem.Name);
                end;
                SysMsg(Format('[±³°üµôÂä] %s(%d)', [StdItem.Name, newpu.Dura]), c_Purple, t_Hint);
              end;
            end;
            if newpu <> nil then
            begin
              Dispose(newpu);
              newpu := nil;
            end;
          end;
        end
        else
        begin
          if DropItemDown(pu, g_Config.nScatterRange, True, ItemOfCreat, Self) then
          begin
            SysMsg(Format('[±³°üµôÂä] %s', [UserEngine.GetStdItemName(pu.wIndex)]), c_Purple, t_Hint);
            if (m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) {or IsHero} then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex), TObject(pu.MakeIndex));
            end;
            Dispose(pu);
            m_ItemList.Delete(i);
          end;
        end;
      end;
    end;
    if DelList <> nil then
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
  ScatterBagItemsWithoutFail(nil);
end;

procedure TPlayObject.ScatterBagItemsWithoutFail(ItemOfCreat: TBaseObject);
var
  i: Integer;
  UserItem: pTUserItem;
  DelList: TStringList;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ScatterBagItems_WithoutFail';
begin
  DelList := nil;
  try
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := pTUserItem(m_ItemList[i]);
      if InLimitItemList('', UserItem.wIndex, t_sDrop) then
      begin
        if DropItemDown(UserItem, g_Config.nScatterRange, True, ItemOfCreat, Self) then
        begin
          SysMsg(Format('[Ç¿ÖÆµôÂä] %s', [UserEngine.GetStdItemName(UserItem.wIndex)]), c_Purple, t_Hint);
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            if DelList = nil then
              DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
          end;
          Dispose(UserItem);
          m_ItemList.Delete(i);
        end;
      end;
    end;
    if DelList <> nil then
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.RecallHuman(sHumName: string);
var
  PlayObject: TPlayObject;
  nX: Integer;
  nY: Integer;
  nRecallX: Integer;
  nRecallY: Integer;
begin
  PlayObject := UserEngine.GetPlayObject(sHumName);
  if (PlayObject <> nil) and not PlayObject.m_boDeath and not PlayObject.m_boDealing then
  begin
    if PlayObject.m_StallMgr.OnSale then
    begin
      SysMsg(Format('%sÕýÔÚ´¦ÓÚ°ÚÌ¯×´Ì¬£¬²»ÄÜÕÙ»½£¡', [sHumName]), c_Red, t_Hint);
      Exit;
    end;
    if GetFrontPosition(nX, nY) then
    begin
      if GetRecallXY(nX, nY, 3, nRecallX, nRecallY) then
      begin
        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        PlayObject.SpaceMove(m_sMapName, nRecallX, nRecallY, 0);
      end;
    end
    else
      SysMsg('ÕÙ»½Ê§°Ü£¡', c_Red, t_Hint);
  end
  else
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
end;

procedure TPlayObject.ReQuestGuildWar(sGuildName: string);
var
  Guild: TGuild;
  WarGuild: pTWarGuild;
  boReQuestOK: Boolean;
begin
  if not IsGuildMaster then
  begin
    SysMsg('Ö»ÓÐÐÐ»áÕÆÃÅÈË²ÅÄÜÉêÇë', c_Red, t_Hint);
    Exit;
  end;
  if g_nServerIndex <> 0 then
  begin
    SysMsg('Õâ¸öÃüÁî²»ÄÜÔÚ±¾·þÎñÆ÷ÉÏÊ¹ÓÃ', c_Red, t_Hint);
    Exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild = nil then
  begin
    SysMsg('ÐÐ»á²»´æÔÚ', c_Red, t_Hint);
    Exit;
  end;
  boReQuestOK := False;
  WarGuild := TGuild(m_MyGuild).AddWarGuild(Guild);
  if WarGuild <> nil then
  begin
    if Guild.AddWarGuild(TGuild(m_MyGuild)) = nil then
      WarGuild.dwWarTick := 0
    else
      boReQuestOK := True;
  end;
  if boReQuestOK then
  begin
    UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, TGuild(m_MyGuild).sGuildName);
    UserEngine.SendInterMsg(ISM_RELOADGUILD, g_nServerIndex, Guild.sGuildName);
  end;
end;

function TPlayObject.CheckDenyLogon(): Boolean;
begin
  Result := False;
  if GetDenyIPaddrList(m_sIPaddr) then
  begin
    SysMsg(g_sYourIPaddrDenyLogon, c_Red, t_Hint);
    Result := True;
  end
  else if GetDenyAccountList(m_sUserID) then
  begin
    SysMsg(g_sYourAccountDenyLogon, c_Red, t_Hint);
    Result := True;
  end
  else if GetDenyChrNameList(m_sCharName) then
  begin
    SysMsg(g_sYourCharNameDenyLogon, c_Red, t_Hint);
    Result := True;
  end;
  if Result then
    m_boEmergencyClose := True;
end;

procedure ClearEctypeManus();
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  EnterCriticalSection(ProcessHumanCriticalSection);
  try
    for i := 0 to UserEngine.m_PlayObjectList.Count - 1 do
    begin
      PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[i]);
      if not PlayObject.m_boGhost then
        PlayObject.m_dwClearCopyTtemTick := 0;
    end;
  finally
    LeaveCriticalSection(ProcessHumanCriticalSection);
  end;
end;

procedure TPlayObject.DeleteBagEctype();
var
  UserItem, UserItemNext: pTUserItem;
  UserItemName: string;
  i, ii: Integer;
resourcestring
  sDelEctypeMsg = '[É¾³ý¸´ÖÆÆ·]:%s %s IDX:%d - Bag';
  sExceptionMsg = '[Exception] TPlayObject::DeleteBagEctype';
begin
  if not m_boGhost and not m_boOffLineFlag and (m_ItemList.Count >= 2) then
  begin
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      UserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if UserItemName = '' then
        Continue;
      for ii := i - 1 downto 0 do
      begin
        UserItemNext := m_ItemList.Items[ii];
        if (UserEngine.GetStdItemName(UserItemNext.wIndex) = UserItemName) and (UserItem.MakeIndex = UserItemNext.MakeIndex) then
        begin
          //MainOutMessageAPI(Format(sDelEctypeMsg, [m_sCharName, UserItemName, UserItemNext.MakeIndex]));
          Dispose(pTUserItem(m_ItemList.Items[ii]));
          m_ItemList.Delete(ii);
          WeightChanged();
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.CheckDelBagCopyed();
var
  i, ii: Integer;
begin
  if m_boGhost or m_boOffLineFlag or (m_ItemList.Count < 2) then
    Exit;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    for ii := 0 to m_ItemList.Count - 1 do
    begin
      if i = ii then
        Continue;
      if pTUserItem(m_ItemList[i]).wIndex <> pTUserItem(m_ItemList[ii]).wIndex then
        Continue;
      if pTUserItem(m_ItemList[i]).MakeIndex = pTUserItem(m_ItemList[ii]).MakeIndex then
      begin
        Dispose(pTUserItem(m_ItemList.Items[i]));
        m_ItemList.Delete(i);
        Exit;
      end;
    end;
  end;
end;

procedure TPlayObject.CheckDelStoCopyed();
var
  i, ii: Integer;
begin
  if m_boGhost or m_boOffLineFlag or (m_ItemList.Count < 2) then
    Exit;
  for i := 0 to m_StorageItemList.Count - 1 do
  begin
    for ii := 0 to m_StorageItemList.Count - 1 do
    begin
      if i = ii then
        Continue;
      if pTUserItem(m_StorageItemList[i]).wIndex <> pTUserItem(m_StorageItemList[ii]).wIndex then
        Continue;
      if pTUserItem(m_StorageItemList[i]).MakeIndex = pTUserItem(m_StorageItemList[ii]).MakeIndex then
      begin
        Dispose(pTUserItem(m_StorageItemList.Items[i]));
        m_StorageItemList.Delete(i);
        Exit;
      end;
    end;
  end;
end;

procedure TPlayObject.DeleteStorageEctype();
var
  UserItem, UserItemNext: pTUserItem;
  UserItemName: string;
  i, ii: Integer;
resourcestring
  sDelEctypeMsg = '[É¾³ý¸´ÖÆÆ·]:%s %s IDX:%d - Storage';
  sExceptionMsg = '[Exception] TPlayObject::DeleteStorageEctype';
begin
  if not m_boGhost and not m_boOffLineFlag and (m_StorageItemList.Count > 1) then
  begin
    try
      for i := m_StorageItemList.Count - 1 downto 0 do
      begin
        UserItem := m_StorageItemList.Items[i];
        UserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if UserItemName = '' then
          Continue;
        for ii := i - 1 downto 0 do
        begin
          UserItemNext := m_StorageItemList.Items[ii];
          if (UserEngine.GetStdItemName(UserItemNext.wIndex) = UserItemName) and (UserItem.MakeIndex = UserItemNext.MakeIndex) then
          begin
            //MainOutMessageAPI(Format(sDelEctypeMsg, [m_sCharName, UserItemName, UserItemNext.MakeIndex]));
            Dispose(pTUserItem(m_StorageItemList.Items[ii]));
            m_StorageItemList.Delete(ii);
          end;
        end;
      end;
    except
      MainOutMessageAPI(sExceptionMsg);
    end;
  end;
end;

procedure TPlayObject.CheckItemExpires();
var
  i, nIDt, nDt: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
  item: TStdItem;
resourcestring
  sItemExpiresMsg = 'ÄãµÄÎïÆ·£º¡¼%s¡½´ïµ½Ê¹ÓÃÆÚÏÞ£¬ÒÑ±»ÏµÍ³×Ô¶¯»ØÊÕ£¡';
  sExceptionMsg = '[Exception] TPlayObject::CheckItemExpires';
begin
  if (not m_boGhost) and (not m_boOffLineFlag) then
  begin
    nIDt := 0;
    try
      for i := m_StorageItemList.Count - 1 downto 0 do
      begin
        UserItem := m_StorageItemList.Items[i];
        if UserItem = nil then
          Exit;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          item := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, item);
          if item.StdMode = 2 then
          begin
            case item.Shape of
              18:
                begin
                  CopyMemory(@nIDt, @UserItem.btValue, SizeOf(Integer));
                  if nIDt = 0 then
                    Continue;
                  nDt := GetItemFormatDate();
                  nIDt := Round((nDt - nIDt) / (24 * 60 * 60));
                  if item.DuraMax - nIDt <= 0 then
                  begin

                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLogAPI('10' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        'ÎïÆ·µ½ÆÚ');

                    Dispose(UserItem);
                    m_StorageItemList.Delete(i);
                    SysMsg(Format(sItemExpiresMsg, [item.Name]), c_Purple, t_Hint);
                    Continue;
                  end;
                end;
            end;
          end;
        end;
      end;
    except
      MainOutMessageAPI(sExceptionMsg);
    end;
  end;
end;

function TPlayObject.ProcessUserCmd(sCmd {, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7}: string): Boolean;
var
  i: Integer;
begin
  Result := False;

  g_UserCmdList.Lock;
  try
    {i := g_UserCmdList.IndexOf(sCmd);
    if i > -1 then begin
      if (g_FunctionNPC <> nil) then g_FunctionNPC.GotoLable(self, '@UserCmd' + IntToStr(Integer(g_UserCmdList.Objects[i])), False);
      Result := True;
    end;}
    for i := 0 to g_UserCmdList.Count - 1 do
    begin
      if CompareText(sCmd, g_UserCmdList.Strings[i]) = 0 then
      begin
        if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
        begin
          g_FunctionNPC.m_OprCount := 0;
          g_FunctionNPC.GotoLable(Self, '@UserCmd' + IntToStr(Integer(g_UserCmdList.Objects[i])), False);
        end;
        Result := True;
        Break;
      end;
    end;
  finally
    g_UserCmdList.UnLock;
  end;
end;

procedure TBaseObject.ReSetGroupAttrib();
var
  boMob: Boolean;
begin
  if m_boGhost then
    Exit;
  boMob := False;
  //if m_boTotalAttrib <> 0 then begin
  //  m_boTotalAttrib := 0;
  //  boMob := True;
  //end;
  if m_nAddHPMPRate <> 100 then
  begin
    m_nAddHPMPRate := 100;
    boMob := True;
  end;
  if m_nAddPowerRate <> 100 then
  begin
    m_nAddPowerRate := 100;
    boMob := True;
  end;
  if boMob then
  begin
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end;
end;

function TPlayObject.SetAttrGroupMemberInNear(GroupMember: TPlayObject; nType: Integer): Boolean;

  procedure ReflashAbilitys(PlayObject: TPlayObject);
  begin
    PlayObject.RecalcAbilitys();
    PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
    PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
  end;
resourcestring
  sHPMPUpMsg = '[×é¶Ó]£ºÎåÐÐÊôÐÔÏàÉú£¬ÌáÉý×ÔÉíÉúÃüÖµºÍÄ§·¨ÖµÉÏÏÞ£¡';
  sPowerUpMsg = '[×é¶Ó]£ºÎåÐÐÊôÐÔÏà¿Ë£¬ÌáÉý×ÔÉíÎïÀíºÍÄ§·¨¹¥»÷Á¦£¡';
begin
  if (m_PEnvir <> nil) and (m_PEnvir = GroupMember.m_PEnvir) and (abs(m_nCurrX - GroupMember.m_nCurrX) <= 14) and (abs(m_nCurrY - GroupMember.m_nCurrY) <= 14) then
  begin
    if nType = 0 then
    begin
      if m_nAddHPMPRate <> g_Config.nGroupAttribHPMPRate then
      begin
        m_nAddHPMPRate := g_Config.nGroupAttribHPMPRate;
        ReflashAbilitys(Self);
        SysMsg(sHPMPUpMsg, c_Purple, t_Hint);
      end;
    end
    else
    begin
      if m_nAddPowerRate <> g_Config.nGroupAttribPowerRate then
      begin
        m_nAddPowerRate := g_Config.nGroupAttribPowerRate;
        ReflashAbilitys(Self);
        SysMsg(sPowerUpMsg, c_Purple, t_Hint);
      end;
    end;
  end
  else
  begin
    if nType = 0 then
    begin
      if m_nAddHPMPRate <> 100 then
      begin
        m_nAddHPMPRate := 100;
        ReflashAbilitys(Self);
      end;
      {if GroupMember.m_nAddHPMPRate <> 100 then begin
        GroupMember.m_nAddHPMPRate := 100;
        ReflashAbilitys(GroupMember);
      end;}
    end
    else
    begin
      if m_nAddPowerRate <> 100 then
      begin
        m_nAddPowerRate := 100;
        ReflashAbilitys(Self);
      end;
      {if GroupMember.m_nAddPowerRate <> 100 then begin
        GroupMember.m_nAddPowerRate := 100;
        ReflashAbilitys(GroupMember);
      end;}
    end;
  end;
end;

function TPlayObject.CheckMapEvent(nAction: Integer; ItemName: string): Boolean;
var
  i, nFlag: Integer;
  MapEvent: pTMapEvent;
  boGroup: Boolean;
  PlayObject: TPlayObject;
  //TotalAttribArr            : array[1..5] of Byte;
begin
  Result := False;
  if g_Config.boHumanAttribute and (nAction in [4, 5]) and (m_btAttribute in [1..5]) then
  begin
    ReSetGroupAttrib();
    if m_GroupOwner <> nil then
    begin
      //FillChar(TotalAttribArr, 5, #0);
      for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
      begin
        PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
        if PlayObject.m_boDeath or PlayObject.m_boGhost then
          Continue;
        if (PlayObject.m_btAttribute in [1..5]) then
        begin
          //if (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 14) and (abs(m_nCurrY - PlayObject.m_nCurrY) <= 14) then
          //  TotalAttribArr[PlayObject.m_btAttribute] := 1;
          case m_btAttribute of
            1: if PlayObject.m_btAttribute = 5 then
                SetAttrGroupMemberInNear(PlayObject, 0)
              else if PlayObject.m_btAttribute = 4 then
                SetAttrGroupMemberInNear(PlayObject, 1);
            2: if PlayObject.m_btAttribute = 3 then
                SetAttrGroupMemberInNear(PlayObject, 0)
              else if PlayObject.m_btAttribute = 1 then
                SetAttrGroupMemberInNear(PlayObject, 1);
            3: if PlayObject.m_btAttribute = 1 then
                SetAttrGroupMemberInNear(PlayObject, 0)
              else if PlayObject.m_btAttribute = 5 then
                SetAttrGroupMemberInNear(PlayObject, 1);
            4: if PlayObject.m_btAttribute = 2 then
                SetAttrGroupMemberInNear(PlayObject, 0)
              else if PlayObject.m_btAttribute = 3 then
                SetAttrGroupMemberInNear(PlayObject, 1);
            5: if PlayObject.m_btAttribute = 4 then
                SetAttrGroupMemberInNear(PlayObject, 0)
              else if PlayObject.m_btAttribute = 2 then
                SetAttrGroupMemberInNear(PlayObject, 1);
          end;
          case PlayObject.m_btAttribute of
            1: if m_btAttribute = 5 then
                PlayObject.SetAttrGroupMemberInNear(Self, 0)
              else if m_btAttribute = 4 then
                PlayObject.SetAttrGroupMemberInNear(Self, 1);
            2: if m_btAttribute = 3 then
                PlayObject.SetAttrGroupMemberInNear(Self, 0)
              else if m_btAttribute = 1 then
                PlayObject.SetAttrGroupMemberInNear(Self, 1);
            3: if m_btAttribute = 1 then
                PlayObject.SetAttrGroupMemberInNear(Self, 0)
              else if m_btAttribute = 5 then
                PlayObject.SetAttrGroupMemberInNear(Self, 1);
            4: if m_btAttribute = 2 then
                PlayObject.SetAttrGroupMemberInNear(Self, 0)
              else if m_btAttribute = 3 then
                PlayObject.SetAttrGroupMemberInNear(Self, 1);
            5: if m_btAttribute = 4 then
                PlayObject.SetAttrGroupMemberInNear(Self, 0)
              else if m_btAttribute = 2 then
                PlayObject.SetAttrGroupMemberInNear(Self, 1);
          end;

        end;
      end;
      {nFlag := 0;
      for nIdx := 1 to 5 do nFlag := nFlag + TotalAttribArr[nIdx];
      if nFlag >= 5 then begin
        for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
          PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
          if PlayObject.m_boDeath or PlayObject.m_boGhost then Continue;
          //PlayObject.m_boTotalAttrib := 1;
        end;
      end else begin
        //PlayObject.m_boTotalAttrib := 0;
      end;}
    end;
  end;
  if g_Config.boEnableMapEvent and (m_PEnvir <> nil) and (m_PEnvir.m_MapEvents.Count > 0) then
  begin
    for i := 0 to m_PEnvir.m_MapEvents.Count - 1 do
    begin
      MapEvent := m_PEnvir.m_MapEvents[i];
      if ((MapEvent.nCurrX < 0) and (MapEvent.nCurrY < 0)) or ((m_nCurrX = MapEvent.nCurrX) and (m_nCurrY = MapEvent.nCurrY)) then
      begin
        if MapEvent.cFlag.nFlag >= 0 then
        begin
          if MapEvent.cFlag.boFlag then
            nFlag := 1
          else
            nFlag := 0;
          if GetQuestFalgStatus(MapEvent.cFlag.nFlag) <> nFlag then
            Break;
        end;
        if (MapEvent.cCondition.nAction <> 0) and (MapEvent.cCondition.nAction = nAction) then
        begin
          boGroup := (m_GroupOwner <> nil);
          if MapEvent.cCondition.boGroup = boGroup then
          begin
            if (nAction in [4, 5]) or (MapEvent.cCondition.sItemName = '*') or (MapEvent.cCondition.sItemName = ItemName) then
            begin
              if (Random(MapEvent.nRate + 1) = 0) and (MapEvent.cEnent.boCall) then
              begin
                if (g_FunctionNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  g_FunctionNPC.m_OprCount := 0;
                  g_FunctionNPC.GotoLable(TPlayObject(Self), MapEvent.cEnent.sLabel, False);
                  Result := True;
                end;
                Break;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TBaseObject.ClearBagItem();
var
  i: Integer;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  DelList := nil;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    if DelList = nil then
      DelList := TStringList.Create;
    DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
    Dispose(UserItem);
  end;
  m_ItemList.Clear;
  if DelList <> nil then
    SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
end;

procedure TBaseObject.ClearStorageItem();
var
  i: Integer;
  UserItem: pTUserItem;
begin
  for i := m_StorageItemList.Count - 1 downto 0 do
  begin
    UserItem := m_StorageItemList.Items[i];
    Dispose(UserItem);
  end;
  m_StorageItemList.Clear;
end;

procedure TPlayObject.SetBankPassword(sPassWord: string);
begin
  //m_sBankPassword := sPassWord;
end;

procedure TPlayObject.GetSaleItemList(MsgObject: TBaseObject; nIndex: Integer);
var
  i, nCount: Integer;
  sSENDMSG: string;
  SaleItem: TSaleItem;
begin
  if g_SaleItemList <> nil then
  begin
    sSENDMSG := '';
    nCount := 0;
    if nIndex > 0 then
    begin
      if nIndex * 7 <= g_SaleItemList.Count then
      begin
        for i := nIndex * 7 to g_SaleItemList.Count - 1 do
        begin
          SaleItem := pTSaleItem(g_SaleItemList.Items[i])^;
          sSENDMSG := sSENDMSG + EncodeBuffer(@SaleItem, SizeOf(TSaleItem));
          Inc(nCount);
          if nCount >= 7 then
            Break;
        end;
      end;
    end
    else
    begin
      for i := 0 to g_SaleItemList.Count - 1 do
      begin
        SaleItem := pTSaleItem(g_SaleItemList.Items[i])^;
        sSENDMSG := sSENDMSG + EncodeBuffer(@SaleItem, SizeOf(TSaleItem));
        Inc(nCount);
        if nCount >= 7 then
          Break;
      end;
    end;
    if sSENDMSG <> '' then
      SendMsg(MsgObject, RM_GETSALELIST, 0, g_SaleItemList.Count, nIndex + 1, nCount, sSENDMSG);
  end;
end;

procedure TPlayObject.BuyShopItem(MsgObject: TBaseObject; sMsg: string);
var
  nItemPrice: Integer;
  sItemName: string;
  pSaleItem: pTSaleItem;
  pUserItem: pTUserItem;
begin
  sItemName := DecodeString(sMsg);
  pSaleItem := GetSaleItemByName(sItemName);
  if pSaleItem <> nil then
  begin
    nItemPrice := pSaleItem.sStdItem.Price div 100;
    if (m_nGameGold >= nItemPrice) and (nItemPrice >= 0) then
    begin
      if IsEnoughBag then
      begin
        New(pUserItem);
        if UserEngine.CopyToUserItemFromName(sItemName, pUserItem) then
        begin
          if AddItemToBag(pUserItem) then
          begin
            Dec(m_nGameGold, nItemPrice);
            SendAddItem(pUserItem);
            GameGoldChanged();
            AddGameDataLogAPI('9' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              sItemName + #9 +
              IntToStr(pUserItem.MakeIndex) + #9 +
              '1' + #9 +
              'ÀÏÉÌÆÌ¹ºÂò-' + IntToStr(nItemPrice) + g_Config.sGameGoldName);
            if g_Config.nShopItemBind = 1 then
              BindItemCharName(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sCharName)
            else if g_Config.nShopItemBind = 2 then
              BindItemAccount(pUserItem^.wIndex, pUserItem^.MakeIndex, m_sUserID);
          end
          else
            Dispose(pUserItem);
        end
        else
          Dispose(pUserItem);
      end
      else
        SysMsg('ÄãµÄ±³°üÒÑÂúÁË£¬ÇëÕûÀíºóÔÙ¹ºÂò£º' + sItemName, c_Purple, t_Hint);
    end
    else
      SysMsg('ÄãÃ»ÓÐ×ã¹»µÄ' + g_Config.sGameGoldName + '¹ºÂò£º' + sItemName, c_Purple, t_Hint);
  end
  else
    SysMsg('ÉÌ³ÇÇ·È±ÎïÆ·£º' + sItemName, c_Purple, t_Hint);
end;

procedure TPlayObject.LoadHumanCustomData();
begin
  {MakerMap := GetUserDataList(m_sCharName);
  if MakerMap <> nil then begin
    //m_MakerMapInfo[i].sMapName := MakerMap.sMapName;
    //m_MakerMapInfo[i].wMapX := MakerMap.wMapX;
    //m_MakerMapInfo[i].wMapY := MakerMap.wMapY;
  end; }
end;

procedure TPlayObject.SaveHumanCustomData();
begin
  {for i := Low(TMakerMapInfo) to High(TMakerMapInfo) do begin
    MakerMap := m_MakerMapInfo[i];
    if (MakerMap.sMapName <> '') and (MakerMap.wMapX > 0) and (MakerMap.wMapY > 0) then
      g_UserDataConf.WriteString(m_sCharName, 'MakerMapInfo' + IntToStr(i), MakerMap.sMapName + '/' + IntToStr(MakerMap.wMapX) + '/' + IntToStr(MakerMap.wMapY));
  end;}
end;

function TAnimalObject.SetUseNormAttack(): Boolean;
var
  btDir: Byte;
begin
  Result := False;

  if GetAttackDir(m_TargetCret, btDir) then
  begin
    if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
    begin
      m_dwHitTick := GetTickCount();
      m_dwTargetFocusTick := GetTickCount();
      Attack(m_TargetCret, btDir);
      BreakHolySeizeMode();
    end;
    Result := True;
  end
  else if m_TargetCret.m_PEnvir = m_PEnvir then
    SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
  else
    DelTargetCreat();
end;

function TBaseObject.GetTagXYRangeCount(nType, nRange: Integer; const btCheck: Byte = 0): Integer;
var
  i, nX, nY: Integer;
  Envir: TEnvirnoment;
  MonList: TList;
  BaseObject: TBaseObject;
  MainObject: TBaseObject;
begin
  Result := 0;
  if nType = 0 then
    MainObject := m_TargetCret
  else
    MainObject := Self;
  if MainObject <> nil then
  begin
    nX := MainObject.m_nCurrX;
    nY := MainObject.m_nCurrY;
    Envir := MainObject.m_PEnvir; //g_MapManager.FindMap(MainObject.m_sMapName);
    if Envir <> nil then
    begin
      MonList := TList.Create;
      if Envir.GetRangeBaseObject(nX, nY, nRange, True, MonList) > 0 then
      begin
        for i := MonList.Count - 1 downto 0 do
        begin
          BaseObject := TBaseObject(MonList.Items[i]);
          if (BaseObject.m_btRaceServer < RC_ANIMAL) or
            (BaseObject.m_btRaceServer = RC_ARCHERGUARD) or
            ((btCheck = 2) and ((BaseObject.m_boCoolEye) and (BaseObject.m_Abil.Level > (m_Abil.Level + 3)))) or
            ((btCheck = 1) and (BaseObject.m_boStickMode or (BaseObject.m_Abil.Level > m_Abil.Level) or TargetInSwordLongAttackRange)) then
            MonList.Delete(i);
        end;
        Result := MonList.Count;
      end;
      MonList.Free;
    end;
  end;
end;

function TBaseObject.GetSelfRangeCount(nRange: Integer): Integer;
var
  i {, nX, nY}: Integer;
  //Envir                     : TEnvirnoment;
  MonList: TList;
  BaseObject: TBaseObject;
  //MainObject                : TBaseObject;
begin
  Result := 0;
  if m_PEnvir <> nil then
  begin
    MonList := TList.Create;
    Result := m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, nRange, True, MonList);
    if Result > 0 then
    begin
      for i := MonList.Count - 1 downto 0 do
      begin
        BaseObject := TBaseObject(MonList.Items[i]);
        if not IsProperTarget(BaseObject, IsHero) then
          Dec(Result);
        if Result <= 0 then
          Break;
      end;
    end;
    MonList.Free;
  end;
end;

function TAnimalObject.MonPickItem(): Boolean;

  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    Result := False;
    if (BaseObject = nil) or (m_Master = BaseObject) then
      Result := True;
  end;

  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    i: Integer;
    GroupMember: TBaseObject;
  begin
    Result := False;
    if TPlayObject(m_Master).m_GroupOwner = nil then
      Exit;
    for i := 0 to TPlayObject(m_Master).m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      GroupMember := TBaseObject(TPlayObject(m_Master).m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = BaseObject then
      begin
        Result := True;
        Break;
      end;
    end;
  end;

var
  i, nC, nDistance: Integer;
  vmi, VisibleMapItem: pTVisibleMapItem;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
resourcestring
  sMsg = 'ÄãµÄ°ü¹üÒÑÂú£¬Ó¢ÐÛ²»ÄÜ¼ÌÐø¼ñÈ¡';
  sMaxGoldMsg = 'ÄãµÄ½ð±Òµ½´ïÏÞ¶î£¬Ó¢ÐÛ²»ÄÜ¼ÌÐø¼ñÈ¡';
begin
  Result := False;
  if (m_Master = nil) or (m_Master.m_btRaceServer <> RC_PLAYOBJECT) then Exit;

  if GetTickCount - m_UnreachableTick > 5 * 1000 then      
  begin
     m_UnreachableTick := GetTickCount;
     ClearUnreachableItemList();                       
  end;

  if (TPlayObject(m_Master).m_VisibleItems.Count > 0) then
  begin
    vmi := nil;
    nDistance := 999;
    for i := 0 to TPlayObject(m_Master).m_VisibleItems.Count - 1 do
    begin
      VisibleMapItem := TPlayObject(m_Master).m_VisibleItems[i];
      if (VisibleMapItem <> nil) then 
      begin
        if FindItemInUnreseachable(VisibleMapItem) then  continue;
        if VisibleMapItem.MapItem.boHeroPickup and (IsSelf(TBaseObject(VisibleMapItem.MapItem.OfBaseObject)) or IsOfGroup(TBaseObject(VisibleMapItem.MapItem.OfBaseObject))) then
        begin
          if (self <>  TBaseObject(VisibleMapItem.MapItem.DropBaseObject)) and (TBaseObject(VisibleMapItem.MapItem.DropBaseObject) <> m_Master) then
          begin
            if VisibleMapItem.MapItem.IsGold {(CompareText(VisibleMapItem.sName, sSTRING_GOLDNAME) = 0)} then
            begin
              if TPlayObject(m_Master).m_nGold + VisibleMapItem.MapItem.Count <= g_Config.nHumanMaxGold then
              begin
                nC := abs(m_nCurrX - VisibleMapItem.nX) + abs(m_nCurrY - VisibleMapItem.nY);
                if nC < nDistance  then
                begin
                  nDistance := nC;
                  vmi := VisibleMapItem;
                end;
              end
              else
              begin
                if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
                begin
                  m_dwHintMsgTick := GetTickCount();
                  m_Master.SysMsg(sMaxGoldMsg, c_Red, t_Hint);
                end;
              end;
            end
            else
            begin
              if TPlayObject(Self).IsEnoughBag or TPlayObject(m_Master).IsEnoughBag then
                begin
                  nC := abs(m_nCurrX - VisibleMapItem.nX) + abs(m_nCurrY - VisibleMapItem.nY);
                  if (nC < nDistance) then
                  begin
                    nDistance := nC;
                    vmi := VisibleMapItem;
                  end;
                end
              else
              begin
                if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
                begin
                  m_dwHintMsgTick := GetTickCount();
                  if not TPlayObject(Self).IsEnoughBag then
                    SysMsg(sMsg, c_Red, t_Hint)
                  else
                    m_Master.SysMsg(sMsg, c_Red, t_Hint);
                end;
              end;
            end;
          end;
        end;
      end;
    end;


    if (vmi <> nil) then
    begin
      if m_PEnvir.CanWalk(vmi.nX, vmi.nY, False) then
      begin
        m_nTargetX := vmi.nX;
        m_nTargetY := vmi.nY;
        Result := True;
      end
      else
        AddUnreachableItem(vmi);      //   Ìí¼Ó²»¿É´ïÎïÆ·µ½Á´±í
      
      if (m_nCurrX = vmi.nX) and (m_nCurrY = vmi.nY) then
      begin
        if vmi.MapItem.IsGold then
        begin
          if TPlayObject(m_Master).HeroPickUpItem(m_nCurrX, m_nCurrY, vmi.MapItem) then
            m_dwWalkTick := 0;
        end
        else
        begin
          if  TPlayObject(Self).IsEnoughBag  then
          begin
            if TPlayObject(Self).HeroPickUpItem(m_nCurrX, m_nCurrY, vmi.MapItem) then
              m_dwWalkTick := 0
          end
          else if  TPlayObject(m_Master).IsEnoughBag then
            if TPlayObject(m_Master).HeroPickUpItem(m_nCurrX, m_nCurrY, vmi.MapItem) then
              m_dwWalkTick := 0;
        end;
         Result := True;
      end;
    end;
  end;
end;

function TPlayObject.DoMag60(UserMagic: pTUserMagic; nDir: Integer; TargeTBaseObject: TBaseObject): Boolean;
var
  nPower, n14, n18, n1C: Integer;
  nTargetX, nTargetY: Integer;
  btOldHitPoint: Byte;

  function GetPower(nPower: Integer): Integer;
  begin
    Result := Round(nPower / (4) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower));
  end;
begin
  Result := False;
  nTargetX := TargeTBaseObject.m_nCurrX;
  nTargetY := TargeTBaseObject.m_nCurrY;
  if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, nDir, 1, n14, n18) then
  begin
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, nDir, 6, nTargetX, nTargetY);
    nPower := GetAttackPower(GetPower(MPow(UserMagic)) + LoWord(m_WAbil.DC), SmallInt(HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)) + 1);
    btOldHitPoint := m_btHitPoint;
    m_btHitPoint := _MIN(High(Byte), m_btHitPoint + UserMagic.btLevel * 6);
    n1C := MagPassThroughMagic60(n14, n18, nTargetX, nTargetY, nDir, nPower, False);
    m_btHitPoint := btOldHitPoint;
    if n1C > 0 then
    begin
      m_Abil.HP := _MIN(m_Abil.MaxHP, m_Abil.HP + (UserMagic.btLevel * n1C * 20));
      Result := True;
    end;
  end;
end;

function TBaseObject.GetMainPlayer(BaseObject: TBaseObject): TBaseObject;
begin
  Result := BaseObject;
  if (BaseObject.m_Master <> nil) and not BaseObject.m_Master.m_boGhost then
  begin
    if (BaseObject.m_Master.m_btRaceServer = RC_HERO) and (BaseObject.m_Master.m_Master <> nil) and not BaseObject.m_Master.m_Master.m_boGhost then
    begin
      if BaseObject.m_Master.m_Master.m_btRaceServer = RC_PLAYOBJECT then
      begin
        Result := BaseObject.m_Master.m_Master;
        Exit;
      end;
    end;
    if BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT then
      Result := BaseObject.m_Master;
  end;
end;

function TBaseObject.IPLevelInRange(): Boolean;
begin
  Result := (m_nInPowerLevel > 0) and (m_nInPowerLevel < MAX_IPLEVEL);
end;

procedure TPlayObject.ScriptOpenBox(sMsg: string);
var
  i, nItemIdx: Integer;
  StdItem: pTStdItem;
  pBoxItem: pTBoxItem;
  BoxItemList: TList;
label
  RegetItem;
begin
  if GetMaxBagItem - m_ItemList.Count >= 6 then
  begin
    BoxItemList := GetBoxItemInfoByName(sMsg);
    if BoxItemList = nil then
    begin
      SendDefMessage(SM_OPENBOX_FAIL, 1, 0, 0, 0, '');
      Exit;
    end;
    //if m_aBoxItems = nil then New(m_aBoxItems);
    FillChar(m_aBoxItems, SizeOf(TBoxItems), #0);
    nItemIdx := -1; //Ìí¼ÓÖÐ¼äÒ»¸ñÎïÆ·
    while nItemIdx < 0 do
    begin
      for i := 0 to BoxItemList.Count - 1 do
      begin
        pBoxItem := BoxItemList.Items[i];
        if pBoxItem.sName = '' then
          Continue;
        if Random(pBoxItem.btRate + 1) = 0 then
        begin
          m_aBoxItems[High(TBoxItems)].sName := pBoxItem.sName;
          m_aBoxItems[High(TBoxItems)].btRate := pBoxItem.btRate;
          m_aBoxItems[High(TBoxItems)].nNumber := pBoxItem.nNumber;
          if CompareText(pBoxItem.sName, 'ÉùÍû') = 0 then
            m_aBoxItems[High(TBoxItems)].nLooks := 1185
          else if CompareText(pBoxItem.sName, '¾­Ñé') = 0 then
            m_aBoxItems[High(TBoxItems)].nLooks := 1186
          else if CompareText(pBoxItem.sName, '½ð¸ÕÊ¯') = 0 then
            m_aBoxItems[High(TBoxItems)].nLooks := 1187
          else
          begin
            StdItem := UserEngine.GetStdItem(pBoxItem.sName);
            if StdItem <> nil then
              m_aBoxItems[High(TBoxItems)].nLooks := StdItem.Looks;
          end;
          nItemIdx := i;
          Break;
        end;
      end;
    end;
    RegetItem:
    for i := Low(TBoxItems) to High(TBoxItems) do
    begin //Ìí¼ÓÆäËû8¸ñÎïÆ·
      if m_aBoxItems[i].sName = '' then
      begin
        pBoxItem := BoxItemList.Items[Random(BoxItemList.Count)];
        if pBoxItem <> nil then
        begin
          m_aBoxItems[i].sName := pBoxItem.sName;
          m_aBoxItems[i].btRate := pBoxItem.btRate;
          m_aBoxItems[i].nNumber := pBoxItem.nNumber;
          if CompareText(pBoxItem.sName, 'ÉùÍû') = 0 then
            m_aBoxItems[i].nLooks := 1185
          else if CompareText(pBoxItem.sName, '¾­Ñé') = 0 then
            m_aBoxItems[i].nLooks := 1186
          else if CompareText(pBoxItem.sName, '½ð¸ÕÊ¯') = 0 then
            m_aBoxItems[i].nLooks := 1187
          else
          begin
            StdItem := UserEngine.GetStdItem(pBoxItem.sName);
            if StdItem <> nil then
              m_aBoxItems[i].nLooks := StdItem.Looks;
          end;
        end;
      end;
    end;
    nItemIdx := 0;
    for i := Low(TBoxItems) to High(TBoxItems) do
      if m_aBoxItems[i].sName <> '' then
        Inc(nItemIdx);
    if nItemIdx = 9 then
    begin
      m_nBoxIndex := 9;
      m_boCanGetRareBoxItem := True;
      m_DefMsg := MakeDefaultMsg(SM_OPENBOX, 0, 1 {Not Need box}, 0, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@m_aBoxItems, SizeOf(TBoxItems)));
    end
    else
      goto RegetItem;
  end
  else
    SendDefMessage(SM_OPENBOX_FAIL, 3, 0, 0, 0, ''); //ÖÁÉÙÐèÒªÔ¤ÁôÁù¸ö¿ÕÎ»,¹é»¹ÎïÆ·
end;

procedure TPlayObject.ClientOpenBox(sMsg: string);
var
  i, nItemIdx: Integer;
  sItemName: string;
  OpenBoxItem: TOpenBoxItem;
  StdItem: pTStdItem;
  StdItemBox, StdItemKey: pTStdItem;
  UserItem: pTUserItem;
  pBoxItem: pTBoxItem;
  BoxItemList: TList;
label
  RegetItem;
begin
  if GetMaxBagItem - m_ItemList.Count >= 6 then
  begin
    //FillChar(OpenBoxItem, SizeOf(TOpenBoxItem), #0);
    DecodeBuffer(sMsg, @OpenBoxItem, SizeOf(TOpenBoxItem));

    StdItemBox := nil;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = OpenBoxItem.nBoxItemMIdx then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;
        sItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sItemName, OpenBoxItem.sBoxItemName) = 0 then
        begin
          StdItemBox := StdItem;
          Break;
        end;
      end;
    end;
    if StdItemBox = nil then
    begin
      SendDefMessage(SM_OPENBOX_FAIL, 1, 0, 0, 0, '');
      Exit;
    end;

    StdItemKey := nil;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = OpenBoxItem.nKeyItemMIdx then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;
        sItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if CompareText(sItemName, OpenBoxItem.sKeyItemName) = 0 then
        begin
          StdItemKey := StdItem;
          Break;
        end;
      end;
    end;
    if StdItemKey = nil then
    begin
      SendDefMessage(SM_OPENBOX_FAIL, 1, 0, 0, 0, '');
      Exit;
    end;

    if (StdItemBox.Shape + 10) = StdItemKey.Shape then
    begin
      BoxItemList := GetBoxItemInfoByIndx(StdItemBox.Shape);
      if BoxItemList = nil then
      begin
        SendDefMessage(SM_OPENBOX_FAIL, 1, 0, 0, 0, '');
        Exit;
      end;
      //if m_aBoxItems = nil then New(m_aBoxItems);
      FillChar(m_aBoxItems, SizeOf(TBoxItems), #0);
      nItemIdx := -1; //Ìí¼ÓÖÐ¼äÒ»¸ñÎïÆ·
      while nItemIdx < 0 do
      begin
        for i := 0 to BoxItemList.Count - 1 do
        begin
          pBoxItem := BoxItemList.Items[i];
          if pBoxItem.sName = '' then
            Continue;
          if Random(pBoxItem.btRate + 1) = 0 then
          begin
            m_aBoxItems[High(TBoxItems)].sName := pBoxItem.sName;
            m_aBoxItems[High(TBoxItems)].btRate := pBoxItem.btRate;
            m_aBoxItems[High(TBoxItems)].nNumber := pBoxItem.nNumber;
            if CompareText(pBoxItem.sName, 'ÉùÍû') = 0 then
              m_aBoxItems[High(TBoxItems)].nLooks := 1185
            else if CompareText(pBoxItem.sName, '¾­Ñé') = 0 then
              m_aBoxItems[High(TBoxItems)].nLooks := 1186
            else if CompareText(pBoxItem.sName, '½ð¸ÕÊ¯') = 0 then
              m_aBoxItems[High(TBoxItems)].nLooks := 1187
            else
            begin
              StdItem := UserEngine.GetStdItem(pBoxItem.sName);
              if StdItem <> nil then
                m_aBoxItems[High(TBoxItems)].nLooks := StdItem.Looks;
            end;
            nItemIdx := i;
            Break;
          end;
        end;
      end;
      RegetItem:
      for i := Low(TBoxItems) to High(TBoxItems) do
      begin //Ìí¼ÓÆäËû8¸ñÎïÆ·
        if m_aBoxItems[i].sName = '' then
        begin
          pBoxItem := BoxItemList.Items[Random(BoxItemList.Count)];
          if pBoxItem <> nil then
          begin
            m_aBoxItems[i].sName := pBoxItem.sName;
            m_aBoxItems[i].btRate := pBoxItem.btRate;
            m_aBoxItems[i].nNumber := pBoxItem.nNumber;
            if CompareText(pBoxItem.sName, 'ÉùÍû') = 0 then
              m_aBoxItems[i].nLooks := 1185
            else if CompareText(pBoxItem.sName, '¾­Ñé') = 0 then
              m_aBoxItems[i].nLooks := 1186
            else if CompareText(pBoxItem.sName, '½ð¸ÕÊ¯') = 0 then
              m_aBoxItems[i].nLooks := 1187
            else
            begin
              StdItem := UserEngine.GetStdItem(pBoxItem.sName);
              if StdItem <> nil then
                m_aBoxItems[i].nLooks := StdItem.Looks;
            end;
          end;
        end;
      end;
      nItemIdx := 0;
      for i := Low(TBoxItems) to High(TBoxItems) do
      begin
        if m_aBoxItems[i].sName <> '' then
          Inc(nItemIdx);
      end;
      if nItemIdx = 9 then
      begin
        for i := m_ItemList.Count - 1 downto 0 do
        begin //É¾³ý±³°ü=MakeIndexÏä×Ó
          UserItem := m_ItemList.Items[i];
          if UserItem.MakeIndex = OpenBoxItem.nBoxItemMIdx then
          begin
            DelBagItem(i, False, '¿ª±¦ÏäÏûºÄ');
            Break;
          end;
        end;

        for i := m_ItemList.Count - 1 downto 0 do
        begin //É¾³ý±³°ü=MakeIndexÔ¿³×
          UserItem := m_ItemList.Items[i];
          if UserItem.MakeIndex = OpenBoxItem.nKeyItemMIdx then
          begin
            DelBagItem(i, False, '¿ª±¦ÏäÏûºÄ');
            Break;
          end;
        end;

        WeightChanged();
        //m_dwSaveRcdTick := 0;           //0408_1
        m_nBoxIndex := 9;
        m_boCanGetRareBoxItem := True;
        m_DefMsg := MakeDefaultMsg(SM_OPENBOX, 0, 0, 0, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@m_aBoxItems, SizeOf(TBoxItems)));
      end
      else
        goto RegetItem;
    end
    else
      SendDefMessage(SM_OPENBOX_FAIL, 2, 0, 0, 0, ''); //±¦ÏäÓëÔ¿³×ÀàÐÍ²»Æ¥Åä,¹é»¹ÎïÆ·
  end
  else
    SendDefMessage(SM_OPENBOX_FAIL, 3, 0, 0, 0, ''); //ÖÁÉÙÐèÒªÔ¤ÁôÁù¸ö¿ÕÎ»,¹é»¹ÎïÆ·
end;

procedure TPlayObject.ClientSelectBoxFlash();
var
  i, nL: Integer;
begin
  //if m_aBoxItems = nil then Exit;
  if not m_boCanGetRareBoxItem or (m_nBoxIndex <> 9) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[¾¯¸æ]: Çë²»ÒªÊ¹ÓÃ·Ç·¨³ÌÐò½øÐÐÓÎÏ·£¡');
    m_boKickFlag := True;
    Exit;
  end;

  nL := 0;
  for i := Low(TBoxItems) to High(TBoxItems) do
    if m_aBoxItems[i].sName <> '' then
      Inc(nL);
  if nL <> 9 then
  begin
    SendDefMessage(SM_OPENBOX_FAIL, 1, 0, 0, 0, '');
    Exit;
  end;

  nL := 0;
  //m_nBoxIndex := 9;
  while True do
  begin
    for i := Low(TBoxItems) to High(TBoxItems) - 1 do
    begin
      if Random(m_aBoxItems[i].btRate + 1) = 0 then
      begin
        m_nBoxIndex := i;
        Break;
      end;
    end;
    if m_nBoxIndex <> 9 then
      Break;
    Inc(nL);
    if nL > High(Byte) * 2 then
    begin
      m_nBoxIndex := Random(9) + 1;
      Break;
    end;
  end;
  if m_nBoxIndex <> 9 then
  begin
    //m_boSelectBoxFlashed := True;
    SendDefMessage(SM_SELETEBOXFLASH, m_nBoxIndex, 0, 0, 0, '');
  end;
end;

{$IF SERIESSKILL}

procedure TPlayObject.ClientSetSeriesSkill(Index, MagID: Integer);
var
  i: Integer;
begin
  if not Index in [0..High(m_SeriesSkillArr)] then
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_SETSERIESSKILL, -1, Index, 0, 1, '')
    else
      SendDefMessage(SM_SETSERIESSKILL, -1, Index, 0, 0, ''); //ÉèÖÃ¼¼ÄÜË³ÐòºÅÓÐ´íÎó...
    Exit;
  end;
  if not (MagID in [0..255]) then
    Exit;

  if MagID > 1 then
  begin
    if m_MagicArr[0][MagID] = nil then
      MagID := 0
    else
    begin
      for i := Low(m_SeriesSkillArr) to High(m_SeriesSkillArr) do
      begin
        if Index = i then
          Continue;
        if MagID = m_SeriesSkillArr[i] then
        begin
          MagID := 0;
          Break;
        end;
      end;
    end;
  end
  else if MagID = 1 then
  begin
    MagID := 1;
  end
  else
  begin
    MagID := 0;
  end;
  m_SeriesSkillArr[Index] := MagID;
  if IsHero then
    TPlayObject(m_Master).SendDefMessage(SM_SETSERIESSKILL, MagID, Index, 0, 1, '')
  else
    SendDefMessage(SM_SETSERIESSKILL, MagID, Index, 0, 0, '');
end;

procedure TPlayObject.ClientSetSeriesSkill2(Index, MagID: Integer);
var
  i: Integer;
begin
  if not Index in [0..High(m_SeriesSkillArr)] then
  begin
    Exit;
  end;
  if not (MagID in [0..255]) then
    Exit;

  if MagID > 1 then
  begin
    if m_MagicArr[0][MagID] = nil then
      MagID := 0
    else
    begin
      for i := Low(m_SeriesSkillArr) to High(m_SeriesSkillArr) do
      begin
        if Index = i then
          Continue;
        if MagID = m_SeriesSkillArr[i] then
        begin
          MagID := 0;
          Break;
        end;
      end;
    end;
  end
  else if MagID = 1 then
  begin
    MagID := 1;
  end
  else
  begin
    MagID := 0;
  end;
  m_SeriesSkillArr[Index] := MagID;
end;

procedure TPlayObject.ClientBuildAcus(buff: string);
var
  s: string;
  b: Boolean;
  i, ii, n, m, Shape, rate: Integer;
  ca: TClientBuildAcus;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if m_StallMgr.OnSale then
    Exit;
  if m_boDealing or ((GetTickCount - m_DealLastTick) <= g_Config.dwTryDealTime) then
  begin
    SendDefMessage(SM_BUILDACUS, -1, 0, 0, 0, ''); //[Ê§°Ü]: ½»Ò×ÆÚ¼ä²»ÄÜ½øÐÐ¶ÍÔì
    Exit;
  end;
  if buff = '' then
  begin
    SendDefMessage(SM_BUILDACUS, -2, 0, 0, 0, ''); //[Ê§°Ü]: Ã»ÓÐ¶ÍÔìËùÐèµÄÎïÆ·
    Exit;
  end;
  FillChar(ca, SizeOf(ca), #0);
  DecodeBuffer(buff, @ca, SizeOf(ca));

  for i := 0 to 7 do
  begin
    for ii := 0 to 7 do
    begin
      if ii = i then
        Continue;
      if (ca[i].nMakeIndex <> 0) and (ca[i].nMakeIndex = ca[ii].nMakeIndex) then
      begin
        SendDefMessage(SM_BUILDACUS, -6, 0, 0, 0, ''); //[Ê§°Ü]: ¶ÍÔì²ÄÁÏ²»Ò»ÖÂ,Çë¿´¶ÍÔìµÄ²ÄÁÏËµÃ÷
        Exit;
      end;
    end;
  end;

  n := 0;
  m := 0;
  Shape := 0;
  for i := 0 to 7 do
  begin
    StdItem := UserEngine.GetStdItem(ca[i].sItemName);
    if (StdItem <> nil) and (StdItem.StdMode = 41) and (StdItem.Shape in [10..14, 30..34]) then
    begin
      b := False;
      for ii := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList[ii];
        if (UserItem.MakeIndex = ca[i].nMakeIndex) then
        begin
          b := True;
          Break;
        end;
      end;
      if not b then
      begin
        SendDefMessage(SM_BUILDACUS, -3, 0, 0, 0, ''); //[Ê§°Ü]: Äã°ü¹üÖÐÃ»ÓÐ¶ÍÔìËùÐèµÄÎïÆ·
        Exit;
      end;

      if i in [0..4] then
        Inc(n) //Õë
      else
        Inc(m); //·û
      if Shape = 0 then
        Shape := StdItem.Shape mod 20
      else if Shape <> (StdItem.Shape mod 20) then
      begin
        SendDefMessage(SM_BUILDACUS, -4, 0, 0, 0, ''); //[Ê§°Ü]: ¶ÍÔì²ÄÁÏ²»Ò»ÖÂ,Çë¿´¶ÍÔìµÄ²ÄÁÏËµÃ÷
        Exit;
      end;

    end;
  end;
  if n = 0 then
  begin
    SendDefMessage(SM_BUILDACUS, -2, 0, 0, 0, ''); //[Ê§°Ü]: Ã»ÓÐ¶ÍÔìËùÐèµÄÎïÆ·
    Exit;
  end;
  rate := 0;
  case Shape of
    10: rate := 8 * n;
    11: rate := 14 * n;
    12..14: rate := 20 * n;
  end;
  if m > 0 then
  begin
    rate := _MIN(100, rate + m * 20);
  end;
  Randomize;
  if rate > Random(100) then
  begin
    SendDefMessage(SM_BUILDACUS, 0, 0, 0, 0, ''); //[OK]: ¶ÍÔìOK
    s := '';
    case Shape of
      10: s := 'Ò»¼¶½ðÕë';
      11: s := '¶þ¼¶½ðÕë';
      12: s := 'Èý¼¶½ðÕë';
      13: s := 'ËÄ¼¶½ðÕë';
      14: s := 'Îå¼¶½ðÕë';
    end;
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(s, UserItem) then
    begin
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);

    for ii := 0 to 7 do
    begin
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList[i];
        if (UserItem.MakeIndex = ca[ii].nMakeIndex) then
        begin
          DelBagItem(i, False, 'ºÏ³É½ðÕëÏûºÄ');
          Break;
        end;
      end;
    end;

  end
  else
  begin
    SendDefMessage(SM_BUILDACUS, -5, 0, 0, 0, ''); //[Ê§°Ü]: ¶ÍÔìÊ§°Ü
    for ii := 0 to 7 do
    begin
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList[i];
        if (UserItem.MakeIndex = ca[ii].nMakeIndex) then
        begin
          DelBagItem(i, False, 'ºÏ³É½ðÕëÏûºÄ');
          Break;
        end;
      end;
    end;

  end;
end;

procedure TPlayObject.ClientTrainVenation(v: Integer);
var
  n, l, Shape: Integer;
  skillname: string;
begin
  if not v in [0..3] then
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_TRAINVENATION, -1, v, 0, 1, '')
    else
      SendDefMessage(SM_TRAINVENATION, -1, v, 0, 0, ''); //Ñ¡ÔñÂöÂç·¢Éú´íÎó...
    Exit;
  end;

  l := m_VenationInfos[v].Level;
  if m_VenationInfos[v].Point = 5 then
  begin

    {if (m_VenationInfos[v].Level >= 5) then begin
      if IsHero then
        TPlayObject(m_Master).SendDefMessage(SM_TRAINVENATION, -3, v, l, 1, '')
      else
        SendDefMessage(SM_TRAINVENATION, -3, v, l, 0, ''); //ÂöÂçÒÑ¾­ÐÞÁ¶µ½×î¸ß¼¶ÁË...
      Exit;
    end;}

    if m_VenationInfos[v].Level = 0 then //Î´Í¨
      m_VenationInfos[v].Level := 1; //Í¨
    if m_VenationInfos[v].Level in [1..5] then
    begin
      Shape := 10 + m_VenationInfos[v].Level;
      /////////¼ì²âÎïÆ·
      n := GetBagStdItemCount(41, Shape, g_VLvNeesAcus[v][m_VenationInfos[v].Level]);
      if n < g_VLvNeesAcus[v][m_VenationInfos[v].Level] then
      begin
        if IsHero then
          TPlayObject(m_Master).SendDefMessage(SM_TRAINVENATION, -4, v, l, 1, '')
        else
          SendDefMessage(SM_TRAINVENATION, -4, v, l, 0, ''); //ÄãµÄ%d¼¶½ðÕë²»¹»
        Exit;
      end;

      /////////É¾³ýÎïÆ·
      DelBagStdItemCount(41, Shape, g_VLvNeesAcus[v][m_VenationInfos[v].Level], 'ÐÞÁ¶¾­Âç');

      m_VenationInfos[v].Level := _MIN(6, m_VenationInfos[v].Level + 1);

      l := m_VenationInfos[v].Level;

      if IsHero then
      begin
        TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_TRAINVENATION, 0, v, l, 1);
        TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@m_VenationInfos, SizeOf(m_VenationInfos)));
      end
      else if (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        m_DefMsg := MakeDefaultMsg(SM_TRAINVENATION, 0, v, l, 0);
        SendSocket(@m_DefMsg, EncodeBuffer(@m_VenationInfos, SizeOf(m_VenationInfos)));
      end;

      if m_VenationInfos[v].Level = 2 then
      begin
        skillname := g_JobofSeriesSkill[m_btJob][v];
        if IsHero then
          skillname := 'Ó¢ÐÛ' + skillname;
        AddSkillByName(skillname, 0);
        SysMsg(Format('¹§Ï²ÄãÍ¨¹ý²»Ð¸µÄÅ¬Á¦, ½«%sÉý¼¶ÎªÒ»ÖØ, Ï°µÃÁ¬»÷ÕÐÊ½: %s', [g_VaStrs[v], skillname]), c_Green, t_Hint);
        UserEngine.SendBroadCastMsg(Format('¹§Ï²: %s Í¨¹ý²»Ð¸µÄÅ¬Á¦, ½«%sÉý¼¶ÎªÒ»ÖØ, Ï°µÃÁ¬»÷ÕÐÊ½: %s', [m_sCharName, g_VaStrs[v], skillname]), t_System);
      end
      else
      begin
        skillname := g_JobofSeriesSkill[m_btJob][v];
        SysMsg(Format('¹§Ï²Äã½«%sÉý¼¶Îª%sÖØ,ÌáÉý%sµÄ±©»÷ÂÊºÍ±©»÷ÍþÁ¦', [g_VaStrs[v], g_VLevelStr[m_VenationInfos[v].Level - 1], skillname]), c_Green, t_Hint);
        UserEngine.SendBroadCastMsg(Format('¹§Ï²: %s ½«%sÉý¼¶Îª%sÖØ, ÌáÉýÁ¬»÷:%sµÄ±©»÷ÂÊºÍ±©»÷ÍþÁ¦', [m_sCharName, g_VaStrs[v], g_VLevelStr[m_VenationInfos[v].Level - 1], skillname]), t_System);
      end;
      RecalcAbilitys();
      case m_btJob of
        0: case v of
            0: n := 101;
            1: n := 100;
            2: n := 102;
            3: n := 103;
          end;
        1: case v of
            0: n := 107;
            1: n := 104;
            2: n := 105;
            3: n := 106;
          end;
        2: case v of
            0: n := 108;
            1: n := 109;
            2: n := 110;
            3: n := 111;
          end;
      end;
      if m_MagicArr[0][n] <> nil then
        SendMsg(Self, RM_MAGIC_MAXLV, m_MagicArr[0][n].MagicInfo.btClass, m_MagicArr[0][n].MagicInfo.wMagicId, MagicMaxTrainLevel(m_MagicArr[0][n]), 0, '');
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      SendRefMsg(RM_STRUCKEFFECTEX, 0, 18, 0, 0, '');

    end
    else
    begin
      if IsHero then
        TPlayObject(m_Master).SendDefMessage(SM_TRAINVENATION, -3, v, l, 1, '')
      else
        SendDefMessage(SM_TRAINVENATION, -3, v, l, 0, ''); //ÂöÂçÒÑ¾­ÐÞÁ¶µ½×î¸ß¼¶ÁË...
      Exit;
    end;
  end
  else
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_TRAINVENATION, -2, v, l, 1, '')
    else
      SendDefMessage(SM_TRAINVENATION, -2, v, l, 0, ''); //¾­ÂçÎ´´òÍ¨...
  end;
end;

procedure TPlayObject.ClientBreakPonit(v, p, h: Integer);
var
  i, n: Integer;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if not (v in [0..3]) then
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -1, v, p, 1, '')
    else
      SendDefMessage(SM_BREAKPOINT, -1, v, p, 0, ''); //Ñ¡ÔñÂöÂç·¢Éú´íÎó...
    Exit;
  end;
  if not (p in [1..5]) then
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -2, v, p, 1, '')
    else
      SendDefMessage(SM_BREAKPOINT, -2, v, p, 0, ''); //Ñ¡ÔñÑ¨Î»·¢Éú´íÎó...
    Exit;
  end;
  if m_nInPowerLevel >= g_VNeedLevels[v][p] then
  begin
    if m_VenationInfos[v].Point < p then
    begin
      if p - m_VenationInfos[v].Point = 1 then
      begin
        n := -1;
        for i := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList[i];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (StdItem.StdMode = 41) and (StdItem.Shape = 9) then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
              begin
                Continue;
              end;
            end;
            n := i;
            Break;
          end;
        end;
        if n < 0 then
        begin
          if IsHero then
            TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -8, v, p, 1, '')
          else
            SendDefMessage(SM_BREAKPOINT, -8, v, p, 0, '');
          Exit;
        end;
        UserItem := m_ItemList[n];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        //SendDelItems(UserItem);
        //Dispose(UserItem);
        //m_ItemList.Delete(n);
        DelBagItem(n, True, '´òÍ¨Ñ¨Î»ÏûºÄ');

        Randomize;
        if Random(100) < StdItem.AniCount then
        begin
          //Inc(m_VenationInfos[v].Point);
          m_VenationInfos[v].Point := _MIN(5, m_VenationInfos[v].Point + 1);
          if m_VenationInfos[v].Point = 5 then
          begin
            m_VenationInfos[v].Level := 1;
            SysMsg(Format('¹§Ï²Äã´òÍ¨ÁË%s,ÐÞÎª¸ü½øÒ»²½', [g_VaStrs[v]]), c_Green, t_Hint);
          end;
          if IsHero then
          begin
            TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_BREAKPOINT, 0, v, p, 1);
            TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeBuffer(@m_VenationInfos, SizeOf(m_VenationInfos)));
          end
          else if (m_btRaceServer = RC_PLAYOBJECT) then
          begin
            m_DefMsg := MakeDefaultMsg(SM_BREAKPOINT, 0, v, p, 0);
            SendSocket(@m_DefMsg, EncodeBuffer(@m_VenationInfos, SizeOf(m_VenationInfos)));
          end;
          SysMsg(Format('¹§Ï²Äã³åÆÆÁË%sÉÏµÄ%sÑ¨,»ñµÃ·ÀÓùÊôÐÔÌáÉý,ÐÞÎª¸ü½øÒ»²½', [g_VaStrs[v], g_VPStrs[v, p]]), c_Green, t_Hint);
          UserEngine.SendBroadCastMsg(Format('¹§Ï²:%sÔÚÊæ¾­»îÂçÍèµÄ×÷ÓÃÏÂ,³åÆÆÁË%sÉÏµÄ%sÑ¨,»ñµÃ·ÀÓùÊôÐÔÌáÉý,ÐÞÎª¸ü½øÒ»²½', [m_sCharName, g_VaStrs[v], g_VPStrs[v, p]]), t_System);
          RecalcAbilitys();
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
          SendRefMsg(RM_STRUCKEFFECTEX, 0, 18, 0, 0, '');

        end
        else
        begin
          if IsHero then
            TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -7, v, p, 1, '')
          else
            SendDefMessage(SM_BREAKPOINT, -7, v, p, 0, '');
          Exit;
        end;
      end
      else
      begin
        if IsHero then
          TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -5, v, p, 1, '')
        else
          SendDefMessage(SM_BREAKPOINT, -5, v, p, 0, ''); //´ËÑ¨Î»Ä¿Ç°²»¿É´òÍ¨...
      end;
    end
    else
    begin
      if IsHero then
        TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -4, v, p, 1, '')
      else
        SendDefMessage(SM_BREAKPOINT, -4, v, p, 0, ''); //´ËÑ¨Î»ÒÑ¾­´òÍ¨ÁË...
    end;
  end
  else
  begin
    if IsHero then
      TPlayObject(m_Master).SendDefMessage(SM_BREAKPOINT, -3, v, p, 1, '')
    else
      SendDefMessage(SM_BREAKPOINT, -3, v, p, 0, ''); //ÄÚ¹¦µÈ¼¶²»¹»...
  end;
end;
{$IFEND SERIESSKILL}

procedure TPlayObject.ClientGetBoxItem();
var
  i, nItemCount: Integer;
  dwInt: LongWord;
  StdItem: pTStdItem;
  UserItem: pTUserItem;
begin
  if GetMaxBagItem - m_ItemList.Count >= 6 then
  begin

    if not m_boCanGetRareBoxItem then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[¾¯¸æ]: Çë²»ÒªÊ¹ÓÃ·Ç·¨³ÌÐò½øÐÐÓÎÏ·£¡');
      m_boKickFlag := True;
      Exit;
    end;

    if (m_nBoxIndex in [1..9]) then
    begin
      m_boCanGetRareBoxItem := False;
      SendDefMessage(SM_CLOSEBOX, 1, 0, 0, 0, '');
      if CompareText(m_aBoxItems[m_nBoxIndex].sName, 'ÉùÍû') = 0 then
      begin
        if m_btCreditPoint + Byte(m_aBoxItems[m_nBoxIndex].nNumber) > High(Byte) then
          m_btCreditPoint := High(Byte)
        else
          Inc(m_btCreditPoint, Byte(m_aBoxItems[m_nBoxIndex].nNumber));
        SysMsg(Format('µ±Ç°µÄÉùÍûÖµ:%d', [m_btCreditPoint]), c_Green, t_Hint);
      end
      else if CompareText(m_aBoxItems[m_nBoxIndex].sName, '¾­Ñé') = 0 then
      begin
        if m_Abil.Exp + LongWord(m_aBoxItems[m_nBoxIndex].nNumber) > High(LongWord) then
          dwInt := High(LongWord) - m_Abil.Exp
        else
          dwInt := LongWord(m_aBoxItems[m_nBoxIndex].nNumber);
        GetExp(dwInt, True, False);
      end
      else if CompareText(m_aBoxItems[m_nBoxIndex].sName, '½ð¸ÕÊ¯') = 0 then
      begin
        m_nGameDiamond := m_nGameDiamond + m_aBoxItems[m_nBoxIndex].nNumber;
        SendDefMessage(SM_REFDIAMOND, m_nGameDiamond, m_nGameGird, 0, 0, '');
      end
      else
      begin
        nItemCount := m_aBoxItems[m_nBoxIndex].nNumber;
        for i := 0 to nItemCount - 1 do
        begin
          if IsEnoughBag then
          begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(m_aBoxItems[m_nBoxIndex].sName, UserItem) then
            begin
              m_ItemList.Add((UserItem));
              SendAddItem(UserItem);
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLogAPI('8'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '±¦Ïä»ñÈ¡');
            end
            else
              Dispose(UserItem);
          end
          else
          begin
            New(UserItem);
            if UserEngine.CopyToUserItemFromName(m_aBoxItems[m_nBoxIndex].sName, UserItem) then
            begin
              if DropItemDown(UserItem, 3, False, Self, nil) then
              begin
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLogAPI('8'#9 + m_sMapName + #9 + IntToStr(m_nCurrX) + #9 + IntToStr(m_nCurrY) + #9 + m_sCharName + #9 + StdItem.Name + #9 + IntToStr(UserItem.MakeIndex) + #9 + BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 + '±¦Ïä»ñÈ¡');
              end;
            end;
            Dispose(UserItem); //memory leak
          end;
        end;
      end;
      m_nBoxIndex := 9;
    end;
  end
  else
    SendDefMessage(SM_CLOSEBOX, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientTrainSkill(idx, mid: Integer);
var
  i, ii: Integer;
  UserItem: pTUserItem;
  pStdItem: pTStdItem;
begin
  {if not (mid in [6, 7, 10..12, 14, 15, 17, 23, 25]) then begin
    SendDefMessage(SM_TRAINSKILL, -6, 0, 0, 0, '');
    Exit;
  end;}

  if m_MagicArr[0][mid] <> nil then
  begin
    if not (m_MagicArr[0][mid].btLevel in [3..14]) then
    begin
      SendDefMessage(SM_TRAINSKILL, -8, 0, 0, 0, '');
      Exit;
    end;
  end
  else
  begin
    SendDefMessage(SM_TRAINSKILL, -7, 0, 0, 0, '');
    Exit;
  end;

  ii := -1;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = idx then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if TPlayObject(Self).IsOnSaleItem(UserItem.MakeIndex) then
        begin
          SendDefMessage(SM_TRAINSKILL, -1, 0, 0, 0, '');
          Exit;
        end;
      end;
      ii := i;
      Break;
    end;
  end;
  if ii >= 0 then
  begin
    UserItem := m_ItemList.Items[ii];
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem <> nil then
    begin
      if (pStdItem.StdMode = 2) and (pStdItem.Shape = 12) then
      begin
        if UserItem.Dura = UserItem.DuraMax then
        begin
          if UserItem.btValue[0] > 0 then
          begin
            if m_MagicArr[0][mid].MagicInfo.TrainLevel[m_MagicArr[0][mid].btLevel] <= m_Abil.Level then
            begin
              Inc(m_MagicArr[0][mid].nTranPoint, UserItem.Dura);
              DelBagItem(ii, True, 'ÐÞÁ¶¼¼ÄÜ');
              //¼ÇÂ¼ÎïÆ·
              SendDefMessage(SM_TRAINSKILL, 0, 0, 0, 0, '');

              if not CheckMagicLevelup(m_MagicArr[0][mid], True) then
              begin
                SendDelayMsg(Self,
                  RM_MAGIC_LVEXP,
                  m_MagicArr[0][mid].MagicInfo.btClass,
                  m_MagicArr[0][mid].MagicInfo.wMagicId,
                  m_MagicArr[0][mid].btLevel,
                  m_MagicArr[0][mid].nTranPoint,
                  '', 10);
              end;
            end
            else
              SendDefMessage(SM_TRAINSKILL, -9, 0, 0, 0, '');
          end
          else
            SendDefMessage(SM_TRAINSKILL, -5, 0, 0, 0, '');
        end
        else
          SendDefMessage(SM_TRAINSKILL, -4, 0, 0, 0, '');
      end
      else
        SendDefMessage(SM_TRAINSKILL, -3, 0, 0, 0, '');
    end
    else
      SendDefMessage(SM_TRAINSKILL, -2, 0, 0, 0, '');
  end
  else
    SendDefMessage(SM_TRAINSKILL, -1, 0, 0, 0, '');
end;

procedure TPlayObject.ClientRefineItem(sBody: string);
type
  TCrystalOperate = (tDelete, tDecDura);
  TRefineStutas = (tRefineOK, tRefineFial);
resourcestring
  sClientRefineItemsError = '[ÌáÊ¾] ´ãÁ¶ÎïÆ·ÓÐÎó£¬²»ÄÜ¼ÌÐø£¡';
  sRefineItemsListError = '[ÌáÊ¾] ´ãÁ¶ÎïÆ·ÅäÖÃ´íÎó£¬²»ÄÜ¼ÌÐø£¡';
  sRefineItemsListNotFound = '[ÌáÊ¾] ²»ÄÜ´ãÁ¶µ±Ç°µÄÎïÆ·£¡';
  sCrystalDuraNotEnough = '[ÌáÊ¾] %s³Ö¾Ã²»×ã£¡';
  sRefineItemsOK = '¹§Ï²£¬´ãÁ¶%s³É¹¦£¬¹²Ôö¼Ó%dµãÊôÐÔ£¡';
  sRefineItemsFail = '´ãÁ¶%sÊ§°Ü£¡';
  sRefineItemsRevert = '´ãÁ¶%s³É¹¦£¬Î´¸½¼ÓÊôÐÔ£¡';

  function DeleteReUserItem(RT: pTRefineItem; CRTS: TClientRefineItems; CrystalOperate: TCrystalOperate; RefineStutas: TRefineStutas; boRefine: Boolean): Integer;
  var
    i, ii: Integer;
    UserItem, ReUserItem: pTUserItem;
  begin
    Result := 0;
    ReUserItem := nil;
    for ii := Low(TClientRefineItems) to High(TClientRefineItems) do
    begin
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[i];
        if UserItem.MakeIndex = CRTS[ii].nMakeIndex then
        begin
          case RefineStutas of
            tRefineOK:
              begin
                if RT.sUpItemName <> CRTS[ii].sItemName then
                begin
                  if ((CRTS[ii].sItemName = g_sCrystal) or (CRTS[ii].sItemName = g_sCrystalScrap)) and (CrystalOperate = tDecDura) then
                  begin
                    Dec(UserItem.Dura, 100);
                    SendAddItem(UserItem, 0);
                  end
                  else
                  begin
                    //Dispose(UserItem);
                    //m_ItemList.Delete(i);
                    DelBagItem(i, False, '´ãÁ¶ÏûºÄ');
                  end;
                end
                else
                  ReUserItem := UserItem;
              end;
            tRefineFial:
              begin
                if ((CRTS[ii].sItemName = g_sCrystal) or (CRTS[ii].sItemName = g_sCrystalScrap)) and (CrystalOperate = tDecDura) then
                begin
                  Dec(UserItem.Dura, 100);
                  SendAddItem(UserItem, 0);
                end
                else
                begin
                  //Dispose(UserItem);
                  //m_ItemList.Delete(i);
                  DelBagItem(i, False, '´ãÁ¶ÏûºÄ');
                end;
              end;
          end;
        end;
      end;
    end;
    if RefineStutas = tRefineOK then
    begin
      if ReUserItem <> nil then
      begin
        FillChar(ReUserItem.btValue, SizeOf(ReUserItem.btValue), #0);
        if boRefine then
          UserEngine.RandomRefineItem(ReUserItem, RT.RamAddValue);
        for i := Low(ReUserItem.btValue) to High(ReUserItem.btValue) do
          Result := Result + ReUserItem.btValue[i];
        SendAddItem(ReUserItem, 0);
      end
      else
      begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(RT.sUpItemName, UserItem) then
        begin
          if boRefine then
            UserEngine.RandomRefineItem(UserItem, RT.RamAddValue);
          for i := Low(UserItem.btValue) to High(UserItem.btValue) do
            Result := Result + UserItem.btValue[i];
          m_ItemList.Add(UserItem);
          SendAddItem(UserItem, 0);
        end
        else
          Dispose(UserItem);
      end;
    end;
  end;

var
  i, ii, nCheckOK: Integer;
  RefineList: TList;
  UserItem: pTUserItem;
  RefineItem: pTRefineItem;
  CRefineItems: TClientRefineItems;
label
  lSendAddAllItem;
begin
  if m_StallMgr.OnSale then
    Exit;
  if m_boDealing or ((GetTickCount - m_DealLastTick) <= g_Config.dwTryDealTime) then
    Exit;
  FillChar(CRefineItems, SizeOf(TClientRefineItems), #0);
  DecodeBuffer(sBody, @CRefineItems, SizeOf(TClientRefineItems));
  nCheckOK := 0;
  for ii := Low(TClientRefineItems) to High(TClientRefineItems) do
  begin
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem.MakeIndex = CRefineItems[ii].nMakeIndex) and (UserEngine.GetStdItemName(UserItem.wIndex) = CRefineItems[ii].sItemName) then
      begin
        Inc(nCheckOK);
        Break;
      end;
    end;
  end;
  if nCheckOK = 3 then
  begin
    RefineList := GetRefineItemList(CRefineItems[0].sItemName, CRefineItems[1].sItemName, CRefineItems[2].sItemName);
    if RefineList = nil then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sRefineItemsListNotFound);
      goto lSendAddAllItem;
    end;
    if RefineList.Count >= 2 then
      RefineItem := RefineList.Items[Random(RefineList.Count)]
    else
      RefineItem := RefineList.First;

    if not RefineItem.bDelCrystal then
    begin
      for ii := Low(TClientRefineItems) to High(TClientRefineItems) do
      begin
        for i := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList.Items[i];
          if UserItem.MakeIndex = CRefineItems[ii].nMakeIndex then
          begin
            if (CRefineItems[ii].sItemName = g_sCrystal) or (CRefineItems[ii].sItemName = g_sCrystalScrap) then
            begin
              if UserItem.Dura < 100 then
              begin
                SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format(sCrystalDuraNotEnough, [CRefineItems[ii].sItemName]));
                goto lSendAddAllItem;
              end;
            end;
          end;
        end;
      end;
      if RefineItem.nSucessRate >= (Random(100) + 1) then
      begin
        nCheckOK := DeleteReUserItem(RefineItem, CRefineItems, tDecDura, tRefineOK, True);
        if nCheckOK > 0 then
          SysMsg(Format(sRefineItemsOK, [RefineItem.sUpItemName, nCheckOK]), c_Blue, t_Hint)
        else
          SysMsg(Format(sRefineItemsRevert, [RefineItem.sUpItemName]), c_Blue, t_Hint);
      end
      else if RefineItem.nRevertRate >= (Random(100) + 1) then
      begin
        DeleteReUserItem(RefineItem, CRefineItems, tDecDura, tRefineOK, False);
        SysMsg(Format(sRefineItemsRevert, [RefineItem.sUpItemName]), c_Blue, t_Hint);
      end
      else
      begin
        DeleteReUserItem(RefineItem, CRefineItems, tDecDura, tRefineFial, False);
        SysMsg(Format(sRefineItemsFail, [RefineItem.sUpItemName]), c_Red, t_Hint);
      end;
    end
    else
    begin
      if RefineItem.nSucessRate >= (Random(100) + 1) then
      begin
        nCheckOK := DeleteReUserItem(RefineItem, CRefineItems, tDelete, tRefineOK, True);
        if nCheckOK > 0 then
          SysMsg(Format(sRefineItemsOK, [RefineItem.sUpItemName, nCheckOK]), c_Blue, t_Hint)
        else
          SysMsg(Format(sRefineItemsRevert, [RefineItem.sUpItemName]), c_Blue, t_Hint);
      end
      else if RefineItem.nRevertRate >= (Random(100) + 1) then
      begin
        DeleteReUserItem(RefineItem, CRefineItems, tDelete, tRefineOK, False);
        SysMsg(Format(sRefineItemsRevert, [RefineItem.sUpItemName]), c_Blue, t_Hint);
      end
      else
      begin
        DeleteReUserItem(RefineItem, CRefineItems, tDelete, tRefineFial, False);
        SysMsg(Format(sRefineItemsFail, [RefineItem.sUpItemName]), c_Red, t_Hint);
      end;
    end;
  end
  else
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sClientRefineItemsError);
    lSendAddAllItem:
    for ii := Low(TClientRefineItems) to High(TClientRefineItems) do
    begin
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[i];
        if (UserItem.MakeIndex = CRefineItems[ii].nMakeIndex) and (UserEngine.GetStdItem(UserItem.wIndex) <> nil) then
          SendAddItem(UserItem, 0);
      end;
    end;
  end;
end;

procedure TPlayObject.ClientQueryLevelRank(nType, nPage: Integer);
begin
  if not g_Config.boOpenLevelRankSystem then
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[ÌáÊ¾]£ºÅÅÐÐÏµÍ³Î´¿ª·Å')
  else
  begin
    {if nPage <> High(word) then begin
      if nPage > 199 then nPage := 199;
      if nPage < 0 then nPage := 0;
    end;}
    FrontEngine.AddLevelRankToLoadList(nType, nPage, m_sCharName);
  end;
end;

procedure TPlayObject.ServerGetMarketList(MarketNpc: TBaseObject; page_: Integer; Body: string);
var
  ItemName_: string;
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;

  case page_ of
    0: RequireLoadRefresh;
    1: SendUserMarketList(page_);
    2:
      begin
        ItemName_ := Body;
        //ÊÇ·ñÄ£ºýËÑË÷
        if (ItemName_ <> '') and (UserEngine.GetStdItemIdx(ItemName_) <> -1) then
          RequireLoadUserMarket(GetMarketName, USERMARKET_TYPE_ITEMNAME, 1, '', ItemName_)
        else
          SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
      end;
  end;
end;

procedure TPlayObject.ServerGetMarketSell(MarketNpc: TBaseObject; Count_: Integer; MakeIndex_: Integer; Body: string);
var
  buffer1, buffer2: string;
  money: Integer;
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;
  buffer1 := Body;
  buffer1 := GetValidStr3(buffer1, buffer2, ['/']);
  money := Str_ToInt(buffer2, 0);
  RequireSellUserMarket(MakeIndex_, Count_, money);
end;

procedure TPlayObject.ServerGetMarketBuy(MarketNpc: TBaseObject; SellIndex_: Integer);
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;
  RequireBuyUserMarket(MarketNpc, SellIndex_);
end;

procedure TPlayObject.ServerGetMarketCancel(MarketNpc: TBaseObject; SellIndex_: Integer);
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;
  RequireCancelUserMarket(MarketNpc, SellIndex_);
end;

procedure TPlayObject.ServerGetMarketGetPay(MarketNpc: TBaseObject; SellIndex_: Integer);
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;
  RequireGetPayUserMarket(MarketNpc, SellIndex_);
end;

procedure TPlayObject.ServerGetMarketClose;
begin
  m_UserMarket.Clear;
{$IFDEF DEBUG}
  //MainOutMessage('MarketClear :' + UserName);
{$ENDIF}
end;

procedure TPlayObject.SendUserMarketCloseMsg;
begin
  SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_MarketNotReady, 0, '');
end;

procedure TPlayObject.RequireLoadRefresh;
begin
  if not g_SQlEngine.RequestLoadPageUserMarket(m_UserMarket.ReqInfo) then
    SendUserMarketCloseMsg;
end;

procedure TPlayObject.RequireLoadUserMarket(MarketName: string; ItemType: Integer; UserMode: Integer; OtherName: string; ItemName_: string);
var
  IsOK: Boolean;
begin

  m_UserMarket.ReqInfo.UserName := m_sCharName;
  m_UserMarket.ReqInfo.MarketName := MarketName;
  m_UserMarket.ReqInfo.SearchWho := OtherName;
  m_UserMarket.ReqInfo.SearchItem := ItemName_;
  m_UserMarket.ReqInfo.ItemType := ItemType;
  m_UserMarket.ReqInfo.ItemSet := 0;
  m_UserMarket.ReqInfo.UserMode := UserMode;

  IsOK := False;

  case ItemType of
    USERMARKET_TYPE_ALL,
      USERMARKET_TYPE_WEAPON,
      USERMARKET_TYPE_NECKLACE,
      USERMARKET_TYPE_RING,
      USERMARKET_TYPE_BRACELET,
      USERMARKET_TYPE_CHARM,
      USERMARKET_TYPE_HELMET,
      USERMARKET_TYPE_BELT,
      USERMARKET_TYPE_SHOES,
      USERMARKET_TYPE_ARMOR,
      USERMARKET_TYPE_DRINK,
      USERMARKET_TYPE_JEWEL,
      USERMARKET_TYPE_BOOK,
      USERMARKET_TYPE_MINERAL,
      USERMARKET_TYPE_QUEST,
      USERMARKET_TYPE_ETC,
      USERMARKET_TYPE_OTHER,
      USERMARKET_TYPE_ITEMNAME:
      begin
        IsOK := True;
      end;
    USERMARKET_TYPE_SET:
      begin
        m_UserMarket.ReqInfo.ItemSet := 1;
        IsOK := True;
      end;
    USERMARKET_TYPE_MINE:
      begin
        m_UserMarket.ReqInfo.SearchWho := m_sCharName;
        IsOK := True;
      end;
  end;
  if IsOK then
  begin
    if not g_SQlEngine.RequestLoadPageUserMarket(m_UserMarket.ReqInfo) then
      SendUserMarketCloseMsg;
  end;
end;

function TPlayObject.IsExistBagItem(MakeIndex_: Integer): pTUserItem;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    if pTUserItem(m_ItemList[i]).MakeIndex = MakeIndex_ then
    begin
      Result := m_ItemList[i];
      Exit;
    end;
  end;
end;

function TPlayObject.IsFullBagCount: Boolean;
begin
  Result := True;
  if m_ItemList.Count < GetMaxBagItem then
    Result := False;
end;

function TPlayObject.IsEnableUseMarket: Boolean;
begin
  Result := False;
  if m_boFlagUserMarket then
    Exit;

  if m_MarketNpc <> nil then
  begin
    if m_PEnvir <> m_MarketNpc.m_PEnvir then
      Exit;
    if not ((abs(m_nCurrX - m_MarketNpc.m_nCurrX) <= 8) and (abs(m_nCurrY - m_MarketNpc.m_nCurrY) <= 8)) then
      Exit;
  end
  else
    Exit;

  if m_Abil.Level >= MARKET_ALLOW_LEVEL then
    Result := True
  else
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_LessLevel, 0, '');
end;

function TPlayObject.DeleteFromBagItem(MakeIndex_: Integer; SellCount_: Integer): Boolean;
var
  i: Integer;
  pstd: pTStdItem;
  ui: pTUserItem;
begin
  Result := False;
  for i := m_ItemList.Count - 1 downto 0 do
  begin
    ui := pTUserItem(m_ItemList[i]);
    begin
      pstd := UserEngine.GetStdItem(ui.wIndex);
      if (pstd.Overlap >= 1) then
      begin
        if ui.Dura > SellCount_ then
        begin
          ui.Dura := ui.Dura - SellCount_; //bug 0920
          SendMsg(Self, RM_COUNTERITEMCHANGE, 0, ui.MakeIndex, ui.Dura, 0, pstd.Name);
          WeightChanged;
          Result := True;
        end
        else if (ui.Dura = SellCount_) then
        begin
          SendDelItems(ui);
          Dispose(ui);
          m_ItemList.Delete(i);
          WeightChanged;
          Result := True;
        end;
      end
      else
      begin
        SendDelItems(ui);
        Dispose(ui);
        m_ItemList.Delete(i);
        WeightChanged;
        Result := True;
      end;
      Exit;
    end;
  end;
end;

function TPlayObject.GetMarketName: string;
begin
  if m_MarketNpc <> nil then
    Result := g_Config.sServerName + '_' + m_MarketNpc.m_sCharName
  else
    Result := g_Config.sServerName + '_' + 'NO_NPC';
end;

function TPlayObject.AddToBagItem(UserItem_: TUserItem): Boolean;
var
  pu: pTUserItem;
begin
  Result := False;
  if not IsFullBagCount then
  begin
    New(pu);
    pu^ := UserItem_;
    Result := AddItemToBag(pu);
    if Result then
    begin
      //WeightChanged;
      SendAddItem(pu);
    end
    else
      Dispose(pu);
  end;
end;

procedure TPlayObject.SendUserMarketSellReady(MarketNpc: TBaseObject);
begin
  if MarketNpc <> nil then
    m_MarketNpc := MarketNpc;

  if not IsEnableUseMarket then
    Exit;

  if not g_SQlEngine.RequestReadyToSellUserMarket(m_sCharName, GetMarketName, m_sCharName) then
    SendUserMarketCloseMsg;
end;

procedure TPlayObject.RequireSellUserMarket(
  MakeIndex_: Integer;
  SellCount_: Integer;
  SellPrice_: Integer);
var
  pInfo: PTMarketLoad;
  pUserItem: pTUserItem;
  ps: pTStdItem;
begin
  if not IsEnableUseMarket then
    Exit;

  if (SellPrice_ < MARKET_CHARGE_MONEY) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_LessTrustMoney, 0, '');
    Exit;
  end;

  if SellPrice_ > MARKET_MAX_TRUST_MONEY then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_MaxTrustMoney, 0, '');
    Exit;
  end;

  if m_nGold < MARKET_CHARGE_MONEY then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_LessMoney, 0, '');
    Exit;
  end;

  pUserItem := IsExistBagItem(MakeIndex_);
  if nil = pUserItem then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
    Exit;
  end;

  ps := UserEngine.GetStdItem(pUserItem.wIndex);
  if ps = nil then
    Exit;

  if (PCardinal(@pUserItem.btValue[22])^ > 0) and (PCardinal(@pUserItem.btValue[22])^ <> m_dwIdCRC) then
  begin
    if g_Config.boBindNoSell then
    begin
      SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
      Exit;
    end;
  end;

  if InLimitItemList('', pUserItem.wIndex, t_dps) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
    Exit;
  end;

  if InLimitItemList('', pUserItem.wIndex, t_dSell) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
    Exit;
  end;

  if ps.Overlap >= 1 then
  begin
    if (pUserItem.Dura < SellCount_) or (SellCount_ <= 0) then
    begin
      SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_DontSell, 0, '');
      Exit;
    end;
  end
  else
    SellCount_ := 0;

  New(pInfo);
  pInfo.UserItem := pUserItem^;
  pInfo.SellPrice := SellPrice_;
  pInfo.MarketName := GetMarketName;
  pInfo.ItemName := ps.Name;
  pInfo.MarketType := ps.ItemType;
  pInfo.Index := 0;
  pInfo.SetType := ps.ItemSet;
  pInfo.SellWho := Self.m_sCharName;
  pInfo.SellCount := SellCount_;

  if (ps.Overlap >= 1) and (SellCount_ > 0) then
    pInfo.UserItem.Dura := SellCount_;

  if not g_SQlEngine.RequestSellItemUserMarket(Self.m_sCharName, pInfo) then
  begin
    SendUserMarketCloseMsg;
    m_boFlagUserMarket := False;
    Exit;
  end;

  m_boFlagUserMarket := True;
end;

procedure TPlayObject.RequireBuyUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);
var
  rMoney: Integer;
begin
  if not IsEnableUseMarket then
    Exit;

  if not m_UserMarket.IsExistIndex(SellIndex_, rMoney) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
    Exit;
  end;

  if m_nGold < (rMoney) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_LessMoney, 0, '');
    Exit;
  end;

  if IsFullBagCount then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_MaxBagItemCount, 0, '');
    Exit;
  end;

  if m_UserMarket.IsMyItem(SellIndex_, Self.m_sCharName) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_DontBuy, 0, '');
    Exit;
  end;

  if not g_SQlEngine.RequestBuyItemUserMarket(Self.m_sCharName, GetMarketName, Self.m_sCharName, SellIndex_) then
  begin
    SendUserMarketCloseMsg;
    m_boFlagUserMarket := False;
    Exit;
  end;

  m_boFlagUserMarket := True;
end;

procedure TPlayObject.RequireCancelUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);
begin
  if not IsEnableUseMarket then
    Exit;

  if not m_UserMarket.IsMyItem(SellIndex_, Self.m_sCharName) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_CancelFail, 0, '');
    Exit;
  end;

  if IsFullBagCount then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_MaxBagItemCount, 0, '');
    Exit;
  end;

  if not g_SQlEngine.RequestCancelSellUserMarket(Self.m_sCharName, GetMarketName, Self.m_sCharName, SellIndex_) then
  begin
    SendUserMarketCloseMsg;
    m_boFlagUserMarket := False;
    Exit;
  end;

  m_boFlagUserMarket := True;
end;

procedure TPlayObject.RequireGetPayUserMarket(MarketNpc: TBaseObject; SellIndex_: Integer);
var
  rMoney: Integer;
begin
  if not IsEnableUseMarket then
    Exit;

  if not m_UserMarket.IsMyItem(SellIndex_, Self.m_sCharName) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_CancelFail, 0, '');
    Exit;
  end;

  if not m_UserMarket.IsExistIndex(SellIndex_, rMoney) then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_NoItem, 0, '');
    Exit;
  end;

  if m_nGold + rMoney > m_nGoldMax then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_OverMoney, 0, '');
    Exit;
  end;

  if not g_SQlEngine.RequestGetPayUserMarket(Self.m_sCharName, GetMarketName, Self.m_sCharName, SellIndex_) then
  begin
    SendUserMarketCloseMsg;
    m_boFlagUserMarket := False;
    Exit;
  end;

  m_boFlagUserMarket := True;
end;

procedure TPlayObject.GetMarketData(pInfo: PTSearchSellItem);
var
  pMarketInfo: PTMarketItem;
  pDbInfo: PTMarketLoad;
  i: Integer;
  ps: pTStdItem;
  std: TStdItem;
begin
  if pInfo.IsOK <> UMRESULT_SUCCESS then
    Exit;
  if pInfo.pList <> nil then
  begin
    m_UserMarket.Clear;
    m_UserMarket.UserMode := pInfo.UserMode;
    m_UserMarket.ItemType := pInfo.ItemType;
    for i := 0 to pInfo.pList.Count - 1 do
    begin
      pDbInfo := pInfo.pList.Items[i];
      if pDbInfo <> nil then
      begin
        ps := UserEngine.GetStdItem(pDbInfo.UserItem.wIndex);
        if ps <> nil then
        begin
          New(pMarketInfo);
          std := ps^;
          ItemUnit.GetItemAddValue(@pDbInfo.UserItem, std);
          pMarketInfo.UpgCount := 0; //ItemMan.GetUpgradeStdItem(pDbInfo.UserItem, std);
          Move(std, pMarketInfo.item.s, SizeOf(TClientStdItem));

          pMarketInfo.item.MakeIndex := pDbInfo.UserItem.MakeIndex;
          pMarketInfo.item.Dura := pDbInfo.UserItem.Dura;
          pMarketInfo.item.DuraMax := pDbInfo.UserItem.DuraMax;

          pMarketInfo.item.s.ItemType := pDbInfo.UserItem.btValue[14];
          GetSendClientItem(@pDbInfo.UserItem, Self, pMarketInfo.item);

          pMarketInfo.Index := pDbInfo.Index;
          pMarketInfo.SellPrice := pDbInfo.SellPrice;
          pMarketInfo.SellDate := pDbInfo.SellDate;
          pMarketInfo.SellState := pDbInfo.SellState;
          pMarketInfo.SellWho := pDbInfo.SellWho;

          m_UserMarket.Add(pMarketInfo);
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.SendUserMarketList(NextPage: Integer);
var
  marketitem: PTMarketItem;
  i, Cnt: Integer;
  Buffer: string;
  cnt_start: Integer;
  cnt_end: Integer;
  bFirstSend: Integer;
  page: Integer;
  maxpage: Integer;
begin
  Buffer := '';
  Cnt := 0;
  page := 0;

  if NextPage = 0 then
  begin
    bFirstSend := 1;
    page := 1;
  end
  else
  begin
    bFirstSend := 0;
  end;

  if (NextPage = 1) then
    page := m_UserMarket.CurrPage + 1;

  m_UserMarket.CurrPage := page;
  maxpage := m_UserMarket.PageCount;
  cnt_start := (page - 1) * MAKET_ITEMCOUNT_PER_PAGE;
  cnt_end := cnt_start + MAKET_ITEMCOUNT_PER_PAGE - 1;

  if cnt_end >= m_UserMarket.Count then
    cnt_end := m_UserMarket.Count - 1;

  for i := cnt_start to cnt_end do
  begin
    marketitem := m_UserMarket.GetItem(i);

    if marketitem <> nil then
    begin
{$IFDEF DEBUG}
      MainOutMessage('LIST :' + marketitem.SellWho + ',' + marketitem.item.s.Name);
{$ENDIF}
      Inc(Cnt);
      Buffer := Buffer + EncodeBuffer(Pointer(marketitem), SizeOf(TMarketItem)) + '/';
    end;
  end;
  Buffer := IntToStr(Cnt) + '/' + IntToStr(page) + '/' + IntToStr(maxpage) + '/' + Buffer;
  SendMsg(Self, RM_MARKET_LIST, 0, m_UserMarket.UserMode, m_UserMarket.ItemType, bFirstSend, Buffer);
end;

procedure TPlayObject.SellUserMarket(pSellItem: PTMarketLoad);
var
  _makeindex: Integer;
  _SellCount: Integer;
  countstr: string;
begin
  countstr := '';
  if pSellItem.IsOK <> UMRESULT_SUCCESS then
    Exit;

  _makeindex := pSellItem.UserItem.MakeIndex;
  _SellCount := pSellItem.SellCount;

  if not m_boFlagReadyToSellCheck then
  begin
    g_SQlEngine.CheckToDB(m_sCharName,
      pSellItem.MarketName,
      pSellItem.SellWho,
      _makeindex,
      0,
      MARKET_CHECKTYPE_SELLFAIL);

    AddGameDataLogAPI('10'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pSellItem.ItemName + ''#9 +
      IntToStr(_makeindex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡');
    Exit;
  end;

  if DeleteFromBagItem(_makeindex, _SellCount) then
  begin
    countstr := '(' + IntToStr(_SellCount) + ')';
    DecGold(MARKET_CHARGE_MONEY);
    GoldChanged;

    g_SQlEngine.CheckToDB(m_sCharName, pSellItem.MarketName, pSellItem.SellWho, _makeindex, 0, MARKET_CHECKTYPE_SELLOK);

    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_SellOK, 0, '');

    AddGameDataLogAPI('10'#9 +
      m_sMapName + ''#9 +
      IntToStr(MARKET_CHARGE_MONEY) + ''#9 +
      IntToStr(m_nGold) + ''#9 +
      m_sCharName + ''#9 +
      pSellItem.ItemName + ''#9 +
      IntToStr(_makeindex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡' + countstr);

  end
  else
  begin
    g_SQlEngine.CheckToDB(m_sCharName, pSellItem.MarketName, pSellItem.SellWho, _makeindex, 0, MARKET_CHECKTYPE_SELLFAIL);

    AddGameDataLogAPI('10'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pSellItem.ItemName + ''#9 +
      IntToStr(_makeindex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡');

  end;

  m_boFlagUserMarket := False;
  m_boFlagReadyToSellCheck := False;
end;

procedure TPlayObject.ReadyToSellUserMarket(pReadyItem: PTMarketLoad);
begin
  if pReadyItem.IsOK <> UMRESULT_SUCCESS then
    Exit;

  if pReadyItem.SellCount < MARKET_MAX_SELL_COUNT then
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, Integer(m_MarketNpc), UMResult_ReadyToSell, 0, '');
  end
  else
  begin
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_OverSellCount, 0, '');
  end;
  m_boFlagReadyToSellCheck := True;
end;

procedure TPlayObject.BuyUserMarket(pBuyItem: PTMarketLoad);
var
  pu: pTUserItem;
  ps: pTStdItem;
  countstr: string;
begin
  countstr := '';
  pu := nil;
  ps := nil;

  if (pBuyItem.IsOK <> UMRESULT_SUCCESS) or (m_nGold < pBuyItem.SellPrice) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '¹ºÂòÎïÆ·Ê§°Ü.');
    Exit;
  end;

  if AddToBagItem(pBuyItem.UserItem) then
  begin
    ps := UserEngine.GetStdItem(pBuyItem.UserItem.wIndex);
    if ps <> nil then
      countstr := '(' + IntToStr(pBuyItem.UserItem.Dura) + ')';

    DecGold(pBuyItem.SellPrice);
    GoldChanged;

    g_SQlEngine.CheckToDB(m_sCharName, pBuyItem.MarketName, m_sCharName, 0, pBuyItem.Index, MARKET_CHECKTYPE_BUYOK);

    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_BuyOK, 0, '');

    RequireLoadRefresh;

    AddGameDataLogAPI('9'#9 +
      m_sMapName + ''#9 +
      IntToStr(pBuyItem.SellPrice) + ''#9 +
      IntToStr(m_nGold) + ''#9 +
      m_sCharName + ''#9 +
      pBuyItem.ItemName + ''#9 +
      IntToStr(pBuyItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡' + countstr);

  end
  else
  begin
    if pu <> nil then
      Dispose(pu);

    g_SQlEngine.CheckToDB(m_sCharName, pBuyItem.MarketName, pBuyItem.SellWho, 0, pBuyItem.Index, MARKET_CHECKTYPE_BUYFAIL);

    AddGameDataLogAPI('9'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pBuyItem.ItemName + ''#9 +
      IntToStr(pBuyItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡');

  end;

  m_boFlagUserMarket := False;
end;

procedure TPlayObject.CancelUserMarket(pCancelItem: PTMarketLoad);
begin
  if pCancelItem.IsOK <> UMRESULT_SUCCESS then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, 'È¡Ïû¼ÄÊÛÎïÆ·Ê§°Ü.');
    Exit;
  end;

  if AddToBagItem(pCancelItem.UserItem) then
  begin

    g_SQlEngine.CheckToDB(m_sCharName, pCancelItem.MarketName, pCancelItem.SellWho, 0, pCancelItem.Index, MARKET_CHECKTYPE_CANCELOK);
    RequireLoadRefresh;

    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_CancelOK, 0, '');

    AddGameDataLogAPI('8'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pCancelItem.ItemName + ''#9 +
      IntToStr(pCancelItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡È¡Ïû³É¹¦');

  end
  else
  begin

    g_SQlEngine.CheckToDB(m_sCharName, pCancelItem.MarketName, pCancelItem.SellWho, 0, pCancelItem.Index, MARKET_CHECKTYPE_CANCELFAIL);

    AddGameDataLogAPI('8'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pCancelItem.ItemName + ''#9 +
      IntToStr(pCancelItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡È¡ÏûÊ§°Ü');

  end;

  m_boFlagUserMarket := False;
end;

procedure TPlayObject.GetPayUserMarket(pGetpayItem: PTMarketLoad);
var
  commision: Integer;
begin
  if pGetpayItem.IsOK <> UMRESULT_SUCCESS then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, 'È¡»ØÊÛ½ðÊ§°Ü.');
    Exit;
  end;

  if (pGetpayItem.SellPrice >= 0) then
  begin

    commision := pGetpayItem.SellPrice * MARKET_COMMISION div 1000;
    IncGold(pGetpayItem.SellPrice);
    DecGold(commision);
    GoldChanged;
    g_SQlEngine.CheckToDB(m_sCharName, pGetpayItem.MarketName, pGetpayItem.SellWho, 0, pGetpayItem.Index, MARKET_CHECKTYPE_GETPAYOK);
    RequireLoadRefresh;
    SendMsg(Self, RM_MARKET_RESULT, 0, 0, UMResult_GetPayOK, 0, '');
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '×ÜÊÛ½ð ' + IntToStr(pGetpayItem.SellPrice) + ' ÊÖÐø·Ñ ' + IntToStr(commision) + '.');
    AddGameDataLogAPI('8'#9 +
      m_sMapName + ''#9 +
      IntToStr(pGetpayItem.SellPrice - commision) + ''#9 +
      IntToStr(m_nGold) + ''#9 +
      m_sCharName + ''#9 +
      pGetpayItem.ItemName + ''#9 +
      IntToStr(pGetpayItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡³öÊÛ»ñµÃ');

  end
  else
  begin

    g_SQlEngine.CheckToDB(m_sCharName, pGetpayItem.MarketName, pGetpayItem.SellWho, 0, pGetpayItem.Index, MARKET_CHECKTYPE_GETPAYFAIL);

    AddGameDataLogAPI('8'#9 +
      m_sMapName + ''#9 +
      IntToStr(0) + ''#9 +
      IntToStr(0) + ''#9 +
      m_sCharName + ''#9 +
      pGetpayItem.ItemName + ''#9 +
      IntToStr(pGetpayItem.UserItem.MakeIndex) + ''#9 +
      '1'#9 +
      '½»Ò×ÊÐ³¡³öÊÛ»ñµÃ');

  end;

  m_boFlagUserMarket := False;
end;

procedure TPlayObject.ClientMerchantItemDlgSelect(nParam1, nParam2, nParam3: Integer);
var
  i, nTemp: Integer;
  Npc: TNormNpc;
  UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  m_nDlgItemIndex := 0;
  if m_StallMgr.OnSale then
    Exit;
  if not m_boDeath and not m_boGhost then
  begin

    if nParam1 = 0 then
      Exit;
    if TObject(nParam1) = m_LastNPC then
    begin
      Npc := TNormNpc(m_LastNPC);
    end
    else
    begin
      Npc := UserEngine.FindMerchant(TObject(nParam1));
      if Npc = nil then
        Npc := UserEngine.FindNPC(TObject(nParam1));
      if Npc <> nil then
        m_LastNPC := Npc;
    end;

    //NPC := UserEngine.FindMerchant(TObject(nParam1));
    //if NPC = nil then
    //  NPC := UserEngine.FindNPC(TObject(nParam1));
    if Npc = nil then
      Exit;

    if ((Npc.m_PEnvir = m_PEnvir) and (abs(Npc.m_nCurrX - m_nCurrX) < 15) and (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
    begin
      m_nDlgItemIndex := MakeLong(nParam2, nParam3);
      if m_boTakeDlgItem and (m_nDlgItemIndex > 0) then
      begin
        nTemp := 255;
        for i := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList.Items[i];
          if UserItem.MakeIndex = m_nDlgItemIndex then
          begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then
            begin
              if (StdItem.Overlap >= 1) then
              begin
                if UserItem.Dura >= 1 then
                begin
                  UserItem.Dura := UserItem.Dura - 1;
                  if UserItem.Dura = 0 then
                  begin
                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLogAPI('10' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        IntToStr(1) + #9 +
                        m_sCharName);
                    SendDelItems(UserItem);
                    Dispose(UserItem);
                    m_ItemList.Delete(i);
                  end
                  else
                  begin
                    SendMsg(Self, RM_COUNTERITEMCHANGE, 0, UserItem.MakeIndex, UserItem.Dura, 0, StdItem.Name);
                    nTemp := 0;
                  end;
                end
                else
                begin
                  if StdItem.NeedIdentify = 1 then
                    AddGameDataLogAPI('10' + #9 +
                      m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 +
                      IntToStr(m_nCurrY) + #9 +
                      m_sCharName + #9 +
                      StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +
                      IntToStr(1) + #9 +
                      m_sCharName);
                  SendDelItems(UserItem);
                  Dispose(UserItem);
                  m_ItemList.Delete(i);
                end;

              end
              else
              begin
                if StdItem.NeedIdentify = 1 then
                  AddGameDataLogAPI('10' + #9 +
                    m_sMapName + #9 +
                    IntToStr(m_nCurrX) + #9 +
                    IntToStr(m_nCurrY) + #9 +
                    m_sCharName + #9 +
                    StdItem.Name + #9 +
                    IntToStr(UserItem.MakeIndex) + #9 +
                    '1' + #9 +
                    m_sCharName);
                SendDelItems(UserItem);
                Dispose(UserItem);
                m_ItemList.Delete(i);
                m_nDlgItemIndex := 0;
              end;
            end;
            Break;
          end;
        end;
      end
      else
        nTemp := 0;

      SendDefMessage(SM_ITEMDLGSELECT, 1, nTemp, 0, 0, '');
      Npc.m_OprCount := 0;
      Npc.GotoLable(Self, m_sGotoNpcLabel, False);
      m_sGotoNpcLabel := '';
    end;
  end;
end;

procedure TPlayObject.ProcessQueryValue(Npc: Integer; sData: string);
var
  NormNpc: TNormNpc;
  sRefMsg: string;
resourcestring
  sIsInQVFilterListMsg = 'ÄãÊäÈëµÄÎÄ±¾ÖÐ°üº¬ÁË·Ç·¨×Ö·û£¬ÇëÖØÐÂ³öÈë';
begin
  if not m_boGhost and (m_sGotoNpcLabel <> '') then
  begin
    sRefMsg := DecodeString(sData);
    //if sRefMsg <> '' then begin
    if IsInGuildRankNameFilterList(sRefMsg) then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, sIsInQVFilterListMsg);
      Exit;
    end;
    case m_btValType of
      0: m_nSval[m_btValLabel] := sRefMsg;
      1: m_nMval[m_btValLabel] := Str_ToInt(sRefMsg, 0);
    end;
    case m_btValNPCType of
      0:
        begin
          NormNpc := UserEngine.FindMerchant(TObject(Npc));
          if NormNpc = nil then
            NormNpc := UserEngine.FindNPC(TObject(Npc));
          if NormNpc <> nil then
          begin
            if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then
              NormNpc.GotoLable(Self, m_sGotoNpcLabel, False);
          end;
        end;
      1: if g_FunctionNPC <> nil then
          g_FunctionNPC.GotoLable(Self, m_sGotoNpcLabel, False);
      2: if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, m_sGotoNpcLabel, False);
    end;
    //end;
    m_sGotoNpcLabel := '';
  end;
end;

function TPlayObject.GetMissionStep(sid: string): Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 0 to m_MissionList.Count - 1 do
  begin
    if CompareText(m_MissionList[i], sid) = 0 then
    begin
      Result := Integer(m_MissionList.Objects[i]);
      Break;
    end;
  end;
end;

function TPlayObject.DeleteMission(sid: string): Integer;
var
  i: Integer;
begin
  Result := -1;
  for i := 0 to m_MissionList.Count - 1 do
  begin
    if CompareText(m_MissionList[i], sid) = 0 then
    begin
      m_sCmdParams[1] := sid;
      m_sCmdParams[2] := IntToStr(Integer(m_MissionList.Objects[i]));
      m_MissionList.Delete(i);
      Result := i;
      Break;
    end;
  end;
end;

function TPlayObject.UpdateMission(sid: string; nstep: Integer): Integer;
var
  i, ns: Integer;
begin
  Result := 0;
  for i := 0 to m_MissionList.Count - 1 do
  begin
    if CompareText(m_MissionList[i], sid) = 0 then
    begin
      if nstep = 0 then
        ns := Integer(m_MissionList.Objects[i]) + 1
      else
        ns := nstep;
      m_MissionList.Objects[i] := TObject(ns);
      Result := ns;
      Break;
    end;
  end;
end;

{$IF SERIESSKILL}

function TPlayObject.GetSeriesSkillDamage(mid: Word; Pwr: Integer): Integer;
const
  s = 'ÄãµÄ%s³öÏÖ±¬»÷,Ôì³É¶îÍâÉËº¦';
var
  i: Integer;
begin
  Result := Pwr;
  for i := Low(m_SeriesSkillArr2) to High(m_SeriesSkillArr2) do
  begin
    if mid = m_SeriesSkillArr2[i].wMagicId then
    begin
      m_SeriesSkillArr2[i].wMagicId := 0;
      Randomize();
      if Random(100) < m_SeriesSkillArr2[i].wDamageRate then
      begin
        Result := Round(Pwr * 1.5);
        SysMsg(Format(s, [m_MagicArr[0][mid].MagicInfo.sMagicName]), c_Green, t_Hint);
        SendRefMsg(RM_STRUCKEFFECTEX, 0, 22, 0, 0, '');
      end;
      Break;
    end;
  end;
end;
{$IFEND SERIESSKILL}

procedure TPlayObject.ServerSendItemCountChanged(mindex, icount, increase: Integer; itmname: string);
begin
  if icount <= 0 then
    Exit;
  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_HEROCOUNTERITEMCHANGE, mindex, icount, increase, 0);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, EncodeString(itmname));
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_DefMsg := MakeDefaultMsg(SM_COUNTERITEMCHANGE, mindex, icount, increase, 0);
    SendSocket(@m_DefMsg, EncodeString(itmname));
  end;
end;

procedure TPlayObject.ServerSendItemCountChangedFail(mindex, icount: Integer);
begin
  if IsHero then
  begin
    TPlayObject(m_Master).m_DefMsg := MakeDefaultMsg(SM_ITEMSUMCOUNT_FAIL, mindex, icount, 0, 1);
    TPlayObject(m_Master).SendSocket(@TPlayObject(m_Master).m_DefMsg, '');
  end
  else if (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_DefMsg := MakeDefaultMsg(SM_ITEMSUMCOUNT_FAIL, mindex, icount, 0, 0);
    SendSocket(@m_DefMsg, '');
  end;
end;

procedure TPlayObject.ServerGetSumCountItem(DestMakeIndex, SrcMakeIndex: Integer; itmnames: string); //2 -> 1
var
  Flag: Boolean;
  I, fact: Integer;
  TempUserItem, SrcItem, DestItem: pTUserItem;
  TempStdItem: pTStdItem;
  DestName, SrcName: string;
  CanOverlapCount, iCurrent: Integer;
begin
  SrcItem := nil;
  DestItem := nil;

  Flag := False;
  SrcName := GetValidStr3(itmnames, DestName, ['/']);

  for I := 0 to m_ItemList.Count - 1 do
  begin
    TempUserItem := pTUserItem(m_ItemList[i]);
    if TempUserItem.wIndex = 0 then Continue;

    TempStdItem := UserEngine.GetStdItem(TempUserItem.wIndex);
    if (TempStdItem = nil) or (not CheckIsOverlapItem(TempStdItem)) then Continue;

    if (TempUserItem.MakeIndex = SrcMakeIndex) and SameText(TempStdItem.Name, SrcName) then
    begin
      SrcItem := TempUserItem;
    end
    else if (TempUserItem.MakeIndex = DestMakeIndex) and SameText(TempStdItem.Name, DestName) then
    begin
      DestItem := TempUserItem;
    end;

    if (DestItem <> nil) and (SrcItem <> nil) then
    begin
      Flag := True;
      Break;
    end;
  end;

  if Flag = False then Exit;

  if DestItem.wIndex <> SrcItem.wIndex then Exit;

  if DestItem.Dura >= DestItem.DuraMax then
  begin
    ServerSendItemCountChangedFail(0, 0);
    Exit;
  end;

  CanOverlapCount := DestItem.DuraMax - DestItem.Dura;
  if SrcItem.Dura <= CanOverlapCount then
  begin
    DestItem.Dura := DestItem.Dura + SrcItem.Dura;
    SendChangeBagItemDura(DestItem.MakeIndex, DestItem.Dura, False);
    DeletePItemAndSend(SrcItem);
  end
  else
  begin
    iCurrent :=  DestItem.Dura - (SrcItem.DuraMax - SrcItem.Dura);

    DestItem.Dura := DestItem.DuraMax;
    SendChangeBagItemDura(DestItem.MakeIndex, DestItem.Dura, False);
    SrcItem.Dura := iCurrent;
    SendChangeBagItemDura(SrcItem.MakeIndex, SrcItem.Dura, True);
  end;
end;

function TPlayObject.UserCounterItemAdd(StdMode, Looks, Cnt: Integer; iName: string; bEnforce: Boolean; ExceptMakeIndex: Integer): Boolean;
var
  i: Integer;
  pu: pTUserItem;
  ps: pTStdItem;
  idxMinimum: Integer;
  countMinimum: Word;
begin
  Result := False;
  idxMinimum := -1;
  countMinimum := 0;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    ps := UserEngine.GetStdItem(pTUserItem(m_ItemList[i]).wIndex);

    if ps = nil then
      Continue;
    if ps.Overlap = 0 then
      Continue;

    if (ps.StdMode = StdMode) and (ps.Looks = Looks) and (ps.Overlap >= 1) then
    begin
      if CompareText(ps.Name, iName) = 0 then
      begin
        pu := pTUserItem(m_ItemList[i]);
        if (ExceptMakeIndex <> -1) and (pu.MakeIndex = ExceptMakeIndex) then
          Continue;
        if idxMinimum = -1 then
        begin
          countMinimum := pu.Dura;
          idxMinimum := i;
        end
        else
        begin
          if countMinimum > pu.Dura then
          begin
            countMinimum := pu.Dura;
            idxMinimum := i;
          end;
        end;
      end;
    end;
  end;

  if (idxMinimum < 0) or (idxMinimum >= m_ItemList.Count) then
    Exit;

  ps := UserEngine.GetStdItem(pTUserItem(m_ItemList[idxMinimum]).wIndex);
  if ps = nil then
    Exit;
  pu := pTUserItem(m_ItemList[idxMinimum]);

  if (bEnforce = False) and (pu.Dura + Cnt > MAX_OVERLAPITEM) then
    Exit;

  if pu.Dura + Cnt > MAX_OVERLAPITEM then
    Exit;

  if pu.Dura + Cnt > pu.DuraMax then     // Hook 2019-11-02
    exit;

  //Ê°È¡ºó°ó¶¨
  if g_Config.boBindPickUp and (PCardinal(@pu.btValue[22])^ = 0) then
  begin
    if ps.SvrSet.nBind and $1 <> 0 then
      PCardinal(@pu.btValue[22])^ := m_dwIdCRC;
  end;

  pu.Dura := _MIN(MAX_OVERLAPITEM, pu.Dura + Cnt);

  if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
  begin
    SendMsg(Self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 1, ps.Name);
  end;

  Result := True;
end;

function TPlayObject.UserCounterDealItemAdd(StdMode, Looks, Cnt: Integer; iName: string): Integer;
const
  FAIL = 0;
  SUCCESS = 1;
  OVERFLOW = 2;
  OVERCOUNT = 3;
var
  i: Integer;
  pu: pTUserItem;
  ps: pTStdItem;
begin
  Result := FAIL;

  for i := 0 to m_DealItemList.Count - 1 do
  begin
    pu := pTUserItem(m_DealItemList[i]);
    ps := UserEngine.GetStdItem(pu.wIndex);
    if ps = nil then
      Continue;
    if ps.Overlap = 0 then
      Continue;
    if (ps.StdMode = StdMode) and (ps.Looks = Looks) and (ps.Overlap >= 1) then
    begin
      if CompareText(ps.Name, iName) = 0 then
      begin

        if pu.Dura + Cnt > MAX_OVERLAPITEM then
        begin
          Result := OVERCOUNT;
          Exit;
        end;

        if pu.Dura + Cnt > MAX_OVERFLOW then
        begin
          Result := OVERFLOW;
          Exit;
        end;

        pu.Dura := _MIN(MAX_OVERLAPITEM, pu.Dura + Cnt);

        //SysMsg('pu.Dura := ' + IntToStr(pu.Dura), c_Red, t_Hint);

        if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
        begin
          SendMsg(Self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Dura, 0, ps.Name);
        end;

        if m_DealCreat <> nil then
          TPlayObject(m_DealCreat).m_DealLastTick := GetTickCount; //0420
        m_DealLastTick := GetTickCount;

        Result := SUCCESS;
        Break;
      end;
    end;
  end;
end;

function TPlayObject.DeletePItemAndSend(pcheckitem: pTUserItem): Boolean;
var
  i: Integer;
  hum: TPlayObject;
begin
  Result := False;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    if m_ItemList[i] = pcheckitem then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) or IsHero then
      begin
        hum := TPlayObject(Self);
        hum.SendDelItems(pTUserItem(m_ItemList[i]));
      end;
      Dispose(pTUserItem(m_ItemList[i]));
      m_ItemList.Delete(i);
      Result := True;
      Exit;
    end;
  end;
end;

procedure TPlayObject.AddDealCounterItem(uitem: TUserItem; remain: Integer);
var
  i: Integer;
  puAdd: pTUserItem;
  ps, psAdd: pTStdItem;
begin
  psAdd := nil;
  if m_DealCreat <> nil then
  begin
    psAdd := UserEngine.GetStdItem(uitem.wIndex);
    if psAdd <> nil then
    begin
      puAdd := nil;
      for i := 0 to m_DealItemList.Count - 1 do
      begin
        ps := UserEngine.GetStdItem(pTUserItem(m_DealItemList[i]).wIndex);
        if ps = nil then
          Continue;
        if ps.Overlap = 0 then
          Continue;
        if (ps.StdMode = psAdd.StdMode) and (ps.Looks = psAdd.Looks) and (ps.Overlap >= 1) then
        begin
          if CompareText(ps.Name, psAdd.Name) = 0 then
          begin
            puAdd := pTUserItem(m_DealItemList[i]);
            Break;
          end;
        end;
      end;

      if puAdd <> nil then
      begin
        m_DefMsg := MakeDefaultMsg(SM_COUNTERITEMCHANGE, puAdd.MakeIndex, puAdd.Dura, 0, 0);
        TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeString(psAdd.Name));

        TPlayObject(m_DealCreat).m_DealLastTick := GetTickCount;
        m_DealLastTick := GetTickCount;
      end;
    end;
  end;
end;

procedure TPlayObject.DelDealCounterItem(uitem: TUserItem);
var
  ps: pTStdItem;
begin
  if m_DealCreat <> nil then
  begin
    ps := UserEngine.GetStdItem(uitem.wIndex);
    if ps <> nil then
    begin

      m_DefMsg := MakeDefaultMsg(SM_COUNTERITEMCHANGE, uitem.MakeIndex, uitem.Dura, 0, 0);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeString(ps.Name));

      TPlayObject(m_DealCreat).m_DealLastTick := GetTickCount;
      m_DealLastTick := GetTickCount;
    end;
  end;
end;

procedure TBaseObject.OnEnvirnomentChanged();
var
  sSENDMSG: string;
  i: Integer;
  StartPointInfo: pTStartPointInfo;
  b1, b2: Boolean;
  MessageBodyW: TMessageBodyW;
  Buffer: array[0..255] of Byte;
begin
  if m_boCanReAlive then
  begin
    if (m_pMonGen <> nil) and (m_pMonGen.Envir <> m_PEnvir) then
    begin
      m_boCanReAlive := False;
      if m_pMonGen.nActiveCount > 0 then
        Dec(m_pMonGen.nActiveCount);
      m_pMonGen := nil;
    end;
  end;

  if (m_PEnvir <> nil) then
  begin
    if m_nLastMapSecret <> m_PEnvir.m_MapFlag.nSecret then
    begin
      if ((m_btRaceServer = RC_PLAYOBJECT) or IsHero) then
      begin
        if (m_btRaceServer = RC_PLAYOBJECT) and (m_nLastMapSecret <> -1) then
        begin
          i := GetFeatureToLong(@buffer[0]);
          sSENDMSG := '';
          // if nSafeX > 0 then
          // begin
          MessageBodyW.param1 := MakeWord(GetTitleIndex, 0);
          MessageBodyW.param2 := 0;
          MessageBodyW.Tag1 := 0;
          MessageBodyW.Tag2 := 0;
          sSENDMSG := EncodeBuffer(@MessageBodyW, SizeOf(MessageBodyW));
          // end;
          //TPlayObject(self).SendDefMessage(SM_FEATURECHANGED, Integer(self), LoWord(i), HiWord(i), GetFeatureEx, sSENDMSG);
          TPlayObject(Self).m_DefMsg := MakeDefaultMsg(SM_FEATURECHANGED,
            Integer(Self),
            LoWord(i),
            HiWord(i),
            GetFeatureEx);
          TPlayObject(Self).SendSocket(@TPlayObject(Self).m_DefMsg, sSENDMSG + EncodeBuffer(@Buffer[0],i));
          TPlayObject(Self).QueryHeroHeroState();
          TPlayObject(Self).InternalPowerPointChanged();

          SendUpdateMsg(Self, RM_USERNAME, 0, 0, 0, 0, GetShowName);
        end;
        //RefShowName();
        //FeatureChanged();
        HealthSpellChanged();
      end;
      m_nLastMapSecret := m_PEnvir.m_MapFlag.nSecret;
    end;
  end;

  m_nCurEnvirIdx := -1;
  m_nCastleEnvirListIdx := -1;
  m_CurSafeZoneList.Clear;
  for i := 0 to g_StartPointManager.m_InfoList.Count - 1 do
  begin
    StartPointInfo := g_StartPointManager.m_InfoList.Items[i];
    if StartPointInfo.Envir = m_PEnvir then
    begin
      m_CurSafeZoneList.Add(StartPointInfo);
    end;
  end;

  if (m_btRaceServer = RC_PLAYOBJECT) and not TPlayObject(Self).m_boOffLineFlag then
  begin

    TPlayObject(Self).CheckMapEvent(5, '');

    with TPlayObject(Self) do
    begin
      if ((m_PEnvir.m_MapFlag.PCollectExp.nCollectExp > 0) or (m_PEnvir.m_MapFlag.PCollectExp.nCollectIPExp > 0)) then
      begin
        //¿ªÆô
        if m_btCollectExpLv = 0 then
        begin
          m_btCollectExpLv := 1;
          m_dwCollectExp := 0;
          m_dwCollectIPExp := 0;
        end;

        b1 := False;
        b2 := False;
        if m_dwCollectExp > m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv] then
        begin
          m_dwCollectExp := m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv];
          b1 := True;
        end;
        if m_dwCollectIPExp > m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv] then
        begin
          m_dwCollectIPExp := m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv];
          b2 := True;
        end;
        if b1 or b2 then
        begin
          if (m_btCollectExpLv < 4) then
            Inc(m_btCollectExpLv);
        end;

        CollectLevelUp(True);
      end
      else
      begin
        CollectLevelUp(False);
      end;
    end;
  end;
end;

procedure TPlayObject.ClientWantReleaseCollectExp();
var
  ggold: Integer;
begin
  if (m_btCollectExpLv in [2..4]) and ((m_dwCollectExp > 0) or (m_dwCollectIPExp > 0)) then
  begin
    ggold := m_btCollectExpLv * m_PEnvir.m_MapFlag.PCollectExp.nGainExpPayment;
    if m_nGameGold >= ggold then
    begin
      if g_FunctionNPC <> nil then
      begin
        g_FunctionNPC.m_OprCount := 0;
        g_FunctionNPC.GotoLable(Self, '@ReleaseCollectExp', False);
      end;
    end
    else
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, 'ÄãµÄÔª±¦²»×ã');
    end;
  end
  else
    SendDefMessage(SM_RELEASECOLLECTEXP, -1, 0, 0, 0, ''); //[Ê§°Ü]: ²»ÄÜÊÍ·Å»ýÀÛµÄ¾­Ñé
end;

procedure TPlayObject.CollectLevelUp(open: Boolean; delay: Integer);
begin
  if open then
  begin
    if (m_btCollectExpLv in [1..4]) then
    begin
      SendDelayMsg(Self, RM_COLLECTEXPSTATE, 1, 0, 0, 0, '', delay);
    end;
  end
  else
  begin
    m_DefMsg := MakeDefaultMsg(SM_COLLECTEXPSTATE, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, '');
  end;
end;

procedure TPlayObject.CollectExp(dwExp, dwIPExp: LongWord);
var
  b1, b2: Boolean;
begin
  if (m_nInPowerLevel <= 0) or (m_boOffLineFlag) then
    Exit;
  b1 := False;
  b2 := False;
  if (m_btCollectExpLv in [1..4]) then
  begin //ÌìµØ½á¾§µÈ¼¶
    if dwExp > 0 then
    begin
      Inc(m_dwCollectExp, dwExp);
      if m_dwCollectExp > m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv] then
      begin
        m_dwCollectExp := m_PEnvir.m_MapFlag.PCollectExp.dwCollectExps[m_btCollectExpLv];
        b1 := True;
      end;
    end;
    if dwIPExp > 0 then
    begin
      Inc(m_dwCollectIPExp, dwIPExp);
      if m_dwCollectIPExp > m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv] then
      begin
        m_dwCollectIPExp := m_PEnvir.m_MapFlag.PCollectExp.dwCollectIPExps[m_btCollectExpLv];
        b2 := True;
      end;
    end;

    if b1 or b2 then
    begin
      if (m_btCollectExpLv < 4) then
      begin
        Inc(m_btCollectExpLv);
        CollectLevelUp(True);
      end;
    end;

    if (dwExp > 0) or (dwIPExp > 0) then
      SendMsg(Self, RM_COLLECTEXP, 0, 0, 0, 0, '');
  end;
end;

function TPlayObject.CretInNearXYEx(nX, nY: Integer): Boolean;
var
  nCX, nCY: Integer;
begin
  Result := True;
  for nCX := nX - 1 to nX + 1 do
  begin
    for nCY := nY - 1 to nY + 1 do
    begin
      if m_PEnvir.GetMovingObject(nCX, nCY, True) = Self then
        Continue;
      if not m_PEnvir.CanWalk(nCX, nCY, False) then
        Result := False;
    end;
  end;
end;

procedure TPlayObject.SendStallItems(RecvObject: TPlayObject);
begin
  RecvObject.m_DefMsg := MakeDefaultMsg(SM_USERSTALL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
  RecvObject.SendSocket(@RecvObject.m_DefMsg, EncodeBuffer(@m_StallMgr.mBlock, SizeOf(TClientStallInfo)));
end;

procedure TPlayObject.ClientStallOnOpening(MsgBuff: string; nCount: Integer);
var
  i, ii: Integer;
  boOK: Boolean;

  StdItem: pTStdItem;
  StdItem24: TStdItem;
  UserItem: pTUserItem;

  ClientStallItems: TClientStallItems;
  //item                      : TClientStall;
  StallInfo: TStallInfo;
begin
  if not g_Config.boStallSystem then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '[Ê§°Ü] °ÚÌ¯ÏµÍ³Î´¿ª·Å£¡');
    Exit;
  end;
  if m_Abil.Level < g_Config.SetShopNeedLevel then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, Format('[Ê§°Ü] ÐèÒª%d¼¶ÒÔÉÏ²ÅÄÜ°ÚÌ¯£¡', [g_Config.SetShopNeedLevel]));
    Exit;
  end;

  if (m_PEnvir = nil) or not m_PEnvir.m_MapFlag.boStall then
  begin
    SendDefMessage(SM_OPENSTALL, -1, 0, 0, 0, ''); //µ±Ç°µØÍ¼²»ÔÊÐí°ÚÌ¯
    Exit;
  end;
  if m_boOnHorse then
  begin
    SendDefMessage(SM_OPENSTALL, -2, 0, 0, 0, '');
    Exit;
  end;
  if (nCount > 0) and not CretInNearXYEx(m_nCurrX, m_nCurrY) then
  begin
    SendDefMessage(SM_OPENSTALL, -3, 0, 0, 0, '');
    Exit;
  end;
  if m_boDealing then
  begin
    SendDefMessage(SM_OPENSTALL, -4, 0, 0, 0, '');
    Exit;
  end;

  FillChar(m_StallMgr.mBlock, SizeOf(TClientStallInfo), #0);
  DecodeBuffer(MsgBuff, @ClientStallItems, SizeOf(TClientStallItems)); // * count ???

  if nCount in [1..10] then
  begin
    if m_StallMgr.OnSale then
      Exit;
    m_StallMgr.mBlock.StallName := ClientStallItems.Name;
    m_StallMgr.mBlock.ItemCount := nCount;

    //Í¬MakeIndex¼ì²â
    for i := 0 to nCount - 1 do
    begin
      if ClientStallItems.Items[i].MakeIndex = 0 then
        Continue;
      for ii := 0 to nCount - 1 do
      begin
        if ClientStallItems.Items[ii].MakeIndex = 0 then
          Continue;
        if i = ii then
          Continue;
        if ClientStallItems.Items[i].MakeIndex = ClientStallItems.Items[ii].MakeIndex then
        begin
          SendDefMessage(SM_OPENSTALL, -10, 0, 0, 0, ''); //Í¬Ò»ÎïÆ·²»¿É¶à´Î³öÊÛ
          Exit;
        end;
      end;
    end;

    for i := 0 to nCount - 1 do
    begin
      if ClientStallItems.Items[i].MakeIndex = 0 then
        Continue;

      if not (ClientStallItems.Items[i].GoldType in [4, 5]) then
      begin
        SendDefMessage(SM_OPENSTALL, -5, 0, 0, 0, ''); //ÎïÆ·³öÊÛ¼Û¸ñÀàÐÍ¶¨Òå´íÎó£¬ÖÕÖ¹°ÚÌ¯
        Exit;
      end;

      boOK := False;
      for ii := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList[ii];
        if (UserItem.MakeIndex = ClientStallItems.Items[i].MakeIndex) then
        begin
          boOK := True;
          Break;
        end;
      end;

      if not boOK then
      begin
        Continue;
      end;

      case ClientStallItems.Items[i].GoldType of
        4: if (ClientStallItems.Items[i].Price <= 0) or (ClientStallItems.Items[i].Price > 1500000000) then
          begin
            SendDefMessage(SM_OPENSTALL, -6, 0, 0, 0, '');
            Exit;
          end;
        5: if (ClientStallItems.Items[i].Price < 1) or (ClientStallItems.Items[i].Price > 1500000000) then
          begin
            SendDefMessage(SM_OPENSTALL, -7, 0, 0, 0, '');
            Exit;
          end;
      end;

      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem = nil then
      begin
        SendDefMessage(SM_OPENSTALL, -8, 0, 0, 0, '');
        Exit;
      end;

      if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
      begin
        if g_Config.boBindNoSell then
        begin
          SendDefMessage(SM_OPENSTALL, -11, 0, 0, 0, StdItem.Name);
          Exit;
        end;
      end;

      if InLimitItemList(StdItem.Name, -1, t_dSell) then
      begin
        SendDefMessage(SM_OPENSTALL, -9, 0, 0, 0, StdItem.Name);
        Exit;
      end;

      StdItem24 := StdItem^;

      ItemUnit.GetItemAddValue(UserItem, StdItem24);
      Move(StdItem24, m_StallMgr.mBlock.Items[i].s, SizeOf(TClientStdItem));

      m_StallMgr.mBlock.Items[i].s.ItemType := UserItem.btValue[14];
      GetSendClientItem(UserItem, Self, m_StallMgr.mBlock.Items[i]);

      m_StallMgr.mBlock.Items[i].s.NeedIdentify := ClientStallItems.Items[i].GoldType;
      m_StallMgr.mBlock.Items[i].s.Price := ClientStallItems.Items[i].Price;
      m_StallMgr.mBlock.Items[i].MakeIndex := UserItem.MakeIndex;
      m_StallMgr.mBlock.Items[i].Dura := UserItem.Dura;
      m_StallMgr.mBlock.Items[i].DuraMax := UserItem.DuraMax;

    end;
    m_StallMgr.OnSale := True;
    StallInfo.open := True;
    StallInfo.Looks := m_StallMgr.StallType;
    StallInfo.Name := m_StallMgr.mBlock.StallName;
    case m_btDirection of
      0, 1: m_btDirection := 1;
      2, 3: m_btDirection := 3;
      4, 5: m_btDirection := 5;
      6, 7: m_btDirection := 7;
    end;
    if (g_FunctionNPC <> nil) then
    begin
      g_FunctionNPC.m_OprCount := 0;
      g_FunctionNPC.GotoLable(Self, '@StoreOpened', False);
    end;
  end
  else
  begin //È¡Ïû°ÚÌ¯
    nCount := 0;
    m_StallMgr.OnSale := False;
    StallInfo.open := False;
  end;

  m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
  SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

  SendRefMsg(RM_STALLSTATUS, nCount, m_nCurrX, m_nCurrY, m_btDirection, '');
end;

procedure TPlayObject.CancelDoStall;
var
  StallInfo: TStallInfo;
begin
  if m_StallMgr.OnSale then
  begin
    m_StallMgr.OnSale := False;
    StallInfo.open := False;

    m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
    SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

    SendRefMsg(RM_STALLSTATUS, 0, m_nCurrX, m_nCurrY, m_btDirection, '');
    if (g_FunctionNPC <> nil) then
    begin
      g_FunctionNPC.m_OprCount := 0;
      g_FunctionNPC.GotoLable(Self, '@StoreClosed', False);
    end;
  end;
end;

procedure TPlayObject.ClientUpdateStallItem(Msg: string; AddItemStall: Boolean);
var
  i, ii: Integer;
  boOK: Boolean;

  StdItem: pTStdItem;
  StdItem24: TStdItem;
  UserItem: pTUserItem;

  StallItem: TClientStall;
  StallInfo: TStallInfo;
begin
  if not m_StallMgr.OnSale then
    Exit;

  if m_boDealing then
  begin
    SendDefMessage(SM_UPDATESTALLITEM, -1, 0, 0, 0, '');
    Exit;
  end;

  if AddItemStall then
  begin
    if m_StallMgr.mBlock.ItemCount >= 10 then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -2, 0, 0, 0, '');
      Exit;
    end;

    DecodeBuffer(Msg, @StallItem, SizeOf(TClientStall));

    if StallItem.MakeIndex = 0 then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -3, 0, 0, 0, '');
      Exit;
    end;

    //Í¬MakeIndex¼ì²â
    for i := 0 to 9 do
    begin
      //if m_StallMgr.mBlock.Items[i].makeindex = 0 then Continue;
      if StallItem.MakeIndex = m_StallMgr.mBlock.Items[i].MakeIndex then
      begin
        SendDefMessage(SM_UPDATESTALLITEM, -13, 0, 0, 0, '');
        Exit;
      end;
    end;

    if not (StallItem.GoldType in [4, 5]) then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -4, 0, 0, 0, ''); //ÎïÆ·³öÊÛ¼Û¸ñÀàÐÍ¶¨Òå´íÎó£¬ÖÕÖ¹°ÚÌ¯
      Exit;
    end;

    boOK := False;
    for ii := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList[ii];
      if (UserItem.MakeIndex = StallItem.MakeIndex) then
      begin
        boOK := True;
        Break;
      end;
    end;
    if not boOK then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -5, 0, 0, 0, '');
      Exit;
    end;

    if IsOnSaleItem(StallItem.MakeIndex) then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -13, 0, 0, 0, '');
      Exit;
    end;

    case StallItem.GoldType of
      4: if (StallItem.Price <= 0) or (StallItem.Price > 1500000000) then
        begin
          SendDefMessage(SM_UPDATESTALLITEM, -6, 0, 0, 0, '');
          Exit;
        end;
      5: if (StallItem.Price < 1) or (StallItem.Price > 1500000000) then
        begin
          SendDefMessage(SM_UPDATESTALLITEM, -7, 0, 0, 0, '');
          Exit;
        end;
    end;

    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem = nil then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -8, 0, 0, 0, '');
      Exit;
    end;

    if (PCardinal(@UserItem.btValue[22])^ > 0) and (PCardinal(@UserItem.btValue[22])^ <> m_dwIdCRC) then
    begin
      if g_Config.boBindNoSell then
      begin
        SendDefMessage(SM_UPDATESTALLITEM, -13, 0, 0, 0, StdItem.Name);
        Exit;
      end;
    end;
    if InLimitItemList(StdItem.Name, -1, t_dSell) then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -9, 0, 0, 0, StdItem.Name);
      Exit;
    end;

    StdItem24 := StdItem^;

    ItemUnit.GetItemAddValue(UserItem, StdItem24);

    for i := 0 to 9 do
    begin
      if m_StallMgr.mBlock.Items[i].MakeIndex = 0 then
      begin
        Move(StdItem24, m_StallMgr.mBlock.Items[i].s, SizeOf(TClientStdItem));

        m_StallMgr.mBlock.Items[i].s.ItemType := UserItem.btValue[14];
        GetSendClientItem(UserItem, Self, m_StallMgr.mBlock.Items[i]);

        m_StallMgr.mBlock.Items[i].s.NeedIdentify := StallItem.GoldType;
        m_StallMgr.mBlock.Items[i].s.Price := StallItem.Price;
        m_StallMgr.mBlock.Items[i].MakeIndex := UserItem.MakeIndex;
        m_StallMgr.mBlock.Items[i].Dura := UserItem.Dura;
        m_StallMgr.mBlock.Items[i].DuraMax := UserItem.DuraMax;
        Inc(m_StallMgr.mBlock.ItemCount);
        Break;
      end;
    end;

    m_DefMsg := MakeDefaultMsg(SM_UPDATESTALLITEM, StallItem.MakeIndex, m_nCurrX, m_nCurrY, m_btDirection);
    SendSocket(@m_DefMsg, '');
  end
  else
  begin
    //delete ...
    if not (m_StallMgr.mBlock.ItemCount in [1..10]) then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -10, 0, 0, 0, '');
      Exit;
    end;

    DecodeBuffer(Msg, @StallItem, SizeOf(TClientStall));

    if StallItem.MakeIndex = 0 then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -3, 0, 0, 0, '');
      Exit;
    end;

    boOK := False;
    for i := 0 to 9 do
    begin
      if m_StallMgr.mBlock.Items[i].s.Name = '' then
        Continue;
      if m_StallMgr.mBlock.Items[i].MakeIndex = StallItem.MakeIndex then
      begin
        m_StallMgr.mBlock.Items[i].MakeIndex := 0;
        m_StallMgr.mBlock.Items[i].s.Name := '';
        Dec(m_StallMgr.mBlock.ItemCount);
        boOK := True;
        Break;
      end;
    end;
    if not boOK then
    begin
      SendDefMessage(SM_UPDATESTALLITEM, -11, 0, 0, 0, '');
      Exit;
    end;

    m_DefMsg := MakeDefaultMsg(SM_UPDATESTALLITEM, 2, m_nCurrX, m_nCurrY, m_btDirection);
    SendSocket(@m_DefMsg, '');

    if m_StallMgr.mBlock.ItemCount <= 0 then
    begin
      m_StallMgr.mBlock.ItemCount := 0;
      m_StallMgr.OnSale := False;
      m_StallMgr.mBlock.StallName := '';
      FillChar(m_StallMgr.mBlock.Items, SizeOf(m_StallMgr.mBlock.Items), #0);

      StallInfo.open := False;
      StallInfo.Name := m_StallMgr.mBlock.StallName;
      StallInfo.Looks := m_StallMgr.StallType;
      m_DefMsg := MakeDefaultMsg(SM_OPENSTALL, Integer(Self), m_nCurrX, m_nCurrY, m_btDirection);
      SendSocket(@m_DefMsg, EncodeBuffer(@StallInfo, SizeOf(TStallInfo)));

      SendRefMsg(RM_STALLSTATUS, 0, m_nCurrX, m_nCurrY, m_btDirection, '');
      if (g_FunctionNPC <> nil) then
      begin
        g_FunctionNPC.m_OprCount := 0;
        g_FunctionNPC.GotoLable(Self, '@StoreClosed', False);
      end;
    end;

    {boOK := False;
    for ii := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList[ii];
      if (UserItem.makeindex = StallItem.makeindex) then begin
        boOK := True;
        Break;
      end;
    end;
    if not boOK then begin
      SendDefMessage(SM_UPDATESTALLITEM, -5, 0, 0, 0, '');
      Exit;
    end;

    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem = nil then begin
      SendDefMessage(SM_UPDATESTALLITEM, -8, 0, 0, 0, '');
      Exit;
    end;}

  end;
end;

function TPlayObject.IsOnSaleItem(MakeIndex: Integer): Boolean;
var
  i: Integer;
begin
  Result := False;
  if not m_StallMgr.OnSale or (m_StallMgr.mBlock.ItemCount = 0) then
    Exit;
  for i := 0 to 9 do
  begin
    if m_StallMgr.mBlock.Items[i].s.Name = '' then
      Continue;
    if m_StallMgr.mBlock.Items[i].MakeIndex = MakeIndex then
    begin
      SysMsg('ÎïÆ·ÒÑ¾­ÔÚÌ¯Î»ÖÐ³öÊÛ£¬²»ÄÜÊ¹ÓÃ', c_Green, t_Hint);
      Result := True;
      Break;
    end;
  end;
end;

function TBaseObject.GetPowerDamage(Attacker: TBaseObject; Pwr: Integer): Integer;
var
  r: Integer;
begin
  Result := Pwr;
  //Randomize();

  if m_btDoubleDamage = 1 then
  begin
    m_btDoubleDamage := 0;
    Result := Pwr * 2;
    if m_nMaxDamageHealth > 0 then
    begin
      if Result > m_nMaxDamageHealth then
        Result := m_nMaxDamageHealth;
    end;
    SendRefMsg(RM_STRUCKEFFECTEX, 0, 29, Result, 0, '');
    Exit;
  end;

  if (Attacker <> nil) and ((Attacker.m_btRaceServer = RC_PLAYOBJECT) or Attacker.IsHero) then
  begin

    if ((Attacker.m_MagicArr[0][77] <> nil) and (Attacker.m_wStatusTimeArrEx[STATE_13] > 0)) then
    begin
      m_boDoubleStruck2 := True;
      case Attacker.m_MagicArr[0][77].btLevel of
        0..2: Result := Round(Pwr * 1.6 / 100 * g_Config.Skill77PowerRate);
        3..6: Result := Round(Pwr * 1.7 / 100 * g_Config.Skill77PowerRate);
        7..10: Result := Round(Pwr * 1.8 / 100 * g_Config.Skill77PowerRate);
      else
        Result := Round(Pwr * 2 / 100 * g_Config.Skill77PowerRate);
      end;
      Result := Result + Attacker.m_wDoublePower * 2;

      if m_nMaxDamageHealth > 0 then
      begin
        if Result > m_nMaxDamageHealth then
          Result := m_nMaxDamageHealth;
      end;

      if g_Config.cbSmiteDamegeShow then
      begin
        m_boDoubleStruck := True;
        SendRefMsg(RM_STRUCKEFFECTEX, 0, 29, Result, 0, '');
      end;
    end
    else if (TPlayObject(Attacker).m_btHitPowerAddOn > 0) and (Random(100) < TPlayObject(Attacker).m_btHitPowerAddOn) then
    begin
      m_boDoubleStruck2 := True;
      r := Random(100);
      if r > 88 then
        Result := Pwr * 2
      else if r > 68 then
        Result := Round(Pwr * 1.9)
      else if r > 58 then
        Result := Round(Pwr * 1.8)
      else if r > 48 then
        Result := Round(Pwr * 1.7)
      else if r > 48 then
        Result := Round(Pwr * 1.6)
      else
        Result := Round(Pwr * 1.5);
      Result := Result + Attacker.m_wDoublePower * 2;

      if ((Attacker.m_MagicArr[0][118] <> nil) and (Attacker.m_wStatusTimeArrEx[STATE_14] > 0)) then
      begin
        Result := Result + g_Config.nMagicDragonRageDamageAdd;
      end;

      if m_nMaxDamageHealth > 0 then
      begin
        if Result > m_nMaxDamageHealth then
          Result := m_nMaxDamageHealth;
      end;
      if g_Config.cbSmiteDamegeShow then
      begin
        m_boDoubleStruck := True;
        SendRefMsg(RM_STRUCKEFFECTEX, 0, 29, Result, 0, '');
      end;
    end;

    if Attacker.m_btDragonRageSkillLevel > 0 then
    begin
      Result := Result + Attacker.m_btDragonRageSkillLevel * 100;
    end;

  end;

  if m_btDoubleDamage = 2 then
  begin
    m_btDoubleDamage := 0;
    Result := Result + Round(m_WAbil.MaxHP / 100 * 5);
  end;

  if (m_wStatusTimeArrEx[STATE_14] > 0) and (Result > 500) then
  begin
    Result := 500;
    if m_btDragonRageSkillLevel > 0 then
    begin
      Result := _MAX(100, Result - m_btDragonRageSkillLevel * 50);
    end;
  end;
end;

//////////////////////////////////////////////////////////////////////////////////////
{$IF DEATHWALKING = 1}

function TPlayObject.Think(): Boolean;
var
  nOldX, nOldY: Integer;
begin
  Result := False;
  if (GetTickCount - m_dwThinkTick) > 3 * 1000 then
  begin
    m_dwThinkTick := GetTickCount();
    //if not InSafeZone() and (m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) >= 2) then
    //  m_boDupMode := True;

    if m_boInSafeZone then
    begin
      if (m_PEnvir.GetXYObjCount_SafeZone(Self, m_nCurrX, m_nCurrY) >= 2) then
        m_boDupMode := True;
    end
    else
    begin
      if (m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) >= 2) then
        m_boDupMode := True;
    end;

    if not IsProperTarget(m_TargetCret) then
      m_TargetCret := nil;
  end;
  if m_boDupMode then
  begin
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(Random(8), False);
    if (nOldX <> m_nCurrX) or (nOldY <> m_nCurrY) then
    begin
      m_boDupMode := False;
      Result := True;
    end;
  end;
end;

{function TPlayObject.Sidestep(): Boolean;
begin
  Result := IsHero and
    TPlayObject(m_Master).m_boHeroSidestep and
    (Round(m_WAbil.HP / m_WAbil.MaxHP * 100) <= TPlayObject(m_Master).m_nHeroSidestepHP);
end;}

function TPlayObject.ProperTarget(): Boolean;
begin
  Result := True;
  if (m_TargetCret <> nil) and IsHero and TPlayObject(m_Master).m_boHeroTargetFilter then
  begin
    if (m_TargetCret.m_btRaceServer <> RC_PLAYOBJECT) or not m_TargetCret.IsHero then
      Result := False;
  end;
end;

procedure TPlayObject.TrainingSkill(Magic: pTUserMagic);
var
  nC: Integer;
begin
  if (Magic <> nil) and (Magic.btLevel < Magic.MagicInfo.btTrainLv) then
  begin
    if Magic.MagicInfo.btClass = 0 then
      nC := m_Abil.Level
    else
      nC := m_nInPowerLevel;
    if Magic.MagicInfo.TrainLevel[Magic.btLevel] <= nC then
    begin
      TrainSkill(Magic, Random(3) + 1);
      if not CheckMagicLevelup(Magic) then
        SendDelayMsg(Self, RM_MAGIC_LVEXP, Magic.MagicInfo.btClass, Magic.MagicInfo.wMagicId, Magic.btLevel, Magic.nTranPoint, '', 1000);
    end;
  end;
end;

function TPlayObject.__Warr__HeroAttackTarget(): Boolean;
var
  btDir, btMasterDir: Byte;
  boTrainOk, boChg: Boolean;
  i, ii, nX, nY, nRange: Integer;
  nHitMode, nMapRangeCount: Integer;
  nC, nd, nDir, nSpellPoint: Integer;
  nNX, nNY, nTX, nTY: Integer;
  UserMagic: pTUserMagic;
  dwTick, dwAttackTime: LongWord;
  nTick, nOldDC, nAbsX, nAbsY: Integer;
  wMagicId: Word;
  sskilltick: LongWord;
label
  LabelDoSpell, LabelStartAttack, LabelNormo, LabLongAttack, LabLongAttack2;
begin
  Result := False;
  m_boLAT := False;
  nHitMode := 0;
  UserMagic := nil;

  //if g_Config.boCalcHeroHitSpeed then
  dwAttackTime := _MAX(350, m_nNextHitTime - (m_nHitSpeed * g_Config.ClientConf.btItemSpeed div 2));
  //else
  //  dwAttackTime := m_nNextHitTime;

  if m_TargetCret <> nil then
  begin
    if (m_nCurrX = m_TargetCret.m_nCurrX) and (m_nCurrY = m_TargetCret.m_nCurrY) then
    begin
      nTick := 0;
      while True do
      begin
        if WalkTo(m_btDirection, False) then
          Exit;
        Inc(m_btDirection);
        m_btDirection := m_btDirection mod 8;
        Inc(nTick);
        if nTick > 8 then
          Break;
      end;
    end;

    // ========= series skill =========
    if ProperTarget() then
    begin
      if (m_nInPowerLevel > 0) and
        (m_nInPowerPoint > 20) and
        (m_btReadySeriesSkill = 1) and
        (m_btSeriesSkillSetpMax in [1..4]) then
      begin

        m_btReadySeriesSkill := 2; //fired ...
        m_dwReadySeriesSkillTick := GetTickCount;

        m_dwLatestRushHitTick := 0;
        m_dwLatestSmiteTick := 0;
        m_dwLatestSmiteLongTick := 0;
        m_dwLatestSmiteWideTick := 0;

        m_btSeriesSkillSetpCur := 0;
        m_nLastSSkillID := 0;
      end;

      if (m_btReadySeriesSkill = 2) and (m_btSeriesSkillSetpCur < m_btSeriesSkillSetpMax) then
      begin
        wMagicId := m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId;
        UserMagic := m_MagicArr[0][wMagicId];
        if (UserMagic <> nil) then
        begin

          sskilltick := 800;
          case m_nLastSSkillID of
            101: sskilltick := 15 * 56;
            102: sskilltick := 10 * 72 + 100;
            103: sskilltick := 10 * 78 + 100;
          end;

          case wMagicId of
            100:
              begin
                if GetAttackDir(m_TargetCret, btDir) or GetLongAttackDir(m_TargetCret, btDir) then
                begin
                  if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                  begin
                    m_dwHitTick := GetTickCount();
                    m_btDirection := btDir;
                    nSpellPoint := GetSpellPoint(UserMagic);
                    if m_nInPowerPoint >= nSpellPoint then
                    begin
                      if nSpellPoint > 0 then
                      begin
                        Dec(m_nInPowerPoint, nSpellPoint);
                        TPlayObject(Self).InternalPowerPointChanged(True);
                      end;
                      if DoMotaeboEx(m_btDirection, _MIN(5, UserMagic.btLevel)) then
                      begin
                        if UserMagic.btLevel < MagicMaxTrainLevel(UserMagic) then
                        begin
                          if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= m_nInPowerLevel then
                          begin
                            TrainSkill(UserMagic, Random(3) + 1);
                            if not CheckMagicLevelup(UserMagic) then
                            begin
                              SendDelayMsg(Self,
                                RM_MAGIC_LVEXP,
                                0,
                                UserMagic.MagicInfo.wMagicId,
                                UserMagic.btLevel,
                                UserMagic.nTranPoint,
                                '', 1000);
                            end;
                          end;
                        end;
                      end;
                      m_dwWalkTick := GetTickCount();
                      m_dwSpellTick := GetTickCount() + 800;
                      m_dwHeroSetTargetTick := GetTickCount + 300;
                      m_nLastSSkillID := wMagicId;
                      if (m_btSeriesSkillSetpCur = 0) and (m_LockTarget = nil) then
                        m_LockTarget := m_TargetCret;
                      Inc(m_btSeriesSkillSetpCur);
                      if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                      begin
                        m_btReadySeriesSkill := 0;
                        m_nLastSSkillID := 0;
                      end;
                      Result := True;
                      Exit;
                    end;
                  end
                  else
                  begin
                    m_dwWalkTick := GetTickCount();
                    m_dwSpellTick := GetTickCount() + 800;
                    m_dwHeroSetTargetTick := GetTickCount + 300;
                    m_nTargetX := -1;
                    Exit;
                  end;
                end
                else
                begin
                  if m_TargetCret.m_PEnvir = m_PEnvir then
                    SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
                  else
                    DelTargetCreat();
                  Exit;
                end;
              end;
            101:
              begin
                if GetAttackDir(m_TargetCret, btDir) then
                begin
                  if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                  begin
                    m_dwHitTick := GetTickCount();
                    if AllowSmiteSkill() then
                    begin
                      nSpellPoint := GetSpellPoint(UserMagic);
                      if m_nInPowerPoint >= nSpellPoint then
                      begin
                        if nSpellPoint > 0 then
                        begin
                          Dec(m_nInPowerPoint, nSpellPoint);
                          TPlayObject(Self).InternalPowerPointChanged(True);
                        end;
                        m_nLastSSkillID := wMagicId;
                        if (m_btSeriesSkillSetpCur = 0) and (m_LockTarget = nil) then
                          m_LockTarget := m_TargetCret;
                        Inc(m_btSeriesSkillSetpCur);
                        if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                        begin
                          m_btReadySeriesSkill := 0;
                          m_nLastSSkillID := 0;
                        end;
                        nHitMode := 20;
                        m_dwWalkTick := GetTickCount();
                        m_dwSpellTick := GetTickCount() + 800;
                        m_dwHeroSetTargetTick := GetTickCount + 300;
                        goto LabelStartAttack;
                      end;
                    end;
                  end
                  else
                  begin
                    m_dwWalkTick := GetTickCount();
                    m_dwSpellTick := GetTickCount() + 800;
                    m_dwHeroSetTargetTick := GetTickCount + 300;
                    m_nTargetX := -1;
                    Exit;
                  end;
                end
                else
                begin
                  if m_TargetCret.m_PEnvir = m_PEnvir then
                    SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
                  else
                    DelTargetCreat();
                  Exit;
                end;
              end;
            102:
              begin
                if (GetLongAttackDir(m_TargetCret, btDir) or GetAttackDir(m_TargetCret, btDir)) then
                begin
                  if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                  begin
                    m_dwHitTick := GetTickCount();
                    if AllowSmiteLongSkill() then
                    begin
                      nSpellPoint := GetSpellPoint(UserMagic);
                      if m_nInPowerPoint >= nSpellPoint then
                      begin
                        if nSpellPoint > 0 then
                        begin
                          Dec(m_nInPowerPoint, nSpellPoint);
                          TPlayObject(Self).InternalPowerPointChanged(True);
                        end;
                        m_nLastSSkillID := wMagicId;
                        if (m_btSeriesSkillSetpCur = 0) and (m_LockTarget = nil) then
                          m_LockTarget := m_TargetCret;
                        Inc(m_btSeriesSkillSetpCur);
                        if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                        begin
                          m_btReadySeriesSkill := 0;
                          m_nLastSSkillID := 0;
                        end;
                        nHitMode := 21;
                        //m_boLAT := True;
                        m_dwWalkTick := GetTickCount();
                        m_dwSpellTick := GetTickCount() + 800;
                        m_dwHeroSetTargetTick := GetTickCount + 300;
                        goto LabelStartAttack;
                      end;
                    end;
                  end
                  else
                  begin
                    m_dwWalkTick := GetTickCount();
                    m_dwSpellTick := GetTickCount() + 800;
                    m_dwHeroSetTargetTick := GetTickCount + 300;
                    m_nTargetX := -1;
                    Exit;
                  end;
                end
                else
                begin
                  if m_TargetCret.m_PEnvir = m_PEnvir then
                    SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
                  else
                    DelTargetCreat();
                  Exit;
                end;
              end;
            103:
              begin
                if GetAttackDir(m_TargetCret, btDir) then
                begin
                  if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                  begin
                    m_dwHitTick := GetTickCount();
                    if AllowSmiteWideSkill() then
                    begin
                      nSpellPoint := GetSpellPoint(UserMagic);
                      if m_nInPowerPoint >= nSpellPoint then
                      begin
                        if nSpellPoint > 0 then
                        begin
                          Dec(m_nInPowerPoint, nSpellPoint);
                          TPlayObject(Self).InternalPowerPointChanged(True);
                        end;
                        m_nLastSSkillID := wMagicId;
                        if (m_btSeriesSkillSetpCur = 0) and (m_LockTarget = nil) then
                          m_LockTarget := m_TargetCret;
                        Inc(m_btSeriesSkillSetpCur);
                        if m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax then
                        begin
                          m_btReadySeriesSkill := 0;
                          m_nLastSSkillID := 0;
                        end;
                        nHitMode := 22;
                        m_dwWalkTick := GetTickCount();
                        m_dwSpellTick := GetTickCount() + 800;
                        m_dwHeroSetTargetTick := GetTickCount + 300;
                        goto LabelStartAttack;
                      end;
                    end;
                  end
                  else
                  begin
                    m_dwWalkTick := GetTickCount();
                    m_dwSpellTick := GetTickCount() + 800;
                    m_dwHeroSetTargetTick := GetTickCount + 300;
                    m_nTargetX := -1;
                    Exit;
                  end;
                end
                else
                begin
                  if m_TargetCret.m_PEnvir = m_PEnvir then
                    SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
                  else
                    DelTargetCreat();
                  Exit;
                end;
              end;

          end;
        end;
      end;
    end;

    if m_btReadySeriesSkill = 2 then
    begin
      {if m_boRushhitSkill and ((GetTickCount - m_dwLatestRushHitTick) > 10 * 1000) then begin //080118
        m_boRushhitSkill := False;
        m_btReadySeriesSkill := 0;
      end;}
      if m_boSmiteSkill and ((GetTickCount - m_dwLatestSmiteTick) > 10 * 1000) then
      begin //080118
        m_boSmiteSkill := False;
        m_btReadySeriesSkill := 0;
        m_nLastSSkillID := 0;
      end;
      if m_boSmiteLongSkill and ((GetTickCount - m_dwLatestSmiteLongTick) > 10 * 1000) then
      begin //080118
        m_boSmiteLongSkill := False;
        m_btReadySeriesSkill := 0;
        m_nLastSSkillID := 0;
      end;
      if m_boSmiteWideSkill and ((GetTickCount - m_dwLatestSmiteWideTick) > 10 * 1000) then
      begin //080118
        m_boSmiteWideSkill := False;
        m_btReadySeriesSkill := 0;
        m_nLastSSkillID := 0;
      end;
    end;

    if ProcUniteAttack() then
    begin
      Result := True;
      Exit;
    end;

    if (m_MagicArr[0][56] <> nil) and ((GetTickCount - m_dwLatestPursueHitTick) > (g_Config.nHeroFireSwordTime + 5000)) and (GetLongAttackDirX(m_TargetCret, btDir)) then
    begin
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        m_dwLatestPursueHitTick := GetTickCount();
        m_dwHitTick := GetTickCount();
        nHitMode := 13;
        m_boPursueHitSkill := True;
        m_boLAT := True;
        goto LabelStartAttack;
      end;
    end;

    //warr
    if (m_MagicArr[0][114] <> nil) and GetLongAttackDirX(m_TargetCret, btDir) and (GetTickCount - m_dwLatestSmiteWideTick2 > _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000)) then
    begin
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        m_dwLatestSmiteWideTick2 := GetTickCount;
        m_dwHitTick := GetTickCount();
        m_dwWalkTick := GetTickCount();
        nHitMode := 23;
        m_boSmiteWideSkill2 := True;
        m_boLAT := True;
        goto LabelStartAttack;
      end;
    end;

    if (m_MagicArr[0][113] <> nil) and GetLongAttackDirX(m_TargetCret, btDir) and (GetTickCount - m_dwLatestSmiteLongTick2 > 15 * 1000) then
    begin
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        m_dwLatestSmiteLongTick2 := GetTickCount;
        m_dwHitTick := GetTickCount();
        nHitMode := 24;
        m_boSmiteLongSkill2 := True;
        m_boLAT := True;
        goto LabelStartAttack;
      end;
    end;

    nd := _MAX(3, Random(10));
    if (m_MagicArr[0][66] <> nil) and (GetTickCount - m_dwLatestHeroLongHitTick > 4 * 1000) and
      (((m_WAbil.Level > m_TargetCret.m_WAbil.Level) and GetLongAttackDirX(m_TargetCret, btDir)) or
      ((m_WAbil.Level <= m_TargetCret.m_WAbil.Level) and GetLongAttackDir(m_TargetCret, btDir))) then
    begin
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        //Inc(m_nLongAttackCount);
        m_dwLatestHeroLongHitTick := GetTickCount();
        m_dwHitTick := GetTickCount();
        if m_WAbil.Level > m_TargetCret.m_WAbil.Level then
        begin
          m_btSquareHit := 2;
          nHitMode := 12;
        end
        else
        begin
          m_btSquareHit := 1;
          nHitMode := 12;
        end;
        m_boLAT := True;
        goto LabelStartAttack;
      end;
    end
    else if (m_MagicArr[0][SKILL_ERGUM] <> nil) and (m_nLongAttackCount <= nd) and GetLongAttackDir(m_TargetCret, btDir) then
    begin
      if (m_nLongAttackCount > 1) and (nd >= 5) then
      begin
        //
        nRange := -9;
        goto LabLongAttack;
      end;
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        Inc(m_nLongAttackCount);
        m_dwHitTick := GetTickCount();
        nHitMode := 4;
        m_boUseThrusting := True;
        m_boLAT := True;
        goto LabelStartAttack;
      end;
    end
    else
    begin
      nRange := Round((m_WAbil.HP * 100) / m_WAbil.MaxHP / 2);
      LabLongAttack:
      m_nLongAttackCount := 0;
      if (m_MagicArr[0][SKILL_ERGUM] <> nil) and (Random(nRange + 32) = 0) or (abs(m_nCurrX - m_TargetCret.m_nCurrX) > 2) or (abs(m_nCurrY - m_TargetCret.m_nCurrY) > 2) then
      begin
        // nd := 999;
        if GetLongAttackDir(m_TargetCret, btDir) then
        begin
          nTX := -1;
          nDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          if Random(2) = 0 then
            nDir := (nDir + 1) mod 8
          else
            nDir := (nDir + 7) mod 8;
          if (m_TargetCret.m_PEnvir <> nil) and m_TargetCret.m_PEnvir.GetNextPosition(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY, nDir, 2, nNX, nNY) then
          begin
            if ((m_nCurrX <> nNX) or (m_nCurrY <> nNY)) and (abs(m_nCurrX - nNX) mod 2 = 0) and (abs(m_nCurrY - nNY) mod 2 = 0) then
            begin
              nTX := nNX;
              nTY := nNY;
            end;
          end;
          if nTX <> -1 then
          begin
            if (m_TargetCret.m_nCurrX <> nTX) or (m_TargetCret.m_nCurrY <> nTY) then
            begin
              if (abs(nTX - m_TargetCret.m_nCurrX) > 1) or (abs(nTY - m_TargetCret.m_nCurrY) > 1) then
              begin
                if m_PEnvir.CanWalk(nTX, nTY, False) then
                  SetTargetXY(nTX, nTY)
                else
                begin
                  goto LabLongAttack2;
                end;
              end;
            end;
          end;
        end
        else
        begin
          LabLongAttack2:
          nd := 999;
          nTX := -1;
          for ii := 0 to 8 - 1 do
          begin
            if (m_TargetCret.m_PEnvir <> nil) and m_TargetCret.m_PEnvir.GetNextPosition(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY, ii, 2, nNX, nNY) then
            begin
              {if ((m_nCurrX <> nNX) or (m_nCurrY <> nNY)) and (abs(m_nCurrX - nNX) mod 2 = 0) and (abs(m_nCurrY - nNY) mod 2 = 0) then begin
                nTX := nNX;
                nTY := nNY;
                Break;
              end;}
              nC := abs(m_nCurrX - nNX) + abs(m_nCurrY - nNY);
              if nC < nd then
              begin
                nd := nC;
                nTX := nNX;
                nTY := nNY;
              end;
            end;
          end;
          if nTX <> -1 then
          begin
            if (m_TargetCret.m_nCurrX <> nTX) or (m_TargetCret.m_nCurrY <> nTY) then
            begin
              if (abs(nTX - m_TargetCret.m_nCurrX) > 1) or (abs(nTY - m_TargetCret.m_nCurrY) > 1) then
              begin
                if m_PEnvir.CanWalk(nTX, nTY, False) then
                  SetTargetXY(nTX, nTY)
                else
                begin
                  nOldDC := 0;
                  while nOldDC <= 15 do
                  begin
                    nTX := m_TargetCret.m_nCurrX + (Random(3) - 1) * 2;
                    nTY := m_TargetCret.m_nCurrY + (Random(3) - 1) * 2;
                    if (m_TargetCret.m_nCurrX <> nTX) or (m_TargetCret.m_nCurrY <> nTY) then
                    begin
                      if (abs(nTX - m_TargetCret.m_nCurrX) > 1) or (abs(nTY - m_TargetCret.m_nCurrY) > 1) then
                      begin
                        if m_PEnvir.CanWalk(nTX, nTY, False) then
                        begin
                          //m_boLockLongAttack := True;
                          SetTargetXY(nTX, nTY);
                          Break;
                        end;
                      end;
                    end;
                    Inc(nOldDC);
                  end;
                end;
              end;
            end;
          end;
        end;
      end
      else
      begin
        if (m_MagicArr[0][75] <> nil) and (m_nMagShieldHP <= 0) then
        begin
          if GetTickCount - m_dwUnionHitShieldTick > 10 * 1000 then
          begin
            m_dwUnionHitShieldTick := GetTickCount;
            Result := HeroDoSpell(m_MagicArr[0][75], m_TargetCret, boTrainOk);
            Exit;
          end;
        end;
        if GetAttackDir(m_TargetCret, btDir) then
        begin
          if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
          begin
            m_dwHitTick := GetTickCount();
            //warr
            if (m_MagicArr[0][114] <> nil) and (GetTickCount - m_dwLatestSmiteWideTick2 > _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000)) then
            begin
              m_dwLatestSmiteWideTick2 := GetTickCount;
              m_dwWalkTick := GetTickCount();
              nHitMode := 23;
              m_boSmiteWideSkill2 := True;
              m_boLAT := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][113] <> nil) then
            begin
              if GetTickCount - m_dwLatestSmiteLongTick2 > 15 * 1000 then
              begin
                m_dwLatestSmiteLongTick2 := GetTickCount;
                nHitMode := 24;
                m_boSmiteLongSkill2 := True;
                goto LabelStartAttack;
              end;
            end;

            UserMagic := m_MagicArr[0][SKILL_MOOTEBO]; //TPlayObject(self).GetMagicInfo(SKILL_MOOTEBO);
            if (UserMagic <> nil) and (m_WAbil.Level > m_TargetCret.m_WAbil.Level) and not m_TargetCret.m_boStickMode then
            begin
              if (GetTickCount - m_dwDoMotaeboTick) > (6 * 1000 + Random(5 * 1000)) then
              begin
                m_dwDoMotaeboTick := GetTickCount();
                m_btDirection := btDir;
                nSpellPoint := TPlayObject(Self).GetSpellPoint(UserMagic);
                if m_WAbil.MP >= nSpellPoint then
                begin
                  if nSpellPoint > 0 then
                  begin
                    TPlayObject(Self).DamageSpell(nSpellPoint);
                    TPlayObject(Self).HealthSpellChanged();
                  end;
                  if TPlayObject(Self).DoMotaebo(m_btDirection, UserMagic.btLevel) then
                  begin
                    TrainingSkill(UserMagic);
                    m_dwTargetFocusTick := GetTickCount();
                    dwTick := GetTickCount;
                    nTick := dwTick - m_dwHitTick - dwAttackTime;
                    if nTick < 0 then
                      m_dwHitTick := dwTick + nTick + 400 + 90;
                    Result := True;
                    Exit;
                  end;
                end;
              end;
            end;

            if (m_MagicArr[0][56] <> nil) and ((GetTickCount - m_dwLatestPursueHitTick) > g_Config.nHeroFireSwordTime) then
            begin
              m_dwLatestPursueHitTick := GetTickCount();
              nHitMode := 13;
              m_boPursueHitSkill := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][43] <> nil) and ((GetTickCount - m_dwLatestTwinHitTick) > 15 * 1000) then
            begin
              m_dwLatestTwinHitTick := GetTickCount();
              nHitMode := 9;
              m_boTwinHitSkill := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][SKILL_FIRESWORD] <> nil) and ((GetTickCount - m_dwLatestFireHitTick) > g_Config.nHeroFireSwordTime) then
            begin
              m_dwLatestFireHitTick := GetTickCount();
              nHitMode := 7;
              m_boFireHitSkill := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][66] <> nil) and ((GetTickCount - m_dwLatestHeroLongHitTick) > 6000) and TargetInSwordLongAttackRangeX() then
            begin
              m_dwLatestHeroLongHitTick := GetTickCount();
              nHitMode := 12;
              if (m_WAbil.Level > m_TargetCret.m_WAbil.Level) then
                m_btSquareHit := 2
              else
                m_btSquareHit := 1;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][66] <> nil) and ((GetTickCount - m_dwLatestHeroLongHitTick) > 8000) then
            begin
              m_dwLatestHeroLongHitTick := GetTickCount();
              nHitMode := 12;
              if (m_WAbil.Level > m_TargetCret.m_WAbil.Level) then
                m_btSquareHit := 2
              else
                m_btSquareHit := 1;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][SKILL_ERGUM] <> nil) and TargetInSwordLongAttackRange then
            begin
              nHitMode := 4;
              m_boUseThrusting := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][SKILL_YEDO] <> nil) and (m_UseItems[U_WEAPON].Dura > 0) and (Random(9) = 0) then
            begin
              nHitMode := 3;
              m_boPowerHit := True;
              goto LabelStartAttack;
            end;

            if (m_MagicArr[0][SKILL_BANWOL] <> nil) and (m_Abil.MP >= 3) and TargetInSwordWideAttackRange then
            begin
              nHitMode := 5;
              goto LabelStartAttack;
            end;

            if GetTickCount - m_dwMag41Tick > (8 * 1000 + Random(8 * 1000)) then
            begin
              m_dwMag41Tick := GetTickCount();
              UserMagic := m_MagicArr[0][41]; //TPlayObject(self).GetMagicInfo(41);
              if (UserMagic <> nil) and (GetTagXYRangeCount(1, 3, 1) > 3) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(UserMagic, m_TargetCret, boTrainOk);
                Exit;
              end;
            end;

            LabelStartAttack:
            m_dwTargetFocusTick := GetTickCount();
            if nHitMode in [0, 3, 4, 5, 7, 9, 12, 13, 20..24] then
            begin
              m_dwHitTick := GetTickCount();
              if m_boLAT then
                begin
                  AttackDir(nil, nHitMode, btDir);
                  // Result := True
                end
              else
                AttackDir(m_TargetCret, nHitMode, btDir);
            end;
          end;
          Result := True;
        end
        else
        begin
          if ((abs(m_nCurrX - m_TargetCret.m_nCurrX) > 3) or (abs(m_nCurrY - m_TargetCret.m_nCurrY) > 3)) then
          begin
            if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
            begin
              m_dwHitTick := GetTickCount();
              nMapRangeCount := GetTagXYRangeCount(0, 1);
              if nMapRangeCount > 3 then
              begin
                UserMagic := m_MagicArr[0][71]; //TPlayObject(self).GetMagicInfo(71);
                if not (m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (m_TargetCret.m_Abil.Level + 8 < m_Abil.Level) and (UserMagic <> nil) then
                  goto LabelDoSpell;
              end;
              if (nMapRangeCount > 2) then
                UserMagic := m_MagicArr[0][39]; //TPlayObject(self).GetMagicInfo(39);
              if UserMagic <> nil then
                goto LabelDoSpell;

              LabelDoSpell:
              if (UserMagic <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(UserMagic, m_TargetCret, boTrainOk);
                Exit;
              end;
            end;
          end;
          if m_TargetCret.m_PEnvir = m_PEnvir then
            SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
          else
            DelTargetCreat();
        end;
      end;
    end;
  end;
end;

function TPlayObject.__Wiza__HeroAttackTarget(): Boolean;
var
  i, nCount, nPower: Integer;
  boTrainOk: Boolean;
  btDir: Byte;
  nTag, nX, nY, nAbsX, nAbsY: Integer;
  nNX, nNY, nTX, nTY, nOldDC: Integer;
  dwAttackTime: LongWord;
  wMagicId: Word;
  UserMagic: pTUserMagic;
  sskilltick: LongWord;
label
  DDDD, FFFF, labLoop, LabelMagPass;
begin
  Result := False;
  boTrainOk := False;

  if (m_btReadySeriesSkill <> 2) and (Integer(GetTickCount - m_dwSpellTick) > m_nNextHitTime) then
  begin
    m_dwSpellTick := GetTickCount();
    if (m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] <= 0) and (m_MagicArr[0][31] <> nil) then
    begin
      m_dwTargetFocusTick := GetTickCount();
      m_dwHitTick := GetTickCount();
      Result := HeroDoSpell(m_MagicArr[0][31], Self, boTrainOk);
      Exit;
    end;
  end;

  if m_Abil.Level >= 7 then
  begin
    if m_TargetCret <> nil then
    begin

      // ========= series skill =========
      if ProperTarget() then
      begin
        if (m_nInPowerLevel > 0) and
          (m_nInPowerPoint > 20) and
          (m_btReadySeriesSkill = 1) and
          (m_btSeriesSkillSetpMax in [1..4]) then
        begin

          m_btReadySeriesSkill := 2; //fired ...
          m_dwReadySeriesSkillTick := GetTickCount;

          m_sTargetCret := m_TargetCret;
          m_btSeriesSkillSetpCur := 0;
          m_nLastSSkillID := 0;
        end;

        if (m_btReadySeriesSkill = 2) and (m_sTargetCret <> nil) and not m_sTargetCret.m_boDeath and (m_btSeriesSkillSetpCur < m_btSeriesSkillSetpMax) then
        begin

          wMagicId := m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId;
          UserMagic := m_MagicArr[0][wMagicId];
          if (UserMagic <> nil) then
          begin
            case wMagicId of
              104..107:
                begin
                  nAbsX := abs(m_nCurrX - m_sTargetCret.m_nCurrX);
                  nAbsY := abs(m_nCurrY - m_sTargetCret.m_nCurrY);
                  if (nAbsX <= g_Config.nMagicAttackRage) and (nAbsY <= g_Config.nMagicAttackRage) then
                  begin

                    sskilltick := 700;
                    case m_nLastSSkillID of
                      104: sskilltick := 06 * 92 - 040;
                      105: sskilltick := 10 * 88 - 030;
                      106: sskilltick := 08 * 88 - 040;
                      107: sskilltick := 13 * 72 - 080;
                    end;
                    if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                    begin
                      m_dwHitTick := GetTickCount();
                      m_dwTargetFocusTick := GetTickCount();
                      m_dwWalkTick := GetTickCount() + 300;
                      m_dwSpellTick := GetTickCount() + 800;
                      m_dwHeroSetTargetTick := GetTickCount + 300;
                      m_dwCloneSelfTick := GetTickCount - g_Config.dwCloneSelfTime + 2000;
                      Result := HeroDoSpell(UserMagic, m_sTargetCret, boTrainOk);
                      Inc(m_btSeriesSkillSetpCur);
                      m_nLastSSkillID := wMagicId;
                      if (m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax) or (m_sTargetCret = nil) or m_sTargetCret.m_boDeath then
                      begin
                        m_btReadySeriesSkill := 0;
                        m_nLastSSkillID := 0;
                        m_dwHitTick := GetTickCount() + 200;
                      end;
                      Exit;
                    end
                    else
                    begin
                      m_dwTargetFocusTick := GetTickCount();
                      m_dwWalkTick := GetTickCount() + 300;
                      m_dwSpellTick := GetTickCount() + 800;
                      m_dwHeroSetTargetTick := GetTickCount + 300;
                      m_dwCloneSelfTick := GetTickCount - g_Config.dwCloneSelfTime + 2000;
                      m_nTargetX := -1;
                      Exit;
                    end;
                  end
                  else
                  begin
                    if (m_btSeriesSkillSetpCur > 0) and (m_sTargetCret <> nil) then
                    begin
                      m_btReadySeriesSkill := 0;
                      m_nLastSSkillID := 0;
                    end;
                    if m_sTargetCret.m_PEnvir = m_PEnvir then
                      SetTargetXY(m_sTargetCret.m_nCurrX, m_sTargetCret.m_nCurrY);
                  end;
                end;
            end;
          end;
        end;
      end;

      nAbsX := abs(m_nCurrX - m_TargetCret.m_nCurrX);
      nAbsY := abs(m_nCurrY - m_TargetCret.m_nCurrY);

      //wizard
      if (m_MagicArr[0][114] <> nil) and (nAbsX < 8) and (nAbsY < 8) and (GetTickCount - m_dwLatestSmiteWideTick2 > _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000)) then
      begin
        if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
        begin
          m_dwLatestSmiteWideTick2 := GetTickCount;
          m_dwHitTick := GetTickCount();
          m_dwWalkTick := GetTickCount();
          btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          m_boSmiteWideSkill2 := True;
          m_dwTargetFocusTick := GetTickCount();
          AttackDir(m_TargetCret, 23, btDir);
          Result := True;
          Exit;
        end;
      end;

      if ((nAbsX > 2) or (nAbsY > 2) {or (Random(12) = 0)}) then
      begin
        if (nAbsX <= g_Config.nMagicAttackRage) and (nAbsY <= g_Config.nMagicAttackRage) then
        begin

          if ProcUniteAttack() then
          begin
            Result := True;
            Exit;
          end;

          if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
          begin
            m_dwHitTick := GetTickCount();
            if (m_MagicArr[0][75] <> nil) and (m_nMagShieldHP <= 0) then
            begin
              if GetTickCount - m_dwUnionHitShieldTick > 15 * 1000 then
              begin
                m_dwUnionHitShieldTick := GetTickCount;
                Result := HeroDoSpell(m_MagicArr[0][75], m_TargetCret, boTrainOk);
                Exit;
              end;
            end;

            if m_boStrike and IsHero and (m_MagicArr[0][74] <> nil) then
            begin
              if GetTickCount - m_dwCloneSelfTick > g_Config.dwCloneSelfTime then
              begin
                m_dwCloneSelfTick := GetTickCount();
                nCount := 0;
                for i := m_SlaveList.Count - 1 downto 0 do
                begin
                  if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_HERO then
                    Inc(nCount);
                end;
                if nCount < g_Config.nBodyCount then
                begin
                  m_dwTargetFocusTick := GetTickCount();
                  Result := HeroDoSpell(m_MagicArr[0][74], Self, boTrainOk);
                  m_boStrike := False;
                  Exit;
                end;
              end;
            end;

            if (m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] <= 0) and (m_MagicArr[0][31] <> nil) then
            begin
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][31], Self, boTrainOk);
              Exit;
            end;

            if (m_MagicArr[0][22] <> nil) then
            begin
              if (GetTagXYRangeCount(1, 6) >= 18) then
              begin
                if m_PEnvir.GetEvent(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY) = nil then
                begin
                  m_dwTargetFocusTick := GetTickCount();
                  Result := HeroDoSpell(m_MagicArr[0][22], m_TargetCret, boTrainOk);
                  Exit;
                end;
              end;
            end;

            if m_btMagPassTh > 0 then
            begin
              Dec(m_btMagPassTh);
              if (m_MagicArr[0][10] <> nil) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 8, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) > 0 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][10], m_TargetCret, boTrainOk);
                    Exit;
                  end;
                end;
              end;
              if (m_MagicArr[0][9] <> nil) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 5, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) > 0 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][9], m_TargetCret, boTrainOk);
                    Exit;
                  end;
                end;
              end;
            end;

            nTag := GetTagXYRangeCount(0, 1, 1);
            if nTag <= 1 then
            begin
              //ReGetMagID:

              if (m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and
                (m_MagicArr[0][10] <> nil) and
                (Random(10) > 2) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 8, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) >= 1 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][10], m_TargetCret, boTrainOk);
                    if m_btMagPassTh > 0 then
                      m_btMagPassTh := 0;
                    Exit;
                  end;
                end;
              end;

              if (m_TargetCret.m_Abil.Level < 50) and (m_TargetCret.m_Abil.Level + 10 < m_Abil.Level) and (m_TargetCret.m_btLifeAttrib = LA_UNDEAD) and (m_MagicArr[0][32] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][32], m_TargetCret, boTrainOk);
                Exit;
              end;
              if (m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (m_TargetCret.m_btJob = 0) and (Random(nAbsX + nAbsX) <= 2) and (m_TargetCret.m_Abil.Level + 3 < m_Abil.Level) and (m_MagicArr[0][44] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][44], m_TargetCret, boTrainOk);
                Exit;
              end;
              m_nCurMagId := 0;
              if m_MagicArr[0][11] <> nil then
                m_nCurMagId := 11
              else if m_MagicArr[0][5] <> nil then
                m_nCurMagId := 5
              else if m_MagicArr[0][1] <> nil then
                m_nCurMagId := 1;
              if (Random(6) > 3) and (m_MagicArr[0][45] <> nil) then
                m_nCurMagId := 45;
              if (m_nCurMagId > 0) and (m_MagicArr[0][m_nCurMagId] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][m_nCurMagId], m_TargetCret, boTrainOk);
                Exit;
              end;
            end;

            if nTag < 5 then
            begin
              if (m_MagicArr[0][10] <> nil) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 8, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) > 2 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][10], m_TargetCret, boTrainOk);
                    if m_btMagPassTh > 0 then
                      m_btMagPassTh := 0;
                    Exit;
                  end;
                end;
              end;
              if (m_MagicArr[0][9] <> nil) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 5, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) > 1 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][9], m_TargetCret, boTrainOk);
                    if m_btMagPassTh > 0 then
                      m_btMagPassTh := 0;
                    Exit;
                  end;
                end;
              end;
            end;

            m_nCurMagId := 0; //Èº¹¥...
            if Random(6) > 1 then
            begin
              if Random(5) > 1 then
              begin
                if (m_MagicArr[0][58] <> nil) then
                  m_nCurMagId := 58
                else if (m_MagicArr[0][33] <> nil) then
                  m_nCurMagId := 33;
              end
              else if (m_MagicArr[0][33] <> nil) then
                m_nCurMagId := 33;
            end
            else if (m_MagicArr[0][47] <> nil) then
              m_nCurMagId := 47;
            if (m_nCurMagId <= 0) and (m_MagicArr[0][23] <> nil) then
              m_nCurMagId := 23;
            if (m_nCurMagId > 0) and (m_MagicArr[0][m_nCurMagId] <> nil) then
            begin
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][m_nCurMagId], m_TargetCret, boTrainOk);
              Exit;
            end;

            //goto ReGetMagID;
            if (m_TargetCret.m_Abil.Level < 50) and (m_TargetCret.m_Abil.Level + 10 < m_Abil.Level) and (m_TargetCret.m_btLifeAttrib = LA_UNDEAD) and (m_MagicArr[0][32] <> nil) then
            begin
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][32], m_TargetCret, boTrainOk);
              Exit;
            end;
            //º®±ùÕÆ
            if (m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and (m_TargetCret.m_btJob = 0) and (nAbsX <= 4) and (nAbsY <= 4) and (m_TargetCret.m_Abil.Level + 3 < m_Abil.Level) and (m_MagicArr[0][44] <> nil) and (Random(3) = 0) then
            begin
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][44], m_TargetCret, boTrainOk);
              Exit;
            end;

            m_nCurMagId := 0; //µ¥¹¥...
            if m_MagicArr[0][11] <> nil then
              m_nCurMagId := 11
            else if m_MagicArr[0][5] <> nil then
              m_nCurMagId := 5
            else if m_MagicArr[0][1] <> nil then
              m_nCurMagId := 1;
            if (Random(6) > 3) and (m_MagicArr[0][45] <> nil) then
              m_nCurMagId := 45;
            if (m_nCurMagId > 0) and (m_MagicArr[0][m_nCurMagId] <> nil) then
            begin
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][m_nCurMagId], m_TargetCret, boTrainOk);
              Exit;
            end;
          end
          else
            m_nTargetX := -1;
        end
        else
        begin //0619
          if (m_TargetCret.m_PEnvir = m_PEnvir) then
            SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
          else
            DelTargetCreat();
        end;
      end
      else
      begin
        //¼ì²âÄ¿±êÍþÐ²ÐÔ....
        if m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          //if m_TargetCret.m_WAbil.HP <= 600 then begin
          case m_TargetCret.m_btJob of
            0:
              begin //Õ½Ê¿
                nPower := m_TargetCret.GetAttackPower(LoWord(m_TargetCret.m_WAbil.DC), SmallInt((HiWord(m_TargetCret.m_WAbil.DC) - LoWord(m_TargetCret.m_WAbil.DC))));
                nPower := GetHitStruckDamage(m_TargetCret, nPower);
                if (nPower = 0) or ((nPower < 9) and (m_WAbil.HP div 120 > nPower)) then
                begin
                  //SysMsg(format('%d %d', [m_WAbil.HP div 50, nPower]), c_Purple, t_Hint);
                  if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
                  begin
                    m_dwHitTick := GetTickCount();
                    goto FFFF;
                  end;
                  Result := True;
                  Exit;
                end;
              end;
          end;
          //end;
        end
        else
        begin
          nPower := m_TargetCret.GetAttackPower(LoWord(m_TargetCret.m_WAbil.DC), SmallInt((HiWord(m_TargetCret.m_WAbil.DC) - LoWord(m_TargetCret.m_WAbil.DC))));
          nPower := GetHitStruckDamage(m_TargetCret, nPower);
          if (nPower = 0) or ((nPower < 9) and (m_WAbil.HP div 100 > nPower)) then
          begin
            //SysMsg(format('%d %d', [m_WAbil.HP div 35, nPower]), c_Purple, t_Hint);
            if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
            begin
              m_dwHitTick := GetTickCount();
              goto DDDD;
            end;
            Result := True;
            Exit;
          end;
        end;

        if (nAbsX <= 1) and (nAbsY <= 1) then
        begin
          if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
          begin
            m_dwHitTick := GetTickCount();

            nTag := GetSelfRangeCount();
            if (nTag >= 4) then
            begin
              if (Random(12) = 0) and (m_MagicArr[0][24] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][24], m_TargetCret, boTrainOk);
                Exit;
              end;

              FFFF: //Ç¿¹¥...
              if (m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO]) and
                (m_MagicArr[0][10] <> nil) and
                (Random(10) > 2) then
              begin
                btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
                if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nNX, nNY) then
                begin
                  m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 8, nTX, nTY);
                  if CheckMagPassThrough(nNX, nNY, nTX, nTY, btDir) >= 1 then
                  begin
                    m_dwTargetFocusTick := GetTickCount();
                    Result := HeroDoSpell(m_MagicArr[0][10], m_TargetCret, boTrainOk);
                    if m_btMagPassTh > 0 then
                      m_btMagPassTh := 0;
                    Exit;
                  end;
                end;
              end;

              DDDD: //Ç¿¹¥...
              m_nCurMagId := 0; //Èº
              if Random(6) > 1 then
              begin
                if (m_MagicArr[0][58] <> nil) and (Random(5) > 1) then
                begin
                  m_nCurMagId := 58;
                end
                else if (m_MagicArr[0][33] <> nil) then
                  m_nCurMagId := 33;
              end
              else if (m_MagicArr[0][47] <> nil) then
                m_nCurMagId := 47;
              if (m_nCurMagId <= 0) and (m_MagicArr[0][23] <> nil) then
                m_nCurMagId := 23;
              if (m_nCurMagId > 0) and (m_MagicArr[0][m_nCurMagId] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][m_nCurMagId], m_TargetCret, boTrainOk);
                Exit;
              end;
              m_nCurMagId := 0; //µ¥
              if m_MagicArr[0][11] <> nil then
                m_nCurMagId := 11
              else if m_MagicArr[0][5] <> nil then
                m_nCurMagId := 5
              else if m_MagicArr[0][1] <> nil then
                m_nCurMagId := 1;
              if (Random(6) > 3) and (m_MagicArr[0][45] <> nil) then
                m_nCurMagId := 45;
              if (m_nCurMagId > 0) and (m_MagicArr[0][m_nCurMagId] <> nil) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][m_nCurMagId], m_TargetCret, boTrainOk);
                Exit;
              end;
            end;
            if (m_MagicArr[0][8] <> nil) and (m_Abil.Level > m_TargetCret.m_Abil.Level) then
            begin
              if m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
                nCount := 1
              else
                nCount := 2 + Random(2);
              if nTag >= nCount then
              begin //¿¹¾Ü±È½ÏÉÙÊ¹ÓÃ
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][8], m_TargetCret, boTrainOk);
                if Result then
                  Inc(m_btMagPassTh, 1 + Random(2));
                Exit;
              end;
            end;
          end;
        end;

        if (m_TargetCret.m_PEnvir = m_PEnvir) then
        begin
          m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          GetBackPosition(nX, nY);
          nTag := 0;
          while (True) do
          begin
            if m_PEnvir.CanWalk(nX, nY, False) then
              Break;
            Inc(m_btDirection);
            m_btDirection := m_btDirection mod 8;
            GetBackPosition(nX, nY);
            Inc(nTag);
            if nTag > 8 then
              Break;
          end;
          if m_PEnvir.CanWalk(nX, nY, False) then
          begin
            GetBackPosition2(nTX, nTY);
            if m_PEnvir.CanWalk(nTX, nTY, False) then
            begin //run away...
              nX := nTX;
              nY := nTY;
            end;
          end
          else if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
          begin //Ç¿¹¥...
            m_dwHitTick := GetTickCount();
            nTag := 1;
            goto DDDD;
          end;
          SetTargetXY(nX, nY);
          //labLoop2:
          {if ((abs(nX - m_Master.m_nCurrX) < 10) and (abs(nY - m_Master.m_nCurrY) < 10)) then begin
            SetTargetXY(nX, nY);
          end else
            DelTargetCreat();}
        end
        else
          DelTargetCreat();
      end;
    end;
  end
  else if m_TargetCret <> nil then
  begin
    if GetAttackDir(m_TargetCret, btDir) then
    begin
      if g_Config.boCalcHeroHitSpeed then
        dwAttackTime := _MAX(350, Integer(m_nNextHitTime) - (_MIN(g_Config.nHeroHitSpeedMax, m_nHitSpeed) * g_Config.ClientConf.btItemSpeed div 2))
      else
        dwAttackTime := m_nNextHitTime;
      if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
      begin
        m_dwHitTick := GetTickCount();
        m_dwTargetFocusTick := GetTickCount();
        Attack(m_TargetCret, btDir);
        BreakHolySeizeMode();
      end;
      Result := True;
    end
    else if m_TargetCret.m_PEnvir = m_PEnvir then
      SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
    else
      DelTargetCreat();
  end;
end;

function TPlayObject.__Taos__HeroAttackTarget(): Boolean;
var
  boTrainOk: Boolean;
  btDir: Byte;
  i, ii, n, nX, nY, nTX, nTY, nTag, nAmuletIdx: Integer;
  UserMagic: pTUserMagic;
  dwAttackTime, sskilltick: LongWord;
  StdItem: pTStdItem;
  nAbsX, nAbsY, nPower: Integer;
  wMagicId: Word;
  Hero: TBaseObject;
label
  labWidAttack {, NorAttack};

  function AutoChagnePoison(nType: Integer): Boolean;
  begin
    Result := True;
    case nType of
      1: if not AutoTakeOnItem(U_ARMRINGL, '»ÆÉ«Ò©·Û(´óÁ¿)') and not AutoTakeOnItem(U_ARMRINGL, '»ÆÉ«Ò©·Û(ÖÐÁ¿)') and not AutoTakeOnItem(U_ARMRINGL, '»ÆÉ«Ò©·Û(ÉÙÁ¿)') then
        begin
          if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
          begin
            m_dwHintMsgTick := GetTickCount();
            SysMsg('°ü¹ü»òÉíÉÏÃ»ÓÐ»ÆÉ«Ò©·Û£¡', c_Purple, t_Hint);
          end;
        end
        else
          Result := False;
      2: if not AutoTakeOnItem(U_ARMRINGL, '»ÒÉ«Ò©·Û(´óÁ¿)') and not AutoTakeOnItem(U_ARMRINGL, '»ÒÉ«Ò©·Û(ÖÐÁ¿)') and not AutoTakeOnItem(U_ARMRINGL, '»ÒÉ«Ò©·Û(ÉÙÁ¿)') then
        begin
          if GetTickCount - m_dwHintMsgTick > 30 * 1000 then
          begin
            m_dwHintMsgTick := GetTickCount();
            SysMsg('°ü¹ü»òÉíÉÏÃ»ÓÐ»ÒÉ«Ò©·Û£¡', c_Purple, t_Hint);
          end;
        end
        else
          Result := False;
    end;
  end;
begin
  Result := False;
  boTrainOk := False;

  if (m_Abil.Level < 18)
    or (((m_MagicArr[0][4] <> nil)) and
    m_boNorAttack and
    (m_TargetCret <> nil) and
    (m_TargetCret.m_Abil.Level + 5 < m_Abil.Level)) then
  begin

    if (Integer(GetTickCount - m_dwSpellTick)) > (m_nNextHitTime * 3) then
    begin
      m_dwSpellTick := GetTickCount();
      if (m_MagicArr[0][2] <> nil) then
      begin
        Hero := GetHeroObjectA;
        if Hero <> nil then
        begin
          if (abs(m_nCurrX - Hero.m_nCurrX) <= g_Config.nMagicAttackRage)
            and (abs(m_nCurrY - Hero.m_nCurrY) <= g_Config.nMagicAttackRage) then
          begin
            if (Round(Hero.m_WAbil.HP / Hero.m_WAbil.MaxHP * 100) <= 80) then
            begin
              Result := HeroDoSpell(m_MagicArr[0][2], Hero, boTrainOk);
              m_dwHitTick := GetTickCount();
              Exit;
            end;
          end;
        end;
        if (Round(m_WAbil.HP / m_WAbil.MaxHP * 100) <= 80) then
        begin
          Result := HeroDoSpell(m_MagicArr[0][2], Self, boTrainOk);
          m_dwHitTick := GetTickCount();
          Exit;
        end;
      end;
    end;
    //NorAttack:
    if m_TargetCret <> nil then
    begin
      if GetAttackDir(m_TargetCret, btDir) then
      begin
        if g_Config.boCalcHeroHitSpeed then
          dwAttackTime := _MAX(350, Integer(m_nNextHitTime) - (_MIN(g_Config.nHeroHitSpeedMax, m_nHitSpeed) * g_Config.ClientConf.btItemSpeed div 2))
        else
          dwAttackTime := m_nNextHitTime;
        if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
        begin
          m_dwHitTick := GetTickCount();
          m_dwTargetFocusTick := GetTickCount();
          Attack(m_TargetCret, btDir);
          BreakHolySeizeMode();
          if m_boNorAttack then
          begin
            //if ((m_MagicArr[0][13] = nil) or (m_MagicArr[0][13].btKey <> 0)) and ((m_MagicArr[0][57] = nil) or (m_MagicArr[0][57].btKey <> 0)) then begin
            //if Random(10) > 3 then
            m_boNorAttack := False;
            //end;
          end;
        end;
        Result := True;
      end
      else if m_TargetCret.m_PEnvir = m_PEnvir then
        SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
      else
        DelTargetCreat();
    end;
  end
  else
  begin
    if (Integer(GetTickCount - m_dwSpellTick)) > (m_nNextHitTime * 3) then
    begin
      m_dwSpellTick := GetTickCount();
      if {(m_Master <> nil) and}(m_SlaveList.Count <= 0) then
      begin
        UserMagic := nil;
        if (m_MagicArr[0][55] <> nil) then
          UserMagic := m_MagicArr[0][55]
        else if (m_MagicArr[0][30] <> nil) then
          UserMagic := m_MagicArr[0][30]
        else if (m_MagicArr[0][17] <> nil) then
          UserMagic := m_MagicArr[0][17];
        if (UserMagic <> nil) then
        begin
          Result := HeroDoSpell(UserMagic, Self, boTrainOk);
          m_dwHitTick := GetTickCount();
          Exit;
        end;
      end;

      //MAGDEFENCEUP
      if (m_MagicArr[0][14] <> nil) then
      begin
        Hero := GetHeroObjectA;
        if Hero <> nil then
        begin
          if (Hero.m_wStatusTimeArr[STATE_MAGDEFENCEUP] <= 0) then
          begin
            Result := HeroDoSpell(m_MagicArr[0][14], Hero, boTrainOk);
            m_dwHitTick := GetTickCount();
            Exit;
          end;
        end;
        if (m_wStatusTimeArr[STATE_MAGDEFENCEUP] <= 0) then
        begin
          Result := HeroDoSpell(m_MagicArr[0][14], Self, boTrainOk);
          m_dwHitTick := GetTickCount();
          Exit;
        end;
      end;
      //DEFENCEUP
      if (m_MagicArr[0][15] <> nil) then
      begin
        Hero := GetHeroObjectA;
        if Hero <> nil then
        begin
          if (Hero.m_wStatusTimeArr[STATE_DEFENCEUP] <= 0) then
          begin
            Result := HeroDoSpell(m_MagicArr[0][15], Hero, boTrainOk);
            m_dwHitTick := GetTickCount();
            Exit;
          end;
        end;
        if (m_wStatusTimeArr[STATE_DEFENCEUP] <= 0) then
        begin
          Result := HeroDoSpell(m_MagicArr[0][15], Self, boTrainOk);
          m_dwHitTick := GetTickCount();
          Exit;
        end;
      end;
      //Healling
      if (m_MagicArr[0][2] <> nil) then
      begin
        Hero := GetHeroObjectA;
        if Hero <> nil then
        begin
          if (abs(m_nCurrX - Hero.m_nCurrX) <= g_Config.nMagicAttackRage)
            and (abs(m_nCurrY - Hero.m_nCurrY) <= g_Config.nMagicAttackRage) then
          begin
            if (Round(Hero.m_WAbil.HP / Hero.m_WAbil.MaxHP * 100) <= 80) then
            begin
              Result := HeroDoSpell(m_MagicArr[0][2], Hero, boTrainOk);
              m_dwHitTick := GetTickCount();
              Exit;
            end;
          end;
        end;
        if (Round(m_WAbil.HP / m_WAbil.MaxHP * 100) <= 80) then
        begin
          Result := HeroDoSpell(m_MagicArr[0][2], Self, boTrainOk);
          m_dwHitTick := GetTickCount();
          Exit;
        end;
        if m_SlaveList.Count > 0 then
        begin
          for ii := 0 to m_SlaveList.Count - 1 do
          begin
            if (abs(m_nCurrX - TBaseObject(m_SlaveList.Items[ii]).m_nCurrX) <= g_Config.nMagicAttackRage)
              and (abs(m_nCurrY - TBaseObject(m_SlaveList.Items[ii]).m_nCurrY) <= g_Config.nMagicAttackRage) then
            begin
              if (Round(TBaseObject(m_SlaveList.Items[ii]).m_WAbil.HP / TBaseObject(m_SlaveList.Items[ii]).m_WAbil.MaxHP * 100) <= 60) then
              begin
                Result := HeroDoSpell(m_MagicArr[0][2], TBaseObject(m_SlaveList.Items[ii]), boTrainOk);
                m_dwHitTick := GetTickCount();
                Exit;
              end;
            end;
          end;
        end;
      end;
    end;

    if m_TargetCret = nil then
    begin
      if Integer(GetTickCount - m_dwHitTick) > (m_nNextHitTime) then
      begin
        m_dwHitTick := GetTickCount();
        //UNAMYOUNSUL
        if (m_MagicArr[0][34] <> nil) then
        begin
          Hero := GetHeroObjectA;
          if Hero <> nil then
          begin
            if (Hero.m_wStatusTimeArr[POISON_DECHEALTH] <> 0) or (Hero.m_wStatusTimeArr[POISON_DAMAGEARMOR] <> 0) or (Hero.m_wStatusTimeArr[POISON_STONE] <> 0) then
            begin
              Result := HeroDoSpell(m_MagicArr[0][34], Hero, boTrainOk);
              m_dwSpellTick := GetTickCount();
              Exit;
            end;
          end;
          if (m_wStatusTimeArr[POISON_DECHEALTH] <> 0) or (m_wStatusTimeArr[POISON_DAMAGEARMOR] <> 0) or (m_wStatusTimeArr[POISON_STONE] <> 0) then
          begin
            Result := HeroDoSpell(m_MagicArr[0][34], Self, boTrainOk);
            m_dwSpellTick := GetTickCount();
            Exit;
          end;
        end;
        //BigHealling
        if (m_MagicArr[0][29] <> nil) then
        begin
          Hero := GetHeroObjectA;
          if Hero <> nil then
          begin
            if (abs(m_nCurrX - Hero.m_nCurrX) <= g_Config.nMagicAttackRage)
              and (abs(m_nCurrY - Hero.m_nCurrY) <= g_Config.nMagicAttackRage) then
            begin
              if (Round(Hero.m_WAbil.HP / Hero.m_WAbil.MaxHP * 100) <= 80) and (Round(m_WAbil.HP / m_WAbil.MaxHP * 100) <= 80) then
              begin
                Result := HeroDoSpell(m_MagicArr[0][29], Self, boTrainOk);
                Exit;
              end
              else
                //m_boBigHealling := False;
            end;
          end;
        end;
      end;
    end
    else
    begin

      // ========= series skill =========
      if ProperTarget() then
      begin
        if (m_nInPowerLevel > 0) and
          (m_nInPowerPoint > 20) and
          (m_btReadySeriesSkill = 1) and
          (m_btSeriesSkillSetpMax in [1..4]) then
        begin

          m_btReadySeriesSkill := 2; //fired ...
          m_dwReadySeriesSkillTick := GetTickCount;

          m_sTargetCret := m_TargetCret;
          m_btSeriesSkillSetpCur := 0;
          m_nLastSSkillID := 0;
        end;

        if (m_btReadySeriesSkill = 2) and (m_sTargetCret <> nil) and not m_sTargetCret.m_boDeath and (m_btSeriesSkillSetpCur < m_btSeriesSkillSetpMax) then
        begin
          //MainOutMessageAPI('m_btReadySeriesSkill');
          wMagicId := m_SeriesSkillArr2[m_btSeriesSkillSetpCur].wMagicId;
          UserMagic := m_MagicArr[0][wMagicId];
          if (UserMagic <> nil) then
          begin
            case wMagicId of
              108..111:
                begin
                  nAbsX := abs(m_nCurrX - m_sTargetCret.m_nCurrX);
                  nAbsY := abs(m_nCurrY - m_sTargetCret.m_nCurrY);
                  if (nAbsX <= g_Config.nMagicAttackRage) and (nAbsY <= g_Config.nMagicAttackRage) then
                  begin
                    sskilltick := 700;
                    case m_nLastSSkillID of
                      108: sskilltick := 06 * 95 - 020;
                      109: sskilltick := 12 * 78 - 050;
                      110: sskilltick := 12 * 78 - 045;
                      111: sskilltick := 14 * 65 - 052;
                    end;
                    //SysMsg(format('%d %d', [m_nLastSSkillID, sskilltick]), c_Red, t_Hint);
                    if Integer(GetTickCount - m_dwHitTick) > sskilltick then
                    begin
                      m_dwHitTick := GetTickCount();
                      m_dwTargetFocusTick := GetTickCount();
                      m_dwWalkTick := GetTickCount() + 300;
                      m_dwSpellTick := GetTickCount() + 800;
                      m_dwHeroSetTargetTick := GetTickCount + 300;
                      Result := HeroDoSpell(UserMagic, m_sTargetCret, boTrainOk);
                      m_nLastSSkillID := wMagicId;
                      Inc(m_btSeriesSkillSetpCur);
                      if (m_btSeriesSkillSetpCur >= m_btSeriesSkillSetpMax) or (m_sTargetCret = nil) or m_sTargetCret.m_boDeath then
                      begin
                        m_btReadySeriesSkill := 0;
                        m_nLastSSkillID := 0;
                        m_dwHitTick := GetTickCount() + 200;
                      end;
                      Exit;
                    end
                    else
                    begin
                      m_dwTargetFocusTick := GetTickCount();
                      m_dwWalkTick := GetTickCount() + 300;
                      m_dwSpellTick := GetTickCount() + 800;
                      m_dwHeroSetTargetTick := GetTickCount + 300;
                      m_nTargetX := -1;
                      Exit;
                    end;
                  end
                  else
                  begin
                    if (m_btSeriesSkillSetpCur > 0) and (m_sTargetCret <> nil) then
                    begin
                      m_btReadySeriesSkill := 0;
                      m_nLastSSkillID := 0;
                    end;
                    if m_sTargetCret.m_PEnvir = m_PEnvir then
                      SetTargetXY(m_sTargetCret.m_nCurrX, m_sTargetCret.m_nCurrY);
                  end;
                end;
            end;
          end;
        end;
      end;

      if (m_MagicArr[0][75] <> nil) and (m_nMagShieldHP <= 0) then
      begin
        if GetTickCount - m_dwUnionHitShieldTick > 15 * 1000 then
        begin
          m_dwUnionHitShieldTick := GetTickCount;
          m_dwTargetFocusTick := GetTickCount();
          Result := HeroDoSpell(m_MagicArr[0][75], m_TargetCret, boTrainOk);
          Exit;
        end;
      end;

      nAbsX := abs(m_nCurrX - m_TargetCret.m_nCurrX);
      nAbsY := abs(m_nCurrY - m_TargetCret.m_nCurrY);

      //taos
      if (m_MagicArr[0][114] <> nil) and (nAbsX <= 6) and (nAbsY <= 6) and (GetTickCount - m_dwLatestSmiteWideTick2 > _MAX(5 * 1000, g_Config.nSmiteWideHitSkillInvTime - m_btReduceSpellTime * 1000)) then
      begin
        if Integer(GetTickCount - m_dwHitTick) > dwAttackTime then
        begin
          m_dwHitTick := GetTickCount();
          m_dwWalkTick := GetTickCount();
          m_dwLatestSmiteWideTick2 := GetTickCount;
          btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          m_boSmiteWideSkill2 := True;
          m_dwTargetFocusTick := GetTickCount();
          AttackDir(m_TargetCret, 23, btDir);
          Result := True;
          Exit;
        end;
      end;

      if (nAbsX > 2) or (nAbsY > 2) then
      begin
        if (nAbsX <= g_Config.nMagicAttackRage) and (nAbsY <= g_Config.nMagicAttackRage) then
        begin
          if ProcUniteAttack() then
          begin
            Result := True;
            Exit;
          end;
          if Integer(GetTickCount - m_dwHitTick) > (m_nNextHitTime) then
          begin
            m_dwHitTick := GetTickCount();
            labWidAttack:
            //DoubluSC
            if (m_MagicArr[0][50] <> nil) then
            begin
              if m_wStatusArrValue[2] <= 0 then
              begin
                if GetTickCount - m_dwDoubleScTick > g_Config.DoubleScInvTime * 1000 then
                begin
                  m_dwTargetFocusTick := GetTickCount();
                  Result := HeroDoSpell(m_MagicArr[0][50], Self, boTrainOk);
                  m_dwSpellTick := GetTickCount();
                  Exit;
                end;
              end;
            end;

            //DECHEALTH & DAMAGEARMOR
            if ((m_MagicArr[0][6] <> nil)) or ((m_MagicArr[0][38] <> nil)) then
            begin
              if (m_TargetCret.m_wStatusTimeArr[POISON_DECHEALTH] <= 0) then
              begin
                if g_Config.boHeroNeedAmulet then
                begin
                  if CheckAmulet({TPlayObject(self),} 1, 2, nAmuletIdx) then
                  begin
                    StdItem := UserEngine.GetStdItem(m_UseItems[nAmuletIdx].wIndex);
                    if StdItem <> nil then
                    begin
                      if (StdItem.Shape = 1) then
                      begin
                        if (GetTagXYRangeCount(0, 1) > 2) then
                        begin
                          if (m_MagicArr[0][38] <> nil) then
                          begin
                            Result := HeroDoSpell(m_MagicArr[0][38], m_TargetCret, boTrainOk);
                            if g_Config.boTaosHeroAutoChangePoison and boTrainOk then
                              AutoChagnePoison(1);
                            m_dwTargetFocusTick := GetTickCount();
                            if Result then
                            begin
                              m_dwSpellTick := GetTickCount();
                              Exit;
                            end;
                          end;
                        end
                        else
                        begin
                          if (m_MagicArr[0][6] <> nil) then
                          begin
                            Result := HeroDoSpell(m_MagicArr[0][6], m_TargetCret, boTrainOk);
                            if g_Config.boTaosHeroAutoChangePoison and boTrainOk then
                              AutoChagnePoison(1);
                            m_dwTargetFocusTick := GetTickCount();
                            if Result then
                            begin
                              m_dwSpellTick := GetTickCount();
                              Exit;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end
                else
                begin
                  if m_btUseAmulet = 1 then
                  begin
                    if (GetTagXYRangeCount(0, 1) > 2) then
                    begin
                      if (m_MagicArr[0][38] <> nil) then
                      begin
                        //MainOutMessageAPI('HeroDoSpell: 38' + BoolToStr(Result));

                        Result := HeroDoSpell(m_MagicArr[0][38], m_TargetCret, boTrainOk);
                        if boTrainOk then
                          m_btUseAmulet := 2;
                        m_dwTargetFocusTick := GetTickCount();
                        if Result then
                        begin
                          m_dwSpellTick := GetTickCount();
                          Exit;
                        end;
                      end;
                    end
                    else
                    begin
                      if (m_MagicArr[0][6] <> nil) then
                      begin
                        //MainOutMessageAPI('HeroDoSpell: 6 -> ' + BoolToStr(Result));
                        Result := HeroDoSpell(m_MagicArr[0][6], m_TargetCret, boTrainOk);
                        if boTrainOk then
                          m_btUseAmulet := 2;
                        m_dwTargetFocusTick := GetTickCount();
                        if Result then
                        begin
                          m_dwSpellTick := GetTickCount();
                          Exit;
                        end;
                      end;
                    end;
                  end;
                end;
              end;

              if (m_TargetCret.m_wStatusTimeArr[POISON_DAMAGEARMOR] <= 0) then
              begin
                if g_Config.boHeroNeedAmulet then
                begin
                  if not CheckAmulet({TPlayObject(self),} 1, 2, nAmuletIdx) then
                    AutoChagnePoison(1);
                  if CheckAmulet({TPlayObject(self),} 1, 2, nAmuletIdx) then
                  begin
                    StdItem := UserEngine.GetStdItem(m_UseItems[nAmuletIdx].wIndex);
                    if StdItem <> nil then
                    begin
                      if (StdItem.Shape = 2) then
                      begin
                        if (GetTagXYRangeCount(0, 1) > 2) then
                        begin
                          if (m_MagicArr[0][38] <> nil) then
                          begin
                            Result := HeroDoSpell(m_MagicArr[0][38], m_TargetCret, boTrainOk);
                            if g_Config.boTaosHeroAutoChangePoison and boTrainOk then
                              AutoChagnePoison(2);
                            m_dwTargetFocusTick := GetTickCount();
                            if Result then
                            begin
                              m_dwSpellTick := GetTickCount();
                              Exit;
                            end;
                          end;
                        end
                        else
                        begin
                          if (m_MagicArr[0][6] <> nil) then
                          begin
                            Result := HeroDoSpell(m_MagicArr[0][6], m_TargetCret, boTrainOk);
                            if g_Config.boTaosHeroAutoChangePoison and boTrainOk then
                              AutoChagnePoison(2);
                            m_dwTargetFocusTick := GetTickCount();
                            if Result then
                            begin
                              m_dwSpellTick := GetTickCount();
                              Exit;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end
                else
                begin
                  if m_btUseAmulet = 2 then
                  begin
                    if (GetTagXYRangeCount(0, 1) > 2) then
                    begin
                      if (m_MagicArr[0][38] <> nil) then
                      begin
                        //MainOutMessageAPI('HeroDoSpell: 382 ' + BoolToStr(Result));
                        Result := HeroDoSpell(m_MagicArr[0][38], m_TargetCret, boTrainOk);

                        if boTrainOk then
                          m_btUseAmulet := 1;
                        m_dwTargetFocusTick := GetTickCount();
                        if Result then
                        begin
                          m_dwSpellTick := GetTickCount();
                          Exit;
                        end;
                      end;
                    end
                    else
                    begin
                      if (m_MagicArr[0][6] <> nil) then
                      begin
                        Result := HeroDoSpell(m_MagicArr[0][6], m_TargetCret, boTrainOk);
                        if boTrainOk then
                          m_btUseAmulet := 1;
                        m_dwTargetFocusTick := GetTickCount();
                        if Result then
                        begin
                          m_dwSpellTick := GetTickCount();
                          Exit;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;

            if (m_MagicArr[0][18] <> nil) and (m_wStatusTimeArr[STATE_TRANSPARENT] <= 0) and (Random(10) = 0) then
            begin
              if (GetTagXYRangeCount(1, 7, 2) >= 8) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                Result := HeroDoSpell(m_MagicArr[0][18], Self, boTrainOk);
                if Result then
                  Exit;
              end;
            end;

            if ((m_MagicArr[0][13] <> nil)) or ((m_MagicArr[0][57] <> nil)) then
            begin

              //MainOutMessageAPI('HeroDoSpell: 57  ' + BoolToStr(Result));
              if (m_MagicArr[0][57] <> nil) and (((Round(m_WAbil.HP / m_WAbil.MaxHP * 100) < 80) and (Random(100 - Round(m_WAbil.HP / m_WAbil.MaxHP * 100)) > 5)) or (Random(10) > 6)) then
              begin
                m_dwTargetFocusTick := GetTickCount();
                if m_MagicArr[0][57] <> nil then
                begin
                  //MainOutMessageAPI('HeroDoSpell: 5722  ' + BoolToStr(Result));
                  HeroDoSpell(m_MagicArr[0][57], m_TargetCret, boTrainOk);
                  if not m_boNorAttack and ((m_MagicArr[0][4] <> nil)) and (m_TargetCret.m_Abil.Level + 5 < m_Abil.Level) then
                    if GetAttackDir(m_TargetCret, btDir) and (Random(10) > 2) then
                    begin
                      m_dwHitTick := 0;
                      m_boNorAttack := True;
                    end;
                  Result := True;
                  Exit;
                end;
              end;

              //MainOutMessageAPI('HeroDoSpell: 13  ' + BoolToStr(Result));
              if (m_MagicArr[0][13] <> nil) {and MagCanHitTarget(m_nCurrX, m_nCurrY, m_TargetCret)} then
              begin
                m_dwTargetFocusTick := GetTickCount();
                //MainOutMessageAPI('HeroDoSpell: 1322  ' + BoolToStr(Result));
                HeroDoSpell(m_MagicArr[0][13], m_TargetCret, boTrainOk);
                if not m_boNorAttack and ((m_MagicArr[0][4] <> nil)) and (m_TargetCret.m_Abil.Level + 5 < m_Abil.Level) then
                  if GetAttackDir(m_TargetCret, btDir) and (Random(10) > 2) then
                  begin
                    m_dwHitTick := 0;
                    m_boNorAttack := True;
                  end;
                Result := True;
                Exit;
              end;
            end;
          end
          else
            m_nTargetX := -1;
        end
        else
        begin
          if (m_TargetCret.m_PEnvir = m_PEnvir) then
            SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY)
          else
            DelTargetCreat();
        end;
      end
      else
      begin
        //¼ì²âÄ¿±êÍþÐ²ÐÔ....

        if m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HERO] then
        begin
          //if m_TargetCret.m_WAbil.HP <= 600 then begin
          case m_TargetCret.m_btJob of
            0:
              begin //Õ½Ê¿
                nPower := m_TargetCret.GetAttackPower(LoWord(m_TargetCret.m_WAbil.DC), SmallInt((HiWord(m_TargetCret.m_WAbil.DC) - LoWord(m_TargetCret.m_WAbil.DC))));
                nPower := GetHitStruckDamage(m_TargetCret, nPower);
                if (nPower = 0) or ((nPower < 15) and (m_WAbil.HP div 120 > nPower)) then
                begin
                  //SysMsg(format('%d %d', [m_WAbil.HP div 50, nPower]), c_Purple, t_Hint);
                  if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
                  begin
                    m_dwHitTick := GetTickCount();
                    goto labWidAttack;
                  end;
                  Result := True;
                  Exit;
                end;
              end;
            //end;
          end;
        end
        else
        begin
          nPower := m_TargetCret.GetAttackPower(LoWord(m_TargetCret.m_WAbil.DC), SmallInt((HiWord(m_TargetCret.m_WAbil.DC) - LoWord(m_TargetCret.m_WAbil.DC))));
          nPower := GetHitStruckDamage(m_TargetCret, nPower);
          if (nPower = 0) or ((nPower < 15) and (m_WAbil.HP div 100 > nPower)) then
          begin
            //SysMsg(format('%d %d', [m_WAbil.HP div 35, nPower]), c_Purple, t_Hint);
            if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
            begin
              m_dwHitTick := GetTickCount();
              goto labWidAttack;
            end;
            Result := True;
            Exit;
          end;
        end;

        if ((abs(m_nCurrX - m_TargetCret.m_nCurrX) <= 1) and (abs(m_nCurrY - m_TargetCret.m_nCurrY) <= 1)) then
        begin
          if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
          begin
            m_dwHitTick := GetTickCount();
            //nTag := GetTagXYRangeCount(1, 1, 1);
            nTag := GetSelfRangeCount();
            if (nTag >= 5) then
            begin //¹ÖÌ«¶à,Ç¿¹¥½âÎ§...
              goto labWidAttack;
            end;
            if (m_MagicArr[0][48] <> nil) and (m_Abil.Level > m_TargetCret.m_Abil.Level) and ((nTag >= 2) or (m_TargetCret.m_btRaceServer = RC_PLAYOBJECT)) then
            begin //¿¹¾Ü...
              m_dwTargetFocusTick := GetTickCount();
              Result := HeroDoSpell(m_MagicArr[0][48], m_TargetCret, boTrainOk);
              m_dwSpellTick := GetTickCount();
              Exit;
            end;
          end;
        end;

        if (m_TargetCret.m_PEnvir = m_PEnvir) then
        begin
          m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);

          GetBackPosition(nX, nY);
          nTag := 0;
          while (True) do
          begin
            if m_PEnvir.CanWalk(nX, nY, False) then
              Break;
            Inc(m_btDirection);
            m_btDirection := m_btDirection mod 8;
            GetBackPosition(nX, nY);
            Inc(nTag);
            if nTag > 8 then
              Break;
          end;
          if m_PEnvir.CanWalk(nX, nY, False) then
          begin
            GetBackPosition2(nTX, nTY);
            if m_PEnvir.CanWalk(nTX, nTY, False) then
            begin //run away...
              nX := nTX;
              nY := nTY;
            end;
          end
          else if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
          begin //Ç¿¹¥...
            m_dwHitTick := GetTickCount;
            goto labWidAttack;
          end;
          SetTargetXY(nX, nY);
          {if ((abs(nX - m_Master.m_nCurrX) < 10) and (abs(nY - m_Master.m_nCurrY) < 10)) then begin
            SetTargetXY(nX, nY);
          end else
            DelTargetCreat();}
        end
        else
          DelTargetCreat();
      end;
    end;
  end;
end;

function TPlayObject.AttackTarget(): Boolean;
begin
  Result := False;
  case m_btJob of
    0: Result := __Warr__HeroAttackTarget;
    1: Result := __Wiza__HeroAttackTarget;
    2: Result := __Taos__HeroAttackTarget;
  end;
  if Result then
  begin
    m_nTargetX := -1;
    m_nTargetY := -1;
  end;
end;

function TPlayObject.RuntoTargetXY(btDir: Byte; boFlag: Boolean): Boolean;
var
  dwTick: DWORD;
  n24, nOldX, nOldY: Integer;
  boInSafeZone: Boolean;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::RuntoTargetXY';
begin
  Result := False;
  if not (btDir in [0..7]) then
    Exit;

  if (m_nCurrX = m_nTargetX) and (m_nCurrY = m_nTargetY) then
  begin
    Exit;
  end;
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY - 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY - 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY - 2, m_boInSafeZone) > 0) then
          begin
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY - 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY - 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY - 2, m_boInSafeZone) > 0) then
          begin
            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY, m_boInSafeZone) > 0) then
          begin
            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_MapHeader.wWidth - 2) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX + 1, m_nCurrY + 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX + 2, m_nCurrY + 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY + 2, m_boInSafeZone) > 0) then
          begin
            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY + 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX, m_nCurrY + 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY + 2, m_boInSafeZone) > 0) then
          begin
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_MapHeader.wHeight - 2) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY + 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY + 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY + 2, m_boInSafeZone) > 0) then
          begin
            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 1) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY, m_boInSafeZone) > 0) then
          begin
            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY > 1) and
            m_PEnvir.CanWalk(m_nCurrX - 1, m_nCurrY - 1, m_boInSafeZone) and
            m_PEnvir.CanWalk(m_nCurrX - 2, m_nCurrY - 2, m_boInSafeZone) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY - 2, m_boInSafeZone) > 0) then
          begin
            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if (m_nCurrX <> nOldX) or (m_nCurrY <> nOldY) then
    begin
      if Walk(RM_RUN) then
      begin
        if m_boTransparent and m_boHideMode then
          m_wStatusTimeArr[STATE_TRANSPARENT] := 1;

        if (m_btRaceServer = RC_HERO) or ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) then
        begin
          dwTick := GetTickCount;
          if (IsHero or ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay)) and (TPlayObject(Self).m_btReadySeriesSkill = 2) then
            TPlayObject(Self).m_dwHitTick := dwTick
          else if g_Config.boHeroHitCmp then
          begin
            n24 := (dwTick - m_dwHitTick - m_nNextHitTime);
            if n24 <= 0 then
            begin
              case m_btJob of //m_nNextHitTime
                0: m_dwHitTick := dwTick + n24 + g_Config.nWarrCmpInvTime;
                1: m_dwHitTick := dwTick + n24 + g_Config.nWizaCmpInvTime;
                2: m_dwHitTick := dwTick + n24 + g_Config.nTaosCmpInvTime;
              end;
            end;
          end;
        end;
        Result := True;
        if g_Config.boHeroRecalcWalkTick and (m_TargetCret <> nil) and m_TargetCret.IsHero and IsProperTarget(m_TargetCret) then
          m_TargetCret.m_dwWalkTick := GetTickCount - m_nWalkSpeed div 2; //m_TargetCret.m_dwWalkTick := 0;
      end
      else
      begin
        //½â¾ö·½·¨ 1
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nOldX, nOldY, True) > 0 then
        begin //0628
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
        end
        else
        begin
          MainOutMessageAPI('[Error] TPlayObject.RuntoTargetXY MovingOBject :' + m_PEnvir.m_sMapFileName + ':' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY));
        end;

      end;
    end;
  except
    MainOutMessageAPI(sExceptionMsg);
  end;
end;

procedure TPlayObject.Run2();
var
  Hero: TBaseObject;
begin
  if (m_sTargetCret <> nil) then
  begin
    if ((GetTickCount - m_dwTargetFocusTick) > 30 * 1000) or m_sTargetCret.m_boDeath or m_sTargetCret.m_boGhost or (m_sTargetCret.m_PEnvir <> m_PEnvir) or (abs(m_sTargetCret.m_nCurrX - m_nCurrX) > 15) or (abs(m_sTargetCret.m_nCurrY - m_nCurrY) > 15) then
      m_sTargetCret := nil;
  end;

  if not m_boGhost and not m_boDeath and not m_boFixedHideMode and not m_boStoneMode and (m_wStatusTimeArr[POISON_STONE] = 0) and (m_wStatusTimeArr[POISON_PURPLE] = 0) then
  begin

    Hero := GetHeroObjectA;
    if (Hero <> nil) and not Hero.m_boDeath then
    begin
      if GetTickCount - m_dwRecallHeroTick > 8000 then
      begin
        if (m_HeroObject.m_Abil.HP <> 0) and (Round((m_HeroObject.m_Abil.HP / m_HeroObject.m_Abil.MaxHP) * 100) < 10) then
        begin
          SendMsg(Self, CM_UNRECALLHERO, 0, 0, 0, 0, '');
        end;
      end;
    end
    else
    begin
      if GetTickCount - m_dwRecallHeroTick > g_Config.nRecallHeroIntervalTime * 1000 then
      begin
        SendMsg(Self, CM_RECALLHERO, 0, 0, 0, 0, '');
      end;
    end;

    if (m_btReadySeriesSkill in [0, 2]) and (m_nInPowerLevel > 0) then
    begin
      if (GetTickCount - m_dwReadySeriesSkillTick > _MAX(12 * 1000, g_Config.nSeriesSkillReleaseInvTime - m_btReduceSpellTime * 1000)) then
      begin
        m_dwReadySeriesSkillTick := GetTickCount;
        SerieSkillReady();
      end;
    end;

    if (m_LockTarget <> nil) and ((m_btRaceServer = RC_PLAYOBJECT) and TPlayObject(Self).m_boOffLinePlay) and (not m_LockTarget.m_boSuperMode) then
    begin
      if {(m_Master.m_btHeroRelax <> 0) or} not IsProperTarget(m_LockTarget) then
      begin
        m_nTargetX := -1;
        m_LockTarget := nil;
      end;
    end;

    if (m_LockTarget <> nil) and ((m_btJob = 0) or (g_Config.boHeroLockTarget and (m_btJob in [1, 2]))) then
    begin
      if m_TargetCret <> m_LockTarget then
      begin
        m_TargetCret := m_LockTarget;
      end;
    end;

    if ((m_TargetCret = nil) and (GetTickCount - m_dwSearchEnemyTick > 1000)) then
    begin
      m_dwSearchEnemyTick := GetTickCount();
      SearchTargetHero();
    end;

    if AttackTarget() then
    begin
      //inherited;
      Exit;
    end;

    if Integer(GetTickCount - m_dwWalkTick) > m_nWalkSpeed then
    begin
      m_dwWalkTick := GetTickCount();
      if m_TargetCret = nil then
      begin
        m_nTargetX := -1;
      end;

      //Ñ°Â·....
      if m_TargetCret = nil then
      begin
        if Random(10) = 0 then
          m_btDirection := Random(8);

        if not m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, m_nTargetX, m_nTargetY) then
        begin
          if not GetFrontPosition(m_nTargetX, m_nTargetY) then
          begin
            TurnTo(Random(8));
            m_nTargetX := -1;
          end;
        end;
      end;

      if m_nTargetX <> -1 then
      begin
        if (abs(m_nCurrX - m_nTargetX) > 1) or (abs(m_nCurrY - m_nTargetY) > 1) then
        begin
          if not RuntoTargetXY(GetNextDirection(m_nCurrX, m_nCurrY, m_nTargetX, m_nTargetY), False) then
            GotoTargetXY();
        end
        else
          GotoTargetXY();
      end;

    end;
  end;
  //inherited Run;
end;

function TPlayObject.ProcUniteAttack(): Boolean;
var
  pcm: pTUserMagic;
  Hero: TBaseObject;
begin
  Result := False;
  if m_boSuperMode then
    Exit;
  if not g_Config.boAllowJointAttack then
    Exit;
  Hero := GetHeroObjectA;
  if (Hero <> nil) and not Hero.m_boDeath then
  begin
    if not Hero.m_boJointAttackReady and (Hero.m_nJointAttackEnergy > 0) and (Hero.m_nJointAttackEnergy >= 200) then
    begin
      pcm := nil;
      case m_btJob of
        0:
          begin
            case Hero.m_btJob of
              0: pcm := Hero.m_MagicArr[0][60];
              1: pcm := Hero.m_MagicArr[0][62];
              2: pcm := Hero.m_MagicArr[0][61];
            end;
            if (pcm <> nil) and (Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime) then
            begin
              m_dwHitTick := GetTickCount();
              m_dwWalkTick := GetTickCount();
              m_dwSpellTick := GetTickCount();
              Result := True;
              ClientHeroSetTarget(Integer(m_TargetCret), m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
              Hero.m_boJointAttackReady := True;
              Exit;
            end;
          end;
        1:
          begin
            case Hero.m_btJob of
              0: pcm := Hero.m_MagicArr[0][62];
              1: pcm := Hero.m_MagicArr[0][65];
              2: pcm := Hero.m_MagicArr[0][64];
            end;
          end;
        2:
          begin
            case Hero.m_btJob of
              0: pcm := Hero.m_MagicArr[0][61];
              1: pcm := Hero.m_MagicArr[0][64];
              2: pcm := Hero.m_MagicArr[0][63];
            end;
          end;
      end;
      if (pcm <> nil) and (Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime) then
      begin
        m_dwHitTick := GetTickCount();
        m_dwWalkTick := GetTickCount();
        m_dwSpellTick := GetTickCount();
        Result := True;
        ClientHeroSetTarget(Integer(m_TargetCret), m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
        Hero.m_boJointAttackReady := True;
      end;
    end;
  end;
end;

{$IFEND DEATHWALKING}

procedure TPlayObject.ClientBindItem(Npc, MakeIndex: Integer; ItemName: string; IsUnBind: Boolean);
var
  i: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  IdCRC: Cardinal;
  StdItem: pTStdItem;
begin
  if Npc = 0 then
    Exit;

  UserItem18 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = MakeIndex then
    begin
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(sUserItemName, ItemName) = 0 then
      begin
        UserItem18 := UserItem;
        Break;
      end;
    end;
  end;
  if UserItem18 = nil then
    Exit;

  //ÔÊÐí°ó¶¨ÁÐ±í
  StdItem := UserEngine.GetStdItem(UserItem18.wIndex);

  if g_AllowBindNameList.IndexOf(StdItem.Name) < 0 then
  begin
    SendDefMessage(SM_QUERYBINDITEM_FALI, -6, 0, 0, 0, '');
    Exit;
  end;

  if TObject(Npc) = m_LastNPC then
  begin
    Merchant := TMerchant(m_LastNPC);
  end
  else
  begin
    Merchant := UserEngine.FindMerchant(TObject(Npc));
    if Merchant <> nil then
      m_LastNPC := Merchant;
  end;

  //Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then
    Exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
  begin
    IdCRC := PCardinal(@UserItem.btValue[22])^;
    if IsUnBind then
    begin //½â
      if IdCRC = 0 then
      begin
        SendDefMessage(SM_QUERYBINDITEM_FALI, -1, 0, 0, 0, '');
        Exit;
      end;
      if IdCRC = m_dwIdCRC then
      begin
        Merchant.m_OprCount := 0;
        Merchant.GotoLable(Self, '@ItemUnBinding', False);
        if m_boCanUnBind then
        begin
          m_boCanUnBind := False;
          IdCRC := 0;
          PCardinal(@UserItem.btValue[22])^ := IdCRC;
          //CopyMemory(@UserItem.btValue[22], @IdCRC, SizeOf(Integer));
          SendDefMessage(SM_QUERYBINDITEM_FALI, 0, 0, 0, 0, '');
          Merchant.m_OprCount := 0;
          Merchant.GotoLable(Self, '@ItemUnBinded', False);
        end
        else
          SendDefMessage(SM_QUERYBINDITEM_FALI, -5, 0, 0, 0, '');
      end
      else
        SendDefMessage(SM_QUERYBINDITEM_FALI, -2, 0, 0, 0, '');
    end
    else
    begin //°ó
      if IdCRC = 0 then
      begin
        Merchant.m_OprCount := 0;
        Merchant.GotoLable(Self, '@ItemBinding', False);
        if m_boCanBind then
        begin
          m_boCanBind := False;
          PCardinal(@UserItem.btValue[22])^ := m_dwIdCRC;
          SendDefMessage(SM_QUERYBINDITEM_FALI, 1, 0, 0, 0, '');
          Merchant.m_OprCount := 0;
          Merchant.GotoLable(Self, '@ItemBinded', False);
        end
        else
          SendDefMessage(SM_QUERYBINDITEM_FALI, -5, 0, 0, 0, '');

      end
      else
      begin
        if IdCRC = m_dwIdCRC then
        begin
          SendDefMessage(SM_QUERYBINDITEM_FALI, -3, 0, 0, 0, '');
        end
        else
        begin
          SendDefMessage(SM_QUERYBINDITEM_FALI, -4, 0, 0, 0, '');
        end;
      end;

    end;
  end;
end;

procedure TPlayObject.ClientQueryChangeHero(HeroName: string);
var
  i, n: Integer;
  Hero: TBaseObject;
begin
  {if m_sHeroName = '' then begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -1, 0, 0, 0, '');
    Exit;
  end;}
  if not g_Config.cbMutiHero then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -7, 0, 0, 0, '');
    Exit;
  end;

  if m_sTempHeroName <> '' then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -1, 0, 0, 0, '');
    Exit;
  end;

  if m_sHeroName = HeroName then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -2, 0, 0, 0, '');
    Exit;
  end;

  if not m_boGetHeros then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -3, 0, 0, 0, '');
    Exit;
  end;

  n := -1;
  for i := Low(m_Heros) to High(m_Heros) do
  begin
    if m_Heros[i].ChrName = '' then
      Continue;
    if m_Heros[i].ChrName = HeroName then
    begin
      n := i;
      Break;
    end;
  end;
  if n = -1 then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -4, 0, 0, 0, '');
    Exit;
  end;

  Hero := GetHeroObjectA();
  if (Hero <> nil) or (UserEngine.GetPlayObject(m_sHeroName) <> nil) or (UserEngine.GetHeroObject(m_sHeroName) <> nil) then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -5, 0, 0, 0, '');
    Exit;
  end;

  if (UserEngine.GetPlayObject(HeroName) <> nil) or (UserEngine.GetHeroObject(HeroName) <> nil) then
  begin
    SendDefMessage(SM_QUERYCHANGEHERO_FALI, -6, 0, 0, 0, HeroName);
    Exit;
  end;

  m_sHeroName := HeroName;
  SendDefMessage(SM_QUERYCHANGEHERO_FALI, 0, 0, 0, 0, m_sHeroName);
end;

procedure TPlayObject.ClientMoveDetectItem(nItemIdx, putOn: Integer);
var
  ii, idx: Integer;
  tpu, UserItem: pTUserItem;
  StdItem: pTStdItem;
begin
  if putOn <> 0 then
  begin
    idx := -1;
    for ii := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[ii];
      if UserItem.MakeIndex = nItemIdx then
      begin
        idx := ii;
        Break;
      end;
    end;
    if idx < 0 then
    begin
      SendDefMessage(SM_MOVEDETECTITEM_FALI, -1, 0, 0, 0, '');
      Exit;
    end;
    StdItem := UserEngine.GetStdItem(pTUserItem(m_ItemList[idx]).wIndex);
    if StdItem = nil then
    begin
      SendDefMessage(SM_MOVEDETECTITEM_FALI, -1, 0, 0, 0, '');
      Exit;
    end;
    if pTUserItem(m_ItemList[idx]).btValueEx[3] = 0 then
    begin //t_SpiritMax ÁéÃ½Æ·ÖÊ
      SendDefMessage(SM_MOVEDETECTITEM_FALI, -2, 0, 0, 0, '');
      Exit;
    end;
    if m_DetectItem.MakeIndex > 0 then
    begin
      New(tpu);
      tpu^ := m_DetectItem;
      m_DetectItem := pTUserItem(m_ItemList[idx])^;
      Dispose(pTUserItem(m_ItemList[idx]));
      m_ItemList.Delete(idx);

      m_ItemList.Add(tpu);
      SendAddItem(tpu);
      SendDefMessage(SM_MOVEDETECTITEM_FALI, 0, 0, 0, 0, '');
    end
    else
    begin
      m_DetectItem := pTUserItem(m_ItemList[idx])^;
      Dispose(pTUserItem(m_ItemList[idx]));
      m_ItemList.Delete(idx);
      SendDefMessage(SM_MOVEDETECTITEM_FALI, 0, 0, 0, 0, '');
    end;
  end
  else
  begin
    if m_DetectItem.MakeIndex > 0 then
    begin
      if m_DetectItem.MakeIndex = nItemIdx then
      begin
        New(tpu);
        tpu^ := m_DetectItem;
        m_DetectItem.MakeIndex := 0;
        m_ItemList.Add(tpu);
        SendDefMessage(SM_MOVEDETECTITEM_FALI, 1, 0, 0, 0, '');
      end
      else
        SendDefMessage(SM_MOVEDETECTITEM_FALI, -4, 0, 0, 0, '');
    end
    else
      SendDefMessage(SM_MOVEDETECTITEM_FALI, -3, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.SendUpdateDetectItem(UserItem: TUserItem);
begin
  m_DefMsg := MakeDefaultMsg(SM_UPDATEDETECTITEM, UserItem.MakeIndex, UserItem.btValueEx[17], UserItem.btValueEx[2], UserItem.btValueEx[3]);
  SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientDetectButchItem(nItemIdx: Integer);
var
  x, y, dis, nC, sp: Integer;
  btDir: Byte;
  MapCellInfo: pTMapCellinfo;
  Event, Event2: TEvent;
begin
  if (nItemIdx = 0) or (m_DetectItem.MakeIndex = 0) or (m_DetectItem.MakeIndex <> nItemIdx) then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 0, 0, 9, '');
    Exit;
  end;
  if m_DetectItem.btValueEx[2] = 0 then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 0, 0, 10, ''); //ÁéÃ½µÄÁéÆøÖµÒÑ¾­²»×ã£¬Çë²¹³äÁéÆøºóÔÙÊ¹ÓÃ£¡
    Exit;
  end;

  if GetTickCount - m_dwDetectItemTick < 1000 then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 0, 0, 11, '');
    Exit;
  end;
  m_dwDetectItemTick := GetTickCount;

  m_DetectItem.btValueEx[2] := m_DetectItem.btValueEx[2] - 1;
  SendUpdateDetectItem(m_DetectItem);

  if (m_PEnvir = nil) or (m_PEnvir.m_MapFlag.nDigItem <= 0) then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 1, 0, 12, '');
    Exit;
  end;
  if (Random(g_Config.nDetectItemRate) <> 0) then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 2, 0, 12, '');
    Exit;
  end;

  dis := 9999;
  Event2 := nil;
  for x := m_nCurrX - 22 to m_nCurrX + 22 do
  begin
    for y := m_nCurrY - 22 to m_nCurrY + 22 do
    begin
      if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.chFlag = 0) then
      begin
        Event := TEvent(m_PEnvir.GetEvent(x, y));
        if (Event <> nil) and (Event.m_nEventType in [ET_ITEMMINE1..ET_ITEMMINE3]) and (TStoneMineEvent(Event).m_nMineCount > 0) then
        begin
          //SysMsg(format('%d %d', [x, y]), c_Red, t_Hint);

          nC := abs(m_nCurrX - x) + abs(m_nCurrY - y);
          if nC < dis then
          begin
            dis := nC;
            Event2 := Event;
          end;
        end;
      end;
    end;
  end;

  if Event2 = nil then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, 0, 3, 0, 12, '');
    Exit;
  end;

  if m_MagicArr[0][67] <> nil then
  begin
    TrainSkill(m_MagicArr[0][67], 1 + Random(3));
    if not CheckMagicLevelup(m_MagicArr[0][67]) then
    begin
      SendDelayMsg(Self,
        RM_MAGIC_LVEXP,
        0,
        m_MagicArr[0][67].MagicInfo.wMagicId,
        m_MagicArr[0][67].btLevel,
        m_MagicArr[0][67].nTranPoint,
        '', 1000);
    end;
  end;

  sp := (Event2.m_nEventType - ET_ITEMMINE1 + 1);
  if (abs(m_nCurrX - Event2.m_nX) <= sp) and (abs(m_nCurrY - Event2.m_nY) <= sp) then
  begin
    SendDefMessage(SM_DETECTITEM_FALI, Integer(Event2), Event2.m_nX, Event2.m_nY, Event2.m_nEventType - ET_ITEMMINE1 + 20, '');
    Exit;
  end;

  btDir := GetNextDirection(m_nCurrX, m_nCurrY, Event2.m_nX, Event2.m_nY);
  SendDefMessage(SM_DETECTITEM_FALI, 0, 0, 0, btDir, '');

end;

procedure TPlayObject.ClientExchangeItem(nItemIdx, nBookIdx: Integer);
var
  i, ItemId, bookid: Integer;
  UserItem: pTUserItem;
  StdItem, StdBook: pTStdItem;
  Eva: TEvaluation;
  Abil: array[0..3] of TEvaAbil;
label
  lend;
begin
  ItemId := -1;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nItemIdx then
    begin
      ItemId := i;
      Break;
    end;
  end;
  if ItemId < 0 then
  begin
    SendDefMessage(SM_ExchangeItem, -1, 0, 0, 0, '');
    Exit;
  end;

  bookid := -1;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nBookIdx then
    begin
      bookid := i;
      Break;
    end;
  end;
  if bookid < 0 then
  begin
    SendDefMessage(SM_ExchangeItem, -1, 0, 0, 0, '');
    Exit;
  end;

  StdItem := UserEngine.GetStdItem(pTUserItem(m_ItemList[ItemId]).wIndex);
  if StdItem = nil then
  begin
    SendDefMessage(SM_ExchangeItem, -1, 0, 0, 0, '');
    Exit;
  end;
  StdBook := UserEngine.GetStdItem(pTUserItem(m_ItemList[bookid]).wIndex);
  if StdBook = nil then
  begin
    SendDefMessage(SM_ExchangeItem, -1, 0, 0, 0, '');
    Exit;
  end;

  Eva := StdItem.Eva;
  GetItemEvaInfo(pTUserItem(m_ItemList[ItemId]), Eva);
  if (Eva.EvaTimes = 0) then
  begin
    SendDefMessage(SM_ExchangeItem, -2, 0, 0, 0, StdItem.Name);
    Exit;
  end;
  if (StdBook.StdMode <> 41) or (StdBook.Shape <> 30) then
  begin
    SendDefMessage(SM_ExchangeItem, -3, 0, 0, 0, '');
    Exit;
  end;
  if g_Config.tiExchangeItemRate < Random(100) then
  begin //³É¹¦ÂÊ
    SendDefMessage(SM_ExchangeItem, -4, 0, 0, 0, StdItem.Name);
    goto lend;
  end;
  UserItem := m_ItemList.Items[ItemId];
  FillChar(UserItem.btValueEx, SizeOf(UserItem.btValueEx), 0); //0..16
  SetItemEvaInfo(UserItem, t_Quality, Random(49) + 1, Abil);
  SendUpdateItem(UserItem);
  SendDefMessage(SM_ExchangeItem, 0, 0, 0, 0, StdItem.Name);
  lend:
  DelBagItem(bookid, True, '¸ü»»±¦Îï');
end;

procedure TPlayObject.ClientTreasureIdentify(nItemIdx, nBookIdx, nType: Integer);
var
  i, r, n, ItemId, bookid: Integer;
  UserItem, UserItem2: pTUserItem;
  sName, lvstr: string;
  StdItem, StdBook: pTStdItem;
  Eva: TEvaluation;
  Abil: array[0..3] of TEvaAbil;

  nQuality: Integer;
label
  lend, lnor;
begin
  ItemId := -1;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nItemIdx then
    begin
      ItemId := i;
      Break;
    end;
  end;
  if ItemId < 0 then
  begin
    SendDefMessage(SM_TreasureIdentify, -1, 0, 0, 0, '');
    Exit;
  end;

  bookid := -1;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nBookIdx then
    begin
      bookid := i;
      Break;
    end;
  end;
  if bookid < 0 then
  begin
    SendDefMessage(SM_TreasureIdentify, -11, 0, 0, 0, '');
    Exit;
  end;

  StdItem := UserEngine.GetStdItem(pTUserItem(m_ItemList[ItemId]).wIndex);
  if StdItem = nil then
  begin
    SendDefMessage(SM_TreasureIdentify, -1, 0, 0, 0, '');
    Exit;
  end;
  if (StdItem.Eva.EvaTimesMax <= 0) then
  begin
    SendDefMessage(SM_TreasureIdentify, -2, 0, 0, 0, StdItem.Name);
    Exit;
  end;
  Eva := StdItem.Eva;
  GetItemEvaInfo(pTUserItem(m_ItemList[ItemId]), Eva);
  if Eva.EvaTimes >= StdItem.Eva.EvaTimesMax then
  begin
    SendDefMessage(SM_TreasureIdentify, -3, 0, 0, 0, StdItem.Name);
    Exit;
  end;

  ///////2
  StdBook := UserEngine.GetStdItem(pTUserItem(m_ItemList[bookid]).wIndex);
  if StdBook = nil then
  begin
    SendDefMessage(SM_TreasureIdentify, -11, 0, 0, 0, '');
    Exit;
  end;
  if (StdBook.StdMode <> 56) or (Eva.EvaTimes + 1 <> StdBook.Shape) then
  begin
    lvstr := '';
    case Eva.EvaTimes of
      0: lvstr := 'Ò»';
      1: lvstr := '¶þ';
      2: lvstr := 'Èý';
    end;
    SendDefMessage(SM_TreasureIdentify, -12, 0, 0, 0, lvstr);
    Exit;
  end;

  UserItem := m_ItemList.Items[ItemId];
  SetItemEvaInfo(UserItem, t_EvaTimes, Eva.EvaTimes + 1, Abil);

  if nType <> 0 then
  begin
    r := _MAX(1, g_Config.tiSucessRateEx - _MIN(45, StdItem.NeedLevel div 2));
    if Random(r) <> 0 then //²»³É¹¦£¬ÆÕÍ¨¼ø¶¨
      goto lnor;

    sName := '';
    case StdItem.StdMode of
      5, 6: sName := g_Config.tiGift_weapon; //'Ö÷Ô×Éñ½£';
      10: sName := g_Config.tiGift_dress_m; //'Ö÷Ô×Éñ¼×(ÄÐ)';
      11: sName := g_Config.tiGift_dress_w; //'Ö÷Ô×Éñ¼×(Å®)';
      30: sName := g_Config.tiGift_medal; //'Ö÷Ô×Ñ«ÕÂ';
      19, 20, 21: sName := g_Config.tiGift_necklace; //'Ö÷Ô×ÏîÁ´';
      15: sName := g_Config.tiGift_helmet; //'Ö÷Ô×Ö®¹Ú';
      16: if Random(2) = 0 then
          sName := g_Config.tiGift_helmetex //'Ö÷Ô×¶·óÒ'
        else
          sName := g_Config.tiGift_mask; //'Ö÷Ô×Ãæ½í';
      24, 26: sName := g_Config.tiGift_armring; //'Ö÷Ô×»¤Íó';
      22, 23: sName := g_Config.tiGift_ring; //'Ö÷Ô×Ö®½ä';
      27: sName := g_Config.tiGift_belt; //'Ö÷Ô×Ñü´ø';
      28: sName := g_Config.tiGift_boots; //'Ö÷Ô×Ö®Ñ¥';
      12, 13, 17, 18:
        begin
          goto lnor;
        end;
    end;
    if sName <> '' then
    begin
      New(UserItem2);
      if UserEngine.CopyToUserItemFromName(sName, UserItem2) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem2.wIndex);

        n := UserItem.MakeIndex;
        UserItem^ := UserItem2^;
        UserItem.MakeIndex := n;

        SetItemEvaInfo(UserItem, t_EvaTimes, Eva.EvaTimes + 1, Abil);

        nQuality := _MIN(255, Eva.Quality + 38 + Random(29));
        SetItemEvaInfo(UserItem, t_Quality, nQuality, Abil);

        n := UserEngine.TreasureIdentify(UserItem);
        SendUpdateItem(UserItem);
        SendDefMessage(SM_TreasureIdentify, 1, n, 0, 0, StdItem.Name);
        DelBagItem(bookid, True, '¼ø¶¨ÏûºÄ');

        if StdItem.NeedIdentify = 1 then
          AddGameDataLogAPI('9' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sName + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            '¸ß¼¶¼ø¶¨');

        if g_HintItemList.Exists(sName) then
          UserEngine.SendBroadCastMsg(Format('%sÊ¹ÓÃ¸ß¼¶¼ø¶¨¹¦ÄÜ£¬¼ø¶¨³ö±¦Îï£º%s', [m_sCharName, sName]), t_System);
      end
      else
      begin
        SendUpdateItem(UserItem);
        SendDefMessage(SM_TreasureIdentify, -52, 0, 0, 0, sName);
        Exit;
      end;
      Dispose(UserItem2);
    end
    else
    begin
      SendUpdateItem(UserItem);
      SendDefMessage(SM_TreasureIdentify, -52, 0, 0, 0, sName);
      Exit;
    end;
  end
  else
  begin
    lnor:
    if g_Config.tiSucessRate < Random(100) then
    begin //³É¹¦ÂÊ
      SendDefMessage(SM_TreasureIdentify, -50, 0, 0, 0, StdItem.Name);
      SendUpdateItem(UserItem);
      goto lend;
    end;

    nQuality := _MIN(255, Eva.Quality + 38 + Random(29));
    SetItemEvaInfo(UserItem, t_Quality, nQuality, Abil);

    n := UserEngine.TreasureIdentify(UserItem);
    SendUpdateItem(UserItem);
    SendDefMessage(SM_TreasureIdentify, 0, n, 0, 0, StdItem.Name);
    lend:
    DelBagItem(bookid, True, '¼ø¶¨ÏûºÄ');
  end;
end;

procedure TPlayObject.ClientSecretProperty(nItemIdx, nBookIdx, mlevel: Integer);
var
  i,  n, ItemId, bookid: Integer;
  UserItem, UserItem2: pTUserItem;
  sName: string;
  StdItem, StdBook: pTStdItem;
  Eva: TEvaluation;
  spCnt: Integer;
label
  lend;
begin
  if mlevel = 0 then
  begin //ÉñÃØ½â¶Á
    ItemId := -1;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = nItemIdx then
      begin
        ItemId := i;
        Break;
      end;
    end;
    if ItemId < 0 then
    begin
      SendDefMessage(SM_SecretProperty, -1, 0, 0, 0, '');
      Exit;
    end;

    bookid := -1;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = nBookIdx then
      begin
        bookid := i;
        Break;
      end;
    end;
    if bookid < 0 then
    begin
      SendDefMessage(SM_SecretProperty, -1, 0, 0, 0, '');
      Exit;
    end;

    StdItem := UserEngine.GetStdItem(pTUserItem(m_ItemList[ItemId]).wIndex);
    if StdItem = nil then
    begin
      SendDefMessage(SM_SecretProperty, -1, 0, 0, 0, '');
      Exit;
    end;
    StdBook := UserEngine.GetStdItem(pTUserItem(m_ItemList[bookid]).wIndex);
    if StdBook = nil then
    begin
      SendDefMessage(SM_SecretProperty, -1, 0, 0, 0, '');
      Exit;
    end;

    if not (StdItem.StdMode in [5, 6, 10..13, 15..24, 26..30, 51..54, 62..64]) then
    begin
      SendDefMessage(SM_SecretProperty, -2, 0, 0, 0, '');
      Exit;
    end;

    if (StdBook.StdMode <> 56) or (StdBook.Shape <> 0) then
    begin
      SendDefMessage(SM_SecretProperty, -3, 0, 0, 0, '');
      Exit;
    end;

    Eva := StdItem.Eva;
    spCnt := GetItemEvaInfo(pTUserItem(m_ItemList[ItemId]), Eva);

    //SysMsg(format('%d %d', [Eva.AdvAbilMax, spCnt]), c_Red, t_Hint);

    if (Eva.AdvAbilMax = 0) or (spCnt >= Eva.AdvAbilMax) then
    begin
      SendDefMessage(SM_SecretProperty, -4, 0, 0, 0, '');
      Exit;
    end;

    UserItem2 := pTUserItem(m_ItemList[bookid]);
    if (UserItem2.btValue[0] <= spCnt) then
    begin
      SendDefMessage(SM_SecretProperty, -5, 0, 0, 0, '');
      Exit;
    end;
    //  m_btSPLuck := 0;
    //m_btSPEnergy := 0;
    if PWord(@UserItem2.btValue[1])^ < Random(1000 + g_Config.spSecretPropertySucessRate + m_btSPLuck) then
    begin //³É¹¦ÂÊ
      m_btSPLuck := _MIN(100, m_btSPLuck + 10);
      SendDefMessage(SM_SecretProperty, -6, m_btSPLuck, m_btSPEnergy, 1, '');
      goto lend;
    end;

    UserItem := m_ItemList.Items[ItemId];
    n := UserEngine.SecretProperty(UserItem, _MIN(1, UserItem2.btValue[0]));

    if n > 0 then
    begin
      if m_btSPLuck > 0 then
        m_btSPLuck := 0;
      SendUpdateItem(UserItem);
      SendDefMessage(SM_SecretProperty, 0, m_btSPLuck, m_btSPEnergy, 1, '');

      sName := '';
      case n of
        100: sName := 'ÎåÔÀ¶À×ð';
        101: sName := 'ÕÙ»½¾ÞÄ§';
        102: sName := 'ÉñÁú¸½Ìå';
        103: sName := 'ÒÐÌìÅüµØ';
      end;
      if sName <> '' then
      begin
        if (g_FunctionNPC <> nil) then
        begin
          m_nSval[98] := sName;
          m_nSval[99] := StdItem.Name;
          g_FunctionNPC.m_OprCount := 0;
          g_FunctionNPC.GotoLable(Self, '@SecretProperty_Skill', False);
        end;
      end;
    end
    else
    begin
      m_btSPLuck := _MIN(100, m_btSPLuck + 10);
      SendDefMessage(SM_SecretProperty, -6, m_btSPLuck, m_btSPEnergy, 1, '');
    end;

    lend:
    DelBagItem(bookid, True, 'ÉñÃØ½â¶Á');

  end
  else if mlevel in [1..4] then
  begin //ÖÆ×÷¾íÖá
    //ÉñÃØ½â¶Á
    //m_MagicArr[0][67]
    if m_btSPEnergy < mlevel then
    begin
      SendDefMessage(SM_SecretProperty, -12, 0, 0, 0, '');
      Exit;
    end;

    ItemId := -1;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = nItemIdx then
      begin
        ItemId := i;
        Break;
      end;
    end;
    if ItemId < 0 then
    begin
      SendDefMessage(SM_SecretProperty, -10, 0, 0, 0, '');
      Exit;
    end;

    StdItem := UserEngine.GetStdItem(pTUserItem(m_ItemList[ItemId]).wIndex);
    if StdItem = nil then
    begin
      SendDefMessage(SM_SecretProperty, -10, 0, 0, 0, '');
      Exit;
    end;

    if (StdItem.StdMode <> 41) or (StdItem.Shape <> 50) then
    begin
      SendDefMessage(SM_SecretProperty, -11, 0, 0, 0, '');
      Exit;
    end;

    if m_MagicArr[0][67] <> nil then
    begin
      if m_MagicArr[0][67].btLevel * 28 + Random(g_Config.spMakeBookSucessRate + m_MagicArr[0][67].btLevel * 100 + m_btSPLuck) > mlevel * 100 then
      begin //³É¹¦ÂÊ
        Dec(m_btSPEnergy, mlevel);
        DelBagItem(ItemId, True, 'ÖÆ×÷½â¶Á¾íÖáÏûºÄ');

        New(UserItem2);
        if UserEngine.CopyToUserItemFromName('ÉñÃØ¾íÖá', UserItem2) and AddItemToBag(UserItem2) then
        begin
          StdItem := UserEngine.GetStdItem(UserItem2.wIndex);

          if (StdItem.StdMode = 56) and (StdItem.Shape = 0) then
          begin
            UserItem2.btValue[0] := mlevel;
            PWord(@UserItem2.btValue[1])^ := 180 + m_MagicArr[0][67].btLevel * 45 + Random(500);
          end;

          SendAddItem(UserItem2);
          SendDefMessage(SM_SecretProperty, 2, m_btSPLuck, m_btSPEnergy, 1, '');

          if StdItem.NeedIdentify = 1 then
            AddGameDataLogAPI('9' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              sName + #9 +
              IntToStr(UserItem2.MakeIndex) + #9 +
              '1' + #9 +
              'ÖÆ×÷½â¶Á¾íÖá');
        end
        else
        begin
          Dispose(UserItem2);
        end;
      end
      else
      begin
        m_btSPLuck := _MIN(100, m_btSPLuck + 10);
        Dec(m_btSPEnergy, mlevel);
        SendDefMessage(SM_SecretProperty, -14, m_btSPLuck, m_btSPEnergy, 1, '');
        DelBagItem(ItemId, True, 'ÖÆ×÷½â¶Á¾íÖáÏûºÄ');
      end;

      if m_MagicArr[0][67] <> nil then
      begin
        TrainSkill(m_MagicArr[0][67], 1 + Random(3));
        if not CheckMagicLevelup(m_MagicArr[0][67]) then
        begin
          SendDelayMsg(Self,
            RM_MAGIC_LVEXP,
            0,
            m_MagicArr[0][67].MagicInfo.wMagicId,
            m_MagicArr[0][67].btLevel,
            m_MagicArr[0][67].nTranPoint,
            '', 1000);
        end;
      end;

    end
    else
    begin
      SendDefMessage(SM_SecretProperty, -13, 0, 0, 0, '');
      Exit;
    end;
  end;
end;

procedure TPlayObject.DoPositionMoveAttack(nLastX, nLastY, nLevel, nMagIdx, nPower: Integer);
var
  i, n: Integer;
  psMessage: TPostionMoveMessage;
  szChrName: string;
  nNameLen: Integer;
  xObjectList: TList;
  BaseObject: TBaseObject;
  Buffer: array[0..255] of Byte;
begin
  m_dwCanNextMoveTick := GetTickCount();

  psMessage.lFeature := GetFeatureToLong(@Buffer[0]);
  psMessage.nStatus := m_nCharStatus;
  psMessage.wHP := m_WAbil.HP;
  psMessage.wMaxHP := m_WAbil.MaxHP;
  psMessage.wCurrX := nLastX;
  psMessage.wCurrY := nLastY;
  psMessage.wMaigcID := nMagIdx;
  szChrName := GetShowName();
  nNameLen := _MIN(255, Length(szChrName));
  Move(szChrName[1], psMessage.szBuff[0], nNameLen);
  psMessage.szBuff[nNameLen] := #0;

  m_btDirection := GetNextDirection(nLastX, nLastY, m_nCurrX, m_nCurrY);

  SendRefMsg(RM_POSTIONMOVE,
    MakeWord(m_btDirection, nMagIdx),
    m_nCurrX,
    m_nCurrY,
    0,
    EncodeBuffer(@psMessage, nNameLen + 24) + '/' + EncodeBuffer(@buffer[0],psMessage.lFeature));

  //¹¥»÷............
  n := 0;
  xObjectList := TList.Create;
  GetMapBaseObjects(m_PEnvir, m_nCurrX, m_nCurrY, 3, xObjectList);
  for i := 0 to xObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(xObjectList.Items[i]);
    if BaseObject.m_boDeath or BaseObject.m_boGhost or (Self = BaseObject) then
      Continue;
    if IsProperTarget(BaseObject, True) then
    begin
      SetTargetCreat(BaseObject);
      BaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0, '', nMagIdx);
      if ((BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and not BaseObject.IsHero) or g_Config.fPosMoveAttackParalysisPlayer then
        BaseObject.MakePosion(nil, 0, POISON_STONE, _MIN(12, Round(nLevel * 1.5) + 1), 0);
      Inc(n);
    end;
    if n > 399 then
      Break;
  end;
  xObjectList.Free;
end;

function TBaseObject.GetTitleIndex(): Byte;
begin
  Result := 0;
  if m_btActiveTitle in [1..6] then
  begin
    if m_Titles[m_btActiveTitle - 1].Index > 0 then
    begin
      Result := m_Titles[m_btActiveTitle - 1].Index;
    end;
  end;
end;

procedure TPlayObject.ClientChangeTitle(nHero, nIdx: Byte);
var
  i, ii: Integer;
  pStdItem: pTStdItem;
  player: TBaseObject;
begin
  if nHero <> 0 then
    player := GetHeroObjectA
  else
    player := Self;

  if player = nil then
    Exit;

  nHero := Byte(player.IsHero);

  if nIdx = 0 then
  begin
    if player.m_btActiveTitle > 0 then
    begin
      ii := player.GetTitleIndex();

      player.m_btActiveTitle := 0;
      player.RecalcAbilitys();
      player.SendMsg(player, RM_ABILITY, 0, 0, 0, 0, '');
      player.SendMsg(player, RM_SUBABILITY, 0, 0, 0, 0, '');
      player.FeatureChanged();
      SendDefMessage(SM_CHANGETITLE, 0, 0, 0, nHero, '');

      pStdItem := UserEngine.GetTitle(ii);
      if pStdItem = nil then
        Exit;

      if g_FunctionNPC <> nil then
      begin
        g_FunctionNPC.m_OprCount := 0;
        if nHero <> 0 then
          g_FunctionNPC.GotoLable(TPlayObject(player.m_Master), Format('@HeroUntitled_%d', [pStdItem.Shape]), False)
        else
          g_FunctionNPC.GotoLable(Self, Format('@Untitled_%d', [pStdItem.Shape]), False);
      end;
    end;
    Exit;
  end;

  ii := -1;
  for i := Low(player.m_Titles) to High(player.m_Titles) do
  begin
    if player.m_Titles[i].Index = nIdx then
    begin
      ii := i;
      Break;
    end;
  end;
  if ii < 0 then
  begin
    SendDefMessage(SM_CHANGETITLE, -1, 0, 0, nHero, '');
    Exit;
  end;

  pStdItem := UserEngine.GetTitle(nIdx);
  if pStdItem = nil then
  begin
    SendDefMessage(SM_CHANGETITLE, -2, 0, 0, nHero, '');
    Exit;
  end;

  if player.m_Titles[ii].Time = 0 then
  begin
    player.m_Titles[ii].Time := GetItemFormatDate();
    TPlayObject(player).SendMyTitles(True);
  end;

  player.m_btActiveTitle := ii + 1;

  if g_FunctionNPC <> nil then
  begin
    g_FunctionNPC.m_OprCount := 0;
    if nHero <> 0 then
      g_FunctionNPC.GotoLable(TPlayObject(player.m_Master), Format('@HeroTitleChanged_%d', [pStdItem.Shape]), False)
    else
      g_FunctionNPC.GotoLable(Self, Format('@TitleChanged_%d', [pStdItem.Shape]), False);
  end;

  player.RecalcAbilitys();
  player.SendMsg(player, RM_ABILITY, 0, 0, 0, 0, '');
  player.SendMsg(player, RM_SUBABILITY, 0, 0, 0, 0, '');
  player.FeatureChanged();
  SendDefMessage(SM_CHANGETITLE, 0, 0, 0, nHero, '');
end;

procedure TPlayObject.ClientChangeConfig(nHero, nIdx: Integer);
var
  nObjCount: Integer;
  player: TBaseObject;
  boTemp: Boolean;
begin
  if nHero <> 0 then
    player := GetHeroObjectA
  else
    player := Self;

  if player = nil then
    Exit;

  nObjCount := 0;
  boTemp := LoWord(nIdx) <> 0;
  if boTemp <> player.m_boShowFashion then
  begin
    if GetTickCount - player.m_dwShowFashionTick > 1500 then
    begin
      player.m_dwShowFashionTick := GetTickCount;
      player.m_boShowFashion := LoWord(nIdx) <> 0;
      player.RecalcAbilitys();
      player.SendMsg(player, RM_ABILITY, 0, 0, 0, 0, '');
      player.SendMsg(player, RM_SUBABILITY, 0, 0, 0, 0, '');
      player.FeatureChanged();
      if player.m_boShowFashion then
        nObjCount := 1
      else
        nObjCount := 2;
    end
    else
      nObjCount := -1;
  end;
  m_DefMsg := MakeDefaultMsg(SM_PLAYERCONFIG,
    nObjCount,
    nHero,
    nHero,
    MakeWord(Byte(player.m_boShowFashion), 0));
  SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.SendChangeBagItemDura(makeIndex: Integer;
  newDura: Word; waitItemToBag: Boolean);
begin
  SendMsg(self, RM_BAGDURACHANGE, newDura, makeIndex, Integer(m_btRaceServer = RC_HERO), Integer(waitItemToBag), '')
end;

initialization

  dwStartTick := GetTickCount;
  dwLastCheck := GetTickCount;
  gdeny := False;
finalization
end.
